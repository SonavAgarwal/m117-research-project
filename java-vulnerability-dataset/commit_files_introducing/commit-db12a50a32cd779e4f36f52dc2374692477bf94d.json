{
    "sha": "db12a50a32cd779e4f36f52dc2374692477bf94d",
    "node_id": "MDY6Q29tbWl0MjA2NDEyOmRiMTJhNTBhMzJjZDc3OWU0ZjM2ZjUyZGMyMzc0NjkyNDc3YmY5NGQ=",
    "commit": {
        "author": {
            "name": "Martin Tzvetanov Grigorov",
            "email": "mgrigorov@apache.org",
            "date": "2010-12-05T13:08:00Z"
        },
        "committer": {
            "name": "Martin Tzvetanov Grigorov",
            "email": "mgrigorov@apache.org",
            "date": "2010-12-05T13:08:00Z"
        },
        "message": "Merge r942052 from 1.4.x:\nauthor: jcompagner\ncommit message: latest code from FileUpload and patched for generating more random files\ndate: Fri May 7 11:29:36 2010 UTC\n\ngit-svn-id: https://svn.apache.org/repos/asf/wicket/trunk@1042345 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "601dc6a81221ba9aec2472a3726baa5629ff868b",
            "url": "https://api.github.com/repos/apache/wicket/git/trees/601dc6a81221ba9aec2472a3726baa5629ff868b"
        },
        "url": "https://api.github.com/repos/apache/wicket/git/commits/db12a50a32cd779e4f36f52dc2374692477bf94d",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/wicket/commits/db12a50a32cd779e4f36f52dc2374692477bf94d",
    "html_url": "https://github.com/apache/wicket/commit/db12a50a32cd779e4f36f52dc2374692477bf94d",
    "comments_url": "https://api.github.com/repos/apache/wicket/commits/db12a50a32cd779e4f36f52dc2374692477bf94d/comments",
    "author": {
        "login": "martin-g",
        "id": 232002,
        "node_id": "MDQ6VXNlcjIzMjAwMg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/232002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martin-g",
        "html_url": "https://github.com/martin-g",
        "followers_url": "https://api.github.com/users/martin-g/followers",
        "following_url": "https://api.github.com/users/martin-g/following{/other_user}",
        "gists_url": "https://api.github.com/users/martin-g/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/martin-g/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/martin-g/subscriptions",
        "organizations_url": "https://api.github.com/users/martin-g/orgs",
        "repos_url": "https://api.github.com/users/martin-g/repos",
        "events_url": "https://api.github.com/users/martin-g/events{/privacy}",
        "received_events_url": "https://api.github.com/users/martin-g/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "martin-g",
        "id": 232002,
        "node_id": "MDQ6VXNlcjIzMjAwMg==",
        "avatar_url": "https://avatars.githubusercontent.com/u/232002?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/martin-g",
        "html_url": "https://github.com/martin-g",
        "followers_url": "https://api.github.com/users/martin-g/followers",
        "following_url": "https://api.github.com/users/martin-g/following{/other_user}",
        "gists_url": "https://api.github.com/users/martin-g/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/martin-g/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/martin-g/subscriptions",
        "organizations_url": "https://api.github.com/users/martin-g/orgs",
        "repos_url": "https://api.github.com/users/martin-g/repos",
        "events_url": "https://api.github.com/users/martin-g/events{/privacy}",
        "received_events_url": "https://api.github.com/users/martin-g/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "71e35a01db49f1395c0d5846ed13e6e78f303af7",
            "url": "https://api.github.com/repos/apache/wicket/commits/71e35a01db49f1395c0d5846ed13e6e78f303af7",
            "html_url": "https://github.com/apache/wicket/commit/71e35a01db49f1395c0d5846ed13e6e78f303af7"
        }
    ],
    "stats": {
        "total": 3186,
        "additions": 2689,
        "deletions": 497
    },
    "files": [
        {
            "sha": "2e696ce98100e54081d0b88f1a3a98189bb7d21c",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/io/DeferredFileOutputStream.java",
            "status": "modified",
            "additions": 45,
            "deletions": 2,
            "changes": 47,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FDeferredFileOutputStream.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FDeferredFileOutputStream.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FDeferredFileOutputStream.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -21,6 +21,7 @@\n import java.io.IOException;\n import java.io.OutputStream;\n \n+\n /**\n  * <p>\n  * An output stream which will retain data in memory until a specified threshold is reached, and\n@@ -34,7 +35,6 @@\n  * </p>\n  * \n  * @author <a href=\"mailto:martinc@apache.org\">Martin Cooper</a>\n- * @version $Id$\n  */\n public class DeferredFileOutputStream extends ThresholdingOutputStream\n {\n@@ -58,7 +58,10 @@ public class DeferredFileOutputStream extends ThresholdingOutputStream\n \t/**\n \t * The file to which output will be directed if the threshold is exceeded.\n \t */\n-\tprivate final File outputFile;\n+\tprivate File outputFile;\n+\n+\n+\tprivate final FileFactory fileFactory;\n \n \n \t// ----------------------------------------------------------- Constructors\n@@ -76,7 +79,30 @@ public class DeferredFileOutputStream extends ThresholdingOutputStream\n \tpublic DeferredFileOutputStream(final int threshold, final File outputFile)\n \t{\n \t\tsuper(threshold);\n+\t\tif (outputFile == null)\n+\t\t\tthrow new IllegalArgumentException(\"output file must be specified\");\n \t\tthis.outputFile = outputFile;\n+\t\tfileFactory = null;\n+\n+\t\tmemoryOutputStream = new ByteArrayOutputStream();\n+\t\tcurrentOutputStream = memoryOutputStream;\n+\t}\n+\n+\t/**\n+\t * Constructs an instance of this class which will trigger an event at the specified threshold,\n+\t * and save data to a file beyond that point.\n+\t * \n+\t * @param threshold\n+\t *            The number of bytes at which to trigger an event.\n+\t * @param fileFactory\n+\t *            The FileFactory to create the file.\n+\t */\n+\tpublic DeferredFileOutputStream(int threshold, FileFactory fileFactory)\n+\t{\n+\t\tsuper(threshold);\n+\t\tif (fileFactory == null)\n+\t\t\tthrow new IllegalArgumentException(\"FileFactory must be specified\");\n+\t\tthis.fileFactory = fileFactory;\n \n \t\tmemoryOutputStream = new ByteArrayOutputStream();\n \t\tcurrentOutputStream = memoryOutputStream;\n@@ -155,9 +181,26 @@ protected OutputStream getStream() throws IOException\n \tprotected void thresholdReached() throws IOException\n \t{\n \t\tbyte[] data = memoryOutputStream.toByteArray();\n+\t\tif (outputFile == null)\n+\t\t{\n+\t\t\toutputFile = fileFactory.createFile();\n+\t\t}\n \t\tFileOutputStream fos = new FileOutputStream(outputFile);\n \t\tfos.write(data);\n \t\tcurrentOutputStream = fos;\n \t\tmemoryOutputStream = null;\n \t}\n+\n+\t/**\n+\t * The file factory for this deferred file output stream.\n+\t * \n+\t * @author jcompagner\n+\t */\n+\tpublic interface FileFactory\n+\t{\n+\t\t/**\n+\t\t * @return the file to use for disk cache\n+\t\t */\n+\t\tFile createFile();\n+}\n }"
        },
        {
            "sha": "49ce4141ebdf585c0e110f8c3d30b05b657e1884",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/io/Streams.java",
            "status": "modified",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FStreams.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FStreams.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fio%2FStreams.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -47,6 +47,30 @@ public static void close(final Closeable closeable) throws IOException\n \t\tIOUtils.close(closeable);\n \t}\n \n+\t/**\n+\t * Writes the input stream to the output stream. Input is done without a Reader object, meaning\n+\t * that the input is copied in its raw form. After it is copied it will close the streams.\n+\t * \n+\t * @param in\n+\t *            The input stream\n+\t * @param out\n+\t *            The output stream\n+\t * @return Number of bytes copied from one stream to the other\n+\t * @throws IOException\n+\t */\n+\tpublic static long copyAndClose(InputStream in, OutputStream out) throws IOException\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\treturn copy(in, out);\n+\t\t}\n+\t\tfinally\n+\t\t{\n+\t\t\tIOUtils.closeQuietly(in);\n+\t\t\tIOUtils.closeQuietly(out);\n+\t\t}\n+\t}\n+\n \t/**\n \t * Writes the input stream to the output stream. Input is done without a Reader object, meaning\n \t * that the input is copied in its raw form."
        },
        {
            "sha": "1c7b459348db44082a8ca425925225a6f7b21c9f",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/Closeable.java",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FCloseable.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FCloseable.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FCloseable.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,43 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * Interface of an object, which may be closed.\n+ */\n+public interface Closeable\n+{\n+\t/**\n+\t * Closes the object.\n+\t * \n+\t * @throws IOException\n+\t *             An I/O error occurred.\n+\t */\n+\tvoid close() throws IOException;\n+\n+\t/**\n+\t * Returns, whether the object is already closed.\n+\t * \n+\t * @return True, if the object is closed, otherwise false.\n+\t * @throws IOException\n+\t *             An I/O error occurred.\n+\t */\n+\tboolean isClosed() throws IOException;\n+}"
        },
        {
            "sha": "562b03b0df3c06e2c5e68a87df3b82395236b8e0",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItem.java",
            "status": "modified",
            "additions": 229,
            "deletions": 48,
            "changes": 277,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItem.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItem.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItem.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -16,19 +16,27 @@\n  */\n package org.apache.wicket.util.upload;\n \n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n import java.io.File;\n import java.io.FileInputStream;\n import java.io.FileOutputStream;\n import java.io.IOException;\n import java.io.InputStream;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n import java.util.Map;\n+import java.util.Random;\n+import java.util.UUID;\n \n import org.apache.wicket.util.file.FileCleaner;\n import org.apache.wicket.util.file.Files;\n import org.apache.wicket.util.io.DeferredFileOutputStream;\n+import org.apache.wicket.util.io.IOUtils;\n+import org.apache.wicket.util.io.Streams;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -38,10 +46,22 @@\n  * interface.\n  * \n  * <p>\n- * After retrieving an instance of this class, you may either request all contents of file at once\n- * using {@link #get()} or request an {@link java.io.InputStream InputStream} with\n- * {@link #getInputStream()} and process the file without attempting to load it into memory, which\n- * may come handy with large files.\n+ * After retrieving an instance of this class from a\n+ * {@link org.apache.wicket.util.upload.DiskFileUpload DiskFileUpload} instance (see\n+ * {@link org.apache.wicket.util.upload.DiskFileUpload #parseRequest(javax.servlet.http.HttpServletRequest)}\n+ * ), you may either request all contents of file at once using {@link #get()} or request an\n+ * {@link java.io.InputStream InputStream} with {@link #getInputStream()} and process the file\n+ * without attempting to load it into memory, which may come handy with large files.\n+ * \n+ * <p>\n+ * When using the <code>DiskFileItemFactory</code>, then you should consider the following:\n+ * Temporary files are automatically deleted as soon as they are no longer needed. (More precisely,\n+ * when the corresponding instance of {@link java.io.File} is garbage collected.) This is done by\n+ * the so-called reaper thread, which is started automatically when the class\n+ * {@link org.apache.commons.io.FileCleaner} is loaded. It might make sense to terminate that\n+ * thread, for example, if your web application ends. See the section on \"Resource cleanup\" in the\n+ * users guide of commons-fileupload.\n+ * </p>\n  * \n  * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n  * @author <a href=\"mailto:sean@informage.net\">Sean Legassick</a>\n@@ -50,13 +70,16 @@\n  * @author <a href=\"mailto:martinc@apache.org\">Martin Cooper</a>\n  * @author Sean C. Sullivan\n  */\n-public class DiskFileItem implements FileItem\n+public class DiskFileItem implements FileItem, FileItemHeadersSupport\n {\n \tprivate static final Logger log = LoggerFactory.getLogger(DiskFileItem.class);\n-\tprivate static final long serialVersionUID = 1L;\n-\n \t// ----------------------------------------------------- Manifest constants\n \n+\t/**\n+\t * The UID to use when serializing this instance.\n+\t */\n+\tprivate static final long serialVersionUID = 2237570099615271025L;\n+\n \n \t/**\n \t * Default content charset to be used when no explicit charset parameter is provided by the\n@@ -67,12 +90,18 @@ public class DiskFileItem implements FileItem\n \n \t// ----------------------------------------------------------- Data members\n \n-\n \t/**\n-\t * Counter used in unique identifier generation.\n+\t * UID used in unique file name generation.\n \t */\n-\tprivate static int counter = 0;\n+\tprivate static final String UID = UUID.randomUUID()\n+\t\t.toString()\n+\t\t.replace(':', '_')\n+\t\t.replace('-', '_');\n \n+\t/**\n+\t * Random counter used in unique identifier generation.\n+\t */\n+\tprivate static final Random counter = new Random();\n \n \t/**\n \t * The name of the form field as provided by the browser.\n@@ -98,6 +127,13 @@ public class DiskFileItem implements FileItem\n \tprivate final String fileName;\n \n \n+\t/**\n+\t * The size of the item, in bytes. This is used to cache the size when a file item is moved from\n+\t * its original location.\n+\t */\n+\tprivate long size = -1;\n+\n+\n \t/**\n \t * The threshold above which uploads will be stored on disk.\n \t */\n@@ -121,6 +157,20 @@ public class DiskFileItem implements FileItem\n \t */\n \tprivate transient DeferredFileOutputStream dfos;\n \n+\t/**\n+\t * The temporary file to use.\n+\t */\n+\tprivate transient File tempFile;\n+\n+\t/**\n+\t * File to allow for serialization of the content of this item.\n+\t */\n+\tprivate File dfosFile;\n+\n+\t/**\n+\t * The file items headers.\n+\t */\n+\tprivate FileItemHeaders headers;\n \n \t// ----------------------------------------------------------- Constructors\n \n@@ -167,12 +217,12 @@ public DiskFileItem(final String fieldName, final String contentType,\n \t * @return An {@link java.io.InputStream InputStream} that can be used to retrieve the contents\n \t *         of the file.\n \t * \n-\t * @exception IOException\n-\t *                if an error occurs.\n+\t * @throws IOException\n+\t *             if an error occurs.\n \t */\n \tpublic InputStream getInputStream() throws IOException\n \t{\n-\t\tif (!dfos.isInMemory())\n+\t\tif (!isInMemory())\n \t\t{\n \t\t\treturn new FileInputStream(dfos.getFile());\n \t\t}\n@@ -233,7 +283,11 @@ public String getName()\n \t */\n \tpublic boolean isInMemory()\n \t{\n-\t\treturn (dfos.isInMemory());\n+\t\tif (cachedContent != null)\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn dfos.isInMemory();\n \t}\n \n \n@@ -244,7 +298,11 @@ public boolean isInMemory()\n \t */\n \tpublic long getSize()\n \t{\n-\t\tif (cachedContent != null)\n+\t\tif (size >= 0)\n+\t\t{\n+\t\t\treturn size;\n+\t\t}\n+\t\telse if (cachedContent != null)\n \t\t{\n \t\t\treturn cachedContent.length;\n \t\t}\n@@ -267,7 +325,7 @@ else if (dfos.isInMemory())\n \t */\n \tpublic byte[] get()\n \t{\n-\t\tif (dfos.isInMemory())\n+\t\tif (isInMemory())\n \t\t{\n \t\t\tif (cachedContent == null)\n \t\t\t{\n@@ -299,8 +357,8 @@ public byte[] get()\n \t * \n \t * @return The contents of the file, as a string.\n \t * \n-\t * @exception UnsupportedEncodingException\n-\t *                if the requested character encoding is not available.\n+\t * @throws UnsupportedEncodingException\n+\t *             if the requested character encoding is not available.\n \t */\n \tpublic String getString(final String charset) throws UnsupportedEncodingException\n \t{\n@@ -351,8 +409,8 @@ public String getString()\n \t * @param file\n \t *            The <code>File</code> into which the uploaded item should be stored.\n \t * \n-\t * @exception Exception\n-\t *                if an error occurs.\n+\t * @throws Exception\n+\t *             if an error occurs.\n \t */\n \tpublic void write(final File file) throws IOException\n \t{\n@@ -379,11 +437,27 @@ public void write(final File file) throws IOException\n \t\t\t\t\t\"for a non-memory upload the file location must not be empty\");\n \t\t\t}\n \n-\t\t\t// The uploaded file is being stored on disk in a temporary location so move it to\n-\t\t\t// the desired file.\n-\t\t\tif (outputFile.renameTo(file) == false)\n+\t\t\t// Save the length of the file\n+\t\t\tsize = outputFile.length();\n+\t\t\t/*\n+\t\t\t * The uploaded file is being stored on disk in a temporary location so move it to the\n+\t\t\t * desired file.\n+\t\t\t */\n+\t\t\tif (!outputFile.renameTo(file))\n \t\t\t{\n-\t\t\t\tFiles.copy(outputFile, file);\n+\t\t\t\tBufferedInputStream in = null;\n+\t\t\t\tBufferedOutputStream out = null;\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tin = new BufferedInputStream(new FileInputStream(outputFile));\n+\t\t\t\t\tout = new BufferedOutputStream(new FileOutputStream(file));\n+\t\t\t\t\tStreams.copy(in, out);\n+\t\t\t\t}\n+\t\t\t\tfinally\n+\t\t\t\t{\n+\t\t\t\t\tIOUtils.closeQuietly(in);\n+\t\t\t\t\tIOUtils.closeQuietly(out);\n+\t\t\t\t}\n \t\t\t}\n \t\t}\n \t}\n@@ -476,15 +550,21 @@ public void setFormField(final boolean state)\n \t * @return An {@link java.io.OutputStream OutputStream} that can be used for storing the\n \t *         contensts of the file.\n \t * \n-\t * @exception IOException\n-\t *                if an error occurs.\n+\t * @throws IOException\n+\t *             if an error occurs.\n \t */\n \tpublic OutputStream getOutputStream() throws IOException\n \t{\n \t\tif (dfos == null)\n \t\t{\n-\t\t\tFile outputFile = getTempFile();\n-\t\t\tdfos = new DeferredFileOutputStream(sizeThreshold, outputFile);\n+\t\t\tdfos = new DeferredFileOutputStream(sizeThreshold,\n+\t\t\t\tnew DeferredFileOutputStream.FileFactory()\n+\t\t\t\t{\n+\t\t\t\t\tpublic File createFile()\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn getTempFile();\n+\t\t\t\t\t}\n+\t\t\t\t});\n \t\t}\n \t\treturn dfos;\n \t}\n@@ -504,7 +584,7 @@ public OutputStream getOutputStream() throws IOException\n \t */\n \tpublic File getStoreLocation()\n \t{\n-\t\treturn dfos.getFile();\n+\t\treturn dfos == null ? null : dfos.getFile();\n \t}\n \n \n@@ -541,57 +621,74 @@ protected void finalize() throws Throwable\n \t */\n \tprotected File getTempFile()\n \t{\n-\t\tFile tempDir = repository;\n-\n-\t\tif (tempDir == null)\n+\t\tif (tempFile == null)\n \t\t{\n+\t\t\tFile tempDir = repository;\n+\t\t\tif (tempDir == null)\n+\t\t\t{\n+\t\t\t\tString systemTmp = null;\n+\t\t\t\ttry\n+\t\t\t\t{\n+\t\t\t\t\tsystemTmp = System.getProperty(\"java.io.tmpdir\");\n+\t\t\t\t}\n+\t\t\t\tcatch (SecurityException e)\n+\t\t\t\t{\n+\t\t\t\t\tthrow new RuntimeException(\n+\t\t\t\t\t\t\"Reading property java.io.tmpdir is not allowed\"\n+\t\t\t\t\t\t\t+ \" for the current security settings. The repository location needs to be\"\n+\t\t\t\t\t\t\t+ \" set manually, or upgrade permissions to allow reading the tmpdir property.\");\n+\t\t\t\t}\n+\t\t\t\ttempDir = new File(systemTmp);\n+\t\t\t}\n+\n \t\t\ttry\n \t\t\t{\n-\t\t\t\ttempDir = new File(System.getProperty(\"java.io.tmpdir\"));\n+\t\t\t\tdo\n+\t\t\t\t{\n+\t\t\t\t\tString tempFileName = \"upload_\" + UID + \"_\" + getUniqueId() + \".tmp\";\n+\t\t\t\t\ttempFile = new File(tempDir, tempFileName);\n+\t\t\t\t}\n+\t\t\t\twhile (!tempFile.createNewFile());\n \t\t\t}\n-\t\t\tcatch (SecurityException e)\n+\t\t\tcatch (IOException e)\n \t\t\t{\n-\t\t\t\tthrow new RuntimeException(\"Reading property java.io.tmpdir is not allowed\"\n-\t\t\t\t\t+ \" for the current security settings. The repository location needs to be\"\n-\t\t\t\t\t+ \" set manually, or upgrade permissions to allow reading the tmpdir property.\");\n+\t\t\t\tthrow new RuntimeException(\"Could not create the temp file for upload\", e);\n \t\t\t}\n-\t\t}\n-\n-\t\tString fileName = \"upload_\" + getUniqueId() + \".tmp\";\n \n-\t\tFile f = new File(tempDir, fileName);\n-\t\tFileCleaner.track(f, this);\n-\t\treturn f;\n+\t\t\tFileCleaner.track(tempFile, this);\n+\t\t}\n+\t\treturn tempFile;\n \t}\n \n-\n \t// -------------------------------------------------------- Private methods\n \n \n \t/**\n \t * Returns an identifier that is unique within the class loader used to load this class, but\n-\t * does not have random-like apearance.\n+\t * does not have random-like appearance.\n \t * \n \t * @return A String with the non-random looking instance identifier.\n \t */\n \tprivate static String getUniqueId()\n \t{\n+\t\tfinal int limit = 100000000;\n \t\tint current;\n \t\tsynchronized (DiskFileItem.class)\n \t\t{\n-\t\t\tcurrent = counter++;\n+\t\t\tcurrent = counter.nextInt();\n \t\t}\n \t\tString id = Integer.toString(current);\n \n \t\t// If you manage to get more than 100 million of ids, you'll\n \t\t// start getting ids longer than 8 characters.\n-\t\tif (current < 100000000)\n+\t\tif (current < limit)\n \t\t{\n \t\t\tid = (\"00000000\" + id).substring(id.length());\n \t\t}\n \t\treturn id;\n \t}\n \n+\n \t/**\n \t * @see java.lang.Object#toString()\n \t */\n@@ -602,4 +699,88 @@ public String toString()\n \t\t\t\", size=\" + getSize() + \"bytes, \" + \"isFormField=\" + isFormField() + \", FieldName=\" +\n \t\t\tgetFieldName();\n \t}\n-}\n\\ No newline at end of file\n+\n+\n+\t// -------------------------------------------------- Serialization methods\n+\n+\n+\t/**\n+\t * Writes the state of this object during serialization.\n+\t * \n+\t * @param out\n+\t *            The stream to which the state should be written.\n+\t * \n+\t * @throws IOException\n+\t *             if an error occurs.\n+\t */\n+\tprivate void writeObject(ObjectOutputStream out) throws IOException\n+\t{\n+\t\t// Read the data\n+\t\tif (dfos.isInMemory())\n+\t\t{\n+\t\t\tcachedContent = get();\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tcachedContent = null;\n+\t\t\tdfosFile = dfos.getFile();\n+\t\t}\n+\n+\t\t// write out values\n+\t\tout.defaultWriteObject();\n+\t}\n+\n+\t/**\n+\t * Reads the state of this object during deserialization.\n+\t * \n+\t * @param in\n+\t *            The stream from which the state should be read.\n+\t * \n+\t * @throws IOException\n+\t *             if an error occurs.\n+\t * @throws ClassNotFoundException\n+\t *             if class cannot be found.\n+\t */\n+\tprivate void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException\n+\t{\n+\t\t// read values\n+\t\tin.defaultReadObject();\n+\n+\t\tOutputStream output = getOutputStream();\n+\t\tif (cachedContent != null)\n+\t\t{\n+\t\t\toutput.write(cachedContent);\n+\t\t}\n+\t\telse\n+\t\t{\n+\t\t\tFileInputStream input = new FileInputStream(dfosFile);\n+\t\t\tStreams.copy(input, output);\n+\t\t\tdfosFile.delete();\n+\t\t\tdfosFile = null;\n+\t\t}\n+\t\toutput.close();\n+\n+\t\tcachedContent = null;\n+\t}\n+\n+\t/**\n+\t * Returns the file item headers.\n+\t * \n+\t * @return The file items headers.\n+\t */\n+\tpublic FileItemHeaders getHeaders()\n+\t{\n+\t\treturn headers;\n+\t}\n+\n+\t/**\n+\t * Sets the file item headers.\n+\t * \n+\t * @param pHeaders\n+\t *            The file items headers.\n+\t */\n+\tpublic void setHeaders(FileItemHeaders pHeaders)\n+\t{\n+\t\theaders = pHeaders;\n+\t}\n+}"
        },
        {
            "sha": "9364a792f55b9fd715ad0c75df5760a9538a5bea",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/DiskFileItemFactory.java",
            "status": "modified",
            "additions": 17,
            "deletions": 5,
            "changes": 22,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItemFactory.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItemFactory.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FDiskFileItemFactory.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -18,6 +18,7 @@\n \n import java.io.File;\n \n+\n /**\n  * <p>\n  * The default {@link org.apache.wicket.util.upload.FileItemFactory} implementation. This\n@@ -36,6 +37,16 @@\n  * </ul>\n  * </p>\n  * \n+ * <p>\n+ * When using the <code>DiskFileItemFactory</code>, then you should consider the following:\n+ * Temporary files are automatically deleted as soon as they are no longer needed. (More precisely,\n+ * when the corresponding instance of {@link java.io.File} is garbage collected.) Cleaning up those\n+ * files is done by an instance of {@link FileCleaningTracker}, and an associated thread. In a\n+ * complex environment, for example in a web application, you should consider terminating this\n+ * thread, for example, when your web application ends. See the section on \"Resource cleanup\" in the\n+ * users guide of commons-fileupload.\n+ * </p>\n+ * \n  * @author <a href=\"mailto:martinc@apache.org\">Martin Cooper</a>\n  */\n public class DiskFileItemFactory implements FileItemFactory\n@@ -74,6 +85,7 @@ public class DiskFileItemFactory implements FileItemFactory\n \t */\n \tpublic DiskFileItemFactory()\n \t{\n+\t\tthis(DEFAULT_SIZE_THRESHOLD, null);\n \t}\n \n \n@@ -93,7 +105,6 @@ public DiskFileItemFactory(final int sizeThreshold, final File repository)\n \t\tthis.repository = repository;\n \t}\n \n-\n \t// ------------------------------------------------------------- Properties\n \n \n@@ -130,7 +141,7 @@ public void setRepository(final File repository)\n \n \t/**\n \t * Returns the size threshold beyond which files are written directly to disk. The default value\n-\t * is 1024 bytes.\n+\t * is 10240 bytes.\n \t * \n \t * @return The size threshold, in bytes.\n \t * \n@@ -160,8 +171,8 @@ public void setSizeThreshold(final int sizeThreshold)\n \t// --------------------------------------------------------- Public Methods\n \n \t/**\n-\t * Create a new {@link org.apache.wicket.util.upload.DiskFileItem} instance from the supplied\n-\t * parameters and the local factory configuration.\n+\t * Create a new {@link org.apache.wicket.util.upload.DiskFileItem} instance from the\n+\t * supplied parameters and the local factory configuration.\n \t * \n \t * @param fieldName\n \t *            The name of the form field.\n@@ -180,4 +191,5 @@ public FileItem createItem(final String fieldName, final String contentType,\n \t\treturn new DiskFileItem(fieldName, contentType, isFormField, fileName, sizeThreshold,\n \t\t\trepository);\n \t}\n-}\n\\ No newline at end of file\n+\n+}"
        },
        {
            "sha": "dbd2c95b844a900981f564879c60f86afceaf158",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItem.java",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItem.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItem.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItem.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -24,18 +24,18 @@\n \n import org.apache.wicket.IClusterable;\n \n-\n /**\n  * <p>\n  * This class represents a file or form item that was received within a\n  * <code>multipart/form-data</code> POST request.\n  * \n  * <p>\n  * After retrieving an instance of this class from a\n- * {@link org.apache.wicket.util.upload.FileUpload FileUpload} instance, you may either request all\n- * contents of the file at once using {@link #get()} or request an {@link java.io.InputStream\n- * InputStream} with {@link #getInputStream()} and process the file without attempting to load it\n- * into memory, which may come handy with large files.\n+ * {@link org.apache.wicket.util.upload.FileUpload FileUpload} instance (see\n+ * {@link org.apache.wicket.util.upload.FileUpload #parseRequest(javax.servlet.http.HttpServletRequest)}\n+ * ), you may either request all contents of the file at once using {@link #get()} or request an\n+ * {@link java.io.InputStream InputStream} with {@link #getInputStream()} and process the file\n+ * without attempting to load it into memory, which may come handy with large files.\n  * \n  * <p>\n  * While this interface does not extend <code>javax.activation.DataSource</code> per se (to avoid a\n@@ -62,8 +62,8 @@ public interface FileItem extends IClusterable\n \t * @return An {@link java.io.InputStream InputStream} that can be used to retrieve the contents\n \t *         of the file.\n \t * \n-\t * @exception IOException\n-\t *                if an error occurs.\n+\t * @throws IOException\n+\t *             if an error occurs.\n \t */\n \tInputStream getInputStream() throws IOException;\n \n@@ -123,8 +123,8 @@ public interface FileItem extends IClusterable\n \t * \n \t * @return The contents of the item, as a string.\n \t * \n-\t * @exception UnsupportedEncodingException\n-\t *                if the requested character encoding is not available.\n+\t * @throws UnsupportedEncodingException\n+\t *             if the requested character encoding is not available.\n \t */\n \tString getString(String encoding) throws UnsupportedEncodingException;\n \n@@ -150,8 +150,8 @@ public interface FileItem extends IClusterable\n \t * @param file\n \t *            The <code>File</code> into which the uploaded item should be stored.\n \t * \n-\t * @exception Exception\n-\t *                if an error occurs.\n+\t * @throws Exception\n+\t *             if an error occurs.\n \t */\n \tvoid write(File file) throws IOException;\n \n@@ -206,10 +206,10 @@ public interface FileItem extends IClusterable\n \t * contents of the file.\n \t * \n \t * @return An {@link java.io.OutputStream OutputStream} that can be used for storing the\n-\t *         contents of the file.\n+\t *         contensts of the file.\n \t * \n-\t * @exception IOException\n-\t *                if an error occurs.\n+\t * @throws IOException\n+\t *             if an error occurs.\n \t */\n \tOutputStream getOutputStream() throws IOException;\n "
        },
        {
            "sha": "12a98a47824bee804d0eaecb7c50cb002129009f",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItemHeaders.java",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeaders.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeaders.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeaders.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,74 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.util.Iterator;\n+\n+/**\n+ * <p>\n+ * This class provides support for accessing the headers for a file or form item that was received\n+ * within a <code>multipart/form-data</code> POST request.\n+ * </p>\n+ * \n+ * @author Michael C. Macaluso\n+ */\n+public interface FileItemHeaders\n+{\n+\t/**\n+\t * Returns the value of the specified part header as a <code>String</code>. If the part did not\n+\t * include a header of the specified name, this method return <code>null</code>. If there are\n+\t * multiple headers with the same name, this method returns the first header in the item. The\n+\t * header name is case insensitive.\n+\t * \n+\t * @param name\n+\t *            a <code>String</code> specifying the header name\n+\t * @return a <code>String</code> containing the value of the requested header, or\n+\t *         <code>null</code> if the item does not have a header of that name\n+\t */\n+\tString getHeader(String name);\n+\n+\t/**\n+\t * <p>\n+\t * Returns all the values of the specified item header as an <code>Enumeration</code> of\n+\t * <code>String</code> objects.\n+\t * </p>\n+\t * <p>\n+\t * If the item did not include any headers of the specified name, this method returns an empty\n+\t * <code>Enumeration</code>. The header name is case insensitive.\n+\t * </p>\n+\t * \n+\t * @param name\n+\t *            a <code>String</code> specifying the header name\n+\t * @return an <code>Enumeration</code> containing the values of the requested header. If the\n+\t *         item does not have any headers of that name, return an empty <code>Enumeration</code>\n+\t */\n+\tIterator getHeaders(String name);\n+\n+\t/**\n+\t * <p>\n+\t * Returns an <code>Enumeration</code> of all the header names.\n+\t * </p>\n+\t * <p>\n+\t * If the item did not include any headers of the specified name, this method returns an empty\n+\t * <code>Enumeration</code>. The header name is case insensitive.\n+\t * </p>\n+\t * \n+\t * @return an <code>Enumeration</code> containing the values of the requested header. If the\n+\t *         item does not have any headers of that name return an empty <code>Enumeration</code>\n+\t */\n+\tIterator getHeaderNames();\n+}"
        },
        {
            "sha": "76b446181061561a0a57129f2c6be8e463e64ac8",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItemHeadersImpl.java",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersImpl.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersImpl.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersImpl.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,95 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * Default implementation of the {@link FileItemHeaders} interface.\n+ * \n+ * @author Michael C. Macaluso\n+ * @since 1.3\n+ */\n+public class FileItemHeadersImpl implements FileItemHeaders, Serializable\n+{\n+\tprivate static final long serialVersionUID = -4455695752627032559L;\n+\n+\t/**\n+\t * Map of <code>String</code> keys to a <code>List</code> of <code>String</code> instances.\n+\t */\n+\tprivate final Map headerNameToValueListMap = new HashMap();\n+\n+\t/**\n+\t * List to preserve order of headers as added. This would not be needed if a\n+\t * <code>LinkedHashMap</code> could be used, but don't want to depend on 1.4.\n+\t */\n+\tprivate final List headerNameList = new ArrayList();\n+\n+\tpublic String getHeader(String name)\n+\t{\n+\t\tString nameLower = name.toLowerCase();\n+\t\tList headerValueList = (List)headerNameToValueListMap.get(nameLower);\n+\t\tif (null == headerValueList)\n+\t\t{\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn (String)headerValueList.get(0);\n+\t}\n+\n+\tpublic Iterator getHeaderNames()\n+\t{\n+\t\treturn headerNameList.iterator();\n+\t}\n+\n+\tpublic Iterator getHeaders(String name)\n+\t{\n+\t\tString nameLower = name.toLowerCase();\n+\t\tList headerValueList = (List)headerNameToValueListMap.get(nameLower);\n+\t\tif (null == headerValueList)\n+\t\t{\n+\t\t\treturn Collections.EMPTY_LIST.iterator();\n+\t\t}\n+\t\treturn headerValueList.iterator();\n+\t}\n+\n+\t/**\n+\t * Method to add header values to this instance.\n+\t * \n+\t * @param name\n+\t *            name of this header\n+\t * @param value\n+\t *            value of this header\n+\t */\n+\tpublic synchronized void addHeader(String name, String value)\n+\t{\n+\t\tString nameLower = name.toLowerCase();\n+\t\tList headerValueList = (List)headerNameToValueListMap.get(nameLower);\n+\t\tif (null == headerValueList)\n+\t\t{\n+\t\t\theaderValueList = new ArrayList();\n+\t\t\theaderNameToValueListMap.put(nameLower, headerValueList);\n+\t\t\theaderNameList.add(nameLower);\n+\t\t}\n+\t\theaderValueList.add(value);\n+\t}\n+}"
        },
        {
            "sha": "cbd629e48d253196a4b82e9b3a220052e20b0bf3",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItemHeadersSupport.java",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersSupport.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersSupport.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemHeadersSupport.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+/**\n+ * Interface that will indicate that {@link FileItem} or {@link FileItemStream} implementations will\n+ * accept the headers read for the item.\n+ * \n+ * @author Michael C. Macaluso\n+ * \n+ * @see FileItem\n+ * @see FileItemStream\n+ */\n+public interface FileItemHeadersSupport\n+{\n+\t/**\n+\t * Returns the collection of headers defined locally within this item.\n+\t * \n+\t * @return the {@link FileItemHeaders} present for this item.\n+\t */\n+\tFileItemHeaders getHeaders();\n+\n+\t/**\n+\t * Sets the headers read from within an item. Implementations of {@link FileItem} or\n+\t * {@link FileItemStream} should implement this interface to be able to get the raw headers\n+\t * found within the item header block.\n+\t * \n+\t * @param headers\n+\t *            the instance that holds onto the headers for this instance.\n+\t */\n+\tvoid setHeaders(FileItemHeaders headers);\n+}"
        },
        {
            "sha": "9fce5c74de1b009e3bd5ec72056b36fe1f5f4439",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItemIterator.java",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemIterator.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemIterator.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemIterator.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,50 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.io.IOException;\n+\n+\n+/**\n+ * An iterator, as returned by {@link FileUploadBase#getItemIterator(RequestContext)}.\n+ */\n+public interface FileItemIterator\n+{\n+\t/**\n+\t * Returns, whether another instance of {@link FileItemStream} is available.\n+\t * \n+\t * @throws FileUploadException\n+\t *             Parsing or processing the file item failed.\n+\t * @throws IOException\n+\t *             Reading the file item failed.\n+\t * @return True, if one or more additional file items are available, otherwise false.\n+\t */\n+\tboolean hasNext() throws FileUploadException, IOException;\n+\n+\t/**\n+\t * Returns the next available {@link FileItemStream}.\n+\t * \n+\t * @throws java.util.NoSuchElementException\n+\t *             No more items are available. Use {@link #hasNext()} to prevent this exception.\n+\t * @throws FileUploadException\n+\t *             Parsing or processing the file item failed.\n+\t * @throws IOException\n+\t *             Reading the file item failed.\n+\t * @return FileItemStream instance, which provides access to the next file item.\n+\t */\n+\tFileItemStream next() throws FileUploadException, IOException;\n+}"
        },
        {
            "sha": "7d18c0ee81d1469638ef1e1a8b8210f818ae624d",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileItemStream.java",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemStream.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemStream.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileItemStream.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\n+/**\n+ * <p>\n+ * This interface provides access to a file or form item that was received within a\n+ * <code>multipart/form-data</code> POST request. The items contents are retrieved by calling\n+ * {@link #openStream()}.\n+ * </p>\n+ * <p>\n+ * Instances of this class are created by accessing the iterator, returned by\n+ * {@link FileUploadBase#getItemIterator(RequestContext)}.\n+ * </p>\n+ * <p>\n+ * <em>Note</em>: There is an interaction between the iterator and its associated instances of\n+ * {@link FileItemStream}: By invoking {@link java.util.Iterator#hasNext()} on the iterator, you\n+ * discard all data, which hasn't been read so far from the previous data.\n+ * </p>\n+ */\n+public interface FileItemStream extends FileItemHeadersSupport\n+{\n+\t/**\n+\t * This exception is thrown, if an attempt is made to read data from the {@link InputStream},\n+\t * which has been returned by {@link FileItemStream#openStream()}, after\n+\t * {@link java.util.Iterator#hasNext()} has been invoked on the iterator, which created the\n+\t * {@link FileItemStream}.\n+\t */\n+\tpublic static class ItemSkippedException extends IOException\n+\t{\n+\t\t/**\n+\t\t * The exceptions serial version UID, which is being used when serializing an exception\n+\t\t * instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = -7280778431581963740L;\n+\t}\n+\n+\t/**\n+\t * Creates an {@link InputStream}, which allows to read the items contents.\n+\t * \n+\t * @return The input stream, from which the items data may be read.\n+\t * @throws IllegalStateException\n+\t *             The method was already invoked on this item. It is not possible to recreate the\n+\t *             data stream.\n+\t * @throws IOException\n+\t *             An I/O error occurred.\n+\t * @see ItemSkippedException\n+\t */\n+\tInputStream openStream() throws IOException;\n+\n+\t/**\n+\t * Returns the content type passed by the browser or <code>null</code> if not defined.\n+\t * \n+\t * @return The content type passed by the browser or <code>null</code> if not defined.\n+\t */\n+\tString getContentType();\n+\n+\t/**\n+\t * Returns the original filename in the client's filesystem, as provided by the browser (or\n+\t * other client software). In most cases, this will be the base file name, without path\n+\t * information. However, some clients, such as the Opera browser, do include path information.\n+\t * \n+\t * @return The original filename in the client's filesystem.\n+\t */\n+\tString getName();\n+\n+\t/**\n+\t * Returns the name of the field in the multipart form corresponding to this file item.\n+\t * \n+\t * @return The name of the form field.\n+\t */\n+\tString getFieldName();\n+\n+\t/**\n+\t * Determines whether or not a <code>FileItem</code> instance represents a simple form field.\n+\t * \n+\t * @return <code>true</code> if the instance represents a simple form field; <code>false</code>\n+\t *         if it represents an uploaded file.\n+\t */\n+\tboolean isFormField();\n+}"
        },
        {
            "sha": "06574361693174a740c3137b4ed2698ffcc10ac4",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileUpload.java",
            "status": "modified",
            "additions": 19,
            "deletions": 4,
            "changes": 23,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUpload.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUpload.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUpload.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -24,7 +24,9 @@\n  * \n  * <p>\n  * This class handles multiple files per single HTML widget, sent using <code>multipart/mixed</code>\n- * encoding type, as specified by <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>.\n+ * encoding type, as specified by <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Use\n+ * {@link #parseRequest(javax.servlet.http.HttpServletRequest)} to acquire a list of\n+ * {@link org.apache.wicket.util.upload.FileItem FileItems} associated with a given HTML widget.\n  * </p>\n  * \n  * <p>\n@@ -42,13 +44,20 @@\n public class FileUpload extends FileUploadBase\n {\n \n+\t// ----------------------------------------------------------- Data members\n+\n+\n \t/**\n \t * The factory to use to create new form items.\n \t */\n \tprivate FileItemFactory fileItemFactory;\n \n+\n+\t// ----------------------------------------------------------- Constructors\n+\n+\n \t/**\n-\t * Constructs an uninitialized instance of this class. A factory must be configured, using\n+\t * Constructs an uninitialised instance of this class. A factory must be configured, using\n \t * <code>setFileItemFactory()</code>, before attempting to parse requests.\n \t * \n \t * @see #FileUpload(FileItemFactory)\n@@ -63,16 +72,20 @@ public FileUpload()\n \t * Constructs an instance of this class which uses the supplied factory to create\n \t * <code>FileItem</code> instances.\n \t * \n-\t * @param fileItemFactory\n-\t * \n \t * @see #FileUpload()\n+\t * @param fileItemFactory\n+\t *            The factory to use for creating file items.\n \t */\n \tpublic FileUpload(final FileItemFactory fileItemFactory)\n \t{\n \t\tsuper();\n \t\tthis.fileItemFactory = fileItemFactory;\n \t}\n \n+\n+\t// ----------------------------------------------------- Property accessors\n+\n+\n \t/**\n \t * Returns the factory class used when creating file items.\n \t * \n@@ -96,4 +109,6 @@ public void setFileItemFactory(final FileItemFactory factory)\n \t{\n \t\tfileItemFactory = factory;\n \t}\n+\n+\n }"
        },
        {
            "sha": "1e7ea078adb25ba9e83fcbe76cec03482b71d753",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileUploadBase.java",
            "status": "modified",
            "additions": 1021,
            "deletions": 205,
            "changes": 1226,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadBase.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadBase.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadBase.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -18,13 +18,18 @@\n \n import java.io.IOException;\n import java.io.InputStream;\n-import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n import java.util.ArrayList;\n import java.util.HashMap;\n+import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n+import java.util.NoSuchElementException;\n \n+import javax.servlet.http.HttpServletRequest;\n+\n+import org.apache.wicket.util.io.Streams;\n+import org.apache.wicket.util.upload.MultipartFormInputStream.ItemInputStream;\n \n /**\n  * <p>\n@@ -33,7 +38,10 @@\n  * \n  * <p>\n  * This class handles multiple files per single HTML widget, sent using <code>multipart/mixed</code>\n- * encoding type, as specified by <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>.\n+ * encoding type, as specified by <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a>. Use\n+ * {@link #parseRequest(HttpServletRequest)} to acquire a list of\n+ * {@link org.apache.wicket.util.upload.FileItem}s associated with a given HTML widget.\n+ * </p>\n  * \n  * <p>\n  * How the data for individual parts is stored is determined by the factory used to create them; a\n@@ -83,6 +91,24 @@ public static final boolean isMultipartContent(final RequestContext ctx)\n \t\treturn false;\n \t}\n \n+\n+\t/**\n+\t * Utility method that determines whether the request contains multipart content.\n+\t * \n+\t * @param req\n+\t *            The servlet request to be evaluated. Must be non-null.\n+\t * \n+\t * @return <code>true</code> if the request is multipart; <code>false</code> otherwise.\n+\t * \n+\t * @deprecated Use the method on <code>ServletFileUpload</code> instead.\n+\t */\n+\t@Deprecated\n+\tpublic static boolean isMultipartContent(HttpServletRequest req)\n+\t{\n+\t\treturn ServletFileUpload.isMultipartContent(req);\n+\t}\n+\n+\n \t// ----------------------------------------------------- Manifest constants\n \n \n@@ -97,6 +123,11 @@ public static final boolean isMultipartContent(final RequestContext ctx)\n \t */\n \tpublic static final String CONTENT_DISPOSITION = \"Content-disposition\";\n \n+\t/**\n+\t * HTTP content length header name.\n+\t */\n+\tpublic static final String CONTENT_LENGTH = \"Content-length\";\n+\n \n \t/**\n \t * Content-disposition value for form data.\n@@ -130,24 +161,39 @@ public static final boolean isMultipartContent(final RequestContext ctx)\n \n \t/**\n \t * The maximum length of a single header line that will be parsed (1024 bytes).\n+\t * \n+\t * @deprecated This constant is no longer used. As of commons-fileupload 1.2, the only\n+\t *             applicable limit is the total size of a parts headers,\n+\t *             {@link MultipartStream#HEADER_PART_SIZE_MAX}.\n \t */\n+\t@Deprecated\n \tpublic static final int MAX_HEADER_SIZE = 1024;\n \n \n \t// ----------------------------------------------------------- Data members\n \n \n \t/**\n-\t * The maximum size permitted for an uploaded file. A value of -1 indicates no maximum.\n+\t * The maximum size permitted for the complete request, as opposed to {@link #fileSizeMax}. A\n+\t * value of -1 indicates no maximum.\n \t */\n \tprivate long sizeMax = -1;\n \n+\t/**\n+\t * The maximum size permitted for a single uploaded file, as opposed to {@link #sizeMax}. A\n+\t * value of -1 indicates no maximum.\n+\t */\n+\tprivate long fileSizeMax = -1;\n \n \t/**\n \t * The content encoding to use when reading part headers.\n \t */\n \tprivate String headerEncoding;\n \n+\t/**\n+\t * The progress listener.\n+\t */\n+\tprivate ProgressListener listener;\n \n \t// ----------------------------------------------------- Property accessors\n \n@@ -170,9 +216,11 @@ public static final boolean isMultipartContent(final RequestContext ctx)\n \n \n \t/**\n-\t * Returns the maximum allowed upload size.\n+\t * Returns the maximum allowed size of a complete request, as opposed to\n+\t * {@link #getFileSizeMax()}.\n \t * \n-\t * @return The maximum allowed size, in bytes.\n+\t * @return The maximum allowed size, in bytes. The default value of -1 indicates, that there is\n+\t *         no limit.\n \t * \n \t * @see #setSizeMax(long)\n \t * \n@@ -184,10 +232,12 @@ public long getSizeMax()\n \n \n \t/**\n-\t * Sets the maximum allowed upload size. If negative, there is no maximum.\n+\t * Sets the maximum allowed size of a complete request, as opposed to\n+\t * {@link #setFileSizeMax(long)}.\n \t * \n \t * @param sizeMax\n-\t *            The maximum allowed size, in bytes, or -1 for no maximum.\n+\t *            The maximum allowed size, in bytes. The default value of -1 indicates, that there\n+\t *            is no limit.\n \t * \n \t * @see #getSizeMax()\n \t * \n@@ -197,10 +247,34 @@ public void setSizeMax(final long sizeMax)\n \t\tthis.sizeMax = sizeMax;\n \t}\n \n+\t/**\n+\t * Returns the maximum allowed size of a single uploaded file, as opposed to\n+\t * {@link #getSizeMax()}.\n+\t * \n+\t * @see #setFileSizeMax(long)\n+\t * @return Maximum size of a single uploaded file.\n+\t */\n+\tpublic long getFileSizeMax()\n+\t{\n+\t\treturn fileSizeMax;\n+\t}\n+\n+\t/**\n+\t * Sets the maximum allowed size of a single uploaded file, as opposed to {@link #getSizeMax()}.\n+\t * \n+\t * @see #getFileSizeMax()\n+\t * @param fileSizeMax\n+\t *            Maximum size of a single uploaded file.\n+\t */\n+\tpublic void setFileSizeMax(long fileSizeMax)\n+\t{\n+\t\tthis.fileSizeMax = fileSizeMax;\n+\t}\n \n \t/**\n \t * Retrieves the character encoding used when reading the headers of an individual part. When\n-\t * not specified, or <code>null</code>, the platform default encoding is used.\n+\t * not specified, or <code>null</code>, the request encoding is used. If that is also not\n+\t * specified, or <code>null</code>, the platform default encoding is used.\n \t * \n \t * @return The encoding used to read part headers.\n \t */\n@@ -211,8 +285,9 @@ public String getHeaderEncoding()\n \n \n \t/**\n-\t * Specifies the character encoding to be used when reading the headers of individual parts.\n-\t * When not specified, or <code>null</code>, the platform default encoding is used.\n+\t * Specifies the character encoding to be used when reading the headers of individual part. When\n+\t * not specified, or <code>null</code>, the request encoding is used. If that is also not\n+\t * specified, or <code>null</code>, the platform default encoding is used.\n \t * \n \t * @param encoding\n \t *            The encoding used to read part headers.\n@@ -225,6 +300,50 @@ public void setHeaderEncoding(final String encoding)\n \n \t// --------------------------------------------------------- Public methods\n \n+\n+\t/**\n+\t * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant\n+\t * <code>multipart/form-data</code> stream.\n+\t * \n+\t * @param req\n+\t *            The servlet request to be parsed.\n+\t * \n+\t * @return A list of <code>FileItem</code> instances parsed from the request, in the order that\n+\t *         they were transmitted.\n+\t * \n+\t * @throws FileUploadException\n+\t *             if there are problems reading/parsing the request or storing files.\n+\t * \n+\t * @deprecated Use the method in <code>ServletFileUpload</code> instead.\n+\t */\n+\t@Deprecated\n+\tpublic List<FileItem> parseRequest(HttpServletRequest req) throws FileUploadException\n+\t{\n+\t\treturn parseRequest(new ServletRequestContext(req));\n+\t}\n+\n+\t/**\n+\t * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant\n+\t * <code>multipart/form-data</code> stream.\n+\t * \n+\t * @param ctx\n+\t *            The context for the request to be parsed.\n+\t * \n+\t * @return An iterator to instances of <code>FileItemStream</code> parsed from the request, in\n+\t *         the order that they were transmitted.\n+\t * \n+\t * @throws FileUploadException\n+\t *             if there are problems reading/parsing the request or storing files.\n+\t * @throws IOException\n+\t *             An I/O error occurred. This may be a network error while communicating with the\n+\t *             client or a problem while storing the uploaded content.\n+\t */\n+\tpublic FileItemIterator getItemIterator(RequestContext ctx) throws FileUploadException,\n+\t\tIOException\n+\t{\n+\t\treturn new FileItemIteratorImpl(ctx);\n+\t}\n+\n \t/**\n \t * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant\n \t * <code>multipart/form-data</code> stream.\n@@ -235,132 +354,55 @@ public void setHeaderEncoding(final String encoding)\n \t * @return A list of <code>FileItem</code> instances parsed from the request, in the order that\n \t *         they were transmitted.\n \t * \n-\t * @exception FileUploadException\n-\t *                if there are problems reading/parsing the request or storing files.\n+\t * @throws FileUploadException\n+\t *             if there are problems reading/parsing the request or storing files.\n \t */\n \tpublic List<FileItem> parseRequest(final RequestContext ctx) throws FileUploadException\n \t{\n-\t\tif (ctx == null)\n-\t\t{\n-\t\t\tthrow new IllegalArgumentException(\"ctx parameter cannot be null\");\n-\t\t}\n-\n-\t\tList<FileItem> items = new ArrayList<FileItem>();\n-\t\tString contentType = ctx.getContentType();\n-\n-\t\tif ((null == contentType) || (!contentType.toLowerCase().startsWith(MULTIPART)))\n-\t\t{\n-\t\t\tthrow new InvalidContentTypeException(\"the request doesn't contain a \" +\n-\t\t\t\tMULTIPART_FORM_DATA + \" or \" + MULTIPART_MIXED +\n-\t\t\t\t\" stream, content type header is \" + contentType);\n-\t\t}\n-\t\tint requestSize = ctx.getContentLength();\n-\n-\t\tif ((requestSize == -1) && (getSizeMax() != Long.MAX_VALUE))\n-\t\t{\n-\t\t\tthrow new UnknownSizeException(\"the request was rejected because its size is unknown\");\n-\t\t}\n-\n-\t\tif ((sizeMax >= 0) && (requestSize > sizeMax))\n-\t\t{\n-\t\t\tthrow new SizeLimitExceededException(\"the request was rejected because \"\n-\t\t\t\t+ \"its size exceeds allowed range\");\n-\t\t}\n-\n \t\ttry\n \t\t{\n-\t\t\tbyte[] boundary = getBoundary(contentType);\n-\t\t\tif (boundary == null)\n+\t\t\tFileItemIterator iter = getItemIterator(ctx);\n+\t\t\tList<FileItem> items = new ArrayList<FileItem>();\n+\t\t\tFileItemFactory fac = getFileItemFactory();\n+\t\t\tif (fac == null)\n \t\t\t{\n-\t\t\t\tthrow new FileUploadException(\"the request was rejected because \"\n-\t\t\t\t\t+ \"no multipart boundary was found\");\n+\t\t\t\tthrow new NullPointerException(\"No FileItemFactory has been set.\");\n \t\t\t}\n-\n-\t\t\tInputStream input = ctx.getInputStream();\n-\n-\t\t\tMultipartFormInputStream multi = new MultipartFormInputStream(input, boundary);\n-\t\t\tmulti.setHeaderEncoding(headerEncoding);\n-\n-\t\t\tboolean nextPart = multi.skipPreamble();\n-\n-\t\t\t// Don't allow a header larger than this size (to prevent DOS\n-\t\t\t// attacks)\n-\t\t\tfinal int maxHeaderBytes = 65536;\n-\t\t\twhile (nextPart)\n+\t\t\twhile (iter.hasNext())\n \t\t\t{\n-\t\t\t\tMap<String, String> headers = parseHeaders(multi.readHeaders(maxHeaderBytes));\n-\t\t\t\tString fieldName = getFieldName(headers);\n-\t\t\t\tif (fieldName != null)\n+\t\t\t\tFileItemStream item = iter.next();\n+\t\t\t\tFileItem fileItem = fac.createItem(item.getFieldName(), item.getContentType(),\n+\t\t\t\t\titem.isFormField(), item.getName());\n+\t\t\t\ttry\n \t\t\t\t{\n-\t\t\t\t\tString subContentType = getHeader(headers, CONTENT_TYPE);\n-\t\t\t\t\tif ((subContentType != null) &&\n-\t\t\t\t\t\tsubContentType.toLowerCase().startsWith(MULTIPART_MIXED))\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// Multiple files.\n-\t\t\t\t\t\tbyte[] subBoundary = getBoundary(subContentType);\n-\t\t\t\t\t\tmulti.setBoundary(subBoundary);\n-\t\t\t\t\t\tboolean nextSubPart = multi.skipPreamble();\n-\t\t\t\t\t\twhile (nextSubPart)\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\theaders = parseHeaders(multi.readHeaders(maxHeaderBytes));\n-\t\t\t\t\t\t\tif (getFileName(headers) != null)\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\tFileItem item = createItem(headers, false);\n-\t\t\t\t\t\t\t\titems.add(item);\n-\t\t\t\t\t\t\t\tOutputStream os = item.getOutputStream();\n-\t\t\t\t\t\t\t\ttry\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tmulti.readBodyData(os);\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t\tfinally\n-\t\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t\tos.close();\n-\t\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\telse\n-\t\t\t\t\t\t\t{\n-\t\t\t\t\t\t\t\t// Ignore anything but files inside\n-\t\t\t\t\t\t\t\t// multipart/mixed.\n-\t\t\t\t\t\t\t\tmulti.discardBodyData();\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tnextSubPart = multi.readBoundary();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tmulti.setBoundary(boundary);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\tFileItem item = createItem(headers, getFileName(headers) == null);\n-\t\t\t\t\t\titems.add(item);\n-\t\t\t\t\t\tOutputStream os = item.getOutputStream();\n-\t\t\t\t\t\ttry\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tmulti.readBodyData(os);\n-\t\t\t\t\t\t}\n-\t\t\t\t\t\tfinally\n-\t\t\t\t\t\t{\n-\t\t\t\t\t\t\tos.close();\n-\t\t\t\t\t\t}\n-\t\t\t\t\t}\n+\t\t\t\t\tStreams.copyAndClose(item.openStream(), fileItem.getOutputStream());\n \t\t\t\t}\n-\t\t\t\telse\n+\t\t\t\tcatch (FileUploadIOException e)\n+\t\t\t\t{\n+\t\t\t\t\tthrow (FileUploadException)e.getCause();\n+\t\t\t\t}\n+\t\t\t\tcatch (IOException e)\n \t\t\t\t{\n-\t\t\t\t\t// Skip this part.\n-\t\t\t\t\tmulti.discardBodyData();\n+\t\t\t\t\tthrow new IOFileUploadException(\"Processing of \" + MULTIPART_FORM_DATA +\n+\t\t\t\t\t\t\" request failed. \" + e.getMessage(), e);\n \t\t\t\t}\n-\t\t\t\tnextPart = multi.readBoundary();\n+\t\t\t\tif (fileItem instanceof FileItemHeadersSupport)\n+\t\t\t\t{\n+\t\t\t\t\tfinal FileItemHeaders fih = item.getHeaders();\n+\t\t\t\t\t((FileItemHeadersSupport)fileItem).setHeaders(fih);\n+\t\t\t\t}\n+\t\t\t\titems.add(fileItem);\n \t\t\t}\n+\t\t\treturn items;\n+\t\t}\n+\t\tcatch (FileUploadIOException e)\n+\t\t{\n+\t\t\tthrow (FileUploadException)e.getCause();\n \t\t}\n \t\tcatch (IOException e)\n \t\t{\n-\t\t\tfor (FileItem item : items)\n-\t\t\t{\n-\t\t\t\titem.delete();\n-\t\t\t}\n-\t\t\tthrow new FileUploadException(\"Processing of \" + MULTIPART_FORM_DATA +\n-\t\t\t\t\" request failed. \" + e.getMessage(), e);\n+\t\t\tthrow new FileUploadException(e.getMessage(), e);\n \t\t}\n-\n-\t\treturn items;\n \t}\n \n \n@@ -380,8 +422,8 @@ protected byte[] getBoundary(final String contentType)\n \t\tParameterParser parser = new ParameterParser();\n \t\tparser.setLowerCaseNames(true);\n \t\t// Parameter parser can handle null input\n-\t\tMap<String, String> params = parser.parse(contentType, ';');\n-\t\tString boundaryStr = params.get(\"boundary\");\n+\t\tMap params = parser.parse(contentType, new char[] { ';', ',' });\n+\t\tString boundaryStr = (String)params.get(\"boundary\");\n \n \t\tif (boundaryStr == null)\n \t\t{\n@@ -407,39 +449,61 @@ protected byte[] getBoundary(final String contentType)\n \t *            A <code>Map</code> containing the HTTP request headers.\n \t * \n \t * @return The file name for the current <code>encapsulation</code>.\n+\t * @deprecated Use {@link #getFileName(FileItemHeaders)}.\n \t */\n+\t@Deprecated\n \tprotected String getFileName(final Map<String, String> headers)\n+\t{\n+\t\treturn getFileName(getHeader(headers, CONTENT_DISPOSITION));\n+\t}\n+\n+\t/**\n+\t * Retrieves the file name from the <code>Content-disposition</code> header.\n+\t * \n+\t * @param headers\n+\t *            The HTTP headers object.\n+\t * \n+\t * @return The file name for the current <code>encapsulation</code>.\n+\t */\n+\tprotected String getFileName(FileItemHeaders headers)\n+\t{\n+\t\treturn getFileName(headers.getHeader(CONTENT_DISPOSITION));\n+\t}\n+\n+\t/**\n+\t * Returns the given content-disposition headers file name.\n+\t * \n+\t * @param pContentDisposition\n+\t *            The content-disposition headers value.\n+\t * @return The file name\n+\t */\n+\tprivate String getFileName(String pContentDisposition)\n \t{\n \t\tString fileName = null;\n-\t\tString cd = getHeader(headers, CONTENT_DISPOSITION);\n-\t\tif (cd.startsWith(FORM_DATA) || cd.startsWith(ATTACHMENT))\n+\t\tif (pContentDisposition != null)\n \t\t{\n-\t\t\tParameterParser parser = new ParameterParser();\n-\t\t\tparser.setLowerCaseNames(true);\n-\t\t\t// Parameter parser can handle null input\n-\t\t\tMap<String, String> params = parser.parse(cd, ';');\n-\t\t\tif (params.containsKey(\"filename\"))\n+\t\t\tString cdl = pContentDisposition.toLowerCase();\n+\t\t\tif (cdl.startsWith(FORM_DATA) || cdl.startsWith(ATTACHMENT))\n \t\t\t{\n-\t\t\t\tfileName = params.get(\"filename\");\n-\t\t\t\tif (fileName != null)\n+\t\t\t\tParameterParser parser = new ParameterParser();\n+\t\t\t\tparser.setLowerCaseNames(true);\n+\t\t\t\t// Parameter parser can handle null input\n+\t\t\t\tMap params = parser.parse(pContentDisposition, ';');\n+\t\t\t\tif (params.containsKey(\"filename\"))\n \t\t\t\t{\n-\t\t\t\t\tfileName = fileName.trim();\n-\t\t\t\t\tint index = fileName.lastIndexOf('\\\\');\n-\t\t\t\t\tif (index == -1)\n+\t\t\t\t\tfileName = (String)params.get(\"filename\");\n+\t\t\t\t\tif (fileName != null)\n \t\t\t\t\t{\n-\t\t\t\t\t\tindex = fileName.lastIndexOf('/');\n+\t\t\t\t\t\tfileName = fileName.trim();\n \t\t\t\t\t}\n-\t\t\t\t\tif (index != -1)\n+\t\t\t\t\telse\n \t\t\t\t\t{\n-\t\t\t\t\t\tfileName = fileName.substring(index + 1);\n+\t\t\t\t\t\t// Even if there is no value, the parameter is present,\n+\t\t\t\t\t\t// so we return an empty file name rather than no file\n+\t\t\t\t\t\t// name.\n+\t\t\t\t\t\tfileName = \"\";\n \t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// Even if there is no value, the parameter is present, so\n-\t\t\t\t\t// we return an empty file name rather than no file name.\n-\t\t\t\t\tfileName = \"\";\n-\t\t\t\t}\n \t\t\t}\n \t\t}\n \t\treturn fileName;\n@@ -454,18 +518,28 @@ protected String getFileName(final Map<String, String> headers)\n \t * \n \t * @return The field name for the current <code>encapsulation</code>.\n \t */\n-\tprotected String getFieldName(final Map<String, String> headers)\n+\tprotected String getFieldName(final FileItemHeaders headers)\n+\t{\n+\t\treturn getFieldName(headers.getHeader(CONTENT_DISPOSITION));\n+\t}\n+\n+\t/**\n+\t * Returns the field name, which is given by the content-disposition header.\n+\t * \n+\t * @param pContentDisposition\n+\t *            The content-dispositions header value.\n+\t * @return The field jake\n+\t */\n+\tprivate String getFieldName(String pContentDisposition)\n \t{\n \t\tString fieldName = null;\n-\t\tString cd = getHeader(headers, CONTENT_DISPOSITION);\n-\t\tif ((cd != null) && cd.startsWith(FORM_DATA))\n+\t\tif (pContentDisposition != null && pContentDisposition.toLowerCase().startsWith(FORM_DATA))\n \t\t{\n-\n \t\t\tParameterParser parser = new ParameterParser();\n \t\t\tparser.setLowerCaseNames(true);\n \t\t\t// Parameter parser can handle null input\n-\t\t\tMap<String, String> params = parser.parse(cd, ';');\n-\t\t\tfieldName = params.get(\"name\");\n+\t\t\tMap params = parser.parse(pContentDisposition, ';');\n+\t\t\tfieldName = (String)params.get(\"name\");\n \t\t\tif (fieldName != null)\n \t\t\t{\n \t\t\t\tfieldName = fieldName.trim();\n@@ -474,6 +548,21 @@ protected String getFieldName(final Map<String, String> headers)\n \t\treturn fieldName;\n \t}\n \n+\t/**\n+\t * Retrieves the field name from the <code>Content-disposition</code> header.\n+\t * \n+\t * @param headers\n+\t *            A <code>Map</code> containing the HTTP request headers.\n+\t * \n+\t * @return The field name for the current <code>encapsulation</code>.\n+\t * @deprecated Use {@link #getFieldName(FileItemHeaders)}.\n+\t */\n+\t@Deprecated\n+\tprotected String getFieldName(Map<String, String> headers)\n+\t{\n+\t\treturn getFieldName(getHeader(headers, CONTENT_DISPOSITION));\n+\t}\n+\n \n \t/**\n \t * Creates a new {@link FileItem} instance.\n@@ -484,14 +573,20 @@ protected String getFieldName(final Map<String, String> headers)\n \t *            Whether or not this item is a form field, as opposed to a file.\n \t * \n \t * @return A newly created <code>FileItem</code> instance.\n+\t * \n+\t * @throws FileUploadException\n+\t *             if an error occurs.\n+\t * @deprecated This method is no longer used in favour of internally created instances of\n+\t *             {@link FileItem}.\n \t */\n+\t@Deprecated\n \tprotected FileItem createItem(final Map<String, String> headers, final boolean isFormField)\n+\t\tthrows FileUploadException\n \t{\n \t\treturn getFileItemFactory().createItem(getFieldName(headers),\n \t\t\tgetHeader(headers, CONTENT_TYPE), isFormField, getFileName(headers));\n \t}\n \n-\n \t/**\n \t * <p>\n \t * Parses the <code>header-part</code> and returns as key/value pairs.\n@@ -505,60 +600,137 @@ protected FileItem createItem(final Map<String, String> headers, final boolean i\n \t * \n \t * @return A <code>Map</code> containing the parsed HTTP request headers.\n \t */\n-\tprotected Map<String, String> parseHeaders(final String headerPart)\n+\tprotected FileItemHeaders getParsedHeaders(final String headerPart)\n \t{\n-\t\tMap<String, String> headers = new HashMap<String, String>();\n-\t\tchar[] buffer = new char[MAX_HEADER_SIZE];\n-\t\tboolean done = false;\n-\t\tint j = 0;\n-\t\tint i;\n-\t\tString header, headerName, headerValue;\n-\t\ttry\n+\t\tfinal int len = headerPart.length();\n+\t\tFileItemHeadersImpl headers = newFileItemHeaders();\n+\t\tint start = 0;\n+\t\tfor (;;)\n \t\t{\n-\t\t\twhile (!done)\n+\t\t\tint end = parseEndOfLine(headerPart, start);\n+\t\t\tif (start == end)\n \t\t\t{\n-\t\t\t\ti = 0;\n-\t\t\t\t// Copy a single line of characters into the buffer,\n-\t\t\t\t// omitting trailing CRLF.\n-\t\t\t\twhile ((i < 2) || (buffer[i - 2] != '\\r') || (buffer[i - 1] != '\\n'))\n-\t\t\t\t{\n-\t\t\t\t\tbuffer[i++] = headerPart.charAt(j++);\n-\t\t\t\t}\n-\t\t\t\theader = new String(buffer, 0, i - 2);\n-\t\t\t\tif (header.equals(\"\"))\n-\t\t\t\t{\n-\t\t\t\t\tdone = true;\n-\t\t\t\t}\n-\t\t\t\telse\n+\t\t\t\tbreak;\n+\t\t\t}\n+\t\t\tString header = headerPart.substring(start, end);\n+\t\t\tstart = end + 2;\n+\t\t\twhile (start < len)\n+\t\t\t{\n+\t\t\t\tint nonWs = start;\n+\t\t\t\twhile (nonWs < len)\n \t\t\t\t{\n-\t\t\t\t\tif (header.indexOf(':') == -1)\n-\t\t\t\t\t{\n-\t\t\t\t\t\t// This header line is malformed, skip it.\n-\t\t\t\t\t\tcontinue;\n-\t\t\t\t\t}\n-\t\t\t\t\theaderName = header.substring(0, header.indexOf(':')).trim().toLowerCase();\n-\t\t\t\t\theaderValue = header.substring(header.indexOf(':') + 1).trim();\n-\t\t\t\t\tif (getHeader(headers, headerName) != null)\n+\t\t\t\t\tchar c = headerPart.charAt(nonWs);\n+\t\t\t\t\tif (c != ' ' && c != '\\t')\n \t\t\t\t\t{\n-\t\t\t\t\t\t// More that one header of that name exists,\n-\t\t\t\t\t\t// append to the list.\n-\t\t\t\t\t\theaders.put(headerName, getHeader(headers, headerName) + ',' + headerValue);\n-\t\t\t\t\t}\n-\t\t\t\t\telse\n-\t\t\t\t\t{\n-\t\t\t\t\t\theaders.put(headerName, headerValue);\n+\t\t\t\t\t\tbreak;\n \t\t\t\t\t}\n+\t\t\t\t\t++nonWs;\n \t\t\t\t}\n+\t\t\t\tif (nonWs == start)\n+\t\t\t\t{\n+\t\t\t\t\tbreak;\n+\t\t\t\t}\n+\t\t\t\t// Continuation line found\n+\t\t\t\tend = parseEndOfLine(headerPart, nonWs);\n+\t\t\t\theader += \" \" + headerPart.substring(nonWs, end);\n+\t\t\t\tstart = end + 2;\n+\t\t\t}\n+\t\t\tparseHeaderLine(headers, header);\n+\t\t}\n+\t\treturn headers;\n+\t}\n+\n+\t/**\n+\t * Creates a new instance of {@link FileItemHeaders}.\n+\t * \n+\t * @return The new instance.\n+\t */\n+\tprotected FileItemHeadersImpl newFileItemHeaders()\n+\t{\n+\t\treturn new FileItemHeadersImpl();\n+\t}\n+\n+\t/**\n+\t * <p>\n+\t * Parses the <code>header-part</code> and returns as key/value pairs.\n+\t * \n+\t * <p>\n+\t * If there are multiple headers of the same names, the name will map to a comma-separated list\n+\t * containing the values.\n+\t * \n+\t * @param headerPart\n+\t *            The <code>header-part</code> of the current <code>encapsulation</code>.\n+\t * \n+\t * @return A <code>Map</code> containing the parsed HTTP request headers.\n+\t * @deprecated Use {@link #getParsedHeaders(String)}\n+\t */\n+\t@Deprecated\n+\tprotected Map /* String, String */parseHeaders(String headerPart)\n+\t{\n+\t\tFileItemHeaders headers = getParsedHeaders(headerPart);\n+\t\tMap result = new HashMap();\n+\t\tfor (Iterator iter = headers.getHeaderNames(); iter.hasNext();)\n+\t\t{\n+\t\t\tString headerName = (String)iter.next();\n+\t\t\tIterator iter2 = headers.getHeaders(headerName);\n+\t\t\tString headerValue = (String)iter2.next();\n+\t\t\twhile (iter2.hasNext())\n+\t\t\t{\n+\t\t\t\theaderValue += \",\" + iter2.next();\n \t\t\t}\n+\t\t\tresult.put(headerName, headerValue);\n \t\t}\n-\t\tcatch (IndexOutOfBoundsException e)\n+\t\treturn result;\n+\t}\n+\n+\t/**\n+\t * Skips bytes until the end of the current line.\n+\t * \n+\t * @param headerPart\n+\t *            The headers, which are being parsed.\n+\t * @param end\n+\t *            Index of the last byte, which has yet been processed.\n+\t * @return Index of the \\r\\n sequence, which indicates end of line.\n+\t */\n+\tprivate int parseEndOfLine(String headerPart, int end)\n+\t{\n+\t\tint index = end;\n+\t\tfor (;;)\n \t\t{\n-\t\t\t// Headers were malformed. continue with all that was\n-\t\t\t// parsed.\n+\t\t\tint offset = headerPart.indexOf('\\r', index);\n+\t\t\tif (offset == -1 || offset + 1 >= headerPart.length())\n+\t\t\t{\n+\t\t\t\tthrow new IllegalStateException(\n+\t\t\t\t\t\"Expected headers to be terminated by an empty line.\");\n+\t\t\t}\n+\t\t\tif (headerPart.charAt(offset + 1) == '\\n')\n+\t\t\t{\n+\t\t\t\treturn offset;\n+\t\t\t}\n+\t\t\tindex = offset + 1;\n \t\t}\n-\t\treturn headers;\n \t}\n \n+\t/**\n+\t * Reads the next header line.\n+\t * \n+\t * @param headers\n+\t *            String with all headers.\n+\t * @param header\n+\t *            Map where to store the current header.\n+\t */\n+\tprivate void parseHeaderLine(FileItemHeadersImpl headers, String header)\n+\t{\n+\t\tfinal int colonOffset = header.indexOf(':');\n+\t\tif (colonOffset == -1)\n+\t\t{\n+\t\t\t// This header line is malformed, skip it.\n+\t\t\treturn;\n+\t\t}\n+\t\tString headerName = header.substring(0, colonOffset).trim();\n+\t\tString headerValue = header.substring(header.indexOf(':') + 1).trim();\n+\t\theaders.addHeader(headerName, headerValue);\n+\t}\n \n \t/**\n \t * Returns the header with the specified name from the supplied map. The header lookup is\n@@ -571,27 +743,506 @@ protected Map<String, String> parseHeaders(final String headerPart)\n \t * \n \t * @return The value of specified header, or a comma-separated list if there were multiple\n \t *         headers of that name.\n+\t * @deprecated Use {@link FileItemHeaders#getHeader(String)}.\n \t */\n+\t@Deprecated\n \tprotected final String getHeader(final Map<String, String> headers, final String name)\n \t{\n \t\treturn headers.get(name.toLowerCase());\n \t}\n \n+\t/**\n+\t * The iterator, which is returned by {@link FileUploadBase#getItemIterator(RequestContext)}.\n+\t */\n+\tprivate class FileItemIteratorImpl implements FileItemIterator\n+\t{\n+\t\t/**\n+\t\t * Default implementation of {@link FileItemStream}.\n+\t\t */\n+\t\tprivate class FileItemStreamImpl implements FileItemStream\n+\t\t{\n+\t\t\t/**\n+\t\t\t * The file items content type.\n+\t\t\t */\n+\t\t\tprivate final String contentType;\n+\t\t\t/**\n+\t\t\t * The file items field name.\n+\t\t\t */\n+\t\t\tprivate final String fieldName;\n+\t\t\t/**\n+\t\t\t * The file items file name.\n+\t\t\t */\n+\t\t\tprivate final String name;\n+\t\t\t/**\n+\t\t\t * Whether the file item is a form field.\n+\t\t\t */\n+\t\t\tprivate final boolean formField;\n+\t\t\t/**\n+\t\t\t * The file items input stream.\n+\t\t\t */\n+\t\t\tprivate final InputStream stream;\n+\t\t\t/**\n+\t\t\t * Whether the file item was already opened.\n+\t\t\t */\n+\t\t\tprivate boolean opened;\n+\t\t\t/**\n+\t\t\t * The headers, if any.\n+\t\t\t */\n+\t\t\tprivate FileItemHeaders headers;\n+\n+\t\t\t/**\n+\t\t\t * Creates a new instance.\n+\t\t\t * \n+\t\t\t * @param pName\n+\t\t\t *            The items file name, or null.\n+\t\t\t * @param pFieldName\n+\t\t\t *            The items field name.\n+\t\t\t * @param pContentType\n+\t\t\t *            The items content type, or null.\n+\t\t\t * @param pFormField\n+\t\t\t *            Whether the item is a form field.\n+\t\t\t * @param pContentLength\n+\t\t\t *            The items content length, if known, or -1\n+\t\t\t * @throws IOException\n+\t\t\t *             Creating the file item failed.\n+\t\t\t */\n+\t\t\tFileItemStreamImpl(String pName, String pFieldName, String pContentType,\n+\t\t\t\tboolean pFormField, long pContentLength) throws IOException\n+\t\t\t{\n+\t\t\t\tname = pName;\n+\t\t\t\tfieldName = pFieldName;\n+\t\t\t\tcontentType = pContentType;\n+\t\t\t\tformField = pFormField;\n+\t\t\t\tfinal ItemInputStream itemStream = multi.newInputStream();\n+\t\t\t\tInputStream istream = itemStream;\n+\t\t\t\tif (fileSizeMax != -1)\n+\t\t\t\t{\n+\t\t\t\t\tif (pContentLength != -1 && pContentLength > fileSizeMax)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tFileUploadException e = new FileSizeLimitExceededException(\"The field \" +\n+\t\t\t\t\t\t\tfieldName + \" exceeds its maximum permitted \" + \" size of \" +\n+\t\t\t\t\t\t\tfileSizeMax + \" characters.\", pContentLength, fileSizeMax);\n+\t\t\t\t\t\tthrow new FileUploadIOException(e);\n+\t\t\t\t\t}\n+\t\t\t\t\tistream = new LimitedInputStream(istream, fileSizeMax)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t@Override\n+\t\t\t\t\t\tprotected void raiseError(long pSizeMax, long pCount) throws IOException\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\titemStream.close(true);\n+\t\t\t\t\t\t\tFileUploadException e = new FileSizeLimitExceededException(\n+\t\t\t\t\t\t\t\t\"The field \" + fieldName + \" exceeds its maximum permitted \" +\n+\t\t\t\t\t\t\t\t\t\" size of \" + pSizeMax + \" characters.\", pCount, pSizeMax);\n+\t\t\t\t\t\t\tthrow new FileUploadIOException(e);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t\tstream = istream;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns the items content type, or null.\n+\t\t\t * \n+\t\t\t * @return Content type, if known, or null.\n+\t\t\t */\n+\t\t\tpublic String getContentType()\n+\t\t\t{\n+\t\t\t\treturn contentType;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns the items field name.\n+\t\t\t * \n+\t\t\t * @return Field name.\n+\t\t\t */\n+\t\t\tpublic String getFieldName()\n+\t\t\t{\n+\t\t\t\treturn fieldName;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns the items file name.\n+\t\t\t * \n+\t\t\t * @return File name, if known, or null.\n+\t\t\t */\n+\t\t\tpublic String getName()\n+\t\t\t{\n+\t\t\t\treturn name;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns, whether this is a form field.\n+\t\t\t * \n+\t\t\t * @return True, if the item is a form field, otherwise false.\n+\t\t\t */\n+\t\t\tpublic boolean isFormField()\n+\t\t\t{\n+\t\t\t\treturn formField;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns an input stream, which may be used to read the items contents.\n+\t\t\t * \n+\t\t\t * @return Opened input stream.\n+\t\t\t * @throws IOException\n+\t\t\t *             An I/O error occurred.\n+\t\t\t */\n+\t\t\tpublic InputStream openStream() throws IOException\n+\t\t\t{\n+\t\t\t\tif (opened)\n+\t\t\t\t{\n+\t\t\t\t\tthrow new IllegalStateException(\"The stream was already opened.\");\n+\t\t\t\t}\n+\t\t\t\tif (((Closeable)stream).isClosed())\n+\t\t\t\t{\n+\t\t\t\t\tthrow new FileItemStream.ItemSkippedException();\n+\t\t\t\t}\n+\t\t\t\treturn stream;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Closes the file item.\n+\t\t\t * \n+\t\t\t * @throws IOException\n+\t\t\t *             An I/O error occurred.\n+\t\t\t */\n+\t\t\tvoid close() throws IOException\n+\t\t\t{\n+\t\t\t\tstream.close();\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Returns the file item headers.\n+\t\t\t * \n+\t\t\t * @return The items header object\n+\t\t\t */\n+\t\t\tpublic FileItemHeaders getHeaders()\n+\t\t\t{\n+\t\t\t\treturn headers;\n+\t\t\t}\n+\n+\t\t\t/**\n+\t\t\t * Sets the file item headers.\n+\t\t\t * \n+\t\t\t * @param pHeaders\n+\t\t\t *            The items header object\n+\t\t\t */\n+\t\t\tpublic void setHeaders(FileItemHeaders pHeaders)\n+\t\t\t{\n+\t\t\t\theaders = pHeaders;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * The multi part stream to process.\n+\t\t */\n+\t\tprivate final MultipartFormInputStream multi;\n+\t\t/**\n+\t\t * The notifier, which used for triggering the {@link ProgressListener}.\n+\t\t */\n+\t\tprivate final MultipartFormInputStream.ProgressNotifier notifier;\n+\t\t/**\n+\t\t * The boundary, which separates the various parts.\n+\t\t */\n+\t\tprivate final byte[] boundary;\n+\t\t/**\n+\t\t * The item, which we currently process.\n+\t\t */\n+\t\tprivate FileItemStreamImpl currentItem;\n+\t\t/**\n+\t\t * The current items field name.\n+\t\t */\n+\t\tprivate String currentFieldName;\n+\t\t/**\n+\t\t * Whether we are currently skipping the preamble.\n+\t\t */\n+\t\tprivate boolean skipPreamble;\n+\t\t/**\n+\t\t * Whether the current item may still be read.\n+\t\t */\n+\t\tprivate boolean itemValid;\n+\t\t/**\n+\t\t * Whether we have seen the end of the file.\n+\t\t */\n+\t\tprivate boolean eof;\n+\n+\t\t/**\n+\t\t * Creates a new instance.\n+\t\t * \n+\t\t * @param ctx\n+\t\t *            The request context.\n+\t\t * @throws FileUploadException\n+\t\t *             An error occurred while parsing the request.\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\tFileItemIteratorImpl(RequestContext ctx) throws FileUploadException, IOException\n+\t\t{\n+\t\t\tif (ctx == null)\n+\t\t\t{\n+\t\t\t\tthrow new NullPointerException(\"ctx parameter\");\n+\t\t\t}\n+\n+\t\t\tString contentType = ctx.getContentType();\n+\t\t\tif ((null == contentType) || (!contentType.toLowerCase().startsWith(MULTIPART)))\n+\t\t\t{\n+\t\t\t\tthrow new InvalidContentTypeException(\"the request doesn't contain a \" +\n+\t\t\t\t\tMULTIPART_FORM_DATA + \" or \" + MULTIPART_MIXED +\n+\t\t\t\t\t\" stream, content type header is \" + contentType);\n+\t\t\t}\n+\n+\t\t\tInputStream input = ctx.getInputStream();\n+\n+\t\t\tif (sizeMax >= 0)\n+\t\t\t{\n+\t\t\t\tint requestSize = ctx.getContentLength();\n+\t\t\t\tif (requestSize == -1)\n+\t\t\t\t{\n+\t\t\t\t\tinput = new LimitedInputStream(input, sizeMax)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t@Override\n+\t\t\t\t\t\tprotected void raiseError(long pSizeMax, long pCount) throws IOException\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tFileUploadException ex = new SizeLimitExceededException(\n+\t\t\t\t\t\t\t\t\"the request was rejected because\" + \" its size (\" + pCount +\n+\t\t\t\t\t\t\t\t\t\") exceeds the configured maximum\" + \" (\" + pSizeMax + \")\",\n+\t\t\t\t\t\t\t\tpCount, pSizeMax);\n+\t\t\t\t\t\t\tthrow new FileUploadIOException(ex);\n+\t\t\t\t\t\t}\n+\t\t\t\t\t};\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tif (sizeMax >= 0 && requestSize > sizeMax)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tthrow new SizeLimitExceededException(\n+\t\t\t\t\t\t\t\"the request was rejected because its size (\" + requestSize +\n+\t\t\t\t\t\t\t\t\") exceeds the configured maximum (\" + sizeMax + \")\", requestSize,\n+\t\t\t\t\t\t\tsizeMax);\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tString charEncoding = headerEncoding;\n+\t\t\tif (charEncoding == null)\n+\t\t\t{\n+\t\t\t\tcharEncoding = ctx.getCharacterEncoding();\n+\t\t\t}\n+\n+\t\t\tboundary = getBoundary(contentType);\n+\t\t\tif (boundary == null)\n+\t\t\t{\n+\t\t\t\tthrow new FileUploadException(\"the request was rejected because \"\n+\t\t\t\t\t+ \"no multipart boundary was found\");\n+\t\t\t}\n+\n+\t\t\tnotifier = new MultipartFormInputStream.ProgressNotifier(listener,\n+\t\t\t\tctx.getContentLength());\n+\t\t\tmulti = new MultipartFormInputStream(input, boundary, notifier);\n+\t\t\tmulti.setHeaderEncoding(charEncoding);\n+\n+\t\t\tskipPreamble = true;\n+\t\t\tfindNextItem();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Called for finding the nex item, if any.\n+\t\t * \n+\t\t * @return True, if an next item was found, otherwise false.\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\tprivate boolean findNextItem() throws IOException\n+\t\t{\n+\t\t\tif (eof)\n+\t\t\t{\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (currentItem != null)\n+\t\t\t{\n+\t\t\t\tcurrentItem.close();\n+\t\t\t\tcurrentItem = null;\n+\t\t\t}\n+\t\t\tfor (;;)\n+\t\t\t{\n+\t\t\t\tboolean nextPart;\n+\t\t\t\tif (skipPreamble)\n+\t\t\t\t{\n+\t\t\t\t\tnextPart = multi.skipPreamble();\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tnextPart = multi.readBoundary();\n+\t\t\t\t}\n+\t\t\t\tif (!nextPart)\n+\t\t\t\t{\n+\t\t\t\t\tif (currentFieldName == null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\t// Outer multipart terminated -> No more data\n+\t\t\t\t\t\teof = true;\n+\t\t\t\t\t\treturn false;\n+\t\t\t\t\t}\n+\t\t\t\t\t// Inner multipart terminated -> Return to parsing the outer\n+\t\t\t\t\tmulti.setBoundary(boundary);\n+\t\t\t\t\tcurrentFieldName = null;\n+\t\t\t\t\tcontinue;\n+\t\t\t\t}\n+\t\t\t\tFileItemHeaders headers = getParsedHeaders(multi.readHeaders());\n+\t\t\t\tif (currentFieldName == null)\n+\t\t\t\t{\n+\t\t\t\t\t// We're parsing the outer multipart\n+\t\t\t\t\tString fieldName = getFieldName(headers);\n+\t\t\t\t\tif (fieldName != null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tString subContentType = headers.getHeader(CONTENT_TYPE);\n+\t\t\t\t\t\tif (subContentType != null &&\n+\t\t\t\t\t\t\tsubContentType.toLowerCase().startsWith(MULTIPART_MIXED))\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tcurrentFieldName = fieldName;\n+\t\t\t\t\t\t\t// Multiple files associated with this field name\n+\t\t\t\t\t\t\tbyte[] subBoundary = getBoundary(subContentType);\n+\t\t\t\t\t\t\tmulti.setBoundary(subBoundary);\n+\t\t\t\t\t\t\tskipPreamble = true;\n+\t\t\t\t\t\t\tcontinue;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t\tString fileName = getFileName(headers);\n+\t\t\t\t\t\tcurrentItem = new FileItemStreamImpl(fileName, fieldName,\n+\t\t\t\t\t\t\theaders.getHeader(CONTENT_TYPE), fileName == null,\n+\t\t\t\t\t\t\tgetContentLength(headers));\n+\t\t\t\t\t\tnotifier.noteItem();\n+\t\t\t\t\t\titemValid = true;\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tString fileName = getFileName(headers);\n+\t\t\t\t\tif (fileName != null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tcurrentItem = new FileItemStreamImpl(fileName, currentFieldName,\n+\t\t\t\t\t\t\theaders.getHeader(CONTENT_TYPE), false, getContentLength(headers));\n+\t\t\t\t\t\tnotifier.noteItem();\n+\t\t\t\t\t\titemValid = true;\n+\t\t\t\t\t\treturn true;\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t\tmulti.discardBodyData();\n+\t\t\t}\n+\t\t}\n+\n+\t\tprivate long getContentLength(FileItemHeaders pHeaders)\n+\t\t{\n+\t\t\ttry\n+\t\t\t{\n+\t\t\t\treturn Long.parseLong(pHeaders.getHeader(CONTENT_LENGTH));\n+\t\t\t}\n+\t\t\tcatch (Exception e)\n+\t\t\t{\n+\t\t\t\treturn -1;\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns, whether another instance of {@link FileItemStream} is available.\n+\t\t * \n+\t\t * @throws FileUploadException\n+\t\t *             Parsing or processing the file item failed.\n+\t\t * @throws IOException\n+\t\t *             Reading the file item failed.\n+\t\t * @return True, if one or more additional file items are available, otherwise false.\n+\t\t */\n+\t\tpublic boolean hasNext() throws FileUploadException, IOException\n+\t\t{\n+\t\t\tif (eof)\n+\t\t\t{\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\tif (itemValid)\n+\t\t\t{\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\treturn findNextItem();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns the next available {@link FileItemStream}.\n+\t\t * \n+\t\t * @throws java.util.NoSuchElementException\n+\t\t *             No more items are available. Use {@link #hasNext()} to prevent this\n+\t\t *             exception.\n+\t\t * @throws FileUploadException\n+\t\t *             Parsing or processing the file item failed.\n+\t\t * @throws IOException\n+\t\t *             Reading the file item failed.\n+\t\t * @return FileItemStream instance, which provides access to the next file item.\n+\t\t */\n+\t\tpublic FileItemStream next() throws FileUploadException, IOException\n+\t\t{\n+\t\t\tif (eof || (!itemValid && !hasNext()))\n+\t\t\t{\n+\t\t\t\tthrow new NoSuchElementException();\n+\t\t\t}\n+\t\t\titemValid = false;\n+\t\t\treturn currentItem;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * This exception is thrown for hiding an inner {@link FileUploadException} in an\n+\t * {@link IOException}.\n+\t */\n+\tpublic static class FileUploadIOException extends IOException\n+\t{\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = -7047616958165584154L;\n+\t\t/**\n+\t\t * The exceptions cause; we overwrite the parent classes field, which is available since\n+\t\t * Java 1.4 only.\n+\t\t */\n+\t\tprivate final FileUploadException cause;\n+\n+\t\t/**\n+\t\t * Creates a <code>FileUploadIOException</code> with the given cause.\n+\t\t * \n+\t\t * @param pCause\n+\t\t *            The exceptions cause, if any, or null.\n+\t\t */\n+\t\tpublic FileUploadIOException(FileUploadException pCause)\n+\t\t{\n+\t\t\t// We're not doing super(pCause) cause of 1.3 compatibility.\n+\t\t\tcause = pCause;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns the exceptions cause.\n+\t\t * \n+\t\t * @return The exceptions cause, if any, or null.\n+\t\t */\n+\t\t@Override\n+\t\tpublic Throwable getCause()\n+\t\t{\n+\t\t\treturn cause;\n+\t\t}\n+\t}\n \n \t/**\n \t * Thrown to indicate that the request is not a multipart request.\n \t */\n \tpublic static class InvalidContentTypeException extends FileUploadException\n \t{\n-\n-\t\tprivate static final long serialVersionUID = 1L;\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = -9073026332015646668L;\n \n \t\t/**\n \t\t * Constructs a <code>InvalidContentTypeException</code> with no detail message.\n \t\t */\n \t\tpublic InvalidContentTypeException()\n \t\t{\n-\t\t\tsuper();\n+\t\t\t// Nothing to do.\n \t\t}\n \n \t\t/**\n@@ -606,14 +1257,114 @@ public InvalidContentTypeException(final String message)\n \t\t}\n \t}\n \n+\t/**\n+\t * Thrown to indicate an IOException.\n+\t */\n+\tpublic static class IOFileUploadException extends FileUploadException\n+\t{\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = 1749796615868477269L;\n+\t\t/**\n+\t\t * The exceptions cause; we overwrite the parent classes field, which is available since\n+\t\t * Java 1.4 only.\n+\t\t */\n+\t\tprivate final IOException cause;\n+\n+\t\t/**\n+\t\t * Creates a new instance with the given cause.\n+\t\t * \n+\t\t * @param pMsg\n+\t\t *            The detail message.\n+\t\t * @param pException\n+\t\t *            The exceptions cause.\n+\t\t */\n+\t\tpublic IOFileUploadException(String pMsg, IOException pException)\n+\t\t{\n+\t\t\tsuper(pMsg);\n+\t\t\tcause = pException;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns the exceptions cause.\n+\t\t * \n+\t\t * @return The exceptions cause, if any, or null.\n+\t\t */\n+\t\t@Override\n+\t\tpublic Throwable getCause()\n+\t\t{\n+\t\t\treturn cause;\n+\t\t}\n+\t}\n \n \t/**\n-\t * Thrown to indicate that the request size is not specified.\n+\t * This exception is thrown, if a requests permitted size is exceeded.\n \t */\n-\tpublic static class UnknownSizeException extends FileUploadException\n+\tprotected abstract static class SizeException extends FileUploadException\n \t{\n+\t\t/**\n+\t\t * The actual size of the request.\n+\t\t */\n+\t\tprivate final long actual;\n+\n+\t\t/**\n+\t\t * The maximum permitted size of the request.\n+\t\t */\n+\t\tprivate final long permitted;\n+\n+\t\t/**\n+\t\t * Creates a new instance.\n+\t\t * \n+\t\t * @param message\n+\t\t *            The detail message.\n+\t\t * @param actual\n+\t\t *            The actual number of bytes in the request.\n+\t\t * @param permitted\n+\t\t *            The requests size limit, in bytes.\n+\t\t */\n+\t\tprotected SizeException(String message, long actual, long permitted)\n+\t\t{\n+\t\t\tsuper(message);\n+\t\t\tthis.actual = actual;\n+\t\t\tthis.permitted = permitted;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Retrieves the actual size of the request.\n+\t\t * \n+\t\t * @return The actual size of the request.\n+\t\t */\n+\t\tpublic long getActualSize()\n+\t\t{\n+\t\t\treturn actual;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Retrieves the permitted size of the request.\n+\t\t * \n+\t\t * @return The permitted size of the request.\n+\t\t */\n+\t\tpublic long getPermittedSize()\n+\t\t{\n+\t\t\treturn permitted;\n+\t\t}\n+\t}\n \n-\t\tprivate static final long serialVersionUID = 1L;\n+\t/**\n+\t * Thrown to indicate that the request size is not specified. In other words, it is thrown, if\n+\t * the content-length header is missing or contains the value -1.\n+\t * \n+\t * @deprecated As of commons-fileupload 1.2, the presence of a content-length header is no\n+\t *             longer required.\n+\t */\n+\t@Deprecated\n+\tpublic static class UnknownSizeException extends FileUploadException\n+\t{\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = 7062279004812015273L;\n \n \t\t/**\n \t\t * Constructs a <code>UnknownSizeException</code> with no detail message.\n@@ -635,33 +1386,98 @@ public UnknownSizeException(final String message)\n \t\t}\n \t}\n \n-\n \t/**\n \t * Thrown to indicate that the request size exceeds the configured maximum.\n \t */\n-\tpublic static class SizeLimitExceededException extends FileUploadException\n+\tpublic static class SizeLimitExceededException extends SizeException\n \t{\n-\n-\t\tprivate static final long serialVersionUID = 1L;\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = -2474893167098052828L;\n \n \t\t/**\n-\t\t * Constructs a <code>SizeExceededException</code> with no detail message.\n+\t\t * @deprecated Replaced by {@link #SizeLimitExceededException(String, long, long)}\n \t\t */\n+\t\t@Deprecated\n \t\tpublic SizeLimitExceededException()\n \t\t{\n-\t\t\tsuper();\n+\t\t\tthis(null, 0, 0);\n+\t\t}\n+\n+\t\t/**\n+\t\t * @deprecated Replaced by {@link #SizeLimitExceededException(String, long, long)}\n+\t\t * @param message\n+\t\t *            The exceptions detail message.\n+\t\t */\n+\t\t@Deprecated\n+\t\tpublic SizeLimitExceededException(String message)\n+\t\t{\n+\t\t\tthis(message, 0, 0);\n \t\t}\n \n \t\t/**\n-\t\t * Constructs an <code>SizeExceededException</code> with the specified detail message.\n+\t\t * Constructs a <code>SizeExceededException</code> with the specified detail message, and\n+\t\t * actual and permitted sizes.\n \t\t * \n \t\t * @param message\n \t\t *            The detail message.\n+\t\t * @param actual\n+\t\t *            The actual request size.\n+\t\t * @param permitted\n+\t\t *            The maximum permitted request size.\n \t\t */\n-\t\tpublic SizeLimitExceededException(final String message)\n+\t\tpublic SizeLimitExceededException(String message, long actual, long permitted)\n \t\t{\n-\t\t\tsuper(message);\n+\t\t\tsuper(message, actual, permitted);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Thrown to indicate that A files size exceeds the configured maximum.\n+\t */\n+\tpublic static class FileSizeLimitExceededException extends SizeException\n+\t{\n+\t\t/**\n+\t\t * The exceptions UID, for serializing an instance.\n+\t\t */\n+\t\tprivate static final long serialVersionUID = 8150776562029630058L;\n+\n+\t\t/**\n+\t\t * Constructs a <code>SizeExceededException</code> with the specified detail message, and\n+\t\t * actual and permitted sizes.\n+\t\t * \n+\t\t * @param message\n+\t\t *            The detail message.\n+\t\t * @param actual\n+\t\t *            The actual request size.\n+\t\t * @param permitted\n+\t\t *            The maximum permitted request size.\n+\t\t */\n+\t\tpublic FileSizeLimitExceededException(String message, long actual, long permitted)\n+\t\t{\n+\t\t\tsuper(message, actual, permitted);\n \t\t}\n \t}\n \n+\t/**\n+\t * Returns the progress listener.\n+\t * \n+\t * @return The progress listener, if any, or null.\n+\t */\n+\tpublic ProgressListener getProgressListener()\n+\t{\n+\t\treturn listener;\n+\t}\n+\n+\t/**\n+\t * Sets the progress listener.\n+\t * \n+\t * @param pListener\n+\t *            The progress listener, if any. Defaults to null.\n+\t */\n+\tpublic void setProgressListener(ProgressListener pListener)\n+\t{\n+\t\tlistener = pListener;\n+\t}\n }"
        },
        {
            "sha": "e3ab95a34293f77bb3d9ee8f76dbcff268c8fe0e",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/FileUploadException.java",
            "status": "modified",
            "additions": 56,
            "deletions": 17,
            "changes": 73,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadException.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadException.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FFileUploadException.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -16,22 +16,33 @@\n  */\n package org.apache.wicket.util.upload;\n \n-import java.io.IOException;\n+import java.io.PrintStream;\n+import java.io.PrintWriter;\n+\n \n /**\n  * Exception for errors encountered while processing the request.\n  * \n  * @author <a href=\"mailto:jmcnally@collab.net\">John McNally</a>\n  */\n-public class FileUploadException extends IOException\n+public class FileUploadException extends Exception\n {\n-\tprivate static final long serialVersionUID = 1L;\n+\t/**\n+\t * Serial version UID, being used, if the exception is serialized.\n+\t */\n+\tprivate static final long serialVersionUID = 8881893724388807504L;\n+\t/**\n+\t * The exceptions cause. We overwrite the cause of the super class, which isn't available in\n+\t * Java 1.3.\n+\t */\n+\tprivate final Throwable cause;\n \n \t/**\n \t * Constructs a new <code>FileUploadException</code> without message.\n \t */\n \tpublic FileUploadException()\n \t{\n+\t\tthis(null, null);\n \t}\n \n \t/**\n@@ -42,32 +53,60 @@ public FileUploadException()\n \t */\n \tpublic FileUploadException(final String msg)\n \t{\n-\t\tsuper(msg);\n+\t\tthis(msg, null);\n \t}\n \n \t/**\n-\t * Constructs a new <code>FileUploadException</code> with specified cause.\n+\t * Creates a new <code>FileUploadException</code> with the given detail message and cause.\n \t * \n+\t * @param msg\n+\t *            The exceptions detail message.\n \t * @param cause\n-\t *            the cause.\n+\t *            The exceptions cause.\n \t */\n-\tpublic FileUploadException(final Throwable cause)\n+\tpublic FileUploadException(String msg, Throwable cause)\n \t{\n-\t\tsuper();\n-\t\tinitCause(cause);\n+\t\tsuper(msg);\n+\t\tthis.cause = cause;\n \t}\n \n \t/**\n-\t * Constructs a new <code>FileUploadException</code> with specified detail message and cause\n+\t * Prints this throwable and its backtrace to the specified print stream.\n \t * \n-\t * @param message\n-\t *            the error message.\n-\t * @param cause\n-\t *            the cause.\n+\t * @param stream\n+\t *            <code>PrintStream</code> to use for output\n \t */\n-\tpublic FileUploadException(final String message, final Throwable cause)\n+\t@Override\n+\tpublic void printStackTrace(PrintStream stream)\n+\t{\n+\t\tsuper.printStackTrace(stream);\n+\t\tif (cause != null)\n+\t\t{\n+\t\t\tstream.println(\"Caused by:\");\n+\t\t\tcause.printStackTrace(stream);\n+\t}\n+}\n+\n+\t/**\n+\t * Prints this throwable and its backtrace to the specified print writer.\n+\t * \n+\t * @param writer\n+\t *            <code>PrintWriter</code> to use for output\n+\t */\n+\t@Override\n+\tpublic void printStackTrace(PrintWriter writer)\n+\t{\n+\t\tsuper.printStackTrace(writer);\n+\t\tif (cause != null)\n+\t\t{\n+\t\t\twriter.println(\"Caused by:\");\n+\t\t\tcause.printStackTrace(writer);\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic Throwable getCause()\n \t{\n-\t\tsuper(message);\n-\t\tinitCause(cause);\n+\t\treturn cause;\n \t}\n }"
        },
        {
            "sha": "2560d61eedf2d3781c8bd3fe5e15d124ba3a96d7",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/LimitedInputStream.java",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FLimitedInputStream.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FLimitedInputStream.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FLimitedInputStream.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,172 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+import java.io.FilterInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+\n+\n+/**\n+ * An input stream, which limits its data size. This stream is used, if the content length is\n+ * unknown.\n+ */\n+public abstract class LimitedInputStream extends FilterInputStream implements Closeable\n+{\n+\t/**\n+\t * The maximum size of an item, in bytes.\n+\t */\n+\tprivate final long sizeMax;\n+\t/**\n+\t * The current number of bytes.\n+\t */\n+\tprivate long count;\n+\t/**\n+\t * Whether this stream is already closed.\n+\t */\n+\tprivate boolean closed;\n+\n+\t/**\n+\t * Creates a new instance.\n+\t * \n+\t * @param pIn\n+\t *            The input stream, which shall be limited.\n+\t * @param pSizeMax\n+\t *            The limit; no more than this number of bytes shall be returned by the source\n+\t *            stream.\n+\t */\n+\tpublic LimitedInputStream(InputStream pIn, long pSizeMax)\n+\t{\n+\t\tsuper(pIn);\n+\t\tsizeMax = pSizeMax;\n+\t}\n+\n+\t/**\n+\t * Called to indicate, that the input streams limit has been exceeded.\n+\t * \n+\t * @param pSizeMax\n+\t *            The input streams limit, in bytes.\n+\t * @param pCount\n+\t *            The actual number of bytes.\n+\t * @throws IOException\n+\t *             The called method is expected to raise an IOException.\n+\t */\n+\tprotected abstract void raiseError(long pSizeMax, long pCount) throws IOException;\n+\n+\t/**\n+\t * Called to check, whether the input streams limit is reached.\n+\t * \n+\t * @throws IOException\n+\t *             The given limit is exceeded.\n+\t */\n+\tprivate void checkLimit() throws IOException\n+\t{\n+\t\tif (count > sizeMax)\n+\t\t{\n+\t\t\traiseError(sizeMax, count);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Reads the next byte of data from this input stream. The value byte is returned as an\n+\t * <code>int</code> in the range <code>0</code> to <code>255</code>. If no byte is available\n+\t * because the end of the stream has been reached, the value <code>-1</code> is returned. This\n+\t * method blocks until input data is available, the end of the stream is detected, or an\n+\t * exception is thrown.\n+\t * <p>\n+\t * This method simply performs <code>in.read()</code> and returns the result.\n+\t * \n+\t * @return the next byte of data, or <code>-1</code> if the end of the stream is reached.\n+\t * @exception IOException\n+\t *                if an I/O error occurs.\n+\t * @see java.io.FilterInputStream#in\n+\t */\n+\t@Override\n+\tpublic int read() throws IOException\n+\t{\n+\t\tint res = super.read();\n+\t\tif (res != -1)\n+\t\t{\n+\t\t\tcount++;\n+\t\t\tcheckLimit();\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t/**\n+\t * Reads up to <code>len</code> bytes of data from this input stream into an array of bytes. If\n+\t * <code>len</code> is not zero, the method blocks until some input is available; otherwise, no\n+\t * bytes are read and <code>0</code> is returned.\n+\t * <p>\n+\t * This method simply performs <code>in.read(b, off, len)</code> and returns the result.\n+\t * \n+\t * @param b\n+\t *            the buffer into which the data is read.\n+\t * @param off\n+\t *            The start offset in the destination array <code>b</code>.\n+\t * @param len\n+\t *            the maximum number of bytes read.\n+\t * @return the total number of bytes read into the buffer, or <code>-1</code> if there is no\n+\t *         more data because the end of the stream has been reached.\n+\t * @exception NullPointerException\n+\t *                If <code>b</code> is <code>null</code>.\n+\t * @exception IndexOutOfBoundsException\n+\t *                If <code>off</code> is negative, <code>len</code> is negative, or\n+\t *                <code>len</code> is greater than <code>b.length - off</code>\n+\t * @exception IOException\n+\t *                if an I/O error occurs.\n+\t * @see java.io.FilterInputStream#in\n+\t */\n+\t@Override\n+\tpublic int read(byte[] b, int off, int len) throws IOException\n+\t{\n+\t\tint res = super.read(b, off, len);\n+\t\tif (res > 0)\n+\t\t{\n+\t\t\tcount += res;\n+\t\t\tcheckLimit();\n+\t\t}\n+\t\treturn res;\n+\t}\n+\n+\t/**\n+\t * Returns, whether this stream is already closed.\n+\t * \n+\t * @return True, if the stream is closed, otherwise false.\n+\t * @throws IOException\n+\t *             An I/O error occurred.\n+\t */\n+\tpublic boolean isClosed() throws IOException\n+\t{\n+\t\treturn closed;\n+\t}\n+\n+\t/**\n+\t * Closes this input stream and releases any system resources associated with the stream. This\n+\t * method simply performs <code>in.close()</code>.\n+\t * \n+\t * @exception IOException\n+\t *                if an I/O error occurs.\n+\t * @see java.io.FilterInputStream#in\n+\t */\n+\t@Override\n+\tpublic void close() throws IOException\n+\t{\n+\t\tclosed = true;\n+\t\tsuper.close();\n+\t}\n+}"
        },
        {
            "sha": "47f6b32027bd96173506958aa378a3bd4f865a4a",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/MultipartFormInputStream.java",
            "status": "modified",
            "additions": 548,
            "deletions": 191,
            "changes": 739,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FMultipartFormInputStream.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FMultipartFormInputStream.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FMultipartFormInputStream.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -22,6 +22,7 @@\n import java.io.OutputStream;\n import java.io.UnsupportedEncodingException;\n \n+import org.apache.wicket.util.io.Streams;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -41,7 +42,7 @@\n  *   multipart-body := preamble 1*encapsulation close-delimiter epilogue<br>\n  *   encapsulation := delimiter body CRLF<br>\n  *   delimiter := \"--\" boundary CRLF<br>\n- *   close-delimiter := \"--\" boundary \"--\"<br>\n+ *   close-delimiter := \"--\" boudary \"--\"<br>\n  *   preamble := &lt;ignore&gt;<br>\n  *   epilogue := &lt;ignore&gt;<br>\n  *   body := header-part CRLF body-part<br>\n@@ -53,8 +54,8 @@\n  * </code>\n  * \n  * <p>\n- * Note that body-data can contain another multipart entity. There is limited support for single\n- * pass processing of such nested streams. The nested stream is <strong>required</strong> to have a\n+ * Note that body-data can contain another mulipart entity. There is limited support for single pass\n+ * processing of such nested streams. The nested stream is <strong>required</strong> to have a\n  * boundary token of the same length as the parent stream (see {@link #setBoundary(byte[])}).\n  * \n  * <p>\n@@ -64,7 +65,7 @@\n  *      try {\n  *          MultipartStream multipartStream = new MultipartStream(input,\n  *                                                                boundary);\n- *          boolean nextPart = malitPartStream.skipPreamble();\n+ *        boolean nextPart = multipartStream.skipPreamble();\n  *          OutputStream output;\n  *          while(nextPart) {\n  *              header = chunks.readHeader();\n@@ -78,130 +79,234 @@\n  *      } catch(IOException) {\n  *            // a read or write error occurred\n  *      }\n+ * \n  * </pre>\n  * \n  * @author <a href=\"mailto:Rafal.Krzewski@e-point.pl\">Rafal Krzewski</a>\n  * @author <a href=\"mailto:martinc@apache.org\">Martin Cooper</a>\n  * @author Sean C. Sullivan\n  * \n- * @version $Id$\n  */\n public class MultipartFormInputStream\n {\n \t/** Log. */\n \tprivate static final Logger log = LoggerFactory.getLogger(MultipartFormInputStream.class);\n \n+\t/**\n+\t * Internal class, which is used to invoke the {@link ProgressListener}.\n+\t */\n+\tstatic class ProgressNotifier\n+\t{\n+\t\t/**\n+\t\t * The listener to invoke.\n+\t\t */\n+\t\tprivate final ProgressListener listener;\n+\t\t/**\n+\t\t * Number of expected bytes, if known, or -1.\n+\t\t */\n+\t\tprivate final long contentLength;\n+\t\t/**\n+\t\t * Number of bytes, which have been read so far.\n+\t\t */\n+\t\tprivate long bytesRead;\n+\t\t/**\n+\t\t * Number of items, which have been read so far.\n+\t\t */\n+\t\tprivate int items;\n+\n+\t\t/**\n+\t\t * Creates a new instance with the given listener and content length.\n+\t\t * \n+\t\t * @param pListener\n+\t\t *            The listener to invoke.\n+\t\t * @param pContentLength\n+\t\t *            The expected content length.\n+\t\t */\n+\t\tProgressNotifier(ProgressListener pListener, long pContentLength)\n+\t\t{\n+\t\t\tlistener = pListener;\n+\t\t\tcontentLength = pContentLength;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Called to indicate that bytes have been read.\n+\t\t * \n+\t\t * @param pBytes\n+\t\t *            Number of bytes, which have been read.\n+\t\t */\n+\t\tvoid noteBytesRead(int pBytes)\n+\t\t{\n+\t\t\t/*\n+\t\t\t * Indicates, that the given number of bytes have been read from the input stream.\n+\t\t\t */\n+\t\t\tbytesRead += pBytes;\n+\t\t\tnotifyListener();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Called to indicate, that a new file item has been detected.\n+\t\t */\n+\t\tvoid noteItem()\n+\t\t{\n+\t\t\t++items;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Called for notifying the listener.\n+\t\t */\n+\t\tprivate void notifyListener()\n+\t\t{\n+\t\t\tif (listener != null)\n+\t\t\t{\n+\t\t\t\tlistener.update(bytesRead, contentLength, items);\n+\t\t\t}\n+\t\t}\n+\t}\n+\n \t// ----------------------------------------------------- Manifest constants\n \n+\n \t/**\n \t * The Carriage Return ASCII character value.\n \t */\n \tpublic static final byte CR = 0x0D;\n \n+\n \t/**\n \t * The Line Feed ASCII character value.\n \t */\n \tpublic static final byte LF = 0x0A;\n \n+\n \t/**\n \t * The dash (-) ASCII character value.\n \t */\n \tpublic static final byte DASH = 0x2D;\n \n+\n \t/**\n \t * The maximum length of <code>header-part</code> that will be processed (10 kilobytes = 10240\n \t * bytes.).\n \t */\n \tpublic static final int HEADER_PART_SIZE_MAX = 10240;\n \n+\n \t/**\n \t * The default length of the buffer used for processing a request.\n \t */\n \tprotected static final int DEFAULT_BUFSIZE = 4096;\n \n+\n \t/**\n \t * A byte sequence that marks the end of <code>header-part</code> (<code>CRLFCRLF</code>).\n \t */\n \tprotected static final byte[] HEADER_SEPARATOR = { CR, LF, CR, LF };\n \n+\n \t/**\n \t * A byte sequence that that follows a delimiter that will be followed by an encapsulation (\n \t * <code>CRLF</code>).\n \t */\n \tprotected static final byte[] FIELD_SEPARATOR = { CR, LF };\n \n+\n \t/**\n \t * A byte sequence that that follows a delimiter of the last encapsulation in the stream (\n \t * <code>--</code>).\n \t */\n \tprotected static final byte[] STREAM_TERMINATOR = { DASH, DASH };\n \n+\n+\t/**\n+\t * A byte sequence that precedes a boundary (<code>CRLF--</code>).\n+\t */\n+\tprotected static final byte[] BOUNDARY_PREFIX = { CR, LF, DASH, DASH };\n+\n+\n \t// ----------------------------------------------------------- Data members\n \n+\n \t/**\n \t * The input stream from which data is read.\n \t */\n-\tprivate InputStream input;\n+\tprivate final InputStream input;\n+\n \n \t/**\n \t * The length of the boundary token plus the leading <code>CRLF--</code>.\n \t */\n \tprivate int boundaryLength;\n \n+\n \t/**\n \t * The amount of data, in bytes, that must be kept in the buffer in order to detect delimiters\n \t * reliably.\n \t */\n-\tprivate int keepRegion;\n+\tprivate final int keepRegion;\n+\n \n \t/**\n \t * The byte sequence that partitions the stream.\n \t */\n-\tprivate byte[] boundary;\n+\tprivate final byte[] boundary;\n+\n \n \t/**\n \t * The length of the buffer used for processing the request.\n \t */\n-\tprivate int bufSize;\n+\tprivate final int bufSize;\n+\n \n \t/**\n \t * The buffer used for processing the request.\n \t */\n-\tprivate byte[] buffer;\n+\tprivate final byte[] buffer;\n+\n \n \t/**\n \t * The index of first valid character in the buffer. <br>\n \t * 0 <= head < bufSize\n \t */\n \tprivate int head;\n \n+\n \t/**\n-\t * The index of last valid character in the buffer + 1. <br>\n+\t * The index of last valid characer in the buffer + 1. <br>\n \t * 0 <= tail <= bufSize\n \t */\n \tprivate int tail;\n \n+\n \t/**\n \t * The content encoding to use when reading headers.\n \t */\n \tprivate String headerEncoding;\n \n+\n+\t/**\n+\t * The progress notifier, if any, or null.\n+\t */\n+\tprivate final ProgressNotifier notifier;\n+\n \t// ----------------------------------------------------------- Constructors\n \n \t/**\n-\t * Default constructor.\n-\t * \n-\t * @see #MultipartFormInputStream(InputStream, byte[], int)\n-\t * @see #MultipartFormInputStream(InputStream, byte[])\n+\t * Creates a new instance.\n \t * \n+\t * @deprecated Use\n+\t *             {@link #MultipartStream(InputStream, byte[], org.apache.wicket.util.uploadMultipartStream.ProgressNotifier)}\n+\t *             , or\n+\t *             {@link #MultipartStream(InputStream, byte[], int, org.apache.wicket.util.uploadMultipartStream.ProgressNotifier)}\n \t */\n+\t@Deprecated\n \tpublic MultipartFormInputStream()\n \t{\n+\t\tthis(null, null, null);\n \t}\n \n \t/**\n \t * <p>\n-\t * Constructs a <code>MultipartStream</code> with a custom size buffer.\n+\t * Constructs a <code>MultipartStream</code> with a custom size buffer and no progress notifier.\n \t * \n \t * <p>\n \t * Note that the buffer must be at least big enough to contain the boundary string, plus 4\n@@ -215,28 +320,54 @@ public MultipartFormInputStream()\n \t * @param bufSize\n \t *            The size of the buffer to be used, in bytes.\n \t * \n+\t * @see #MultipartFormInputStream(InputStream, byte[],\n+\t *      MultipartFormInputStream.ProgressNotifier)\n+\t * @deprecated Use\n+\t *             {@link #MultipartStream(InputStream, byte[], int, org.apache.wicket.util.uploadMultipartStream.ProgressNotifier)}\n+\t *             .\n+\t */\n+\t@Deprecated\n+\tpublic MultipartFormInputStream(InputStream input, byte[] boundary, int bufSize)\n+\t{\n+\t\tthis(input, boundary, bufSize, null);\n+\t}\n+\n+\t/**\n+\t * <p>\n+\t * Constructs a <code>MultipartStream</code> with a custom size buffer.\n \t * \n-\t * @see #MultipartFormInputStream()\n-\t * @see #MultipartFormInputStream(InputStream, byte[])\n+\t * <p>\n+\t * Note that the buffer must be at least big enough to contain the boundary string, plus 4\n+\t * characters for CR/LF and double dash, plus at least one byte of data. Too small a buffer size\n+\t * setting will degrade performance.\n \t * \n+\t * @param input\n+\t *            The <code>InputStream</code> to serve as a data source.\n+\t * @param boundary\n+\t *            The token used for dividing the stream into <code>encapsulations</code>.\n+\t * @param bufSize\n+\t *            The size of the buffer to be used, in bytes.\n+\t * @param pNotifier\n+\t *            The notifier, which is used for calling the progress listener, if any.\n+\t * \n+\t * @see #MultipartFormInputStream(InputStream, byte[],\n+\t *      MultipartFormInputStream.ProgressNotifier)\n \t */\n-\tpublic MultipartFormInputStream(final InputStream input, final byte[] boundary,\n-\t\tfinal int bufSize)\n+\tMultipartFormInputStream(InputStream input, byte[] boundary, int bufSize,\n+\t\tProgressNotifier pNotifier)\n \t{\n \t\tthis.input = input;\n \t\tthis.bufSize = bufSize;\n \t\tbuffer = new byte[bufSize];\n+\t\tnotifier = pNotifier;\n \n-\t\t// We prepend CR/LF to the boundary to chop trailing CR/LF from\n+\t\t// We prepend CR/LF to the boundary to chop trailng CR/LF from\n \t\t// body-data tokens.\n-\t\tthis.boundary = new byte[boundary.length + 4];\n-\t\tboundaryLength = boundary.length + 4;\n-\t\tkeepRegion = boundary.length + 3;\n-\t\tthis.boundary[0] = CR;\n-\t\tthis.boundary[1] = LF;\n-\t\tthis.boundary[2] = DASH;\n-\t\tthis.boundary[3] = DASH;\n-\t\tSystem.arraycopy(boundary, 0, this.boundary, 4, boundary.length);\n+\t\tthis.boundary = new byte[boundary.length + BOUNDARY_PREFIX.length];\n+\t\tboundaryLength = boundary.length + BOUNDARY_PREFIX.length;\n+\t\tkeepRegion = this.boundary.length;\n+\t\tSystem.arraycopy(BOUNDARY_PREFIX, 0, this.boundary, 0, BOUNDARY_PREFIX.length);\n+\t\tSystem.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n \n \t\thead = 0;\n \t\ttail = 0;\n@@ -251,17 +382,18 @@ public MultipartFormInputStream(final InputStream input, final byte[] boundary,\n \t *            The <code>InputStream</code> to serve as a data source.\n \t * @param boundary\n \t *            The token used for dividing the stream into <code>encapsulations</code>.\n+\t * @param pNotifier\n+\t *            An object for calling the progress listener, if any.\n \t * \n-\t * @see #MultipartFormInputStream()\n-\t * @see #MultipartFormInputStream(InputStream, byte[], int)\n \t * \n+\t * @see #MultipartFormInputStream(InputStream, byte[], int,\n+\t *      MultipartFormInputStream.ProgressNotifier)\n \t */\n-\tpublic MultipartFormInputStream(final InputStream input, final byte[] boundary)\n+\tMultipartFormInputStream(InputStream input, byte[] boundary, ProgressNotifier pNotifier)\n \t{\n-\t\tthis(input, boundary, DEFAULT_BUFSIZE);\n+\t\tthis(input, boundary, DEFAULT_BUFSIZE, pNotifier);\n \t}\n \n-\n \t// --------------------------------------------------------- Public methods\n \n \n@@ -296,8 +428,8 @@ public void setHeaderEncoding(final String encoding)\n \t * \n \t * @return The next byte from the input stream.\n \t * \n-\t * @exception IOException\n-\t *                if there is no more data available.\n+\t * @throws IOException\n+\t *             if there is no more data available.\n \t */\n \tpublic byte readByte() throws IOException\n \t{\n@@ -312,6 +444,10 @@ public byte readByte() throws IOException\n \t\t\t\t// No more data available.\n \t\t\t\tthrow new IOException(\"No more data is available\");\n \t\t\t}\n+\t\t\tif (notifier != null)\n+\t\t\t{\n+\t\t\t\tnotifier.noteBytesRead(tail);\n+\t\t\t}\n \t\t}\n \t\treturn buffer[head++];\n \t}\n@@ -324,8 +460,8 @@ public byte readByte() throws IOException\n \t * @return <code>true</code> if there are more encapsulations in this stream; <code>false</code>\n \t *         otherwise.\n \t * \n-\t * @exception MalformedStreamException\n-\t *                if the stream ends unexpectedly or fails to follow required syntax.\n+\t * @throws MalformedStreamException\n+\t *             if the stream ends unexpecetedly or fails to follow required syntax.\n \t */\n \tpublic boolean readBoundary() throws MalformedStreamException\n \t{\n@@ -387,70 +523,67 @@ else if (arrayequals(marker, FIELD_SEPARATOR, 2))\n \t * @param boundary\n \t *            The boundary to be used for parsing of the nested stream.\n \t * \n-\t * @exception IllegalBoundaryException\n-\t *                if the <code>boundary</code> has a different length than the one being\n-\t *                currently parsed.\n+\t * @throws IllegalBoundaryException\n+\t *             if the <code>boundary</code> has a different length than the one being currently\n+\t *             parsed.\n \t */\n \tpublic void setBoundary(final byte[] boundary) throws IllegalBoundaryException\n \t{\n-\t\tif (boundary.length != boundaryLength - 4)\n+\t\tif (boundary.length != boundaryLength - BOUNDARY_PREFIX.length)\n \t\t{\n \t\t\tthrow new IllegalBoundaryException(\"The length of a boundary token can not be changed\");\n \t\t}\n-\t\tSystem.arraycopy(boundary, 0, this.boundary, 4, boundary.length);\n+\t\tSystem.arraycopy(boundary, 0, this.boundary, BOUNDARY_PREFIX.length, boundary.length);\n \t}\n \n+\n \t/**\n \t * <p>\n \t * Reads the <code>header-part</code> of the current <code>encapsulation</code>.\n+\t * \n \t * <p>\n \t * Headers are returned verbatim to the input stream, including the trailing <code>CRLF</code>\n \t * marker. Parsing is left to the application.\n \t * \n-\t * @param maxSize\n-\t *            The maximum amount to read before giving up\n+\t * <p>\n+\t * <strong>TODO</strong> allow limiting maximum header size to protect against abuse.\n \t * \n \t * @return The <code>header-part</code> of the current encapsulation.\n \t * \n-\t * @exception MalformedStreamException\n-\t *                if the stream ends unexpectedly.\n+\t * @throws MalformedStreamException\n+\t *             if the stream ends unexpecetedly.\n \t */\n-\tpublic String readHeaders(final int maxSize) throws MalformedStreamException\n+\tpublic String readHeaders() throws MalformedStreamException\n \t{\n \t\tint i = 0;\n-\t\tbyte[] b = new byte[1];\n+\t\tbyte b;\n \t\t// to support multi-byte characters\n \t\tByteArrayOutputStream baos = new ByteArrayOutputStream();\n-\t\tint sizeMax = HEADER_PART_SIZE_MAX;\n \t\tint size = 0;\n-\t\twhile (i < 4)\n+\t\twhile (i < HEADER_SEPARATOR.length)\n \t\t{\n \t\t\ttry\n \t\t\t{\n-\t\t\t\tb[0] = readByte();\n+\t\t\t\tb = readByte();\n \t\t\t}\n \t\t\tcatch (IOException e)\n \t\t\t{\n \t\t\t\tthrow new MalformedStreamException(\"Stream ended unexpectedly\");\n \t\t\t}\n-\t\t\tsize++;\n-\t\t\tif (size > maxSize)\n+\t\t\tif (++size > HEADER_PART_SIZE_MAX)\n \t\t\t{\n-\t\t\t\tthrow new MalformedStreamException(\"Stream exceeded maximum of \" + maxSize +\n-\t\t\t\t\t\" bytes\");\n+\t\t\t\tthrow new MalformedStreamException(\"Header section has more than \" +\n+\t\t\t\t\tHEADER_PART_SIZE_MAX + \" bytes (maybe it is not properly terminated)\");\n \t\t\t}\n-\t\t\tif (b[0] == HEADER_SEPARATOR[i])\n+\t\t\tif (b == HEADER_SEPARATOR[i])\n \t\t\t{\n \t\t\t\ti++;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n \t\t\t\ti = 0;\n \t\t\t}\n-\t\t\tif (size <= sizeMax)\n-\t\t\t{\n-\t\t\t\tbaos.write(b[0]);\n-\t\t\t}\n+\t\t\tbaos.write(b);\n \t\t}\n \n \t\tString headers = null;\n@@ -483,81 +616,36 @@ public String readHeaders(final int maxSize) throws MalformedStreamException\n \t * \n \t * <p>\n \t * Arbitrary large amounts of data can be processed by this method using a constant size buffer.\n-\t * (see {@link #MultipartFormInputStream(InputStream,byte[],int) constructor}).\n+\t * (see\n+\t * {@link #MultipartFormInputStream(InputStream,byte[],int, MultipartFormInputStream.ProgressNotifier)\n+\t * constructor}).\n \t * \n \t * @param output\n-\t *            The <code>Stream</code> to write data into.\n+\t *            The <code>Stream</code> to write data into. May be null, in which case this method\n+\t *            is equivalent to {@link #discardBodyData()}.\n \t * \n \t * @return the amount of data written.\n \t * \n-\t * @exception MalformedStreamException\n-\t *                if the stream ends unexpectedly.\n-\t * @exception IOException\n-\t *                if an i/o error occurs.\n+\t * @throws MalformedStreamException\n+\t *             if the stream ends unexpectedly.\n+\t * @throws IOException\n+\t *             if an i/o error occurs.\n \t */\n \tpublic int readBodyData(final OutputStream output) throws MalformedStreamException, IOException\n \t{\n-\t\tboolean done = false;\n-\t\tint pad;\n-\t\tint pos;\n-\t\tint bytesRead;\n-\t\tint total = 0;\n-\t\twhile (!done)\n-\t\t{\n-\t\t\t// Is boundary token present somewhere in the buffer?\n-\t\t\tpos = findSeparator();\n-\t\t\tif (pos != -1)\n-\t\t\t{\n-\t\t\t\t// Write the rest of the data before the boundary.\n-\t\t\t\toutput.write(buffer, head, pos - head);\n-\t\t\t\ttotal += pos - head;\n-\t\t\t\thead = pos;\n-\t\t\t\tdone = true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// Determine how much data should be kept in the\n-\t\t\t\t// buffer.\n-\t\t\t\tif (tail - head > keepRegion)\n-\t\t\t\t{\n-\t\t\t\t\tpad = keepRegion;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tpad = tail - head;\n-\t\t\t\t}\n-\t\t\t\t// Write out the data belonging to the body-data.\n-\t\t\t\toutput.write(buffer, head, tail - head - pad);\n-\n-\t\t\t\t// Move the data to the beginning of the buffer.\n-\t\t\t\ttotal += tail - head - pad;\n-\t\t\t\tSystem.arraycopy(buffer, tail - pad, buffer, 0, pad);\n-\n-\t\t\t\t// Refill buffer with new data.\n-\t\t\t\thead = 0;\n-\t\t\t\tbytesRead = input.read(buffer, pad, bufSize - pad);\n-\n-\t\t\t\t// [pprrrrrrr]\n-\t\t\t\tif (bytesRead != -1)\n-\t\t\t\t{\n-\t\t\t\t\ttail = pad + bytesRead;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// The last pad amount is left in the buffer.\n-\t\t\t\t\t// Boundary can't be in there so write out the\n-\t\t\t\t\t// data you have and signal an error condition.\n-\t\t\t\t\toutput.write(buffer, 0, pad);\n-\t\t\t\t\toutput.flush();\n-\t\t\t\t\ttotal += pad;\n-\t\t\t\t\tthrow new MalformedStreamException(\"Stream ended unexpectedly\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\toutput.flush();\n-\t\treturn total;\n+\t\tfinal InputStream istream = newInputStream();\n+\t\treturn Streams.copy(istream, output == null ? new NoopOutputStream() : output);\n \t}\n \n+\t/**\n+\t * Creates a new {@link ItemInputStream}.\n+\t * \n+\t * @return A new instance of {@link ItemInputStream}.\n+\t */\n+\tItemInputStream newInputStream()\n+\t{\n+\t\treturn new ItemInputStream();\n+\t}\n \n \t/**\n \t * <p>\n@@ -568,75 +656,24 @@ public int readBodyData(final OutputStream output) throws MalformedStreamExcepti\n \t * \n \t * @return The amount of data discarded.\n \t * \n-\t * @exception MalformedStreamException\n-\t *                if the stream ends unexpectedly.\n-\t * @exception IOException\n-\t *                if an i/o error occurs.\n+\t * @throws MalformedStreamException\n+\t *             if the stream ends unexpectedly.\n+\t * @throws IOException\n+\t *             if an i/o error occurs.\n \t */\n \tpublic int discardBodyData() throws MalformedStreamException, IOException\n \t{\n-\t\tboolean done = false;\n-\t\tint pad;\n-\t\tint pos;\n-\t\tint bytesRead;\n-\t\tint total = 0;\n-\t\twhile (!done)\n-\t\t{\n-\t\t\t// Is boundary token present somewhere in the buffer?\n-\t\t\tpos = findSeparator();\n-\t\t\tif (pos != -1)\n-\t\t\t{\n-\t\t\t\t// Write the rest of the data before the boundary.\n-\t\t\t\ttotal += pos - head;\n-\t\t\t\thead = pos;\n-\t\t\t\tdone = true;\n-\t\t\t}\n-\t\t\telse\n-\t\t\t{\n-\t\t\t\t// Determine how much data should be kept in the\n-\t\t\t\t// buffer.\n-\t\t\t\tif (tail - head > keepRegion)\n-\t\t\t\t{\n-\t\t\t\t\tpad = keepRegion;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\tpad = tail - head;\n-\t\t\t\t}\n-\t\t\t\ttotal += tail - head - pad;\n-\n-\t\t\t\t// Move the data to the beginning of the buffer.\n-\t\t\t\tSystem.arraycopy(buffer, tail - pad, buffer, 0, pad);\n-\n-\t\t\t\t// Refill buffer with new data.\n-\t\t\t\thead = 0;\n-\t\t\t\tbytesRead = input.read(buffer, pad, bufSize - pad);\n-\n-\t\t\t\t// [pprrrrrrr]\n-\t\t\t\tif (bytesRead != -1)\n-\t\t\t\t{\n-\t\t\t\t\ttail = pad + bytesRead;\n-\t\t\t\t}\n-\t\t\t\telse\n-\t\t\t\t{\n-\t\t\t\t\t// The last pad amount is left in the buffer.\n-\t\t\t\t\t// Boundary can't be in there so signal an error\n-\t\t\t\t\t// condition.\n-\t\t\t\t\ttotal += pad;\n-\t\t\t\t\tthrow new MalformedStreamException(\"Stream ended unexpectedly\");\n-\t\t\t\t}\n-\t\t\t}\n-\t\t}\n-\t\treturn total;\n+\t\treturn readBodyData(null);\n \t}\n \n+\n \t/**\n \t * Finds the beginning of the first <code>encapsulation</code>.\n \t * \n \t * @return <code>true</code> if an <code>encapsulation</code> was found in the stream.\n \t * \n-\t * @exception IOException\n-\t *                if an i/o error occurs.\n+\t * @throws IOException\n+\t *             if an i/o error occurs.\n \t */\n \tpublic boolean skipPreamble() throws IOException\n \t{\n@@ -648,7 +685,7 @@ public boolean skipPreamble() throws IOException\n \t\t\t// Discard all data up to the delimiter.\n \t\t\tdiscardBodyData();\n \n-\t\t\t// Read boundary - if succeeded, the stream contains an\n+\t\t\t// Read boundary - if succeded, the stream contains an\n \t\t\t// encapsulation.\n \t\t\treturn readBoundary();\n \t\t}\n@@ -783,6 +820,7 @@ public String toString()\n \t\treturn sbTemp.toString();\n \t}\n \n+\n \t/**\n \t * Thrown to indicate that the input stream fails to follow the required syntax.\n \t */\n@@ -838,23 +876,342 @@ public IllegalBoundaryException(final String message)\n \t\t}\n \t}\n \n+\t/**\n+\t * An {@link InputStream} for reading an items contents.\n+\t */\n+\tpublic class ItemInputStream extends InputStream implements Closeable\n+\t{\n+\t\t/**\n+\t\t * The number of bytes, which have been read so far.\n+\t\t */\n+\t\tprivate long total;\n+\t\t/**\n+\t\t * The number of bytes, which must be hold, because they might be a part of the boundary.\n+\t\t */\n+\t\tprivate int pad;\n+\t\t/**\n+\t\t * The current offset in the buffer.\n+\t\t */\n+\t\tprivate int pos;\n+\t\t/**\n+\t\t * Whether the stream is already closed.\n+\t\t */\n+\t\tprivate boolean closed;\n+\n+\t\t/**\n+\t\t * Creates a new instance.\n+\t\t */\n+\t\tItemInputStream()\n+\t\t{\n+\t\t\tfindSeparator();\n+\t\t}\n+\n+\t\t/**\n+\t\t * Called for finding the separator.\n+\t\t */\n+\t\tprivate void findSeparator()\n+\t\t{\n+\t\t\tpos = MultipartFormInputStream.this.findSeparator();\n+\t\t\tif (pos == -1)\n+\t\t\t{\n+\t\t\t\tif (tail - head > keepRegion)\n+\t\t\t\t{\n+\t\t\t\t\tpad = keepRegion;\n+\t\t\t\t}\n+\t\t\t\telse\n+\t\t\t\t{\n+\t\t\t\t\tpad = tail - head;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns the number of bytes, which have been read by the stream.\n+\t\t * \n+\t\t * @return Number of bytes, which have been read so far.\n+\t\t */\n+\t\tpublic long getBytesRead()\n+\t\t{\n+\t\t\treturn total;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns the number of bytes, which are currently available, without blocking.\n+\t\t * \n+\t\t * @throws IOException\n+\t\t *             An I/O error occurs.\n+\t\t * @return Number of bytes in the buffer.\n+\t\t */\n+\t\t@Override\n+\t\tpublic int available() throws IOException\n+\t\t{\n+\t\t\tif (pos == -1)\n+\t\t\t{\n+\t\t\t\treturn tail - head - pad;\n+\t\t\t}\n+\t\t\treturn pos - head;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Offset when converting negative bytes to integers.\n+\t\t */\n+\t\tprivate static final int BYTE_POSITIVE_OFFSET = 256;\n+\n+\t\t/**\n+\t\t * Returns the next byte in the stream.\n+\t\t * \n+\t\t * @return The next byte in the stream, as a non-negative integer, or -1 for EOF.\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\t@Override\n+\t\tpublic int read() throws IOException\n+\t\t{\n+\t\t\tif (closed)\n+\t\t\t{\n+\t\t\t\tthrow new FileItemStream.ItemSkippedException();\n+\t\t\t}\n+\t\t\tif (available() == 0)\n+\t\t\t{\n+\t\t\t\tif (makeAvailable() == 0)\n+\t\t\t\t{\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\t++total;\n+\t\t\tint b = buffer[head++];\n+\t\t\tif (b >= 0)\n+\t\t\t{\n+\t\t\t\treturn b;\n+\t\t\t}\n+\t\t\treturn b + BYTE_POSITIVE_OFFSET;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Reads bytes into the given buffer.\n+\t\t * \n+\t\t * @param b\n+\t\t *            The destination buffer, where to write to.\n+\t\t * @param off\n+\t\t *            Offset of the first byte in the buffer.\n+\t\t * @param len\n+\t\t *            Maximum number of bytes to read.\n+\t\t * @return Number of bytes, which have been actually read, or -1 for EOF.\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\t@Override\n+\t\tpublic int read(byte[] b, int off, int len) throws IOException\n+\t\t{\n+\t\t\tif (closed)\n+\t\t\t{\n+\t\t\t\tthrow new FileItemStream.ItemSkippedException();\n+\t\t\t}\n+\t\t\tif (len == 0)\n+\t\t\t{\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\t\t\tint res = available();\n+\t\t\tif (res == 0)\n+\t\t\t{\n+\t\t\t\tres = makeAvailable();\n+\t\t\t\tif (res == 0)\n+\t\t\t\t{\n+\t\t\t\t\treturn -1;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tres = Math.min(res, len);\n+\t\t\tSystem.arraycopy(buffer, head, b, off, res);\n+\t\t\thead += res;\n+\t\t\ttotal += res;\n+\t\t\treturn res;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Closes the input stream.\n+\t\t * \n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\t@Override\n+\t\tpublic void close() throws IOException\n+\t\t{\n+\t\t\tclose(false);\n+\t\t}\n+\n+\t\t/**\n+\t\t * Closes the input stream.\n+\t\t * \n+\t\t * @param pCloseUnderlying\n+\t\t *            Whether to close the underlying stream (hard close)\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\tpublic void close(boolean pCloseUnderlying) throws IOException\n+\t\t{\n+\t\t\tif (closed)\n+\t\t\t{\n+\t\t\t\treturn;\n+\t\t\t}\n+\t\t\tif (pCloseUnderlying)\n+\t\t\t{\n+\t\t\t\tclosed = true;\n+\t\t\t\tinput.close();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\tfor (;;)\n+\t\t\t\t{\n+\t\t\t\t\tint av = available();\n+\t\t\t\t\tif (av == 0)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tav = makeAvailable();\n+\t\t\t\t\t\tif (av == 0)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tskip(av);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tclosed = true;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Skips the given number of bytes.\n+\t\t * \n+\t\t * @param bytes\n+\t\t *            Number of bytes to skip.\n+\t\t * @return The number of bytes, which have actually been skipped.\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\t@Override\n+\t\tpublic long skip(long bytes) throws IOException\n+\t\t{\n+\t\t\tif (closed)\n+\t\t\t{\n+\t\t\t\tthrow new FileItemStream.ItemSkippedException();\n+\t\t\t}\n+\t\t\tint av = available();\n+\t\t\tif (av == 0)\n+\t\t\t{\n+\t\t\t\tav = makeAvailable();\n+\t\t\t\tif (av == 0)\n+\t\t\t\t{\n+\t\t\t\t\treturn 0;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tlong res = Math.min(av, bytes);\n+\t\t\thead += res;\n+\t\t\treturn res;\n+\t\t}\n+\n+\t\t/**\n+\t\t * Attempts to read more data.\n+\t\t * \n+\t\t * @return Number of available bytes\n+\t\t * @throws IOException\n+\t\t *             An I/O error occurred.\n+\t\t */\n+\t\tprivate int makeAvailable() throws IOException\n+\t\t{\n+\t\t\tif (pos != -1)\n+\t\t\t{\n+\t\t\t\treturn 0;\n+\t\t\t}\n+\n+\t\t\t// Move the data to the beginning of the buffer.\n+\t\t\ttotal += tail - head - pad;\n+\t\t\tSystem.arraycopy(buffer, tail - pad, buffer, 0, pad);\n+\n+\t\t\t// Refill buffer with new data.\n+\t\t\thead = 0;\n+\t\t\ttail = pad;\n+\n+\t\t\tfor (;;)\n+\t\t\t{\n+\t\t\t\tint bytesRead = input.read(buffer, tail, bufSize - tail);\n+\t\t\t\tif (bytesRead == -1)\n+\t\t\t\t{\n+\t\t\t\t\t// The last pad amount is left in the buffer.\n+\t\t\t\t\t// Boundary can't be in there so signal an error\n+\t\t\t\t\t// condition.\n+\t\t\t\t\tfinal String msg = \"Stream ended unexpectedly\";\n+\t\t\t\t\tthrow new MalformedStreamException(msg);\n+\t\t\t\t}\n+\t\t\t\tif (notifier != null)\n+\t\t\t\t{\n+\t\t\t\t\tnotifier.noteBytesRead(bytesRead);\n+\t\t\t\t}\n+\t\t\t\ttail += bytesRead;\n+\n+\t\t\t\tfindSeparator();\n+\t\t\t\tint av = available();\n+\n+\t\t\t\tif (av > 0 || pos != -1)\n+\t\t\t\t{\n+\t\t\t\t\treturn av;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\t/**\n+\t\t * Returns, whether the stream is closed.\n+\t\t * \n+\t\t * @return True, if the stream is closed, otherwise false.\n+\t\t */\n+\t\tpublic boolean isClosed()\n+\t\t{\n+\t\t\treturn closed;\n+\t\t}\n+\t}\n+\n+\tprivate final static class NoopOutputStream extends OutputStream\n+\t{\n+\t\t@Override\n+\t\tpublic void close()\n+\t\t{\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void flush()\n+\t\t{\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void write(byte[] b)\n+\t\t{\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void write(byte[] b, int i, int l)\n+\t\t{\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic void write(int b)\n+\t\t{\n+\t\t}\n+\t}\n \n \t// ------------------------------------------------------ Debugging methods\n \n \n \t// These are the methods that were used to debug this stuff.\n \t/*\n+\t * \n \t * // Dump data. protected void dump() { System.out.println(\"01234567890\"); byte[] temp = new\n \t * byte[buffer.length]; for(int i=0; i<buffer.length; i++) { if (buffer[i] == 0x0D || buffer[i]\n \t * == 0x0A) { temp[i] = 0x21; } else { temp[i] = buffer[i]; } } System.out.println(new\n \t * String(temp)); int i; for (i=0; i<head; i++) System.out.print(\" \"); System.out.println(\"h\");\n \t * for (i=0; i<tail; i++) System.out.print(\" \"); System.out.println(\"t\"); System.out.flush(); }\n+\t * \n \t * // Main routine, for testing purposes only. // // @param args A String[] with the command\n-\t * line arguments. // @exception Exception, a generic exception. public static void main(\n-\t * String[] args ) throws Exception { File boundaryFile = new File(\"boundary.dat\"); int\n-\t * boundarySize = (int)boundaryFile.length(); byte[] boundary = new byte[boundarySize];\n-\t * FileInputStream input = new FileInputStream(boundaryFile);\n-\t * input.read(boundary,0,boundarySize);\n+\t * line arguments. // @throws Exception, a generic exception. public static void main( String[]\n+\t * args ) throws Exception { File boundaryFile = new File(\"boundary.dat\"); int boundarySize =\n+\t * (int)boundaryFile.length(); byte[] boundary = new byte[boundarySize]; FileInputStream input =\n+\t * new FileInputStream(boundaryFile); input.read(boundary,0,boundarySize);\n \t * \n \t * input = new FileInputStream(\"multipart.dat\"); MultipartStream chunks = new\n \t * MultipartStream(input, boundary);"
        },
        {
            "sha": "c5986ffe8f886221bb1acecb7449bc4cecc0becf",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/ParameterParser.java",
            "status": "modified",
            "additions": 40,
            "deletions": 3,
            "changes": 43,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FParameterParser.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FParameterParser.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FParameterParser.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -20,8 +20,8 @@\n import java.util.Map;\n \n /**\n- * A simple parser intended to parse sequences of name/value pairs. Parameter values are expected to\n- * be enclosed in quotes if they contain unsafe characters, such as '=' characters or separators.\n+ * A simple parser intended to parse sequences of name/value pairs. Parameter values are exptected\n+ * to be enclosed in quotes if they contain unsafe characters, such as '=' characters or separators.\n  * Parameter values are optional and can be omitted.\n  * \n  * <p>\n@@ -122,7 +122,7 @@ private String getToken(final boolean quoted)\n \t * Tests if the given character is present in the array of characters.\n \t * \n \t * @param ch\n-\t *            the character to test for presence in the array of characters\n+\t *            the character to test for presense in the array of characters\n \t * @param charray\n \t *            the array of characters to test against\n \t * \n@@ -231,6 +231,43 @@ public void setLowerCaseNames(final boolean b)\n \t\tlowerCaseNames = b;\n \t}\n \n+\t/**\n+\t * Extracts a map of name/value pairs from the given string. Names are expected to be unique.\n+\t * Multiple separators may be specified and the earliest found in the input string is used.\n+\t * \n+\t * @param str\n+\t *            the string that contains a sequence of name/value pairs\n+\t * @param separators\n+\t *            the name/value pairs separators\n+\t * \n+\t * @return a map of name/value pairs\n+\t */\n+\tpublic Map<String, String> parse(final String str, char[] separators)\n+\t{\n+\t\tif (separators == null || separators.length == 0)\n+\t\t{\n+\t\t\treturn new HashMap<String, String>();\n+\t\t}\n+\t\tchar separator = separators[0];\n+\t\tif (str != null)\n+\t\t{\n+\t\t\tint idx = str.length();\n+\t\t\tfor (int i = 0; i < separators.length; i++)\n+\t\t\t{\n+\t\t\t\tint tmp = str.indexOf(separators[i]);\n+\t\t\t\tif (tmp != -1)\n+\t\t\t\t{\n+\t\t\t\t\tif (tmp < idx)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tidx = tmp;\n+\t\t\t\t\t\tseparator = separators[i];\n+\t\t\t\t\t}\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn parse(str, separator);\n+\t}\n+\n \t/**\n \t * Extracts a map of name/value pairs from the given string. Names are expected to be unique.\n \t * "
        },
        {
            "sha": "eed1ff6946763b506baa0b667ee2041565836e57",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/ProgressListener.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FProgressListener.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FProgressListener.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FProgressListener.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -0,0 +1,38 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.wicket.util.upload;\n+\n+\n+/**\n+ * The {@link ProgressListener} may be used to display a progress bar or do stuff like that.\n+ */\n+public interface ProgressListener\n+{\n+\t/**\n+\t * Updates the listeners status information.\n+\t * \n+\t * @param pBytesRead\n+\t *            The total number of bytes, which have been read so far.\n+\t * @param pContentLength\n+\t *            The total number of bytes, which are being read. May be -1, if this number is\n+\t *            unknown.\n+\t * @param pItems\n+\t *            The number of the field, which is currently being read. (0 = no item so far, 1 =\n+\t *            first item is being read, ...)\n+\t */\n+\tvoid update(long pBytesRead, long pContentLength, int pItems);\n+}"
        },
        {
            "sha": "3f20b8111ed5441435853e723d4600c1ff2ef6e4",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/RequestContext.java",
            "status": "modified",
            "additions": 8,
            "deletions": 1,
            "changes": 9,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FRequestContext.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FRequestContext.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FRequestContext.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -21,7 +21,7 @@\n \n /**\n  * <p>\n- * Abstracts access to the request information needed for file uploads. This interface should be\n+ * Abstracts access to the request information needed for file uploads. This interfsace should be\n  * implemented for each type of request that may be handled by FileUpload, such as servlets and\n  * portlets.\n  * </p>\n@@ -31,6 +31,13 @@\n public interface RequestContext\n {\n \n+\t/**\n+\t * Retrieve the character encoding for the request.\n+\t * \n+\t * @return The character encoding for the request.\n+\t */\n+\tString getCharacterEncoding();\n+\n \t/**\n \t * Retrieve the content type of the request.\n \t * "
        },
        {
            "sha": "cf3b5323fb044adf16eb5e19925e62166bbf1559",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/ServletFileUpload.java",
            "status": "modified",
            "additions": 40,
            "deletions": 4,
            "changes": 44,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletFileUpload.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletFileUpload.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletFileUpload.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -16,11 +16,11 @@\n  */\n package org.apache.wicket.util.upload;\n \n+import java.io.IOException;\n import java.util.List;\n \n import javax.servlet.http.HttpServletRequest;\n \n-\n /**\n  * <p>\n  * High level API for processing file uploads.\n@@ -65,16 +65,27 @@ public static final boolean isMultipartContent(final HttpServletRequest request)\n \t\t{\n \t\t\treturn false;\n \t\t}\n-\t\treturn FileUploadBase.isMultipartContent(new ServletRequestContext(request));\n+\t\tString contentType = request.getContentType();\n+\t\tif (contentType == null)\n+\t\t{\n+\t\t\treturn false;\n+\t}\n+\t\tif (contentType.toLowerCase().startsWith(MULTIPART))\n+\t\t{\n+\t\t\treturn true;\n+\t\t}\n+\t\treturn false;\n \t}\n \n \n \t// ----------------------------------------------------------- Constructors\n \n \n \t/**\n-\t * Constructs an uninitialized instance of this class. A factory must be configured, using\n+\t * Constructs an uninitialised instance of this class. A factory must be configured, using\n \t * <code>setFileItemFactory()</code>, before attempting to parse requests.\n+\t * \n+\t * @see FileUpload#FileUpload(FileItemFactory)\n \t */\n \tpublic ServletFileUpload()\n \t{\n@@ -86,7 +97,9 @@ public ServletFileUpload()\n \t * Constructs an instance of this class which uses the supplied factory to create\n \t * <code>FileItem</code> instances.\n \t * \n+\t * @see FileUpload#FileUpload()\n \t * @param fileItemFactory\n+\t *            The factory to use for creating file items.\n \t */\n \tpublic ServletFileUpload(final FileItemFactory fileItemFactory)\n \t{\n@@ -107,11 +120,34 @@ public ServletFileUpload(final FileItemFactory fileItemFactory)\n \t * @return A list of <code>FileItem</code> instances parsed from the request, in the order that\n \t *         they were transmitted.\n \t * \n-\t * @exception FileUploadException\n+\t * @throws FileUploadException\n \t *                if there are problems reading/parsing the request or storing files.\n \t */\n \tpublic List<FileItem> parseRequest(final HttpServletRequest request) throws FileUploadException\n \t{\n \t\treturn parseRequest(new ServletRequestContext(request));\n \t}\n+\n+\n+\t/**\n+\t * Processes an <a href=\"http://www.ietf.org/rfc/rfc1867.txt\">RFC 1867</a> compliant\n+\t * <code>multipart/form-data</code> stream.\n+\t * \n+\t * @param request\n+\t *            The servlet request to be parsed.\n+\t * \n+\t * @return An iterator to instances of <code>FileItemStream</code> parsed from the request, in\n+\t *         the order that they were transmitted.\n+\t * \n+\t * @throws FileUploadException\n+\t *             if there are problems reading/parsing the request or storing files.\n+\t * @throws IOException\n+\t *             An I/O error occurred. This may be a network error while communicating with the\n+\t *             client or a problem while storing the uploaded content.\n+\t */\n+\tpublic FileItemIterator getItemIterator(HttpServletRequest request) throws FileUploadException,\n+\t\tIOException\n+\t{\n+\t\treturn super.getItemIterator(new ServletRequestContext(request));\n+}\n }"
        },
        {
            "sha": "ca13e6f77b3c3784c67787bd2b9b92cdfd428fa9",
            "filename": "wicket-util/src/main/java/org/apache/wicket/util/upload/ServletRequestContext.java",
            "status": "modified",
            "additions": 11,
            "deletions": 3,
            "changes": 14,
            "blob_url": "https://github.com/apache/wicket/blob/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletRequestContext.java",
            "raw_url": "https://github.com/apache/wicket/raw/db12a50a32cd779e4f36f52dc2374692477bf94d/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletRequestContext.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-util%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2Futil%2Fupload%2FServletRequestContext.java?ref=db12a50a32cd779e4f36f52dc2374692477bf94d",
            "patch": "@@ -21,7 +21,6 @@\n \n import javax.servlet.http.HttpServletRequest;\n \n-\n /**\n  * <p>\n  * Provides access to the request information needed for a request made to an HTTP servlet.\n@@ -56,6 +55,16 @@ public ServletRequestContext(final HttpServletRequest request)\n \n \t// --------------------------------------------------------- Public Methods\n \n+\t/**\n+\t * Retrieve the character encoding for the request.\n+\t * \n+\t * @return The character encoding for the request.\n+\t */\n+\tpublic String getCharacterEncoding()\n+\t{\n+\t\treturn request.getCharacterEncoding();\n+\t}\n+\n \t/**\n \t * Retrieve the content type of the request.\n \t * \n@@ -95,7 +104,6 @@ public InputStream getInputStream() throws IOException\n \t@Override\n \tpublic String toString()\n \t{\n-\t\treturn \"ContentLength=\" + this.getContentLength() + \", ContentType=\" +\n-\t\t\tthis.getContentType();\n+\t\treturn \"ContentLength=\" + getContentLength() + \", ContentType=\" + getContentType();\n \t}\n }"
        }
    ]
}
{
    "sha": "528b82634f528468970eaa655c0085b1c9592b71",
    "node_id": "MDY6Q29tbWl0Mjc5MTEwODg6NTI4YjgyNjM0ZjUyODQ2ODk3MGVhYTY1NWMwMDg1YjFjOTU5MmI3MQ==",
    "commit": {
        "author": {
            "name": "Matt Gilman",
            "email": "matt.c.gilman@gmail.com",
            "date": "2017-08-01T14:46:45Z"
        },
        "committer": {
            "name": "Andy LoPresto",
            "email": "alopresto@apache.org",
            "date": "2017-08-10T18:15:35Z"
        },
        "message": "NIFI-4210:\n- Introducing support for OpenId Connect.\n- Updating REST API and UI to support the authorization code flow.\n- Adding/fixing documentation.\n- Implementing time constant equality checks where appropriate.\n- Corrected error handling during startup and throughout the OIDC login sequence.\n- Redacting the token values from the user log.\n- Defaulting to RS256 when not preferred algorithm is specified.\n- Marking the OIDC endpoints as non-guaranteed in to allow for minor adjustments if/when additional SSO techniques are introduced.\n\nThis closes #2047.\n\nSigned-off-by: Andy LoPresto <alopresto@apache.org>",
        "tree": {
            "sha": "e978055dcc48a3e759a4de3aec29beeeb3e0970e",
            "url": "https://api.github.com/repos/apache/nifi/git/trees/e978055dcc48a3e759a4de3aec29beeeb3e0970e"
        },
        "url": "https://api.github.com/repos/apache/nifi/git/commits/528b82634f528468970eaa655c0085b1c9592b71",
        "comment_count": 0,
        "verification": {
            "verified": true,
            "reason": "valid",
            "signature": "-----BEGIN PGP SIGNATURE-----\nComment: GPGTools - https://gpgtools.org\n\niQIcBAABCgAGBQJZjKLHAAoJEG7CkxUtkLYd/ioP/0JNdjECXm3RjVgJ84lWLnRo\nP4F2wQyVDLEN7QcGUodOXja5Rs7W0PER0TW4QZqzcqpxiqdU9kCMQtI9HkDVKWPc\nZbZ4210pwgxysdldlcskL3Ynr5gARI1jlez95Be4HhIMIlmcPUYjo7aWE8BAZdHq\nUbCADv/JjfbIisUU36F86OfYBXbQMp404kjIGxlazc64/S/0Uej3j1KhVgJTYV7s\nhDwtDh2vA8fFXfwL8UjkFfsqcf0aDtHqkHNxWTYPF0iA3x8+ieFEu5y3Wq8mCb60\n23wr/j/O19dVqnekyGFqudwURQhEQSf8Eg/j4k0ak8TLTRRYcKk3DkkposwEn+bg\n3iJw7pJr3KklZkBMCBwpAM32J/6929dEo2hPB/46i3jZ9gNDidEKZK5RJ2rwvzKA\nMavI+/vDvbweozW57k+F0vYTmUkqyRdbzXfyGCSEcqFKjAkHphA3tp8+PurJT+H6\nRfPF8laOULxJEcrSeNKAQolL7tKTADTUoXauVJn+AQvP6XN1Ue39W72bC00RV/pH\nr140IEQCaP7jkkmcQNW+AQpBsCyswtQrgwp07EyCHMr0KLpkYlFuwh2fprw+/21g\njwWIA/Fbn9L6KkyoKVAYk6C6G63wPKpZ9Hou7YSOaVO4mGFFXz6V/V60yNRgoZd4\nPfVKYdc+Y+fYTSvXBr34\n=Rifh\n-----END PGP SIGNATURE-----",
            "payload": "tree e978055dcc48a3e759a4de3aec29beeeb3e0970e\nparent 505e93065ec98a45d75f0308255d4b3f42ba4389\nauthor Matt Gilman <matt.c.gilman@gmail.com> 1501598805 -0400\ncommitter Andy LoPresto <alopresto@apache.org> 1502388935 -0700\n\nNIFI-4210:\n- Introducing support for OpenId Connect.\n- Updating REST API and UI to support the authorization code flow.\n- Adding/fixing documentation.\n- Implementing time constant equality checks where appropriate.\n- Corrected error handling during startup and throughout the OIDC login sequence.\n- Redacting the token values from the user log.\n- Defaulting to RS256 when not preferred algorithm is specified.\n- Marking the OIDC endpoints as non-guaranteed in to allow for minor adjustments if/when additional SSO techniques are introduced.\n\nThis closes #2047.\n\nSigned-off-by: Andy LoPresto <alopresto@apache.org>\n",
            "verified_at": "2024-11-08T03:20:46Z"
        }
    },
    "url": "https://api.github.com/repos/apache/nifi/commits/528b82634f528468970eaa655c0085b1c9592b71",
    "html_url": "https://github.com/apache/nifi/commit/528b82634f528468970eaa655c0085b1c9592b71",
    "comments_url": "https://api.github.com/repos/apache/nifi/commits/528b82634f528468970eaa655c0085b1c9592b71/comments",
    "author": {
        "login": "mcgilman",
        "id": 123395,
        "node_id": "MDQ6VXNlcjEyMzM5NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/123395?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/mcgilman",
        "html_url": "https://github.com/mcgilman",
        "followers_url": "https://api.github.com/users/mcgilman/followers",
        "following_url": "https://api.github.com/users/mcgilman/following{/other_user}",
        "gists_url": "https://api.github.com/users/mcgilman/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/mcgilman/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/mcgilman/subscriptions",
        "organizations_url": "https://api.github.com/users/mcgilman/orgs",
        "repos_url": "https://api.github.com/users/mcgilman/repos",
        "events_url": "https://api.github.com/users/mcgilman/events{/privacy}",
        "received_events_url": "https://api.github.com/users/mcgilman/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "alopresto",
        "id": 798465,
        "node_id": "MDQ6VXNlcjc5ODQ2NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/798465?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/alopresto",
        "html_url": "https://github.com/alopresto",
        "followers_url": "https://api.github.com/users/alopresto/followers",
        "following_url": "https://api.github.com/users/alopresto/following{/other_user}",
        "gists_url": "https://api.github.com/users/alopresto/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/alopresto/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/alopresto/subscriptions",
        "organizations_url": "https://api.github.com/users/alopresto/orgs",
        "repos_url": "https://api.github.com/users/alopresto/repos",
        "events_url": "https://api.github.com/users/alopresto/events{/privacy}",
        "received_events_url": "https://api.github.com/users/alopresto/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "505e93065ec98a45d75f0308255d4b3f42ba4389",
            "url": "https://api.github.com/repos/apache/nifi/commits/505e93065ec98a45d75f0308255d4b3f42ba4389",
            "html_url": "https://github.com/apache/nifi/commit/505e93065ec98a45d75f0308255d4b3f42ba4389"
        }
    ],
    "stats": {
        "total": 1403,
        "additions": 1373,
        "deletions": 30
    },
    "files": [
        {
            "sha": "fd26a97915435eb4779ea2dac1976bb558586edc",
            "filename": "nifi-commons/nifi-properties/src/main/java/org/apache/nifi/util/NiFiProperties.java",
            "status": "modified",
            "additions": 84,
            "deletions": 1,
            "changes": 85,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-commons%2Fnifi-properties%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Futil%2FNiFiProperties.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-commons%2Fnifi-properties%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Futil%2FNiFiProperties.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-commons%2Fnifi-properties%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Futil%2FNiFiProperties.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -148,6 +148,14 @@ public abstract class NiFiProperties {\n     public static final String SECURITY_IDENTITY_MAPPING_PATTERN_PREFIX = \"nifi.security.identity.mapping.pattern.\";\n     public static final String SECURITY_IDENTITY_MAPPING_VALUE_PREFIX = \"nifi.security.identity.mapping.value.\";\n \n+    // oidc\n+    public static final String SECURITY_USER_OIDC_DISCOVERY_URL = \"nifi.security.user.oidc.discovery.url\";\n+    public static final String SECURITY_USER_OIDC_CONNECT_TIMEOUT = \"nifi.security.user.oidc.connect.timeout\";\n+    public static final String SECURITY_USER_OIDC_READ_TIMEOUT = \"nifi.security.user.oidc.read.timeout\";\n+    public static final String SECURITY_USER_OIDC_CLIENT_ID = \"nifi.security.user.oidc.client.id\";\n+    public static final String SECURITY_USER_OIDC_CLIENT_SECRET = \"nifi.security.user.oidc.client.secret\";\n+    public static final String SECURITY_USER_OIDC_PREFERRED_JWSALGORITHM = \"nifi.security.user.oidc.preferred.jwsalgorithm\";\n+\n     // web properties\n     public static final String WEB_WAR_DIR = \"nifi.web.war.directory\";\n     public static final String WEB_HTTP_PORT = \"nifi.web.http.port\";\n@@ -244,6 +252,8 @@ public abstract class NiFiProperties {\n     public static final String DEFAULT_FLOW_CONFIGURATION_ARCHIVE_ENABLED = \"true\";\n     public static final String DEFAULT_FLOW_CONFIGURATION_ARCHIVE_MAX_TIME = \"30 days\";\n     public static final String DEFAULT_FLOW_CONFIGURATION_ARCHIVE_MAX_STORAGE = \"500 MB\";\n+    public static final String DEFAULT_SECURITY_USER_OIDC_CONNECT_TIMEOUT = \"5 secs\";\n+    public static final String DEFAULT_SECURITY_USER_OIDC_READ_TIMEOUT = \"5 secs\";\n \n     // cluster common defaults\n     public static final String DEFAULT_CLUSTER_PROTOCOL_HEARTBEAT_INTERVAL = \"5 sec\";\n@@ -803,18 +813,91 @@ public boolean isKerberosSpnegoSupportEnabled() {\n         return !StringUtils.isBlank(getKerberosSpnegoPrincipal()) && !StringUtils.isBlank(getKerberosSpnegoKeytabLocation());\n     }\n \n+    /**\n+     * Returns true if the login identity provider has been configured.\n+     *\n+     * @return true if the login identity provider has been configured\n+     */\n+    public boolean isLoginIdentityProviderEnabled() {\n+        return !StringUtils.isBlank(getProperty(NiFiProperties.SECURITY_USER_LOGIN_IDENTITY_PROVIDER));\n+    }\n+\n+    /**\n+     * Returns whether an OpenId Connect (OIDC) URL is set.\n+     *\n+     * @return whether an OpenId Connection URL is set\n+     */\n+    public boolean isOidcEnabled() {\n+        return !StringUtils.isBlank(getOidcDiscoveryUrl());\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect (OIDC) URL. Null otherwise.\n+     *\n+     * @return OIDC discovery url\n+     */\n+    public String getOidcDiscoveryUrl() {\n+        return getProperty(SECURITY_USER_OIDC_DISCOVERY_URL);\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect connect timeout. Non null.\n+     *\n+     * @return OIDC connect timeout\n+     */\n+    public String getOidcConnectTimeout() {\n+        return getProperty(SECURITY_USER_OIDC_CONNECT_TIMEOUT, DEFAULT_SECURITY_USER_OIDC_CONNECT_TIMEOUT);\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect read timeout. Non null.\n+     *\n+     * @return OIDC read timeout\n+     */\n+    public String getOidcReadTimeout() {\n+        return getProperty(SECURITY_USER_OIDC_READ_TIMEOUT, DEFAULT_SECURITY_USER_OIDC_READ_TIMEOUT);\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect client id.\n+     *\n+     * @return OIDC client id\n+     */\n+    public String getOidcClientId() {\n+        return getProperty(SECURITY_USER_OIDC_CLIENT_ID);\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect client secret.\n+     *\n+     * @return OIDC client secret\n+     */\n+    public String getOidcClientSecret() {\n+        return getProperty(SECURITY_USER_OIDC_CLIENT_SECRET);\n+    }\n+\n+    /**\n+     * Returns the preferred json web signature algorithm. May be null/blank.\n+     *\n+     * @return OIDC preferred json web signature algorithm\n+     */\n+    public String getOidcPreferredJwsAlgorithm() {\n+        return getProperty(SECURITY_USER_OIDC_PREFERRED_JWSALGORITHM);\n+    }\n+\n     /**\n      * Returns true if client certificates are required for REST API. Determined\n      * if the following conditions are all true:\n      * <p>\n      * - login identity provider is not populated\n      * - Kerberos service support is not enabled\n+     * - openid connect is not enabled\n      *\n      * @return true if client certificates are required for access to the REST\n      * API\n      */\n     public boolean isClientAuthRequiredForRestApi() {\n-        return StringUtils.isBlank(getProperty(NiFiProperties.SECURITY_USER_LOGIN_IDENTITY_PROVIDER)) && !isKerberosSpnegoSupportEnabled();\n+        return !isLoginIdentityProviderEnabled() && !isKerberosSpnegoSupportEnabled() && !isOidcEnabled();\n     }\n \n     public InetSocketAddress getNodeApiAddress() {"
        },
        {
            "sha": "f922d927f0b0d81f25672db4c7616a0200e265eb",
            "filename": "nifi-docs/src/main/asciidoc/administration-guide.adoc",
            "status": "modified",
            "additions": 29,
            "deletions": 3,
            "changes": 32,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-docs%2Fsrc%2Fmain%2Fasciidoc%2Fadministration-guide.adoc",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-docs%2Fsrc%2Fmain%2Fasciidoc%2Fadministration-guide.adoc",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-docs%2Fsrc%2Fmain%2Fasciidoc%2Fadministration-guide.adoc?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -282,15 +282,21 @@ For a client certificate that can be easily imported into the browser, specify:\n User Authentication\n -------------------\n \n-NiFi supports user authentication via client certificates or via username/password. Username/password authentication is performed by a 'Login Identity\n-Provider'. The Login Identity Provider is a pluggable mechanism for authenticating users via their username/password. Which Login Identity Provider\n-to use is configured in two properties in the _nifi.properties_ file.\n+NiFi supports user authentication via client certificates, via username/password, or using OpenId Connect (http://openid.net/connect).\n+\n+Username/password authentication is performed by a 'Login Identity Provider'. The Login Identity Provider is a pluggable mechanism for\n+authenticating users via their username/password. Which Login Identity Provider to use is configured in two properties in the _nifi.properties_ file.\n \n The `nifi.login.identity.provider.configuration.file` property specifies the configuration file for Login Identity Providers.\n The `nifi.security.user.login.identity.provider` property indicates which of the configured Login Identity Provider should be\n used. If this property is not configured, NiFi will not support username/password authentication and will require client\n certificates for authenticating users over HTTPS. By default, this property is not configured meaning that username/password must be explicitly enabled.\n \n+During OpenId Connect authentication, NiFi will redirect users to login with the Provider before returning to NiFi. NiFi will then\n+call the Provider to obtain the user identity.\n+\n+NOTE: NiFi cannot be configured for both username/password and OpenId Connect authentication at the same time.\n+\n A secured instance of NiFi cannot be accessed anonymously unless configured to use an LDAP or Kerberos Login Identity Provider, which in turn must be configured to explicitly allow anonymous access. Anonymous access is not currently possible by the default FileAuthorizer (see <<authorizer-configuration>>), but is a future effort (https://issues.apache.org/jira/browse/NIFI-2730[NIFI-2730]).\n \n NOTE: NiFi does not perform user authentication over HTTP. Using HTTP, all users will be granted all roles.\n@@ -397,6 +403,26 @@ nifi.security.user.login.identity.provider=kerberos-provider\n \n See also <<kerberos_service>> to allow single sign-on access via client Kerberos tickets.\n \n+[[openid_connect]]\n+OpenId Connect\n+~~~~~~~~~~~~~~\n+\n+To enable authentication via OpenId Connect the following properties must be configured in nifi.properties.\n+\n+[options=\"header,footer\"]\n+|==================================================================================================================================================\n+| Property Name | Description\n+|`nifi.security.user.oidc.discovery.url` | The discovery URL for the desired OpenId Connect Provider (http://openid.net/specs/openid-connect-discovery-1_0.html).\n+|`nifi.security.user.oidc.connect.timeout` | Connect timeout when communicating with the OpenId Connect Provider.\n+|`nifi.security.user.oidc.read.timeout` | Read timeout when communicating with the OpenId Connect Provider.\n+|`nifi.security.user.oidc.client.id` | The client id for NiFi after registration with the OpenId Connect Provider.\n+|`nifi.security.user.oidc.client.secret` | The client secret for NiFi after registration with the OpenId Connect Provider.\n+|`nifi.security.user.oidc.preferred.jwsalgorithm` | The preferred algorithm for for validating identity tokens. If this value is blank, it will default to 'RS256' which is required to be supported\n+by the OpenId Connect Provider according to the specification. If this value is 'HS256', 'HS384', or 'HS512', NiFi will attempt to validate HMAC protected tokens using the specified client secret.\n+If this value is 'none', NiFi will attempt to validate unsecured/plain tokens. Other values for this algorithm will attempt to parse as an RSA or EC algorithm to be used in conjunction with the\n+JSON Web Key (JWK) provided through the jwks_uri in the metadata found at the discovery URL.\n+|==================================================================================================================================================\n+\n [[multi-tenant-authorization]]\n Multi-Tenant Authorization\n --------------------------"
        },
        {
            "sha": "78eb4c174add34896f3b77cda6ad2832b2f4c253",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework-nar/src/main/resources/META-INF/LICENSE",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework-nar%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2FLICENSE",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework-nar%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2FLICENSE",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework-nar%2Fsrc%2Fmain%2Fresources%2FMETA-INF%2FLICENSE?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -743,5 +743,33 @@ This product bundles 'jsonlint' which is available under an MIT license.\n     OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n     THE SOFTWARE.\n \n+This product bundles 'asm' which is available under a 3-Clause BSD style license.\n+For details see http://asm.ow2.org/asmdex-license.html\n \n+    Copyright (c) 2012 France T\u00e9l\u00e9com\n+    All rights reserved.\n+\n+    Redistribution and use in source and binary forms, with or without\n+    modification, are permitted provided that the following conditions\n+    are met:\n+    1. Redistributions of source code must retain the above copyright\n+       notice, this list of conditions and the following disclaimer.\n+    2. Redistributions in binary form must reproduce the above copyright\n+       notice, this list of conditions and the following disclaimer in the\n+       documentation and/or other materials provided with the distribution.\n+    3. Neither the name of the copyright holders nor the names of its\n+       contributors may be used to endorse or promote products derived from\n+       this software without specific prior written permission.\n+\n+    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\n+    AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\n+    IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\n+    ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE\n+    LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n+    CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\n+    SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\n+    INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\n+    CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\n+    ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF\n+    THE POSSIBILITY OF SUCH DAMAGE.\n "
        },
        {
            "sha": "fc8b572fa19aa2b2660d0acfaa29dbd196cd6e00",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-resources/pom.xml",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fpom.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fpom.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fpom.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -147,6 +147,14 @@\n         <nifi.security.ocsp.responder.url />\n         <nifi.security.ocsp.responder.certificate />\n \n+        <!-- nifi.properties: openid connect -->\n+        <nifi.security.user.oidc.discovery.url />\n+        <nifi.security.user.oidc.connect.timeout>5 secs</nifi.security.user.oidc.connect.timeout>\n+        <nifi.security.user.oidc.read.timeout>5 secs</nifi.security.user.oidc.read.timeout>\n+        <nifi.security.user.oidc.client.id />\n+        <nifi.security.user.oidc.client.secret />\n+        <nifi.security.user.oidc.preferred.jwsalgorithm />\n+\n         <!-- nifi.properties: cluster common properties (cluster manager and nodes must have same values) -->\n         <nifi.cluster.protocol.heartbeat.interval>5 sec</nifi.cluster.protocol.heartbeat.interval>\n         <nifi.cluster.protocol.is.secure>false</nifi.cluster.protocol.is.secure>"
        },
        {
            "sha": "54c6e5d7760450e4a16f2dd5414de0d004dadd55",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-resources/src/main/resources/conf/nifi.properties",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fsrc%2Fmain%2Fresources%2Fconf%2Fnifi.properties",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fsrc%2Fmain%2Fresources%2Fconf%2Fnifi.properties",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-resources%2Fsrc%2Fmain%2Fresources%2Fconf%2Fnifi.properties?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -156,6 +156,14 @@ nifi.security.user.login.identity.provider=${nifi.security.user.login.identity.p\n nifi.security.ocsp.responder.url=${nifi.security.ocsp.responder.url}\n nifi.security.ocsp.responder.certificate=${nifi.security.ocsp.responder.certificate}\n \n+# OpenId Connect Properties #\n+nifi.security.user.oidc.discovery.url=${nifi.security.user.oidc.discovery.url}\n+nifi.security.user.oidc.connect.timeout=${nifi.security.user.oidc.connect.timeout}\n+nifi.security.user.oidc.read.timeout=${nifi.security.user.oidc.read.timeout}\n+nifi.security.user.oidc.client.id=${nifi.security.user.oidc.client.id}\n+nifi.security.user.oidc.client.secret=${nifi.security.user.oidc.client.secret}\n+nifi.security.user.oidc.preferred.jwsalgorithm=${nifi.security.user.oidc.preferred.jwsalgorithm}\n+\n # Identity Mapping Properties #\n # These properties allow normalizing user identities such that identities coming from different identity providers\n # (certificates, LDAP, Kerberos) can be treated the same internally in NiFi. The following example demonstrates normalizing"
        },
        {
            "sha": "cab3922c884d5ca7d92128330be98c8a99fad5d2",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-jetty/src/main/java/org/apache/nifi/web/server/JettyServer.java",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-jetty%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fserver%2FJettyServer.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-jetty%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fserver%2FJettyServer.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-jetty%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fserver%2FJettyServer.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -289,7 +289,9 @@ private void loadWars(final Set<Bundle> bundles) {\n         }\n \n         // load the web ui app\n-        handlers.addHandler(loadWar(webUiWar, \"/nifi\", frameworkClassLoader));\n+        final WebAppContext webUiContext = loadWar(webUiWar, \"/nifi\", frameworkClassLoader);\n+        webUiContext.getInitParams().put(\"oidc-supported\", String.valueOf(props.isOidcEnabled()));\n+        handlers.addHandler(webUiContext);\n \n         // load the web api app\n         webApiContext = loadWar(webApiWar, \"/nifi-api\", frameworkClassLoader);"
        },
        {
            "sha": "ded51d0919741d918010b906714ebc5cbe17e461",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/pom.xml",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fpom.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fpom.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fpom.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -326,6 +326,11 @@\n             <artifactId>cglib-nodep</artifactId>\n             <scope>provided</scope>\n         </dependency>\n+        <dependency>\n+            <groupId>com.nimbusds</groupId>\n+            <artifactId>oauth2-oidc-sdk</artifactId>\n+            <scope>provided</scope>\n+        </dependency>\n \n         <!-- testing dependencies -->\n         <dependency>"
        },
        {
            "sha": "26f2443ba76d4e1ee54f8094b1f7a94d7b6c86dd",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/NiFiWebApiSecurityConfiguration.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2FNiFiWebApiSecurityConfiguration.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2FNiFiWebApiSecurityConfiguration.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2FNiFiWebApiSecurityConfiguration.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -78,7 +78,7 @@ public void configure(WebSecurity webSecurity) throws Exception {\n         // the /access/download-token and /access/ui-extension-token endpoints\n         webSecurity\n                 .ignoring()\n-                    .antMatchers(\"/access\", \"/access/config\", \"/access/token\", \"/access/kerberos\");\n+                    .antMatchers(\"/access\", \"/access/config\", \"/access/token\", \"/access/kerberos\", \"/access/oidc/**\");\n     }\n \n     @Override"
        },
        {
            "sha": "5c0360e238dfffa30763cab2447999fa90e74fc3",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/AccessResource.java",
            "status": "modified",
            "additions": 231,
            "deletions": 0,
            "changes": 231,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FAccessResource.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FAccessResource.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FAccessResource.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -16,6 +16,14 @@\n  */\n package org.apache.nifi.web.api;\n \n+import com.nimbusds.oauth2.sdk.AuthorizationCode;\n+import com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.id.State;\n+import com.nimbusds.openid.connect.sdk.AuthenticationErrorResponse;\n+import com.nimbusds.openid.connect.sdk.AuthenticationResponseParser;\n+import com.nimbusds.openid.connect.sdk.AuthenticationSuccessResponse;\n import com.wordnik.swagger.annotations.Api;\n import com.wordnik.swagger.annotations.ApiOperation;\n import com.wordnik.swagger.annotations.ApiResponse;\n@@ -45,6 +53,7 @@\n import org.apache.nifi.web.security.jwt.JwtAuthenticationRequestToken;\n import org.apache.nifi.web.security.jwt.JwtService;\n import org.apache.nifi.web.security.kerberos.KerberosService;\n+import org.apache.nifi.web.security.oidc.OidcService;\n import org.apache.nifi.web.security.otp.OtpService;\n import org.apache.nifi.web.security.token.LoginAuthenticationToken;\n import org.apache.nifi.web.security.token.NiFiAuthenticationToken;\n@@ -59,7 +68,10 @@\n import org.springframework.security.core.AuthenticationException;\n import org.springframework.security.web.authentication.preauth.x509.X509PrincipalExtractor;\n \n+import javax.servlet.ServletContext;\n+import javax.servlet.http.Cookie;\n import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n import javax.ws.rs.Consumes;\n import javax.ws.rs.FormParam;\n import javax.ws.rs.GET;\n@@ -69,8 +81,10 @@\n import javax.ws.rs.core.Context;\n import javax.ws.rs.core.MediaType;\n import javax.ws.rs.core.Response;\n+import javax.ws.rs.core.UriBuilder;\n import java.net.URI;\n import java.security.cert.X509Certificate;\n+import java.util.UUID;\n import java.util.concurrent.TimeUnit;\n \n /**\n@@ -85,6 +99,9 @@ public class AccessResource extends ApplicationResource {\n \n     private static final Logger logger = LoggerFactory.getLogger(AccessResource.class);\n \n+    private static final String OIDC_REQUEST_IDENTIFIER = \"oidc-request-identifier\";\n+    private static final String OIDC_ERROR_TITLE = \"Unable to continue login sequence\";\n+\n     private X509CertificateExtractor certificateExtractor;\n     private X509AuthenticationProvider x509AuthenticationProvider;\n     private X509PrincipalExtractor principalExtractor;\n@@ -93,6 +110,7 @@ public class AccessResource extends ApplicationResource {\n     private JwtAuthenticationProvider jwtAuthenticationProvider;\n     private JwtService jwtService;\n     private OtpService otpService;\n+    private OidcService oidcService;\n \n     private KerberosService kerberosService;\n \n@@ -125,6 +143,176 @@ public Response getLoginConfig(@Context HttpServletRequest httpServletRequest) {\n         return generateOkResponse(entity).build();\n     }\n \n+    @GET\n+    @Consumes(MediaType.WILDCARD)\n+    @Produces(MediaType.WILDCARD)\n+    @Path(\"oidc/request\")\n+    @ApiOperation(\n+            value = \"Initiates a request to authenticate through the configured OpenId Connect provider.\",\n+            notes = NON_GUARANTEED_ENDPOINT\n+    )\n+    public void oidcRequest(@Context HttpServletRequest httpServletRequest, @Context HttpServletResponse httpServletResponse) throws Exception {\n+        // only consider user specific access over https\n+        if (!httpServletRequest.isSecure()) {\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"User authentication/authorization is only supported when running over HTTPS.\");\n+            return;\n+        }\n+\n+        // ensure oidc is enabled\n+        if (!oidcService.isOidcEnabled()) {\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"OpenId Connect is not configured.\");\n+            return;\n+        }\n+\n+        final String oidcRequestIdentifier = UUID.randomUUID().toString();\n+\n+        // generate a cookie to associate this login sequence\n+        final Cookie cookie = new Cookie(OIDC_REQUEST_IDENTIFIER, oidcRequestIdentifier);\n+        cookie.setPath(\"/\");\n+        cookie.setHttpOnly(true);\n+        cookie.setMaxAge(60);\n+        cookie.setSecure(true);\n+        httpServletResponse.addCookie(cookie);\n+\n+        // get the state for this request\n+        final State state = oidcService.createState(oidcRequestIdentifier);\n+\n+        // build the authorization uri\n+        final URI authorizationUri = UriBuilder.fromUri(oidcService.getAuthorizationEndpoint())\n+                .queryParam(\"client_id\", oidcService.getClientId())\n+                .queryParam(\"response_type\", \"code\")\n+                .queryParam(\"scope\", oidcService.getScope().toString())\n+                .queryParam(\"state\", state.getValue())\n+                .queryParam(\"redirect_uri\", getOidcCallback())\n+                .build();\n+\n+        // generate the response\n+        httpServletResponse.sendRedirect(authorizationUri.toString());\n+    }\n+\n+    @GET\n+    @Consumes(MediaType.WILDCARD)\n+    @Produces(MediaType.WILDCARD)\n+    @Path(\"oidc/callback\")\n+    @ApiOperation(\n+            value = \"Redirect/callback URI for processing the result of the OpenId Connect login sequence.\",\n+            notes = NON_GUARANTEED_ENDPOINT\n+    )\n+    public void oidcCallback(@Context HttpServletRequest httpServletRequest, @Context HttpServletResponse httpServletResponse) throws Exception {\n+        // only consider user specific access over https\n+        if (!httpServletRequest.isSecure()) {\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"User authentication/authorization is only supported when running over HTTPS.\");\n+            return;\n+        }\n+\n+        // ensure oidc is enabled\n+        if (!oidcService.isOidcEnabled()) {\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"OpenId Connect is not configured.\");\n+            return;\n+        }\n+\n+        final String oidcRequestIdentifier = getCookieValue(httpServletRequest.getCookies(), OIDC_REQUEST_IDENTIFIER);\n+        if (oidcRequestIdentifier == null) {\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"The login request identifier was not found in the request. Unable to continue.\");\n+            return;\n+        }\n+\n+        final com.nimbusds.openid.connect.sdk.AuthenticationResponse oidcResponse;\n+        try {\n+            oidcResponse = AuthenticationResponseParser.parse(getRequestUri());\n+        } catch (final ParseException e) {\n+            logger.error(\"Unable to parse the redirect URI from the OpenId Connect Provider. Unable to continue login process.\");\n+\n+            // remove the oidc request cookie\n+            removeOidcRequestCookie(httpServletResponse);\n+\n+            // forward to the error page\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"Unable to parse the redirect URI from the OpenId Connect Provider. Unable to continue login process.\");\n+            return;\n+        }\n+\n+        if (oidcResponse.indicatesSuccess()) {\n+            final AuthenticationSuccessResponse successfulOidcResponse = (AuthenticationSuccessResponse) oidcResponse;\n+\n+            // confirm state\n+            final State state = successfulOidcResponse.getState();\n+            if (state == null || !oidcService.isStateValid(oidcRequestIdentifier, state)) {\n+                logger.error(\"The state value returned by the OpenId Connect Provider does not match the stored state. Unable to continue login process.\");\n+\n+                // remove the oidc request cookie\n+                removeOidcRequestCookie(httpServletResponse);\n+\n+                // forward to the error page\n+                forwardToMessagePage(httpServletRequest, httpServletResponse, \"Purposed state does not match the stored state. Unable to continue login process.\");\n+                return;\n+            }\n+\n+            try {\n+                // exchange authorization code for id token\n+                final AuthorizationCode authorizationCode = successfulOidcResponse.getAuthorizationCode();\n+                final AuthorizationGrant authorizationGrant = new AuthorizationCodeGrant(authorizationCode, URI.create(getOidcCallback()));\n+                oidcService.exchangeAuthorizationCode(oidcRequestIdentifier, authorizationGrant);\n+            } catch (final Exception e) {\n+                logger.error(\"Unable to exchange authorization for ID token: \" + e.getMessage(), e);\n+\n+                // remove the oidc request cookie\n+                removeOidcRequestCookie(httpServletResponse);\n+\n+                // forward to the error page\n+                forwardToMessagePage(httpServletRequest, httpServletResponse, \"Unable to exchange authorization for ID token: \" + e.getMessage());\n+                return;\n+            }\n+\n+            // redirect to the name page\n+            httpServletResponse.sendRedirect(\"../../../nifi\");\n+        } else {\n+            // remove the oidc request cookie\n+            removeOidcRequestCookie(httpServletResponse);\n+\n+            // report the unsuccessful login\n+            final AuthenticationErrorResponse errorOidcResponse = (AuthenticationErrorResponse) oidcResponse;\n+            forwardToMessagePage(httpServletRequest, httpServletResponse, \"Unsuccessful login attempt: \" + errorOidcResponse.getErrorObject().getDescription());\n+        }\n+    }\n+\n+    @POST\n+    @Consumes(MediaType.WILDCARD)\n+    @Produces(MediaType.TEXT_PLAIN)\n+    @Path(\"oidc/exchange\")\n+    @ApiOperation(\n+            value = \"Retrieves a JWT following a successful login sequence using the configured OpenId Connect provider.\",\n+            response = String.class,\n+            notes = NON_GUARANTEED_ENDPOINT\n+    )\n+    public Response oidcExchange(@Context HttpServletRequest httpServletRequest, @Context HttpServletResponse httpServletResponse) throws Exception {\n+        // only consider user specific access over https\n+        if (!httpServletRequest.isSecure()) {\n+            throw new IllegalStateException(\"User authentication/authorization is only supported when running over HTTPS.\");\n+        }\n+\n+        // ensure oidc is enabled\n+        if (!oidcService.isOidcEnabled()) {\n+            throw new IllegalStateException(\"OpenId Connect is not configured.\");\n+        }\n+\n+        final String oidcRequestIdentifier = getCookieValue(httpServletRequest.getCookies(), OIDC_REQUEST_IDENTIFIER);\n+        if (oidcRequestIdentifier == null) {\n+            throw new IllegalArgumentException(\"The login request identifier was not found in the request. Unable to continue.\");\n+        }\n+\n+        // remove the oidc request cookie\n+        removeOidcRequestCookie(httpServletResponse);\n+\n+        // get the jwt\n+        final String jwt = oidcService.getJwt(oidcRequestIdentifier);\n+        if (jwt == null) {\n+            throw new IllegalArgumentException(\"A JWT for this login request identifier could not be found. Unable to continue.\");\n+        }\n+\n+        // generate the response\n+        return generateOkResponse(jwt).build();\n+    }\n+\n     /**\n      * Gets the status the client's access.\n      *\n@@ -470,6 +658,46 @@ private long validateTokenExpiration(long proposedTokenExpiration, String identi\n         return proposedTokenExpiration;\n     }\n \n+    /**\n+     * Gets the value of a cookie matching the specified name. If no cookie with that name exists, null is returned.\n+     *\n+     * @param cookies the cookies\n+     * @param name the name of the cookie\n+     * @return the value of the corresponding cookie, or null if the cookie does not exist\n+     */\n+    private String getCookieValue(final Cookie[] cookies, final String name) {\n+        if (cookies != null) {\n+            for (final Cookie cookie : cookies) {\n+                if (name.equals(cookie.getName())) {\n+                    return cookie.getValue();\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    private String getOidcCallback() {\n+        return generateResourceUri(\"access\", \"oidc\", \"callback\");\n+    }\n+\n+    private void removeOidcRequestCookie(final HttpServletResponse httpServletResponse) {\n+        final Cookie cookie = new Cookie(OIDC_REQUEST_IDENTIFIER, null);\n+        cookie.setPath(\"/\");\n+        cookie.setHttpOnly(true);\n+        cookie.setMaxAge(0);\n+        cookie.setSecure(true);\n+        httpServletResponse.addCookie(cookie);\n+    }\n+\n+    private void forwardToMessagePage(final HttpServletRequest httpServletRequest, final HttpServletResponse httpServletResponse, final String message) throws Exception {\n+        httpServletRequest.setAttribute(\"title\", OIDC_ERROR_TITLE);\n+        httpServletRequest.setAttribute(\"messages\", message);\n+\n+        final ServletContext uiContext = httpServletRequest.getServletContext().getContext(\"/nifi\");\n+        uiContext.getRequestDispatcher(\"/WEB-INF/pages/message-page.jsp\").forward(httpServletRequest, httpServletResponse);\n+    }\n+\n     // setters\n \n     public void setLoginIdentityProvider(LoginIdentityProvider loginIdentityProvider) {\n@@ -504,4 +732,7 @@ public void setOtpService(OtpService otpService) {\n         this.otpService = otpService;\n     }\n \n+    public void setOidcService(OidcService oidcService) {\n+        this.oidcService = oidcService;\n+    }\n }"
        },
        {
            "sha": "3d78741be73da4e82060e328625ce27a95a151d0",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/java/org/apache/nifi/web/api/ApplicationResource.java",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FApplicationResource.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FApplicationResource.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fapi%2FApplicationResource.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -295,6 +295,10 @@ protected URI getAbsolutePath() {\n         return uriInfo.getAbsolutePath();\n     }\n \n+    protected URI getRequestUri() {\n+        return uriInfo.getRequestUri();\n+    }\n+\n     protected MultivaluedMap<String, String> getRequestParameters() {\n         final MultivaluedMap<String, String> entity = new MultivaluedMapImpl();\n "
        },
        {
            "sha": "2311b0785df6c5c53b1c32682c4a7209089649c4",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-api/src/main/resources/nifi-web-api-context.xml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fresources%2Fnifi-web-api-context.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fresources%2Fnifi-web-api-context.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-api%2Fsrc%2Fmain%2Fresources%2Fnifi-web-api-context.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -382,6 +382,7 @@\n     </bean>\n     <bean id=\"accessResource\" class=\"org.apache.nifi.web.api.AccessResource\" scope=\"singleton\">\n         <property name=\"loginIdentityProvider\" ref=\"loginIdentityProvider\"/>\n+        <property name=\"oidcService\" ref=\"oidcService\"/>\n         <property name=\"x509AuthenticationProvider\" ref=\"x509AuthenticationProvider\"/>\n         <property name=\"certificateExtractor\" ref=\"certificateExtractor\"/>\n         <property name=\"principalExtractor\" ref=\"principalExtractor\"/>"
        },
        {
            "sha": "59f88c7d11264fccf10ef2452b34c0cc231ae453",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/pom.xml",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fpom.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fpom.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fpom.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -136,5 +136,9 @@\n             <artifactId>spring-security-kerberos-core</artifactId>\n             <version>1.0.1.RELEASE</version>\n         </dependency>\n+        <dependency>\n+            <groupId>com.nimbusds</groupId>\n+            <artifactId>oauth2-oidc-sdk</artifactId>\n+        </dependency>\n     </dependencies>\n </project>"
        },
        {
            "sha": "5125bc5eceace18c14c19a05d9e68595b22e9c83",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/java/org/apache/nifi/web/security/jwt/JwtAuthenticationRequestToken.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fjwt%2FJwtAuthenticationRequestToken.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fjwt%2FJwtAuthenticationRequestToken.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fjwt%2FJwtAuthenticationRequestToken.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -53,7 +53,7 @@ public String getToken() {\n \n     @Override\n     public String toString() {\n-        return getName();\n+        return \"<JWT token>\";\n     }\n \n }"
        },
        {
            "sha": "4cc5ba136a244da13d106e0942fcfc8524c3c2f4",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/java/org/apache/nifi/web/security/oidc/OidcIdentityProvider.java",
            "status": "added",
            "additions": 68,
            "deletions": 0,
            "changes": 68,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcIdentityProvider.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcIdentityProvider.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcIdentityProvider.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -0,0 +1,68 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.web.security.oidc;\n+\n+\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+\n+public interface OidcIdentityProvider {\n+\n+    String OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED = \"OpenId Connect support is not configured\";\n+\n+    /**\n+     * Returns whether OIDC support is enabled.\n+     *\n+     * @return whether OIDC support is enabled\n+     */\n+    boolean isOidcEnabled();\n+\n+    /**\n+     * Returns the configured client id.\n+     *\n+     * @return the client id\n+     */\n+    ClientID getClientId();\n+\n+    /**\n+     * Returns the URI for the authorization endpoint.\n+     *\n+     * @return uri for the authorization endpoint\n+     */\n+    URI getAuthorizationEndpoint();\n+\n+    /**\n+     * Returns the scopes supported by the OIDC provider.\n+     *\n+     * @return support scopes\n+     */\n+    Scope getScope();\n+\n+    /**\n+     * Exchanges the supplied authorization grant for an ID token. Extracts the identity from the ID\n+     * token and converts it into NiFi JWT.\n+     *\n+     * @param authorizationGrant authorization grant for invoking the Token Endpoint\n+     * @return a NiFi JWT\n+     * @throws IOException if there was an exceptional error while communicating with the OIDC provider\n+     */\n+    String exchangeAuthorizationCode(AuthorizationGrant authorizationGrant) throws IOException;\n+}"
        },
        {
            "sha": "427fbdf1179e27b23d907c08ee4197d8d9c5f652",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/java/org/apache/nifi/web/security/oidc/OidcService.java",
            "status": "added",
            "additions": 246,
            "deletions": 0,
            "changes": 246,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcService.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcService.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcService.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -0,0 +1,246 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.web.security.oidc;\n+\n+import com.google.common.cache.Cache;\n+import com.google.common.cache.CacheBuilder;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.id.State;\n+import org.apache.nifi.web.security.util.CacheKey;\n+\n+import java.io.IOException;\n+import java.math.BigInteger;\n+import java.net.URI;\n+import java.nio.charset.StandardCharsets;\n+import java.security.MessageDigest;\n+import java.security.SecureRandom;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.apache.nifi.web.security.oidc.StandardOidcIdentityProvider.OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED;\n+\n+/**\n+ * OidcService is a service for managing the OpenId Connect Authorization flow.\n+ */\n+public class OidcService {\n+\n+    private OidcIdentityProvider identityProvider;\n+    private Cache<CacheKey, State> stateLookupForPendingRequests; // identifier from cookie -> state value\n+    private Cache<CacheKey, String> jwtLookupForCompletedRequests; // identifier from cookie -> jwt or identity (and generate jwt on retrieval)\n+\n+    /**\n+     * Creates a new OtpService with an expiration of 1 minute.\n+     *\n+     * @param identityProvider          The identity provider\n+     */\n+    public OidcService(final OidcIdentityProvider identityProvider) {\n+        this(identityProvider, 60, TimeUnit.SECONDS);\n+    }\n+\n+    /**\n+     * Creates a new OtpService.\n+     *\n+     * @param identityProvider          The identity provider\n+     * @param duration                  The expiration duration\n+     * @param units                     The expiration units\n+     * @throws NullPointerException     If units is null\n+     * @throws IllegalArgumentException If duration is negative\n+     */\n+    public OidcService(final OidcIdentityProvider identityProvider, final int duration, final TimeUnit units) {\n+        if (identityProvider == null) {\n+            throw new RuntimeException(\"The OidcIdentityProvider must be specified.\");\n+        }\n+\n+        this.identityProvider = identityProvider;\n+        this.stateLookupForPendingRequests = CacheBuilder.newBuilder().expireAfterWrite(duration, units).build();\n+        this.jwtLookupForCompletedRequests = CacheBuilder.newBuilder().expireAfterWrite(duration, units).build();\n+    }\n+\n+    /**\n+     * Returns whether OpenId Connect is enabled.\n+     *\n+     * @return whether OpenId Connect is enabled\n+     */\n+    public boolean isOidcEnabled() {\n+        return identityProvider.isOidcEnabled();\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect authorization endpoint.\n+     *\n+     * @return the authorization endpoint\n+     */\n+    public URI getAuthorizationEndpoint() {\n+        return identityProvider.getAuthorizationEndpoint();\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect scope.\n+     *\n+     * @return scope\n+     */\n+    public Scope getScope() {\n+        return identityProvider.getScope();\n+    }\n+\n+    /**\n+     * Returns the OpenId Connect client id.\n+     *\n+     * @return client id\n+     */\n+    public String getClientId() {\n+        return identityProvider.getClientId().getValue();\n+    }\n+\n+    /**\n+     * Initiates an OpenId Connection authorization code flow using the specified request identifier to maintain state.\n+     *\n+     * @param oidcRequestIdentifier request identifier\n+     * @return state\n+     */\n+    public State createState(final String oidcRequestIdentifier) {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        final CacheKey oidcRequestIdentifierKey = new CacheKey(oidcRequestIdentifier);\n+        final State state = new State(generateStateValue());\n+\n+        try {\n+            synchronized (stateLookupForPendingRequests) {\n+                final State cachedState = stateLookupForPendingRequests.get(oidcRequestIdentifierKey, () -> state);\n+                if (!timeConstantEqualityCheck(state.getValue(), cachedState.getValue())) {\n+                    throw new IllegalStateException(\"An existing login request is already in progress.\");\n+                }\n+            }\n+        } catch (ExecutionException e) {\n+            throw new IllegalStateException(\"Unable to store the login request state.\");\n+        }\n+\n+        return state;\n+    }\n+\n+    /**\n+     * Generates a value to use as State in the OpenId Connect login sequence. 128 bits is considered cryptographically strong\n+     * with current hardware/software, but a Base32 digit needs 5 bits to be fully encoded, so 128 is rounded up to 130. Base32\n+     * is chosen because it encodes data with a single case and without including confusing or URI-incompatible characters,\n+     * unlike Base64, but is approximately 20% more compact than Base16/hexadecimal\n+     *\n+     * @return the state value\n+     */\n+    private String generateStateValue() {\n+        return new BigInteger(130, new SecureRandom()).toString(32);\n+    }\n+\n+    /**\n+     * Validates the proposed state with the given request identifier. Will return false if the\n+     * state does not match or if entry for this request identifier has expired.\n+     *\n+     * @param oidcRequestIdentifier request identifier\n+     * @param proposedState proposed state\n+     * @return whether the state is valid or not\n+     */\n+    public boolean isStateValid(final String oidcRequestIdentifier, final State proposedState) {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        if (proposedState == null) {\n+            throw new IllegalArgumentException(\"Proposed state must be specified.\");\n+        }\n+\n+        final CacheKey oidcRequestIdentifierKey = new CacheKey(oidcRequestIdentifier);\n+\n+        synchronized (stateLookupForPendingRequests) {\n+            final State state = stateLookupForPendingRequests.getIfPresent(oidcRequestIdentifierKey);\n+            if (state != null) {\n+                stateLookupForPendingRequests.invalidate(oidcRequestIdentifierKey);\n+            }\n+\n+            return state != null && timeConstantEqualityCheck(state.getValue(), proposedState.getValue());\n+        }\n+    }\n+\n+    /**\n+     * Exchanges the specified authorization grant for an ID token for the given request identifier.\n+     *\n+     * @param oidcRequestIdentifier request identifier\n+     * @param authorizationGrant authorization grant\n+     * @throws IOException exceptional case for communication error with the OpenId Connect provider\n+     */\n+    public void exchangeAuthorizationCode(final String oidcRequestIdentifier, final AuthorizationGrant authorizationGrant) throws IOException {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        final CacheKey oidcRequestIdentifierKey = new CacheKey(oidcRequestIdentifier);\n+        final String nifiJwt = identityProvider.exchangeAuthorizationCode(authorizationGrant);\n+\n+        try {\n+            // cache the jwt for later retrieval\n+            synchronized (jwtLookupForCompletedRequests) {\n+                final String cachedJwt = jwtLookupForCompletedRequests.get(oidcRequestIdentifierKey, () -> nifiJwt);\n+                if (!timeConstantEqualityCheck(nifiJwt, cachedJwt)) {\n+                    throw new IllegalStateException(\"An existing login request is already in progress.\");\n+                }\n+            }\n+        } catch (final ExecutionException e) {\n+            throw new IllegalStateException(\"Unable to store the login authentication token.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns the resulting JWT for the given request identifier. Will return null if the request\n+     * identifier is not associated with a JWT or if the login sequence was not completed before\n+     * this request identifier expired.\n+     *\n+     * @param oidcRequestIdentifier request identifier\n+     * @return jwt token\n+     */\n+    public String getJwt(final String oidcRequestIdentifier) {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        final CacheKey oidcRequestIdentifierKey = new CacheKey(oidcRequestIdentifier);\n+\n+        synchronized (jwtLookupForCompletedRequests) {\n+            final String jwt = jwtLookupForCompletedRequests.getIfPresent(oidcRequestIdentifierKey);\n+            if (jwt != null) {\n+                jwtLookupForCompletedRequests.invalidate(oidcRequestIdentifierKey);\n+            }\n+\n+            return jwt;\n+        }\n+    }\n+\n+    /**\n+     * Implements a time constant equality check. If either value is null, false is returned.\n+     *\n+     * @param value1 value1\n+     * @param value2 value2\n+     * @return if value1 equals value2\n+     */\n+    private boolean timeConstantEqualityCheck(final String value1, final String value2) {\n+        if (value1 == null || value2 == null) {\n+            return false;\n+        }\n+\n+        return MessageDigest.isEqual(value1.getBytes(StandardCharsets.UTF_8), value2.getBytes(StandardCharsets.UTF_8));\n+    }\n+}"
        },
        {
            "sha": "6f4b6b9f4e64e032ae3f29843b92caa5556aa6d8",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/java/org/apache/nifi/web/security/oidc/StandardOidcIdentityProvider.java",
            "status": "added",
            "additions": 364,
            "deletions": 0,
            "changes": 364,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FStandardOidcIdentityProvider.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FStandardOidcIdentityProvider.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FStandardOidcIdentityProvider.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -0,0 +1,364 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.web.security.oidc;\n+\n+import com.nimbusds.jose.JOSEException;\n+import com.nimbusds.jose.JWSAlgorithm;\n+import com.nimbusds.jose.proc.BadJOSEException;\n+import com.nimbusds.jose.util.DefaultResourceRetriever;\n+import com.nimbusds.jose.util.ResourceRetriever;\n+import com.nimbusds.jwt.JWT;\n+import com.nimbusds.jwt.JWTClaimsSet;\n+import com.nimbusds.oauth2.sdk.AuthorizationGrant;\n+import com.nimbusds.oauth2.sdk.ParseException;\n+import com.nimbusds.oauth2.sdk.Scope;\n+import com.nimbusds.oauth2.sdk.TokenErrorResponse;\n+import com.nimbusds.oauth2.sdk.TokenRequest;\n+import com.nimbusds.oauth2.sdk.TokenResponse;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthentication;\n+import com.nimbusds.oauth2.sdk.auth.ClientAuthenticationMethod;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretBasic;\n+import com.nimbusds.oauth2.sdk.auth.ClientSecretPost;\n+import com.nimbusds.oauth2.sdk.auth.Secret;\n+import com.nimbusds.oauth2.sdk.http.HTTPRequest;\n+import com.nimbusds.oauth2.sdk.http.HTTPResponse;\n+import com.nimbusds.oauth2.sdk.id.ClientID;\n+import com.nimbusds.oauth2.sdk.token.BearerAccessToken;\n+import com.nimbusds.openid.connect.sdk.OIDCScopeValue;\n+import com.nimbusds.openid.connect.sdk.OIDCTokenResponse;\n+import com.nimbusds.openid.connect.sdk.OIDCTokenResponseParser;\n+import com.nimbusds.openid.connect.sdk.UserInfoErrorResponse;\n+import com.nimbusds.openid.connect.sdk.UserInfoRequest;\n+import com.nimbusds.openid.connect.sdk.UserInfoResponse;\n+import com.nimbusds.openid.connect.sdk.UserInfoSuccessResponse;\n+import com.nimbusds.openid.connect.sdk.claims.IDTokenClaimsSet;\n+import com.nimbusds.openid.connect.sdk.op.OIDCProviderMetadata;\n+import com.nimbusds.openid.connect.sdk.token.OIDCTokens;\n+import com.nimbusds.openid.connect.sdk.validators.IDTokenValidator;\n+import net.minidev.json.JSONObject;\n+import org.apache.commons.lang3.StringUtils;\n+import org.apache.nifi.util.FormatUtils;\n+import org.apache.nifi.util.NiFiProperties;\n+import org.apache.nifi.web.security.jwt.JwtService;\n+import org.apache.nifi.web.security.token.LoginAuthenticationToken;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.IOException;\n+import java.net.URI;\n+import java.net.URL;\n+import java.util.Calendar;\n+import java.util.Date;\n+import java.util.List;\n+import java.util.concurrent.TimeUnit;\n+\n+import static com.nimbusds.openid.connect.sdk.claims.UserInfo.EMAIL_CLAIM_NAME;\n+\n+/**\n+ * OidcProvider for managing the OpenId Connect Authorization flow.\n+ */\n+public class StandardOidcIdentityProvider implements OidcIdentityProvider {\n+\n+    private static final Logger logger = LoggerFactory.getLogger(StandardOidcIdentityProvider.class);\n+\n+    private NiFiProperties properties;\n+    private JwtService jwtService;\n+    private OIDCProviderMetadata oidcProviderMetadata;\n+    private int oidcConnectTimeout;\n+    private int oidcReadTimeout;\n+    private IDTokenValidator tokenValidator;\n+    private ClientID clientId;\n+    private Secret clientSecret;\n+\n+    /**\n+     * Creates a new StandardOidcIdentityProvider.\n+     *\n+     * @param jwtService jwt service\n+     * @param properties properties\n+     */\n+    public StandardOidcIdentityProvider(final JwtService jwtService, final NiFiProperties properties) {\n+        this.properties = properties;\n+        this.jwtService = jwtService;\n+\n+        // attempt to process the oidc configuration if configured\n+        if (properties.isOidcEnabled()) {\n+            if (properties.isLoginIdentityProviderEnabled()) {\n+                throw new RuntimeException(\"OpenId Connect support cannot be enabled if the Login Identity Provider is configured.\");\n+            }\n+\n+            // oidc connect timeout\n+            final String rawConnectTimeout = properties.getOidcConnectTimeout();\n+            try {\n+                oidcConnectTimeout = (int) FormatUtils.getTimeDuration(rawConnectTimeout, TimeUnit.MILLISECONDS);\n+            } catch (final Exception e) {\n+                logger.warn(\"Failed to parse value of property '{}' as a valid time period. Value was '{}'. Ignoring this value and using the default value of '{}'\",\n+                        NiFiProperties.SECURITY_USER_OIDC_CONNECT_TIMEOUT, rawConnectTimeout, NiFiProperties.DEFAULT_SECURITY_USER_OIDC_CONNECT_TIMEOUT);\n+                oidcConnectTimeout = (int) FormatUtils.getTimeDuration(NiFiProperties.DEFAULT_SECURITY_USER_OIDC_CONNECT_TIMEOUT, TimeUnit.MILLISECONDS);\n+            }\n+\n+            // oidc read timeout\n+            final String rawReadTimeout = properties.getOidcReadTimeout();\n+            try {\n+                oidcReadTimeout = (int) FormatUtils.getTimeDuration(rawReadTimeout, TimeUnit.MILLISECONDS);\n+            } catch (final Exception e) {\n+                logger.warn(\"Failed to parse value of property '{}' as a valid time period. Value was '{}'. Ignoring this value and using the default value of '{}'\",\n+                        NiFiProperties.SECURITY_USER_OIDC_READ_TIMEOUT, rawReadTimeout, NiFiProperties.DEFAULT_SECURITY_USER_OIDC_READ_TIMEOUT);\n+                oidcReadTimeout = (int) FormatUtils.getTimeDuration(NiFiProperties.DEFAULT_SECURITY_USER_OIDC_READ_TIMEOUT, TimeUnit.MILLISECONDS);\n+            }\n+\n+            // client id\n+            final String rawClientId = properties.getOidcClientId();\n+            if (StringUtils.isBlank(rawClientId)) {\n+                throw new RuntimeException(\"Client ID is required when configuring an OIDC Provider.\");\n+            }\n+            clientId = new ClientID(rawClientId);\n+\n+            // client secret\n+            final String rawClientSecret = properties.getOidcClientSecret();\n+            if (StringUtils.isBlank(rawClientSecret)) {\n+                throw new RuntimeException(\"Client secret is required when configured an OIDC Provider.\");\n+            }\n+            clientSecret = new Secret(rawClientSecret);\n+\n+            try {\n+                // retrieve the oidc provider metadata\n+                oidcProviderMetadata = retrieveOidcProviderMetadata(properties.getOidcDiscoveryUrl());\n+            } catch (IOException | ParseException e) {\n+                throw new RuntimeException(\"Unable to retrieve OpenId Connect Provider metadata from: \" + properties.getOidcDiscoveryUrl(), e);\n+            }\n+\n+            // ensure the authorization endpoint is present\n+            if (oidcProviderMetadata.getAuthorizationEndpointURI() == null) {\n+                throw new RuntimeException(\"OpenId Connect Provider metadata does not contain an Authorization Endpoint.\");\n+            }\n+\n+            // ensure the token endpoint is present\n+            if (oidcProviderMetadata.getTokenEndpointURI() == null) {\n+                throw new RuntimeException(\"OpenId Connect Provider metadata does not contain a Token Endpoint.\");\n+            }\n+\n+            // ensure the required scopes are present\n+            if (oidcProviderMetadata.getScopes() == null) {\n+                if (!oidcProviderMetadata.getScopes().contains(OIDCScopeValue.OPENID)) {\n+                    throw new RuntimeException(\"OpenId Connect Provider does not support the required scope: \" + OIDCScopeValue.OPENID.getValue());\n+                }\n+\n+                if (!oidcProviderMetadata.getScopes().contains(OIDCScopeValue.EMAIL) && oidcProviderMetadata.getUserInfoEndpointURI() == null) {\n+                    throw new RuntimeException(String.format(\"OpenId Connect Provider does not support '%s' scope and does not provide a UserInfo Endpoint.\", OIDCScopeValue.EMAIL.getValue()));\n+                }\n+            }\n+\n+            // ensure the oidc provider supports basic or post client auth\n+            final List<ClientAuthenticationMethod> clientAuthenticationMethods = oidcProviderMetadata.getTokenEndpointAuthMethods();\n+            if (clientAuthenticationMethods == null\n+                    || (!clientAuthenticationMethods.contains(ClientAuthenticationMethod.CLIENT_SECRET_BASIC)\n+                    && !clientAuthenticationMethods.contains(ClientAuthenticationMethod.CLIENT_SECRET_POST))) {\n+\n+                throw new RuntimeException(String.format(\"OpenId Connect Provider does not support %s or %s\",\n+                        ClientAuthenticationMethod.CLIENT_SECRET_BASIC.getValue(),\n+                        ClientAuthenticationMethod.CLIENT_SECRET_POST.getValue()));\n+            }\n+\n+            // extract the supported json web signature algorithms\n+            final List<JWSAlgorithm> allowedAlgorithms = oidcProviderMetadata.getIDTokenJWSAlgs();\n+            if (allowedAlgorithms == null || allowedAlgorithms.isEmpty()) {\n+                throw new RuntimeException(\"The OpenId Connect Provider does not support any JWS algorithms.\");\n+            }\n+\n+            try {\n+                // get the preferred json web signature algorithm\n+                final String rawPreferredJwsAlgorithm = properties.getOidcPreferredJwsAlgorithm();\n+\n+                final JWSAlgorithm preferredJwsAlgorithm;\n+                if (StringUtils.isBlank(rawPreferredJwsAlgorithm)) {\n+                    preferredJwsAlgorithm = JWSAlgorithm.RS256;\n+                } else {\n+                    if (\"none\".equalsIgnoreCase(rawPreferredJwsAlgorithm)) {\n+                        preferredJwsAlgorithm = null;\n+                    } else {\n+                        preferredJwsAlgorithm = JWSAlgorithm.parse(rawPreferredJwsAlgorithm);\n+                    }\n+                }\n+\n+                if (preferredJwsAlgorithm == null) {\n+                    tokenValidator = new IDTokenValidator(oidcProviderMetadata.getIssuer(), clientId);\n+                } else if (JWSAlgorithm.HS256.equals(preferredJwsAlgorithm) || JWSAlgorithm.HS384.equals(preferredJwsAlgorithm) || JWSAlgorithm.HS512.equals(preferredJwsAlgorithm)) {\n+                    tokenValidator = new IDTokenValidator(oidcProviderMetadata.getIssuer(), clientId, preferredJwsAlgorithm, clientSecret);\n+                } else {\n+                    final ResourceRetriever retriever = new DefaultResourceRetriever(oidcConnectTimeout, oidcReadTimeout);\n+                    tokenValidator = new IDTokenValidator(oidcProviderMetadata.getIssuer(), clientId, preferredJwsAlgorithm, oidcProviderMetadata.getJWKSetURI().toURL(), retriever);\n+                }\n+            } catch (final Exception e) {\n+                throw new RuntimeException(\"Unable to create the ID token validator for the configured OpenId Connect Provider: \" + e.getMessage(), e);\n+            }\n+        }\n+    }\n+\n+    private OIDCProviderMetadata retrieveOidcProviderMetadata(final String discoveryUri) throws IOException, ParseException {\n+        final URL url = new URL(discoveryUri);\n+        final HTTPRequest httpRequest = new HTTPRequest(HTTPRequest.Method.GET, url);\n+        httpRequest.setConnectTimeout(oidcConnectTimeout);\n+        httpRequest.setReadTimeout(oidcReadTimeout);\n+\n+        final HTTPResponse httpResponse = httpRequest.send();\n+\n+        if (httpResponse.getStatusCode() != 200) {\n+            throw new IOException(\"Unable to download OpenId Connect Provider metadata from \" + url + \": Status code \" + httpResponse.getStatusCode());\n+        }\n+\n+        final JSONObject jsonObject = httpResponse.getContentAsJSONObject();\n+        return OIDCProviderMetadata.parse(jsonObject);\n+    }\n+\n+    @Override\n+    public boolean isOidcEnabled() {\n+        return properties.isOidcEnabled();\n+    }\n+\n+    @Override\n+    public URI getAuthorizationEndpoint() {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        return oidcProviderMetadata.getAuthorizationEndpointURI();\n+    }\n+\n+    @Override\n+    public Scope getScope() {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        final Scope scope = new Scope(\"openid\");\n+\n+        // if this provider supports email scope, include it to prevent a subsequent request to the user endpoint\n+        if (oidcProviderMetadata.getScopes() != null && oidcProviderMetadata.getScopes().contains(OIDCScopeValue.EMAIL)) {\n+            scope.add(\"email\");\n+        }\n+        return scope;\n+    }\n+\n+    @Override\n+    public ClientID getClientId() {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        return clientId;\n+    }\n+\n+    @Override\n+    public String exchangeAuthorizationCode(final AuthorizationGrant authorizationGrant) throws IOException {\n+        if (!isOidcEnabled()) {\n+            throw new IllegalStateException(OPEN_ID_CONNECT_SUPPORT_IS_NOT_CONFIGURED);\n+        }\n+\n+        final ClientAuthentication clientAuthentication;\n+        if (oidcProviderMetadata.getTokenEndpointAuthMethods().contains(ClientAuthenticationMethod.CLIENT_SECRET_POST)) {\n+            clientAuthentication = new ClientSecretPost(clientId, clientSecret);\n+        } else {\n+            clientAuthentication = new ClientSecretBasic(clientId, clientSecret);\n+        }\n+\n+        try {\n+            // build the token request\n+            final TokenRequest request = new TokenRequest(oidcProviderMetadata.getTokenEndpointURI(), clientAuthentication, authorizationGrant, getScope());\n+            final HTTPRequest tokenHttpRequest = request.toHTTPRequest();\n+            tokenHttpRequest.setConnectTimeout(oidcConnectTimeout);\n+            tokenHttpRequest.setReadTimeout(oidcReadTimeout);\n+\n+            // get the token response\n+            final TokenResponse response = OIDCTokenResponseParser.parse(tokenHttpRequest.send());\n+\n+            if (response.indicatesSuccess()) {\n+                final OIDCTokenResponse oidcTokenResponse = (OIDCTokenResponse) response;\n+                final OIDCTokens oidcTokens = oidcTokenResponse.getOIDCTokens();\n+                final JWT oidcJwt = oidcTokens.getIDToken();\n+\n+                // validate the token - no nonce required for authorization code flow\n+                final IDTokenClaimsSet claimsSet = tokenValidator.validate(oidcJwt, null);\n+\n+                // attempt to extract the email from the id token if possible\n+                String email = claimsSet.getStringClaim(EMAIL_CLAIM_NAME);\n+                if (StringUtils.isBlank(email)) {\n+                    // extract the bearer access token\n+                    final BearerAccessToken bearerAccessToken = oidcTokens.getBearerAccessToken();\n+                    if (bearerAccessToken == null) {\n+                        throw new IllegalStateException(\"No access token found in the ID tokens\");\n+                    }\n+\n+                    // invoke the UserInfo endpoint\n+                    email = lookupEmail(bearerAccessToken);\n+                }\n+\n+                // extract expiration details from the claims set\n+                final Calendar now = Calendar.getInstance();\n+                final Date expiration = claimsSet.getExpirationTime();\n+                final long expiresIn = expiration.getTime() - now.getTimeInMillis();\n+\n+                // convert into a nifi jwt for retrieval later\n+                final LoginAuthenticationToken loginToken = new LoginAuthenticationToken(email, email, expiresIn, claimsSet.getIssuer().getValue());\n+                return jwtService.generateSignedToken(loginToken);\n+            } else {\n+                final TokenErrorResponse errorResponse = (TokenErrorResponse) response;\n+                throw new RuntimeException(\"An error occurred while invoking the Token endpoint: \" + errorResponse.getErrorObject().getDescription());\n+            }\n+        } catch (final ParseException | JOSEException | BadJOSEException e) {\n+            throw new RuntimeException(\"Unable to parse the response from the Token request: \" + e.getMessage());\n+        }\n+    }\n+\n+    private String lookupEmail(final BearerAccessToken bearerAccessToken) throws IOException {\n+        try {\n+            // build the user request\n+            final UserInfoRequest request = new UserInfoRequest(oidcProviderMetadata.getUserInfoEndpointURI(), bearerAccessToken);\n+            final HTTPRequest tokenHttpRequest = request.toHTTPRequest();\n+            tokenHttpRequest.setConnectTimeout(oidcConnectTimeout);\n+            tokenHttpRequest.setReadTimeout(oidcReadTimeout);\n+\n+            // send the user request\n+            final UserInfoResponse response = UserInfoResponse.parse(request.toHTTPRequest().send());\n+\n+            // interpret the details\n+            if (response.indicatesSuccess()) {\n+                final UserInfoSuccessResponse successResponse = (UserInfoSuccessResponse) response;\n+\n+                final JWTClaimsSet claimsSet;\n+                if (successResponse.getUserInfo() != null) {\n+                    claimsSet = successResponse.getUserInfo().toJWTClaimsSet();\n+                } else {\n+                    claimsSet = successResponse.getUserInfoJWT().getJWTClaimsSet();\n+                }\n+\n+                final String email = claimsSet.getStringClaim(EMAIL_CLAIM_NAME);\n+\n+                // ensure we were able to get the user email\n+                if (StringUtils.isBlank(email)) {\n+                    throw new IllegalStateException(\"Unable to extract email from the UserInfo token.\");\n+                } else {\n+                    return email;\n+                }\n+            } else {\n+                final UserInfoErrorResponse errorResponse = (UserInfoErrorResponse) response;\n+                throw new RuntimeException(\"An error occurred while invoking the UserInfo endpoint: \" + errorResponse.getErrorObject().getDescription());\n+            }\n+        } catch (final ParseException | java.text.ParseException e) {\n+            throw new RuntimeException(\"Unable to parse the response from the UserInfo token request: \" + e.getMessage());\n+        }\n+    }\n+}"
        },
        {
            "sha": "bad7c945ad3e284ec7e7edb2a74ae9fe64602cb9",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/java/org/apache/nifi/web/security/otp/OtpAuthenticationRequestToken.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fotp%2FOtpAuthenticationRequestToken.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fotp%2FOtpAuthenticationRequestToken.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Fotp%2FOtpAuthenticationRequestToken.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -60,7 +60,7 @@ public boolean isDownloadToken() {\n \n     @Override\n     public String toString() {\n-        return getName();\n+        return \"<OTP token>\";\n     }\n \n }"
        },
        {
            "sha": "6b0c0c195ff21fb4a707305af66085d52d28a5fd",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/main/resources/nifi-web-security-context.xml",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fresources%2Fnifi-web-security-context.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fresources%2Fnifi-web-security-context.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Fmain%2Fresources%2Fnifi-web-security-context.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -78,4 +78,13 @@\n         <property name=\"properties\" ref=\"nifiProperties\"/>\n     </bean>\n \n+    <!-- oidc -->\n+    <bean id=\"oidcProvider\" class=\"org.apache.nifi.web.security.oidc.StandardOidcIdentityProvider\">\n+        <constructor-arg ref=\"jwtService\" index=\"0\"/>\n+        <constructor-arg ref=\"nifiProperties\" index=\"1\"/>\n+    </bean>\n+    <bean id=\"oidcService\" class=\"org.apache.nifi.web.security.oidc.OidcService\">\n+        <constructor-arg ref=\"oidcProvider\"/>\n+    </bean>\n+\n </beans>"
        },
        {
            "sha": "6c135761ee69ef8e0774cc9fd0febd87c1eed83b",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-security/src/test/java/org/apache/nifi/web/security/oidc/OidcServiceTest.java",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcServiceTest.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcServiceTest.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-security%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Fsecurity%2Foidc%2FOidcServiceTest.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -0,0 +1,154 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.web.security.oidc;\n+\n+import com.nimbusds.oauth2.sdk.AuthorizationCode;\n+import com.nimbusds.oauth2.sdk.AuthorizationCodeGrant;\n+import com.nimbusds.oauth2.sdk.id.State;\n+import org.junit.Test;\n+\n+import java.net.URI;\n+import java.util.UUID;\n+import java.util.concurrent.TimeUnit;\n+\n+import static org.junit.Assert.assertFalse;\n+import static org.junit.Assert.assertNotNull;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.assertTrue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class OidcServiceTest {\n+\n+    public static final String TEST_REQUEST_IDENTIFIER = \"test-request-identifier\";\n+    public static final String TEST_STATE = \"test-state\";\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testOidcNotEnabledCreateState() throws Exception {\n+        final OidcService service = getServiceWithNoOidcSupport();\n+        service.createState(TEST_REQUEST_IDENTIFIER);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testCreateStateMultipleInvocations() throws Exception {\n+        final OidcService service = getServiceWithOidcSupport();\n+        service.createState(TEST_REQUEST_IDENTIFIER);\n+        service.createState(TEST_REQUEST_IDENTIFIER);\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testOidcNotEnabledValidateState() throws Exception {\n+        final OidcService service = getServiceWithNoOidcSupport();\n+        service.isStateValid(TEST_REQUEST_IDENTIFIER, new State(TEST_STATE));\n+    }\n+\n+    @Test\n+    public void testOidcUnknownState() throws Exception {\n+        final OidcService service = getServiceWithOidcSupport();\n+        assertFalse(service.isStateValid(TEST_REQUEST_IDENTIFIER, new State(TEST_STATE)));\n+    }\n+\n+    @Test\n+    public void testValidateState() throws Exception {\n+        final OidcService service = getServiceWithOidcSupport();\n+        final State state = service.createState(TEST_REQUEST_IDENTIFIER);\n+        assertTrue(service.isStateValid(TEST_REQUEST_IDENTIFIER, state));\n+    }\n+\n+    @Test\n+    public void testValidateStateExpiration() throws Exception {\n+        final OidcService service = getServiceWithOidcSupportAndCustomExpiration(1, TimeUnit.SECONDS);\n+        final State state = service.createState(TEST_REQUEST_IDENTIFIER);\n+\n+        Thread.sleep(3 * 1000);\n+\n+        assertFalse(service.isStateValid(TEST_REQUEST_IDENTIFIER, state));\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testOidcNotEnabledExchangeCode() throws Exception {\n+        final OidcService service = getServiceWithNoOidcSupport();\n+        service.exchangeAuthorizationCode(TEST_REQUEST_IDENTIFIER, getAuthorizationCodeGrant());\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testExchangeCodeMultipleInvocation() throws Exception {\n+        final OidcService service = getServiceWithOidcSupport();\n+        service.exchangeAuthorizationCode(TEST_REQUEST_IDENTIFIER, getAuthorizationCodeGrant());\n+        service.exchangeAuthorizationCode(TEST_REQUEST_IDENTIFIER, getAuthorizationCodeGrant());\n+    }\n+\n+    @Test(expected = IllegalStateException.class)\n+    public void testOidcNotEnabledGetJwt() throws Exception {\n+        final OidcService service = getServiceWithNoOidcSupport();\n+        service.getJwt(TEST_REQUEST_IDENTIFIER);\n+    }\n+\n+    @Test\n+    public void testGetJwt() throws Exception {\n+        final OidcService service = getServiceWithOidcSupport();\n+        service.exchangeAuthorizationCode(TEST_REQUEST_IDENTIFIER, getAuthorizationCodeGrant());\n+        assertNotNull(service.getJwt(TEST_REQUEST_IDENTIFIER));\n+    }\n+\n+    @Test\n+    public void testGetJwtExpiration() throws Exception {\n+        final OidcService service = getServiceWithOidcSupportAndCustomExpiration(1, TimeUnit.SECONDS);\n+        service.exchangeAuthorizationCode(TEST_REQUEST_IDENTIFIER, getAuthorizationCodeGrant());\n+\n+        Thread.sleep(3 * 1000);\n+\n+        assertNull(service.getJwt(TEST_REQUEST_IDENTIFIER));\n+    }\n+\n+    private OidcService getServiceWithNoOidcSupport() {\n+        final OidcIdentityProvider provider = mock(OidcIdentityProvider.class);\n+        when(provider.isOidcEnabled()).thenReturn(false);\n+\n+        final OidcService service = new OidcService(provider);\n+        assertFalse(service.isOidcEnabled());\n+\n+        return service;\n+    }\n+\n+    private OidcService getServiceWithOidcSupport() throws Exception {\n+        final OidcIdentityProvider provider = mock(OidcIdentityProvider.class);\n+        when(provider.isOidcEnabled()).thenReturn(true);\n+        when(provider.exchangeAuthorizationCode(any())).then(invocation -> UUID.randomUUID().toString());\n+\n+        final OidcService service = new OidcService(provider);\n+        assertTrue(service.isOidcEnabled());\n+\n+        return service;\n+    }\n+\n+    private OidcService getServiceWithOidcSupportAndCustomExpiration(final int duration, final TimeUnit units) throws Exception {\n+        final OidcIdentityProvider provider = mock(OidcIdentityProvider.class);\n+        when(provider.isOidcEnabled()).thenReturn(true);\n+        when(provider.exchangeAuthorizationCode(any())).then(invocation -> UUID.randomUUID().toString());\n+\n+        final OidcService service = new OidcService(provider, duration, units);\n+        assertTrue(service.isOidcEnabled());\n+\n+        return service;\n+    }\n+\n+    private AuthorizationCodeGrant getAuthorizationCodeGrant() {\n+        return new AuthorizationCodeGrant(new AuthorizationCode(\"code\"), URI.create(\"http://localhost:8080/nifi\"));\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "4f70ed8bb4360611bd5d43fa16060af19d2a53b1",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-ui/src/main/java/org/apache/nifi/web/filter/LoginFilter.java",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Ffilter%2FLoginFilter.java",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Ffilter%2FLoginFilter.java",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fnifi%2Fweb%2Ffilter%2FLoginFilter.java?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -0,0 +1,55 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.nifi.web.filter;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletContext;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import java.io.IOException;\n+\n+/**\n+ * Filter for determining appropriate login location.\n+ */\n+public class LoginFilter implements Filter {\n+\n+    private ServletContext servletContext;\n+\n+    @Override\n+    public void init(FilterConfig filterConfig) throws ServletException {\n+        servletContext = filterConfig.getServletContext();\n+    }\n+\n+    @Override\n+    public void doFilter(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n+        final boolean supportsOidc = Boolean.parseBoolean(servletContext.getInitParameter(\"oidc-supported\"));\n+\n+        if (supportsOidc) {\n+            final ServletContext apiContext = servletContext.getContext(\"/nifi-api\");\n+            apiContext.getRequestDispatcher(\"/access/oidc/request\").forward(request, response);\n+        } else {\n+            filterChain.doFilter(request, response);\n+        }\n+    }\n+\n+    @Override\n+    public void destroy() {\n+    }\n+}"
        },
        {
            "sha": "1c82a62fd3b43abdc169f1a968d6eb780e926103",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-ui/src/main/webapp/WEB-INF/pages/message-page.jsp",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fpages%2Fmessage-page.jsp",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fpages%2Fmessage-page.jsp",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fpages%2Fmessage-page.jsp?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -32,18 +32,37 @@\n     <head>\n         <title><%= request.getAttribute(\"title\") == null ? \"\" : org.apache.nifi.util.EscapeUtils.escapeHtml(request.getAttribute(\"title\").toString()) %></title>\n         <meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" />\n-        <link rel=\"shortcut icon\" href=\"images/nifi16.ico\"/>\n+        <link rel=\"shortcut icon\" href=\"<%= contextPath %>/images/nifi16.ico\"/>\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/assets/reset.css/reset.css\" type=\"text/css\" />\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/css/common-ui.css\" type=\"text/css\" />\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/fonts/flowfont/flowfont.css\" type=\"text/css\" />\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/assets/font-awesome/css/font-awesome.min.css\" type=\"text/css\" />\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/css/message-pane.css\" type=\"text/css\" />\n         <link rel=\"stylesheet\" href=\"<%= contextPath %>/nifi/css/message-page.css\" type=\"text/css\" />\n+        <script type=\"text/javascript\" src=\"<%= contextPath %>/nifi/assets/jquery/dist/jquery.min.js\"></script>\n+        <script type=\"text/javascript\">\n+            $(document).ready(function () {\n+                $('#user-home').on('mouseenter', function () {\n+                    $(this).addClass('link-over');\n+                }).on('mouseleave', function () {\n+                    $(this).removeClass('link-over');\n+                }).on('click', function () {\n+                    window.location = '<%= contextPath %>/nifi';\n+                });\n+            });\n+        </script>\n     </head>\n \n     <body class=\"message-pane\">\n         <div class=\"message-pane-message-box\">\n             <div class=\"message-pane-title\"><%= request.getAttribute(\"title\") == null ? \"\" : org.apache.nifi.util.EscapeUtils.escapeHtml(request.getAttribute(\"title\").toString()) %></div>\n+            <div id=\"user-links-container\" style=\"margin-left: 20px; float: left;\">\n+                <ul class=\"links\">\n+                    <li>\n+                        <span id=\"user-home\" class=\"link\">home</span>\n+                    </li>\n+                </ul>\n+            </div>\n             <div class=\"message-pane-content\"><%= request.getAttribute(\"messages\") == null ? \"\" : org.apache.nifi.util.EscapeUtils.escapeHtml(request.getAttribute(\"messages\").toString()) %></div>\n         </div>\n     </body>"
        },
        {
            "sha": "b758a67bba93c95f05c3b61951348e4183a3e2cb",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-ui/src/main/webapp/WEB-INF/web.xml",
            "status": "modified",
            "additions": 22,
            "deletions": 12,
            "changes": 34,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fweb.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fweb.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2FWEB-INF%2Fweb.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -15,7 +15,7 @@\n -->\n <web-app version=\"3.0\" xmlns=\"http://java.sun.com/xml/ns/javaee\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" xsi:schemaLocation=\"http://java.sun.com/xml/ns/javaee http://java.sun.com/xml/ns/javaee/web-app_3_0.xsd\">\n     <display-name>nifi</display-name>\n-    \n+\n     <!-- servlet to map to canvas page -->\n     <servlet>\n         <servlet-name>NiFiCanvas</servlet-name>\n@@ -25,7 +25,7 @@\n         <servlet-name>NiFiCanvas</servlet-name>\n         <url-pattern>/canvas</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to summary page -->\n     <servlet>\n         <servlet-name>NiFiSummary</servlet-name>\n@@ -35,7 +35,7 @@\n         <servlet-name>NiFiSummary</servlet-name>\n         <url-pattern>/summary</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to history page -->\n     <servlet>\n         <servlet-name>NiFiHistory</servlet-name>\n@@ -45,7 +45,7 @@\n         <servlet-name>NiFiHistory</servlet-name>\n         <url-pattern>/history</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to provenance page -->\n     <servlet>\n         <servlet-name>NiFiProvenance</servlet-name>\n@@ -55,7 +55,7 @@\n         <servlet-name>NiFiProvenance</servlet-name>\n         <url-pattern>/provenance</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to counters page -->\n     <servlet>\n         <servlet-name>NiFiCounters</servlet-name>\n@@ -65,7 +65,7 @@\n         <servlet-name>NiFiCounters</servlet-name>\n         <url-pattern>/counters</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to templates page -->\n     <servlet>\n         <servlet-name>NiFiTemplates</servlet-name>\n@@ -75,7 +75,7 @@\n         <servlet-name>NiFiTemplates</servlet-name>\n         <url-pattern>/templates</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to users page -->\n     <servlet>\n         <servlet-name>NiFiUsers</servlet-name>\n@@ -85,7 +85,7 @@\n         <servlet-name>NiFiUsers</servlet-name>\n         <url-pattern>/users</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to cluster page -->\n     <servlet>\n         <servlet-name>NiFiCluster</servlet-name>\n@@ -95,7 +95,7 @@\n         <servlet-name>NiFiCluster</servlet-name>\n         <url-pattern>/cluster</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to map to bulletin board page -->\n     <servlet>\n         <servlet-name>BulletinBoard</servlet-name>\n@@ -105,7 +105,7 @@\n         <servlet-name>BulletinBoard</servlet-name>\n         <url-pattern>/bulletin-board</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to support message page -->\n     <servlet>\n         <servlet-name>MessagePage</servlet-name>\n@@ -115,7 +115,7 @@\n         <servlet-name>MessagePage</servlet-name>\n         <url-pattern>/message</url-pattern>\n     </servlet-mapping>\n-    \n+\n     <!-- servlet to login page -->\n     <servlet>\n         <servlet-name>Login</servlet-name>\n@@ -125,7 +125,17 @@\n         <servlet-name>Login</servlet-name>\n         <url-pattern>/login</url-pattern>\n     </servlet-mapping>\n-    \n+\n+    <!-- login filter -->\n+    <filter>\n+        <filter-name>LoginFilter</filter-name>\n+        <filter-class>org.apache.nifi.web.filter.LoginFilter</filter-class>\n+    </filter>\n+    <filter-mapping>\n+        <filter-name>LoginFilter</filter-name>\n+        <url-pattern>/login</url-pattern>\n+    </filter-mapping>\n+\n     <welcome-file-list>\n         <welcome-file>canvas.jsp</welcome-file>\n         <welcome-file>/WEB-INF/pages/canvas.jsp</welcome-file>"
        },
        {
            "sha": "49ded8cd6992a50f3f3e5b48d8b566277bc72df7",
            "filename": "nifi-nar-bundles/nifi-framework-bundle/nifi-framework/nifi-web/nifi-web-ui/src/main/webapp/js/nf/canvas/nf-canvas.js",
            "status": "modified",
            "additions": 21,
            "deletions": 8,
            "changes": 29,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2Fjs%2Fnf%2Fcanvas%2Fnf-canvas.js",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2Fjs%2Fnf%2Fcanvas%2Fnf-canvas.js",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/nifi-nar-bundles%2Fnifi-framework-bundle%2Fnifi-framework%2Fnifi-web%2Fnifi-web-ui%2Fsrc%2Fmain%2Fwebapp%2Fjs%2Fnf%2Fcanvas%2Fnf-canvas.js?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -99,6 +99,7 @@\n             currentUser: '../nifi-api/flow/current-user',\n             controllerBulletins: '../nifi-api/flow/controller/bulletins',\n             kerberos: '../nifi-api/access/kerberos',\n+            oidc: '../nifi-api/access/oidc/exchange',\n             revision: '../nifi-api/flow/revision',\n             banners: '../nifi-api/flow/banners'\n         }\n@@ -780,8 +781,16 @@\n          * Initialize NiFi.\n          */\n         init: function () {\n-            // attempt kerberos authentication\n+            // attempt kerberos/oidc authentication\n             var ticketExchange = $.Deferred(function (deferred) {\n+                var successfulAuthentication = function (jwt) {\n+                    // get the payload and store the token with the appropriate expiration\n+                    var token = nfCommon.getJwtPayload(jwt);\n+                    var expiration = parseInt(token['exp'], 10) * nfCommon.MILLIS_PER_SECOND;\n+                    nfStorage.setItem('jwt', jwt, expiration);\n+                    deferred.resolve();\n+                };\n+\n                 if (nfStorage.hasItem('jwt')) {\n                     deferred.resolve();\n                 } else {\n@@ -790,13 +799,17 @@\n                         url: config.urls.kerberos,\n                         dataType: 'text'\n                     }).done(function (jwt) {\n-                        // get the payload and store the token with the appropriate expiration\n-                        var token = nfCommon.getJwtPayload(jwt);\n-                        var expiration = parseInt(token['exp'], 10) * nfCommon.MILLIS_PER_SECOND;\n-                        nfStorage.setItem('jwt', jwt, expiration);\n-                        deferred.resolve();\n+                        successfulAuthentication(jwt);\n                     }).fail(function () {\n-                        deferred.reject();\n+                        $.ajax({\n+                            type: 'POST',\n+                            url: config.urls.oidc,\n+                            dataType: 'text'\n+                        }).done(function (jwt) {\n+                            successfulAuthentication(jwt)\n+                        }).fail(function () {\n+                            deferred.reject();\n+                        });\n                     });\n                 }\n             }).promise();\n@@ -822,7 +835,7 @@\n                     }).fail(function (xhr, status, error) {\n                         // there is no anonymous access and we don't know this user - open the login page which handles login/registration/etc\n                         if (xhr.status === 401) {\n-                            window.location = '/nifi/login';\n+                            window.location = '../nifi/login';\n                         } else {\n                             deferred.reject(xhr, status, error);\n                         }"
        },
        {
            "sha": "9a00d09822488fcfc1cdfa448f79b95306e46fe1",
            "filename": "pom.xml",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/apache/nifi/blob/528b82634f528468970eaa655c0085b1c9592b71/pom.xml",
            "raw_url": "https://github.com/apache/nifi/raw/528b82634f528468970eaa655c0085b1c9592b71/pom.xml",
            "contents_url": "https://api.github.com/repos/apache/nifi/contents/pom.xml?ref=528b82634f528468970eaa655c0085b1c9592b71",
            "patch": "@@ -95,7 +95,7 @@\n         <jetty.version>9.4.3.v20170317</jetty.version>\n         <lucene.version>4.10.4</lucene.version>\n         <spring.version>4.2.4.RELEASE</spring.version>\n-        <spring.security.version>4.0.3.RELEASE</spring.security.version>\n+        <spring.security.version>4.2.3.RELEASE</spring.security.version>\n         <jersey.version>1.19</jersey.version>\n         <hadoop.version>2.7.3</hadoop.version>\n         <hadoop.guava.version>12.0.1</hadoop.guava.version>\n@@ -376,6 +376,11 @@\n                     </exclusion>\n                 </exclusions>\n             </dependency>\n+            <dependency>\n+                <groupId>com.nimbusds</groupId>\n+                <artifactId>oauth2-oidc-sdk</artifactId>\n+                <version>5.34</version>\n+            </dependency>\n             <dependency>\n                 <groupId>com.sun.jersey.contribs</groupId>\n                 <artifactId>jersey-multipart</artifactId>"
        }
    ]
}
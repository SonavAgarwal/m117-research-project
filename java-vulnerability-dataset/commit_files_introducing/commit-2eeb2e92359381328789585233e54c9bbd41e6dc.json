{
    "sha": "2eeb2e92359381328789585233e54c9bbd41e6dc",
    "node_id": "MDY6Q29tbWl0MTE0ODc1MzoyZWViMmU5MjM1OTM4MTMyODc4OTU4NTIzM2U1NGM5YmJkNDFlNmRj",
    "commit": {
        "author": {
            "name": "Andy Clement",
            "email": "aclement@gopivotal.com",
            "date": "2014-06-04T17:09:02Z"
        },
        "committer": {
            "name": "Andy Clement",
            "email": "aclement@gopivotal.com",
            "date": "2014-07-10T16:49:05Z"
        },
        "message": "Add a compiler for SpEL\n\nWith these changes an optional compiler is added for SpEL\nexpressions. The compiler is off by default but can be enabled\nvia the SpEL parser configuration object or system property\n(when SpEL is embedded and parser configuration is not possible).\nNot all expressions are currently handled but the common\ncases are and it is an extensible compilation framework.\n\nIssue: SPR-10943",
        "tree": {
            "sha": "4ade8f0f88c0e7959a79175a1f2525913bf28e2a",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/git/trees/4ade8f0f88c0e7959a79175a1f2525913bf28e2a"
        },
        "url": "https://api.github.com/repos/spring-projects/spring-framework/git/commits/2eeb2e92359381328789585233e54c9bbd41e6dc",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/2eeb2e92359381328789585233e54c9bbd41e6dc",
    "html_url": "https://github.com/spring-projects/spring-framework/commit/2eeb2e92359381328789585233e54c9bbd41e6dc",
    "comments_url": "https://api.github.com/repos/spring-projects/spring-framework/commits/2eeb2e92359381328789585233e54c9bbd41e6dc/comments",
    "author": {
        "login": "aclement",
        "id": 226298,
        "node_id": "MDQ6VXNlcjIyNjI5OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/226298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aclement",
        "html_url": "https://github.com/aclement",
        "followers_url": "https://api.github.com/users/aclement/followers",
        "following_url": "https://api.github.com/users/aclement/following{/other_user}",
        "gists_url": "https://api.github.com/users/aclement/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/aclement/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/aclement/subscriptions",
        "organizations_url": "https://api.github.com/users/aclement/orgs",
        "repos_url": "https://api.github.com/users/aclement/repos",
        "events_url": "https://api.github.com/users/aclement/events{/privacy}",
        "received_events_url": "https://api.github.com/users/aclement/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "aclement",
        "id": 226298,
        "node_id": "MDQ6VXNlcjIyNjI5OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/226298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aclement",
        "html_url": "https://github.com/aclement",
        "followers_url": "https://api.github.com/users/aclement/followers",
        "following_url": "https://api.github.com/users/aclement/following{/other_user}",
        "gists_url": "https://api.github.com/users/aclement/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/aclement/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/aclement/subscriptions",
        "organizations_url": "https://api.github.com/users/aclement/orgs",
        "repos_url": "https://api.github.com/users/aclement/repos",
        "events_url": "https://api.github.com/users/aclement/events{/privacy}",
        "received_events_url": "https://api.github.com/users/aclement/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "e254b558f045630138524217982dfe4f576077c7",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/e254b558f045630138524217982dfe4f576077c7",
            "html_url": "https://github.com/spring-projects/spring-framework/commit/e254b558f045630138524217982dfe4f576077c7"
        }
    ],
    "stats": {
        "total": 6054,
        "additions": 5964,
        "deletions": 90
    },
    "files": [
        {
            "sha": "35caa15700be212baca5949a4f91a20347b8e5b5",
            "filename": "spring-expression/src/main/java/org/springframework/expression/CompilablePropertyAccessor.java",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2FCompilablePropertyAccessor.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2FCompilablePropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2FCompilablePropertyAccessor.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression;\n+\n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Opcodes;\n+import org.springframework.expression.spel.ast.PropertyOrFieldReference;\n+import org.springframework.expression.spel.standard.CodeFlow;\n+\n+\n+/**\n+ * A compilable property accessor is able to generate bytecode that represents \n+ * the access operation, facilitating compilation to bytecode of expressions\n+ * that use the accessor.\n+ *\n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public interface CompilablePropertyAccessor extends PropertyAccessor, Opcodes {\n+\n+\t/**\n+\t * @return true if this property accessor is currently suitable for compilation.\n+\t */\n+\tboolean isCompilable();\n+\n+\t/**\n+\t * Generate the bytecode the performs the access operation into the specified MethodVisitor using \n+\t * context information from the codeflow where necessary.\n+\t * @param propertyReference the property reference for which code is being generated\n+\t * @param mv the Asm method visitor into which code should be generated\n+\t * @param codeflow the current state of the expression compiler\n+\t */\n+\tvoid generateCode(PropertyOrFieldReference propertyReference, MethodVisitor mv, CodeFlow codeflow);\n+\n+\t/**\n+\t * @return the type of the accessed property - may only be known once an access has occurred.\n+\t */\n+\tClass<?> getPropertyType();\n+}"
        },
        {
            "sha": "6a2f88e6975ab2e04c76b7be2b574ec0b674aa2c",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/CompiledExpression.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCompiledExpression.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCompiledExpression.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCompiledExpression.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression.spel;\n+\n+import org.springframework.expression.EvaluationContext;\n+import org.springframework.expression.EvaluationException;\n+\n+/**\n+ * Base superclass for compiled expressions. Each generated compiled expression class will\n+ * extend this class and implement one of the getValue() methods. It is not intended\n+ * to subclassed by user code.\n+ * \n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public abstract class CompiledExpression {\n+\t\n+\t/**\n+\t * Subclasses of CompiledExpression generated by SpelCompiler will provide an implementation of\n+\t * this method.\n+\t */\n+\tpublic abstract Object getValue(Object target, EvaluationContext context) throws EvaluationException;\n+\n+}"
        },
        {
            "sha": "da53d058dee3c39e27ad4023625dbdd8a43c6cb6",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/SpelCompilerMode.java",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilerMode.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilerMode.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilerMode.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression.spel;\n+\n+/**\n+ * Captures the possible configuration settings for a compiler that can be\n+ * used when evaluating expressions.\n+ * \n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public enum SpelCompilerMode {\n+\t/** \n+\t * The compiler is switched off, this is the default. \n+\t */\n+\toff,\n+\t\n+\t/** \n+\t * In immediate mode, expressions are compiled as soon as possible (usually after 1 interpreted run). \n+\t * If a compiled expression fails it will throw an exception to the caller.\n+\t */\n+\timmediate,\n+\t\n+\t/** \n+\t * In mixed mode, expression evaluate silently switches between interpreted and compiled over time.\n+\t * After a number of runs the expression gets compiled. If it later fails (possibly due to inferred\n+\t * type information changing) then that will be caught internally and the system switches back to\n+\t * interpreted mode. It may subsequently compile it again later. \n+\t */\n+\tmixed \n+}\n\\ No newline at end of file"
        },
        {
            "sha": "b1e4c12c47dc3d27c1fce9adb6f1f8e55121d671",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/SpelMessage.java",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelMessage.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelMessage.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelMessage.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -249,7 +249,10 @@ public enum SpelMessage {\n \t\t\t\"Problem parsing left operand\"),\n \n \tMISSING_SELECTION_EXPRESSION(Kind.ERROR, 1071,\n-\t\t\t\"A required selection expression has not been specified\");\n+\t\t\t\"A required selection expression has not been specified\"),\n+\t\n+\tEXCEPTION_RUNNING_COMPILED_EXPRESSION(Kind.ERROR,1072,\n+\t\t\t\"An exception occurred whilst evaluating a compiled expression\");\n \n \n \tprivate final Kind kind;"
        },
        {
            "sha": "7d5b4e2be22db5d83f4eecf0fc04e6b6a37b86e2",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/SpelParserConfiguration.java",
            "status": "modified",
            "additions": 31,
            "deletions": 2,
            "changes": 33,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelParserConfiguration.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelParserConfiguration.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelParserConfiguration.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,11 +16,15 @@\n \n package org.springframework.expression.spel;\n \n+import org.springframework.core.SpringProperties;\n+\n+\n /**\n  * Configuration object for the SpEL expression parser.\n  *\n  * @author Juergen Hoeller\n  * @author Phillip Webb\n+ * @author Andy Clement\n  * @since 3.0\n  * @see org.springframework.expression.spel.standard.SpelExpressionParser#SpelExpressionParser(SpelParserConfiguration)\n  */\n@@ -29,10 +33,21 @@ public class SpelParserConfiguration {\n \tprivate final boolean autoGrowNullReferences;\n \n \tprivate final boolean autoGrowCollections;\n+\t\n+\tprivate static SpelCompilerMode defaultCompilerMode = SpelCompilerMode.off;\n+\t\n+\tprivate SpelCompilerMode compilerMode;\n \n \tprivate final int maximumAutoGrowSize;\n \n-\n+\tstatic {\n+\t\tString compilerMode = SpringProperties.getProperty(\"spring.expression.compiler.mode\");\n+\t\tif (compilerMode != null) {\n+\t\t\tdefaultCompilerMode = SpelCompilerMode.valueOf(compilerMode.toLowerCase());\n+\t\t\t// System.out.println(\"SpelCompiler: switched to \"+defaultCompilerMode+\" mode\");\n+\t\t}\n+\t}\n+\t\n \t/**\n \t * Create a new {@link SpelParserConfiguration} instance.\n \t * @param autoGrowNullReferences if null references should automatically grow\n@@ -53,8 +68,22 @@ public SpelParserConfiguration(boolean autoGrowNullReferences, boolean autoGrowC\n \t\tthis.autoGrowNullReferences = autoGrowNullReferences;\n \t\tthis.autoGrowCollections = autoGrowCollections;\n \t\tthis.maximumAutoGrowSize = maximumAutoGrowSize;\n+\t\tthis.compilerMode = defaultCompilerMode;\n+\t}\n+\t\n+\t/**\n+\t * @param compilerMode the compiler mode that parsers using this configuration object should use\n+\t */\n+\tpublic void setCompilerMode(SpelCompilerMode compilerMode) {\n+\t\tthis.compilerMode = compilerMode;\n \t}\n \n+\t/**\n+\t * @return the configuration mode for parsers using this configuration object\n+\t */\n+\tpublic SpelCompilerMode getCompilerMode() {\n+\t\treturn this.compilerMode;\n+\t}\n \n \t/**\n \t * @return {@code true} if {@code null} references should be automatically grown"
        },
        {
            "sha": "abd9f89a827bfd96c156c6e854fe4013cabe8c3e",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/BooleanLiteral.java",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FBooleanLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FBooleanLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FBooleanLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,6 +15,8 @@\n  */\n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -31,12 +33,29 @@ public class BooleanLiteral extends Literal {\n \tpublic BooleanLiteral(String payload, int pos, boolean value) {\n \t\tsuper(payload, pos);\n \t\tthis.value = BooleanTypedValue.forValue(value);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \n \t@Override\n \tpublic BooleanTypedValue getLiteralValue() {\n \t\treturn this.value;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tif (this.value == BooleanTypedValue.TRUE) {\n+\t\t\tmv.visitLdcInsn(1);\t\t\n+\t\t}\n+\t\telse {\n+\t\t\tmv.visitLdcInsn(0);\n+\t\t}\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "7973fe457bf340d4826882eb845a2bde6d74eef6",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/CompoundExpression.java",
            "status": "modified",
            "additions": 36,
            "deletions": 1,
            "changes": 37,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FCompoundExpression.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FCompoundExpression.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FCompoundExpression.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,10 +16,12 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Represents a DOT separated expression sequence, such as 'property1.property2.methodOne()'\n@@ -81,7 +83,15 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException\n \t */\n \t@Override\n \tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n-\t\treturn getValueRef(state).getValue();\n+\t\tValueRef ref = getValueRef(state);\n+\t\tTypedValue result = ref.getValue();\n+\t\tthis.exitTypeDescriptor = this.children[this.children.length-1].getExitDescriptor();\n+\t\treturn result;\n+\t}\n+\t\n+\t@Override\n+\tpublic String getExitDescriptor() {\n+\t\treturn this.exitTypeDescriptor;\n \t}\n \n \t@Override\n@@ -105,5 +115,30 @@ public String toStringAST() {\n \t\t}\n \t\treturn sb.toString();\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tfor (SpelNodeImpl child: children) {\n+\t\t\tif (!child.isCompilable()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv,CodeFlow codeflow) {\t\n+\t\t// TODO could optimize T(SomeType).staticMethod - no need to generate the T() part\n+\t\tfor (int i=0;i<children.length;i++) {\n+\t\t\tSpelNodeImpl child = children[i];\n+\t\t\tif (child instanceof TypeReference && \n+\t\t\t\t(i+1) < children.length && \n+\t\t\t\tchildren[i+1] instanceof MethodReference) {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tchild.generateCode(mv, codeflow);\n+\t\t}\n+\t\tcodeflow.pushDescriptor(this.getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "33bf269084e3573c7b693cf849862997c7d336c2",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/ConstructorReference.java",
            "status": "modified",
            "additions": 58,
            "deletions": 1,
            "changes": 59,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FConstructorReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FConstructorReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FConstructorReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,10 +17,13 @@\n package org.springframework.expression.spel.ast;\n \n import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.List;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n import org.springframework.expression.ConstructorExecutor;\n@@ -34,6 +37,8 @@\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n import org.springframework.expression.spel.SpelNode;\n+import org.springframework.expression.spel.standard.CodeFlow;\n+import org.springframework.expression.spel.support.ReflectiveConstructorExecutor;\n \n /**\n  * Represents the invocation of a constructor. Either a constructor on a regular type or\n@@ -151,6 +156,10 @@ private TypedValue createNewInstance(ExpressionState state) throws EvaluationExc\n \t\texecutorToUse = findExecutorForConstructor(typename, argumentTypes, state);\n \t\ttry {\n \t\t\tthis.cachedExecutor = executorToUse;\n+\t\t\tif (this.cachedExecutor instanceof ReflectiveConstructorExecutor) {\n+\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(((ReflectiveConstructorExecutor)this.cachedExecutor).getConstructor().getDeclaringClass());\n+\t\t\t\t\n+\t\t\t}\n \t\t\treturn executorToUse.execute(state.getEvaluationContext(), arguments);\n \t\t}\n \t\tcatch (AccessException ae) {\n@@ -403,5 +412,53 @@ private void populateIntArray(ExpressionState state, Object newArray, TypeConver\n \tprivate boolean hasInitializer() {\n \t\treturn getChildCount() > 1;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (!(this.cachedExecutor instanceof ReflectiveConstructorExecutor) || \n+\t\t\tthis.exitTypeDescriptor == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (getChildCount() > 1) {\n+\t\t\tfor (int c = 1, max = getChildCount();c < max; c++) {\n+\t\t\t\tif (!children[c].isCompilable()) {\n+\t\t\t\t\treturn false;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tReflectiveConstructorExecutor executor = (ReflectiveConstructorExecutor)this.cachedExecutor;\n+\t\tConstructor<?> constructor = executor.getConstructor();\n+\t\tif (!Modifier.isPublic(constructor.getModifiers()) || \n+\t\t\t!Modifier.isPublic(constructor.getDeclaringClass().getModifiers())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (constructor.isVarArgs()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tReflectiveConstructorExecutor executor = ((ReflectiveConstructorExecutor) this.cachedExecutor);\n+\t\tConstructor<?> constructor = executor.getConstructor();\n+\t\t\n+\t\tString classSlashedDescriptor = constructor.getDeclaringClass().getName().replace('.','/');\n+\t\tString[] paramDescriptors = CodeFlow.toParamDescriptors(constructor);\n+\t\tmv.visitTypeInsn(NEW,classSlashedDescriptor);\n+\t\tmv.visitInsn(DUP);\n+\t\tfor (int c = 1; c < children.length; c++) { // children[0] is the type of the constructor\n+\t\t\tSpelNodeImpl child = children[c];\n+\t\t\tcodeflow.enterCompilationScope();\n+\t\t\tchild.generateCode(mv, codeflow);\n+\t\t\t// Check if need to box it for the method reference?\n+\t\t\tif (CodeFlow.isPrimitive(codeflow.lastDescriptor()) && (paramDescriptors[c-1].charAt(0)=='L')) {\n+\t\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t\t}\n+\t\t\tcodeflow.exitCompilationScope();\n+\t\t}\n+\t\tmv.visitMethodInsn(INVOKESPECIAL,classSlashedDescriptor,\"<init>\",CodeFlow.createSignatureDescriptor(constructor),false);\n+\t\tcodeflow.pushDescriptor(exitTypeDescriptor);\n+\t}\n \n }"
        },
        {
            "sha": "5677fcd73272b4a6d5257abb10c5245e4034dbb1",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Elvis.java",
            "status": "modified",
            "additions": 71,
            "deletions": 2,
            "changes": 73,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FElvis.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FElvis.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FElvis.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,9 +16,12 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Represents the elvis operator ?:. For an expression \"a?:b\" if a is not null, the value\n@@ -49,7 +52,18 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\treturn value;\n \t\t}\n \t\telse {\n-\t\t\treturn this.children[1].getValueInternal(state);\n+\t\t\tTypedValue result = this.children[1].getValueInternal(state);\n+\t\t\tif (exitTypeDescriptor == null) {\n+\t\t\t\tString testDescriptor = this.children[0].exitTypeDescriptor;\n+\t\t\t\tString ifNullDescriptor = this.children[1].exitTypeDescriptor;\n+\t\t\t\tif (testDescriptor.equals(ifNullDescriptor)) {\n+\t\t\t\t\tthis.exitTypeDescriptor = testDescriptor;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"Ljava/lang/Object\";\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\treturn result;\n \t\t}\n \t}\n \n@@ -59,4 +73,59 @@ public String toStringAST() {\n \t\t\t\tgetChild(1).toStringAST()).toString();\n \t}\n \n+\tprivate void computeExitTypeDescriptor() {\n+\t\tif (exitTypeDescriptor == null &&\n+\t\t\t\tthis.children[0].getExitDescriptor()!=null &&\n+\t\t\t\tthis.children[1].getExitDescriptor()!=null) {\n+\t\t\tString conditionDescriptor = this.children[0].exitTypeDescriptor;\n+\t\t\tString ifNullValueDescriptor = this.children[1].exitTypeDescriptor;\n+\t\t\tif (conditionDescriptor.equals(ifNullValueDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = conditionDescriptor;\n+\t\t\t}\n+\t\t\telse if (conditionDescriptor.equals(\"Ljava/lang/Object\") && !CodeFlow.isPrimitive(ifNullValueDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = ifNullValueDescriptor;\n+\t\t\t}\n+\t\t\telse if (ifNullValueDescriptor.equals(\"Ljava/lang/Object\") && !CodeFlow.isPrimitive(conditionDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = conditionDescriptor;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Use the easiest to compute common super type\n+\t\t\t\tthis.exitTypeDescriptor = \"Ljava/lang/Object\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl condition = this.children[0];\n+\t\tSpelNodeImpl ifNullValue = this.children[1];\n+\t\tif (!(condition.isCompilable() && ifNullValue.isCompilable())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn\n+\t\t\tcondition.getExitDescriptor()!=null &&\n+\t\t\tifNullValue.getExitDescriptor()!=null;\n+\t}\n+\n+\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\t// exit type descriptor can be null if both components are literal expressions\n+\t\tcomputeExitTypeDescriptor();\n+\t\tthis.children[0].generateCode(mv, codeflow);\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tmv.visitInsn(DUP);\n+\t\tmv.visitJumpInsn(IFNULL, elseTarget);\n+\t\tmv.visitJumpInsn(GOTO, endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tmv.visitInsn(POP);\n+\t\tthis.children[1].generateCode(mv, codeflow);\n+\t\tif (!CodeFlow.isPrimitive(getExitDescriptor())) {\n+\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t}\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n }"
        },
        {
            "sha": "e11bbf37da83b14c91b6900094546265f7476de7",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/FloatLiteral.java",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFloatLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFloatLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFloatLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,12 +16,15 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents a float literal.\n  *\n  * @author Satyapal Reddy\n+ * @author Andy Clement\n  * @since 3.2\n  */\n public class FloatLiteral extends Literal {\n@@ -31,11 +34,23 @@ public class FloatLiteral extends Literal {\n \tFloatLiteral(String payload, int pos, float value) {\n \t\tsuper(payload, pos);\n \t\tthis.value = new TypedValue(value);\n+\t\tthis.exitTypeDescriptor = \"F\";\n \t}\n \n \n \t@Override\n \tpublic TypedValue getLiteralValue() {\n \t\treturn this.value;\n \t}\n+\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tmv.visitLdcInsn(this.value.getValue());\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n }"
        },
        {
            "sha": "f1e39a6e132c8a5ed44654a91e1f955406839fd4",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/FunctionReference.java",
            "status": "modified",
            "additions": 42,
            "deletions": 3,
            "changes": 45,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFunctionReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFunctionReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FFunctionReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -19,6 +19,7 @@\n import java.lang.reflect.Method;\n import java.lang.reflect.Modifier;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.MethodParameter;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.EvaluationException;\n@@ -27,6 +28,7 @@\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.ReflectionHelper;\n import org.springframework.util.ReflectionUtils;\n \n@@ -48,6 +50,10 @@ public class FunctionReference extends SpelNodeImpl {\n \n \tprivate final String name;\n \n+\t// Captures the most recently used method for the function invocation *if*\n+\t// the method can safely be used for compilation (i.e. no argument conversion is\n+\t// going on)\n+\tprivate Method method;\n \n \tpublic FunctionReference(String functionName, int pos, SpelNodeImpl... arguments) {\n \t\tsuper(pos,arguments);\n@@ -84,6 +90,7 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t * @throws EvaluationException if there is any problem invoking the method\n \t */\n \tprivate TypedValue executeFunctionJLRMethod(ExpressionState state, Method method) throws EvaluationException {\n+\t\tthis.method = null;\n \t\tObject[] functionArgs = getArguments(state);\n \n \t\tif (!method.isVarArgs() && method.getParameterTypes().length != functionArgs.length) {\n@@ -96,11 +103,11 @@ private TypedValue executeFunctionJLRMethod(ExpressionState state, Method method\n \t\t\t\t\tSpelMessage.FUNCTION_MUST_BE_STATIC,\n \t\t\t\t\tmethod.getDeclaringClass().getName() + \".\" + method.getName(), this.name);\n \t\t}\n-\n+\t\tboolean argumentConversionOccurred = false;\n \t\t// Convert arguments if necessary and remap them for varargs if required\n \t\tif (functionArgs != null) {\n \t\t\tTypeConverter converter = state.getEvaluationContext().getTypeConverter();\n-\t\t\tReflectionHelper.convertAllArguments(converter, functionArgs, method);\n+\t\t\targumentConversionOccurred |= ReflectionHelper.convertAllArguments(converter, functionArgs, method);\n \t\t}\n \t\tif (method.isVarArgs()) {\n \t\t\tfunctionArgs = ReflectionHelper.setupArgumentsForVarargsInvocation(\n@@ -110,6 +117,10 @@ private TypedValue executeFunctionJLRMethod(ExpressionState state, Method method\n \t\ttry {\n \t\t\tReflectionUtils.makeAccessible(method);\n \t\t\tObject result = method.invoke(method.getClass(), functionArgs);\n+\t\t\tif (!argumentConversionOccurred) {\n+\t\t\t\tthis.method = method;\n+\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n+\t\t\t}\n \t\t\treturn new TypedValue(result, new TypeDescriptor(new MethodParameter(method,-1)).narrow(result));\n \t\t}\n \t\tcatch (Exception ex) {\n@@ -146,5 +157,33 @@ private Object[] getArguments(ExpressionState state) throws EvaluationException\n \t\t}\n \t\treturn arguments;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\t// Don't yet support non-static method compilation.\n+\t\treturn method!=null && Modifier.isStatic(method.getModifiers());\n+\t}\n+\t\n+\t@Override \n+\tpublic void generateCode(MethodVisitor mv,CodeFlow codeflow) {\n+\t\tString methodDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.','/');\n+\t\tString[] paramDescriptors = CodeFlow.toParamDescriptors(method);\n+\t\tfor (int c = 0; c < children.length; c++) {\n+\t\t\tSpelNodeImpl child = children[c];\n+\t\t\tcodeflow.enterCompilationScope();\n+\t\t\tchild.generateCode(mv, codeflow);\n+\t\t\t// Check if need to box it for the method reference?\n+\t\t\tif (CodeFlow.isPrimitive(codeflow.lastDescriptor()) && (paramDescriptors[c].charAt(0)=='L')) {\n+\t\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t\t}\n+\t\t\telse if (!codeflow.lastDescriptor().equals(paramDescriptors[c])) {\n+\t\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes a Number but passed in is an Integer)\n+\t\t\t\tCodeFlow.insertCheckCast(mv, paramDescriptors[c]);\n+\t\t\t}\n+\t\t\tcodeflow.exitCompilationScope();\n+\t\t}\n+\t\tmv.visitMethodInsn(INVOKESTATIC,methodDeclaringClassSlashedDescriptor,method.getName(),CodeFlow.createSignatureDescriptor(method),false);\n+\t\tcodeflow.pushDescriptor(exitTypeDescriptor);\n+\t}\n \n }"
        },
        {
            "sha": "ad5774a6d3cd72497aa85d86f4fc9d7879befe3a",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Indexer.java",
            "status": "modified",
            "additions": 157,
            "deletions": 3,
            "changes": 160,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIndexer.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIndexer.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIndexer.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,10 +16,15 @@\n \n package org.springframework.expression.spel.ast;\n \n+import java.lang.reflect.Field;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.Collection;\n import java.util.List;\n import java.util.Map;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n import org.springframework.expression.EvaluationContext;\n@@ -30,6 +35,7 @@\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.ReflectivePropertyAccessor;\n \n /**\n@@ -66,6 +72,10 @@ public class Indexer extends SpelNodeImpl {\n \n \tprivate PropertyAccessor cachedWriteAccessor;\n \n+\tprivate static enum IndexedType { map, array, list, string, object; }\n+\t\n+\tprivate IndexedType indexedType;\n+\n \n \tpublic Indexer(int pos, SpelNodeImpl expr) {\n \t\tsuper(pos, expr);\n@@ -122,6 +132,7 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException\n \t\t\tif (targetObjectTypeDescriptor.getMapKeyTypeDescriptor() != null) {\n \t\t\t\tkey = state.convertValue(key, targetObjectTypeDescriptor.getMapKeyTypeDescriptor());\n \t\t\t}\n+\t\t\tthis.indexedType = IndexedType.map;\n \t\t\treturn new MapIndexingValueRef(state.getTypeConverter(), (Map<?, ?>) targetObject, key,\n \t\t\t\t\ttargetObjectTypeDescriptor);\n \t\t}\n@@ -135,28 +146,149 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException\n \t\tif (targetObject.getClass().isArray() || targetObject instanceof Collection || targetObject instanceof String) {\n \t\t\tint idx = (Integer) state.convertValue(index, TypeDescriptor.valueOf(Integer.class));\n \t\t\tif (targetObject.getClass().isArray()) {\n+\t\t\t\tthis.indexedType = IndexedType.array;\n \t\t\t\treturn new ArrayIndexingValueRef(state.getTypeConverter(), targetObject, idx, targetObjectTypeDescriptor);\n \t\t\t}\n \t\t\telse if (targetObject instanceof Collection) {\n+\t\t\t\tif (targetObject instanceof List) {\n+\t\t\t\t\tthis.indexedType = IndexedType.list;\n+\t\t\t\t}\n \t\t\t\treturn new CollectionIndexingValueRef((Collection<?>) targetObject, idx, targetObjectTypeDescriptor,\n \t\t\t\t\t\tstate.getTypeConverter(), state.getConfiguration().isAutoGrowCollections(),\n \t\t\t\t\t\tstate.getConfiguration().getMaximumAutoGrowSize());\n \t\t\t}\n \t\t\telse if (targetObject instanceof String) {\n+\t\t\t\tthis.indexedType = IndexedType.string;\n \t\t\t\treturn new StringIndexingLValue((String) targetObject, idx, targetObjectTypeDescriptor);\n \t\t\t}\n \t\t}\n \n \t\t// Try and treat the index value as a property of the context object\n \t\t// TODO could call the conversion service to convert the value to a String\n \t\tif (indexValue.getTypeDescriptor().getType() == String.class) {\n+\t\t\tthis.indexedType = IndexedType.object;\n \t\t\treturn new PropertyIndexingValueRef(targetObject, (String) indexValue.getValue(),\n \t\t\t\t\tstate.getEvaluationContext(), targetObjectTypeDescriptor);\n \t\t}\n \n \t\tthrow new SpelEvaluationException(getStartPosition(), SpelMessage.INDEXING_NOT_SUPPORTED_FOR_TYPE,\n \t\t\t\ttargetObjectTypeDescriptor.toString());\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (this.indexedType == IndexedType.array) {\n+\t\t\treturn exitTypeDescriptor != null;\n+\t\t}\n+\t\telse if (this.indexedType == IndexedType.list || this.indexedType == IndexedType.map) {\n+\t\t\treturn true;\n+\t\t}\n+\t\telse if (this.indexedType == IndexedType.object) {\n+\t\t\t// If the string name is changing the accessor is clearly going to change (so compilation is not possible)\n+\t\t\tif (this.cachedReadAccessor != null && \n+\t\t\t\t\t(this.cachedReadAccessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor) &&\n+\t\t\t\t\t(getChild(0) instanceof StringLiteral)) {\n+\t\t\t\treturn true;\n+\t\t\t};\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tString s = codeflow.lastDescriptor();\n+\t\t\n+\t\tif (s == null) {\n+\t\t\t// stack is empty, should use context object\n+\t\t\tcodeflow.loadTarget(mv);\n+\t\t}\n+\t\t\n+\t\tif (this.indexedType == IndexedType.array) {\n+\t\t\tif (exitTypeDescriptor == \"I\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[I\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(IALOAD);\n+\t\t\t} \n+\t\t\telse if (exitTypeDescriptor == \"D\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[D\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(DALOAD);\n+\t\t\t}\n+\t\t\telse if (exitTypeDescriptor == \"J\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[J\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(LALOAD);\n+\t\t\t}\n+\t\t\telse if (exitTypeDescriptor == \"F\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[F\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(FALOAD);\n+\t\t\t}\n+\t\t\telse if (exitTypeDescriptor == \"S\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[S\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(SALOAD);\n+\t\t\t}\n+\t\t\telse if (exitTypeDescriptor == \"B\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[B\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(BALOAD);\n+\t\t\t}\n+\t\t\telse if (exitTypeDescriptor == \"C\") {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[C\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(CALOAD);\n+\t\t\t}\n+\t\t\telse { \n+\t\t\t\tmv.visitTypeInsn(CHECKCAST,\"[\"+exitTypeDescriptor+(CodeFlow.isPrimitiveArray(exitTypeDescriptor)?\"\":\";\"));//depthPlusOne(exitTypeDescriptor)+\"Ljava/lang/Object;\");\n+\t\t\t\tSpelNodeImpl index = this.children[0];\n+\t\t\t\tindex.generateCode(mv, codeflow);\n+\t\t\t\tmv.visitInsn(AALOAD);\n+\t\t\t}\n+\t\t}\n+\t\telse if (this.indexedType == IndexedType.list) {\n+\t\t\tmv.visitTypeInsn(CHECKCAST,\"java/util/List\");\n+\t\t\tthis.children[0].generateCode(mv, codeflow);\n+\t\t\tmv.visitMethodInsn(INVOKEINTERFACE,\"java/util/List\",\"get\",\"(I)Ljava/lang/Object;\", true);\n+\t\t\tCodeFlow.insertCheckCast(mv,exitTypeDescriptor);\n+\t\t}\n+\t\telse if (this.indexedType == IndexedType.map) {\n+\t\t\tmv.visitTypeInsn(CHECKCAST,\"java/util/Map\");\n+\t\t\tthis.children[0].generateCode(mv, codeflow);\n+\t\t\tmv.visitMethodInsn(INVOKEINTERFACE,\"java/util/Map\",\"get\",\"(Ljava/lang/Object;)Ljava/lang/Object;\", true);\n+\t\t\tCodeFlow.insertCheckCast(mv,exitTypeDescriptor);\n+\t\t} \n+\t\telse if (this.indexedType == IndexedType.object) {\n+\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor accessor =\n+\t\t\t\t\t(ReflectivePropertyAccessor.OptimalPropertyAccessor)this.cachedReadAccessor;\n+\t\t\tMember member = accessor.member;\n+\t\t\tboolean isStatic = Modifier.isStatic(member.getModifiers());\n+\n+\t\t\tString descriptor = codeflow.lastDescriptor();\n+\t\t\tString memberDeclaringClassSlashedDescriptor = member.getDeclaringClass().getName().replace('.','/');\n+\t\t\tif (!isStatic) {\n+\t\t\t\tif (descriptor == null) {\n+\t\t\t\t\tcodeflow.loadTarget(mv);\n+\t\t\t\t}\n+\t\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n+\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (member instanceof Field) {\n+\t\t\t\tmv.visitFieldInsn(isStatic?GETSTATIC:GETFIELD,memberDeclaringClassSlashedDescriptor,member.getName(),CodeFlow.toJVMDescriptor(((Field) member).getType()));\n+\t\t\t} else {\n+\t\t\t\tmv.visitMethodInsn(isStatic?INVOKESTATIC:INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor, member.getName(),CodeFlow.createSignatureDescriptor((Method)member),false);\n+\t\t\t}\n+\t\t} \n+\t\tcodeflow.pushDescriptor(exitTypeDescriptor);\n+\t}\n \n \t@Override\n \tpublic String toStringAST() {\n@@ -236,47 +368,57 @@ private Object accessArrayElement(Object ctx, int idx) throws SpelEvaluationExce\n \t\tif (arrayComponentType == Integer.TYPE) {\n \t\t\tint[] array = (int[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"I\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Boolean.TYPE) {\n \t\t\tboolean[] array = (boolean[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"Z\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Character.TYPE) {\n \t\t\tchar[] array = (char[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"C\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Long.TYPE) {\n \t\t\tlong[] array = (long[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"J\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Short.TYPE) {\n \t\t\tshort[] array = (short[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"S\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Double.TYPE) {\n \t\t\tdouble[] array = (double[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"D\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Float.TYPE) {\n \t\t\tfloat[] array = (float[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"F\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse if (arrayComponentType == Byte.TYPE) {\n \t\t\tbyte[] array = (byte[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n+\t\t\tthis.exitTypeDescriptor = \"B\";\n \t\t\treturn array[idx];\n \t\t}\n \t\telse {\n \t\t\tObject[] array = (Object[]) ctx;\n \t\t\tcheckAccess(array.length, idx);\n-\t\t\treturn array[idx];\n+\t\t\tObject retValue = array[idx];\n+\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(arrayComponentType);\n+\t\t\treturn retValue;\n \t\t}\n \t}\n \n@@ -327,7 +469,7 @@ public boolean isWritable() {\n \n \n \t@SuppressWarnings({\"rawtypes\", \"unchecked\"})\n-\tprivate static class MapIndexingValueRef implements ValueRef {\n+\tprivate class MapIndexingValueRef implements ValueRef {\n \n \t\tprivate final TypeConverter typeConverter;\n \n@@ -347,6 +489,7 @@ public MapIndexingValueRef(TypeConverter typeConverter, Map map, Object key, Typ\n \t\t@Override\n \t\tpublic TypedValue getValue() {\n \t\t\tObject value = this.map.get(this.key);\n+\t\t\texitTypeDescriptor = CodeFlow.toDescriptorFromObject(value);\n \t\t\treturn new TypedValue(value,\n \t\t\t\t\tthis.mapEntryTypeDescriptor.getMapValueTypeDescriptor(value));\n \t\t}\n@@ -408,7 +551,17 @@ public TypedValue getValue() {\n \t\t\t\t\t\t\tIndexer.this.cachedReadAccessor = accessor;\n \t\t\t\t\t\t\tIndexer.this.cachedReadName = this.name;\n \t\t\t\t\t\t\tIndexer.this.cachedReadTargetType = targetObjectRuntimeClass;\n-\t\t\t\t\t\t\treturn accessor.read(this.evaluationContext, this.targetObject, this.name);\n+\t\t\t\t\t\t\tif (accessor instanceof ReflectivePropertyAccessor.OptimalPropertyAccessor) {\n+\t\t\t\t\t\t\t\tReflectivePropertyAccessor.OptimalPropertyAccessor optimalAccessor = (ReflectivePropertyAccessor.OptimalPropertyAccessor)accessor;\n+\t\t\t\t\t\t\t\tMember member = optimalAccessor.member;\n+\t\t\t\t\t\t\t\tif (member instanceof Field) {\n+\t\t\t\t\t\t\t\t\tIndexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(((Field)member).getType());\n+\t\t\t\t\t\t\t\t} else {\n+\t\t\t\t\t\t\t\t\tIndexer.this.exitTypeDescriptor = CodeFlow.toDescriptor(((Method)member).getReturnType());\n+\t\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\t}\n+\t\t\t\t\t\t\tTypedValue value = accessor.read(this.evaluationContext, this.targetObject, this.name);\n+\t\t\t\t\t\t\treturn value;\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n \t\t\t\t}\n@@ -490,6 +643,7 @@ public TypedValue getValue() {\n \t\t\tgrowCollectionIfNecessary();\n \t\t\tif (this.collection instanceof List) {\n \t\t\t\tObject o = ((List) this.collection).get(this.index);\n+\t\t\t\texitTypeDescriptor = CodeFlow.toDescriptorFromObject(o);\n \t\t\t\treturn new TypedValue(o, this.collectionEntryDescriptor.elementTypeDescriptor(o));\n \t\t\t}\n \t\t\tint pos = 0;"
        },
        {
            "sha": "4e2c77f553adea1202fcb1f7d9b95374e961e957",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/IntLiteral.java",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIntLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIntLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FIntLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,7 +15,9 @@\n  */\n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents an integer literal.\n@@ -27,10 +29,10 @@ public class IntLiteral extends Literal {\n \n \tprivate final TypedValue value;\n \n-\n \tIntLiteral(String payload, int pos, int value) {\n \t\tsuper(payload, pos);\n \t\tthis.value = new TypedValue(value);\n+\t\tthis.exitTypeDescriptor = \"I\";\n \t}\n \n \n@@ -39,4 +41,25 @@ public TypedValue getLiteralValue() {\n \t\treturn this.value;\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tint intValue = ((Integer)this.value.getValue()).intValue();\n+\t\tif (intValue==-1) {\n+\t\t\t// Not sure we can get here because -1 is OpMinus\n+\t\t\tmv.visitInsn(ICONST_M1);\n+\t\t}\n+\t\telse if (intValue >= 0 && intValue < 6) {\n+\t\t\tmv.visitInsn(ICONST_0+intValue);\t\t\t\n+\t\t}\n+\t\telse {\n+\t\t\tmv.visitLdcInsn(intValue);\n+\t\t}\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n }"
        },
        {
            "sha": "6dd102e868a5b7bc1e65937e32d87c484fc06044",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/LongLiteral.java",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FLongLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FLongLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FLongLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,9 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents a long integer literal.\n@@ -32,12 +34,23 @@ public class LongLiteral extends Literal {\n \tLongLiteral(String payload, int pos, long value) {\n \t\tsuper(payload, pos);\n \t\tthis.value = new TypedValue(value);\n+\t\tthis.exitTypeDescriptor = \"J\";\n \t}\n \n-\n \t@Override\n \tpublic TypedValue getLiteralValue() {\n \t\treturn this.value;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tmv.visitLdcInsn(this.value.getValue());\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "cfe1b7109a270d84deffacdf5522250cb120ff53",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java",
            "status": "modified",
            "additions": 91,
            "deletions": 6,
            "changes": 97,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -17,10 +17,13 @@\n package org.springframework.expression.spel.ast;\n \n import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.List;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n import org.springframework.expression.EvaluationContext;\n@@ -32,6 +35,8 @@\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n+import org.springframework.expression.spel.support.ReflectiveMethodExecutor;\n import org.springframework.expression.spel.support.ReflectiveMethodResolver;\n \n /**\n@@ -77,7 +82,18 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\tObject value = state.getActiveContextObject().getValue();\n \t\tTypeDescriptor targetType = state.getActiveContextObject().getTypeDescriptor();\n \t\tObject[] arguments = getArguments(state);\n-\t\treturn getValueInternal(evaluationContext, value, targetType, arguments);\n+\t\tTypedValue result = getValueInternal(evaluationContext, value, targetType, arguments);\n+\t\tif (cachedExecutor.get() instanceof ReflectiveMethodExecutor) {\n+\t\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) cachedExecutor.get();\n+\t\t\tMethod method = executor.getMethod();\n+\t\t\texitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n+\t\t}\n+\t\treturn result;\n+\t}\n+\n+\t@Override\n+\tpublic String getExitDescriptor() {\n+\t\treturn exitTypeDescriptor;\n \t}\n \n \tprivate TypedValue getValueInternal(EvaluationContext evaluationContext,\n@@ -161,9 +177,7 @@ private List<TypeDescriptor> getArgumentTypes(Object... arguments) {\n \t\treturn Collections.unmodifiableList(descriptors);\n \t}\n \n-\tprivate MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value,\n-\t\t\tTypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n-\n+\tprivate MethodExecutor getCachedExecutor(EvaluationContext evaluationContext, Object value, TypeDescriptor target, List<TypeDescriptor> argumentTypes) {\n \t\tList<MethodResolver> methodResolvers = evaluationContext.getMethodResolvers();\n \t\tif (methodResolvers == null || methodResolvers.size() != 1 ||\n \t\t\t\t!(methodResolvers.get(0) instanceof ReflectiveMethodResolver)) {\n@@ -255,7 +269,13 @@ public MethodValueRef(ExpressionState state, Object[] arguments) {\n \n \t\t@Override\n \t\tpublic TypedValue getValue() {\n-\t\t\treturn getValueInternal(this.evaluationContext, this.value, this.targetType, this.arguments);\n+\t\t\tTypedValue result = MethodReference.this.getValueInternal(this.evaluationContext, this.value, this.targetType, this.arguments);\n+\t\t\tif (MethodReference.this.cachedExecutor.get() instanceof ReflectiveMethodExecutor) {\n+\t\t\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) MethodReference.this.cachedExecutor.get();\n+\t\t\t\tMethod method = executor.getMethod();\n+\t\t\t\tMethodReference.this.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n+\t\t\t}\n+\t\t\treturn result;\n \t\t}\n \n \t\t@Override\n@@ -298,4 +318,69 @@ public MethodExecutor get() {\n \t\t}\n \t}\n \n+\t/**\n+\t * A method reference is compilable if it has been resolved to a reflectively accessible method\n+\t * and the child nodes (arguments to the method) are also compilable.\n+\t */\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (this.cachedExecutor == null || !(this.cachedExecutor.get() instanceof ReflectiveMethodExecutor)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tfor (SpelNodeImpl child: children) {\n+\t\t\tif (!child.isCompilable()) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) this.cachedExecutor.get();\n+\t\tMethod method = executor.getMethod();\n+\t\tif (!Modifier.isPublic(method.getModifiers()) || !Modifier.isPublic(method.getDeclaringClass().getModifiers())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (method.isVarArgs()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (executor.didArgumentConversionOccur()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn true;\n+\t}\n+\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv,CodeFlow codeflow) {\n+\t\tReflectiveMethodExecutor executor = (ReflectiveMethodExecutor) this.cachedExecutor.get();\n+\t\tMethod method = executor.getMethod();\n+\t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n+\t\tString descriptor = codeflow.lastDescriptor();\n+\n+\t\tif (descriptor == null && !isStaticMethod) {\n+\t\t\tcodeflow.loadTarget(mv);\n+\t\t}\n+\n+\t\tboolean itf = method.getDeclaringClass().isInterface();\n+\t\tString methodDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.','/');\n+\t\tif (!isStaticMethod) {\n+\t\t\tif (descriptor == null || !descriptor.equals(method.getDeclaringClass())) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, method.getDeclaringClass().getName().replace('.','/'));\n+\t\t\t}\n+\t\t}\n+\t\tString[] paramDescriptors = CodeFlow.toParamDescriptors(method);\n+\t\tfor (int c=0;c<children.length;c++) {\n+\t\t\tSpelNodeImpl child = children[c];\n+\t\t\tcodeflow.enterCompilationScope();\n+\t\t\tchild.generateCode(mv, codeflow);\n+\t\t\t// Check if need to box it for the method reference?\n+\t\t\tif (CodeFlow.isPrimitive(codeflow.lastDescriptor()) && (paramDescriptors[c].charAt(0)=='L')) {\n+\t\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t\t}\n+\t\t\telse if (!codeflow.lastDescriptor().equals(paramDescriptors[c])) {\n+\t\t\t\t// This would be unnecessary in the case of subtyping (e.g. method takes a Number but passed in is an Integer)\n+\t\t\t\tCodeFlow.insertCheckCast(mv, paramDescriptors[c]);\n+\t\t\t}\n+\t\t\tcodeflow.exitCompilationScope();\n+\t\t}\n+\t\tmv.visitMethodInsn(isStaticMethod?INVOKESTATIC:INVOKEVIRTUAL,methodDeclaringClassSlashedDescriptor,method.getName(),CodeFlow.createSignatureDescriptor(method), itf);\n+\t\tcodeflow.pushDescriptor(exitTypeDescriptor);\n+\t}\n+\n }"
        },
        {
            "sha": "483665d5fc28fd7e730e99ddaa26bf22da1754b5",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/NullLiteral.java",
            "status": "modified",
            "additions": 15,
            "deletions": 1,
            "changes": 16,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FNullLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FNullLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FNullLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,9 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents null.\n@@ -28,6 +30,7 @@ public class NullLiteral extends Literal {\n \n \tpublic NullLiteral(int pos) {\n \t\tsuper(null,pos);\n+\t\tthis.exitTypeDescriptor = \"Ljava/lang/Object\";\n \t}\n \n \n@@ -41,4 +44,15 @@ public String toString() {\n \t\treturn \"null\";\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tmv.visitInsn(ACONST_NULL);\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n }"
        },
        {
            "sha": "fb2a6daefc8e90762af042f5ea3643a45b830a59",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpAnd.java",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpAnd.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpAnd.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpAnd.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,11 +16,14 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -35,6 +38,7 @@ public class OpAnd extends Operator {\n \n \tpublic OpAnd(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"and\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \n@@ -65,4 +69,37 @@ private void assertValueNotNull(Boolean value) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl left = getLeftOperand();\n+\t\tSpelNodeImpl right= getRightOperand();\n+\t\tif (!left.isCompilable() || !right.isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn\n+\t\t\tCodeFlow.isBooleanCompatible(left.getExitDescriptor()) &&\n+\t\t\tCodeFlow.isBooleanCompatible(right.getExitDescriptor());\t\t\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\t// pseudo: if (!leftOperandValue) { result=false; } else { result=rightOperandValue; }\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tcodeflow.enterCompilationScope();\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tcodeflow.unboxBooleanIfNecessary(mv);\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitJumpInsn(IFNE, elseTarget);\n+\t\tmv.visitLdcInsn(0); // FALSE\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tcodeflow.enterCompilationScope();\n+\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\tcodeflow.unboxBooleanIfNecessary(mv);\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(this.exitTypeDescriptor);\n+\t}\n+\n }"
        },
        {
            "sha": "2b144e30b10010599d162f957690d5f3bc4c359d",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpDivide.java",
            "status": "modified",
            "additions": 68,
            "deletions": 6,
            "changes": 74,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpDivide.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpDivide.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpDivide.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,13 +16,16 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+\n import java.math.BigDecimal;\n import java.math.RoundingMode;\n \n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.Operation;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.util.NumberUtils;\n \n /**\n@@ -58,20 +61,79 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Double || rightNumber instanceof Double) {\n+\t\t\t\tif (leftNumber instanceof Double && rightNumber instanceof Double) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"D\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.doubleValue() / rightNumber.doubleValue());\n \t\t\t}\n-\t\t\tif (leftNumber instanceof Float || rightNumber instanceof Float) {\n+\t\t\telse if (leftNumber instanceof Float || rightNumber instanceof Float) {\n+\t\t\t\tif (leftNumber instanceof Float && rightNumber instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.floatValue() / rightNumber.floatValue());\n \t\t\t}\n-\t\t\tif (leftNumber instanceof Long || rightNumber instanceof Long) {\n+\t\t\telse if (leftNumber instanceof Long || rightNumber instanceof Long) {\n+\t\t\t\tif (leftNumber instanceof Long && rightNumber instanceof Long) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"J\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.longValue() / rightNumber.longValue());\n \t\t\t}\n-\n-\t\t\t// TODO what about non-int result of the division?\n-\t\t\treturn new TypedValue(leftNumber.intValue() / rightNumber.intValue());\n+\t\t\telse {\n+\t\t\t\tif (leftNumber instanceof Integer && rightNumber instanceof Integer) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"I\";\n+\t\t\t\t}\n+\t\t\t\t// TODO what about non-int result of the division?\n+\t\t\t\treturn new TypedValue(leftNumber.intValue() / rightNumber.intValue());\n+\t\t\t}\n \t\t}\n \n \t\treturn state.operate(Operation.DIVIDE, leftOperand, rightOperand);\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (!getLeftOperand().isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\t if (!getRightOperand().isCompilable()) {\n+\t\t\t\t return false;\n+\t\t\t }\n+\t\t}\n+\t\treturn this.exitTypeDescriptor!=null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tString leftdesc = getLeftOperand().getExitDescriptor();\n+\t\tif (!CodeFlow.isPrimitive(leftdesc)) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t}\n+\t\tif (this.children.length > 1) {\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tString rightdesc = getRightOperand().getExitDescriptor();\n+\t\t\tif (!CodeFlow.isPrimitive(rightdesc)) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t\t}\n+\t\t\tswitch (this.exitTypeDescriptor.charAt(0)) {\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tmv.visitInsn(IDIV);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'J':\n+\t\t\t\t\tmv.visitInsn(LDIV);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'F': \n+\t\t\t\t\tmv.visitInsn(FDIV);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'D':\n+\t\t\t\t\tmv.visitInsn(DDIV);\n+\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalStateException(\"Unrecognized exit descriptor: '\"+this.exitTypeDescriptor+\"'\");\t\t\t\n+\t\t\t}\n+\t\t}\n+\t\tcodeflow.pushDescriptor(this.exitTypeDescriptor);\n+\t}\n \n }"
        },
        {
            "sha": "a3aa5dcc6f573b6743f78e9db48bfb468ccdecaa",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpEQ.java",
            "status": "modified",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpEQ.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpEQ.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpEQ.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,8 +16,11 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -30,6 +33,7 @@ public class OpEQ extends Operator {\n \n \tpublic OpEQ(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"==\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \t@Override\n@@ -38,5 +42,100 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \t\tObject right = getRightOperand().getValueInternal(state).getValue();\n \t\treturn BooleanTypedValue.forValue(equalityCheck(state, left, right));\n \t}\n+\t\n+\t// This check is different to the one in the other numeric operators (OpLt/etc)\n+\t// because it allows for simple object comparison\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl left = getLeftOperand();\n+\t\tSpelNodeImpl right= getRightOperand();\n+\t\tif (!left.isCompilable() || !right.isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tString leftdesc = left.getExitDescriptor();\n+\t\tString rightdesc = right.getExitDescriptor();\n+\t\tif ((CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(leftdesc) ||\n+\t\t\t\tCodeFlow.isPrimitiveOrUnboxableSupportedNumber(rightdesc))) {\n+\t\t\tif (!CodeFlow.areBoxingCompatible(leftdesc, rightdesc)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tString leftDesc = getLeftOperand().getExitDescriptor();\n+\t\tString rightDesc = getRightOperand().getExitDescriptor();\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tboolean leftPrim = CodeFlow.isPrimitive(leftDesc);\n+\t\tboolean rightPrim = CodeFlow.isPrimitive(rightDesc);\n+\n+\t\tif ((CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(leftDesc) || \n+\t\t\t CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rightDesc)) && \n+\t\t\t CodeFlow.areBoxingCompatible(leftDesc,rightDesc)) {\n+\t\t\tchar targetType = CodeFlow.toPrimitiveTargetDesc(leftDesc);\n+\t\t\t\n+\t\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\t\tif (!leftPrim) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t\t}\n+\t\t\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tif (!rightPrim) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t\t}\n+\t\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n+\t\t\tif (targetType=='D') {\n+\t\t\t\tmv.visitInsn(DCMPL);\n+\t\t\t\tmv.visitJumpInsn(IFNE, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType=='F') {\n+\t\t\t\tmv.visitInsn(FCMPL);\t\t\n+\t\t\t\tmv.visitJumpInsn(IFNE, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType=='J') {\n+\t\t\t\tmv.visitInsn(LCMP);\t\t\n+\t\t\t\tmv.visitJumpInsn(IFNE, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType=='I' || targetType=='Z') {\n+\t\t\t\tmv.visitJumpInsn(IF_ICMPNE, elseTarget);\t\t\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \"+leftDesc);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tLabel leftNotNull = new Label();\n+\t\t\tmv.visitInsn(DUP_X1); // Dup right on the top of the stack\n+\t\t\tmv.visitJumpInsn(IFNONNULL,leftNotNull);\n+\t\t\t\t// Right is null!\n+\t\t\t\tmv.visitInsn(SWAP);\n+\t\t\t\tmv.visitInsn(POP); // remove it\n+\t\t\t\tLabel rightNotNull = new Label();\n+\t\t\t\tmv.visitJumpInsn(IFNONNULL, rightNotNull);\n+\t\t\t\t\t// Left is null too\n+\t\t\t\t\tmv.visitInsn(ICONST_1);\n+\t\t\t\tmv.visitJumpInsn(GOTO, endOfIf);\n+\t\t\t\t\tmv.visitLabel(rightNotNull);\n+\t\t\t\t\tmv.visitInsn(ICONST_0);\n+\t\t\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\t\t\n+\t\t\t\n+\t\t\tmv.visitLabel(leftNotNull);\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL,\"java/lang/Object\",\"equals\",\"(Ljava/lang/Object;)Z\",false);\n+\t\t\tmv.visitLabel(endOfIf);\n+\t\t\tcodeflow.pushDescriptor(\"Z\");\n+\t\t\treturn;\n+\t\t}\n+\t\tmv.visitInsn(ICONST_1);\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tmv.visitInsn(ICONST_0);\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(\"Z\");\n+\t}\n \n }"
        },
        {
            "sha": "48b43df71883c2731b34ee1511e643612e3e73ee",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpGE.java",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGE.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGE.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGE.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -15,10 +15,11 @@\n  */\n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import java.math.BigDecimal;\n-\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n import org.springframework.util.NumberUtils;\n \n@@ -34,6 +35,7 @@ public class OpGE extends Operator {\n \n \tpublic OpGE(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\">=\", pos, operands);\n+\t\tthis.exitTypeDescriptor=\"Z\";\n \t}\n \n \n@@ -66,5 +68,15 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \t\t}\n \t\treturn BooleanTypedValue.forValue(state.getTypeComparator().compare(left, right) >= 0);\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn isCompilableOperatorUsingNumerics();\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgenerateComparisonCode(mv, codeflow, IFLT, IF_ICMPLT);\n+\t}\n \n }"
        },
        {
            "sha": "2780ba96e883fd935f41fea8e5219126a368075f",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpGT.java",
            "status": "modified",
            "additions": 12,
            "deletions": 1,
            "changes": 13,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGT.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGT.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpGT.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,10 +16,11 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import java.math.BigDecimal;\n-\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n import org.springframework.util.NumberUtils;\n \n@@ -35,6 +36,7 @@ public class OpGT extends Operator {\n \n \tpublic OpGT(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\">\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \t@Override\n@@ -75,4 +77,13 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \t\treturn BooleanTypedValue.forValue(state.getTypeComparator().compare(left, right) > 0);\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn isCompilableOperatorUsingNumerics();\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgenerateComparisonCode(mv, codeflow, IFLE, IF_ICMPLE);\n+\t}\n }"
        },
        {
            "sha": "98fd4ecbbec7ac87f53d70343ddb5ee54ab17a25",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpLE.java",
            "status": "modified",
            "additions": 14,
            "deletions": 2,
            "changes": 16,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLE.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLE.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLE.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,10 +16,11 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import java.math.BigDecimal;\n-\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n import org.springframework.util.NumberUtils;\n \n@@ -35,6 +36,7 @@ public class OpLE extends Operator {\n \n \tpublic OpLE(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"<=\", pos, operands);\n+\t\tthis.exitTypeDescriptor=\"Z\";\n \t}\n \n \n@@ -70,5 +72,15 @@ public BooleanTypedValue getValueInternal(ExpressionState state)\n \n \t\treturn BooleanTypedValue.forValue(state.getTypeComparator().compare(left, right) <= 0);\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn isCompilableOperatorUsingNumerics();\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgenerateComparisonCode(mv, codeflow, IFGT, IF_ICMPGT);\t\t\t\n+\t}\n \n }"
        },
        {
            "sha": "ee36f1320fedf2c962a3af06774ba8b60b046515",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpLT.java",
            "status": "modified",
            "additions": 13,
            "deletions": 1,
            "changes": 14,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLT.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLT.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpLT.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,10 +16,11 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import java.math.BigDecimal;\n-\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n import org.springframework.util.NumberUtils;\n \n@@ -35,6 +36,7 @@ public class OpLT extends Operator {\n \n \tpublic OpLT(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"<\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \t@Override\n@@ -74,5 +76,15 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \n \t\treturn BooleanTypedValue.forValue(state.getTypeComparator().compare(left, right) < 0);\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn isCompilableOperatorUsingNumerics();\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgenerateComparisonCode(mv, codeflow, IFGE, IF_ICMPGE);\t\t\t\t\t\t\t\n+\t}\n \n }"
        },
        {
            "sha": "acbc5deca0c8932c7755d74f88856141781bc509",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpMinus.java",
            "status": "modified",
            "additions": 83,
            "deletions": 4,
            "changes": 87,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMinus.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMinus.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMinus.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,12 +16,15 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+\n import java.math.BigDecimal;\n \n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.Operation;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.util.NumberUtils;\n \n /**\n@@ -67,17 +70,20 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t\t}\n \n \t\t\t\tif (operand instanceof Double) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"D\";\n \t\t\t\t\treturn new TypedValue(0 - n.doubleValue());\n \t\t\t\t}\n \n \t\t\t\tif (operand instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n \t\t\t\t\treturn new TypedValue(0 - n.floatValue());\n \t\t\t\t}\n \n \t\t\t\tif (operand instanceof Long) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"J\";\n \t\t\t\t\treturn new TypedValue(0 - n.longValue());\n \t\t\t\t}\n-\n+\t\t\t\tthis.exitTypeDescriptor = \"I\";\n \t\t\t\treturn new TypedValue(0 - n.intValue());\n \t\t\t}\n \n@@ -96,19 +102,28 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n \t\t\t\treturn new TypedValue(leftBigDecimal.subtract(rightBigDecimal));\n \t\t\t}\n-\n+\t\t\t\n \t\t\tif (leftNumber instanceof Double || rightNumber instanceof Double) {\n+\t\t\t\tif (leftNumber instanceof Double && rightNumber instanceof Double) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"D\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.doubleValue() - rightNumber.doubleValue());\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Float || rightNumber instanceof Float) {\n+\t\t\t\tif (leftNumber instanceof Float && rightNumber instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.floatValue() - rightNumber.floatValue());\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Long || rightNumber instanceof Long) {\n+\t\t\t\tif (leftNumber instanceof Long && rightNumber instanceof Long) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"J\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.longValue() - rightNumber.longValue());\n \t\t\t}\n-\n+\t\t\tthis.exitTypeDescriptor = \"I\";\n \t\t\treturn new TypedValue(leftNumber.intValue() - rightNumber.intValue());\n \t\t}\n \t\telse if (left instanceof String && right instanceof Integer\n@@ -130,10 +145,74 @@ public String toStringAST() {\n \t\t}\n \t\treturn super.toStringAST();\n \t}\n+\n \t@Override\n \tpublic SpelNodeImpl getRightOperand() {\n \t\tif (this.children.length<2) {return null;}\n \t\treturn this.children[1];\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (!getLeftOperand().isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\t if (!getRightOperand().isCompilable()) {\n+\t\t\t\t return false;\n+\t\t\t }\n+\t\t}\n+\t\treturn this.exitTypeDescriptor!=null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tString leftdesc = getLeftOperand().getExitDescriptor();\n+\t\tif (!CodeFlow.isPrimitive(leftdesc)) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t}\t\n+\t\tif (this.children.length>1) {\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tString rightdesc = getRightOperand().getExitDescriptor();\n+\t\t\tif (!CodeFlow.isPrimitive(rightdesc)) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t\t}\n+\t\t\tswitch (this.exitTypeDescriptor.charAt(0)) {\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tmv.visitInsn(ISUB);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'J':\n+\t\t\t\t\tmv.visitInsn(LSUB);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'F': \n+\t\t\t\t\tmv.visitInsn(FSUB);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'D':\n+\t\t\t\t\tmv.visitInsn(DSUB);\n+\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalStateException(\"Unrecognized exit descriptor: '\"+this.exitTypeDescriptor+\"'\");\n+\t\t\t}\n+\t\t} else {\n+\t\t\tswitch (this.exitTypeDescriptor.charAt(0)) {\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tmv.visitInsn(INEG);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'J':\n+\t\t\t\t\tmv.visitInsn(LNEG);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'F': \n+\t\t\t\t\tmv.visitInsn(FNEG);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'D':\n+\t\t\t\t\tmv.visitInsn(DNEG);\n+\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalStateException(\"Unrecognized exit descriptor: '\"+this.exitTypeDescriptor+\"'\");\n+\t\t\t}\t\t\t\n+\t\t}\n+\t\tcodeflow.pushDescriptor(this.exitTypeDescriptor);\n+\t}\n \n }"
        },
        {
            "sha": "ff0c967d2df724cd33c02e79f705b9e296ab391e",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpMultiply.java",
            "status": "modified",
            "additions": 64,
            "deletions": 3,
            "changes": 67,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMultiply.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMultiply.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpMultiply.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,12 +16,15 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+\n import java.math.BigDecimal;\n \n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.Operation;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.util.NumberUtils;\n \n /**\n@@ -81,17 +84,29 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Double || rightNumber instanceof Double) {\n-\t\t\t\treturn new TypedValue(leftNumber.doubleValue() * rightNumber.doubleValue());\n+\t\t\t\tif (leftNumber instanceof Double && rightNumber instanceof Double) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"D\";\n+\t\t\t\t}\n+\t\t\t\treturn new TypedValue(leftNumber.doubleValue()\n+\t\t\t\t\t\t* rightNumber.doubleValue());\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Float || rightNumber instanceof Float) {\n+\t\t\t\tif (leftNumber instanceof Float && rightNumber instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.floatValue() * rightNumber.floatValue());\n \t\t\t}\n \n \t\t\tif (leftNumber instanceof Long || rightNumber instanceof Long) {\n+\t\t\t\tif (leftNumber instanceof Long && rightNumber instanceof Long) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"J\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.longValue() * rightNumber.longValue());\n \t\t\t}\n-\n+\t\t\tif (leftNumber instanceof Integer && rightNumber instanceof Integer) {\n+\t\t\t\tthis.exitTypeDescriptor = \"I\";\n+\t\t\t}\n \t\t\treturn new TypedValue(leftNumber.intValue() * rightNumber.intValue());\n \t\t}\n \t\telse if (leftOperand instanceof String && rightOperand instanceof Integer) {\n@@ -105,5 +120,51 @@ else if (leftOperand instanceof String && rightOperand instanceof Integer) {\n \n \t\treturn state.operate(Operation.MULTIPLY, leftOperand, rightOperand);\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (!getLeftOperand().isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\t if (!getRightOperand().isCompilable()) {\n+\t\t\t\t return false;\n+\t\t\t }\n+\t\t}\n+\t\treturn this.exitTypeDescriptor!=null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tString leftdesc = getLeftOperand().getExitDescriptor();\n+\t\tif (!CodeFlow.isPrimitive(leftdesc)) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tString rightdesc = getRightOperand().getExitDescriptor();\n+\t\t\tif (!CodeFlow.isPrimitive(rightdesc)) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t\t}\n+\t\t\tswitch (this.exitTypeDescriptor.charAt(0)) {\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tmv.visitInsn(IMUL);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'J':\n+\t\t\t\t\tmv.visitInsn(LMUL);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'F': \n+\t\t\t\t\tmv.visitInsn(FMUL);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'D':\n+\t\t\t\t\tmv.visitInsn(DMUL);\n+\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalStateException(\"Unrecognized exit descriptor: '\"+this.exitTypeDescriptor+\"'\");\t\t\t\n+\t\t\t}\n+\t\t}\n+\t\tcodeflow.pushDescriptor(this.exitTypeDescriptor);\n+\t}\n \n }"
        },
        {
            "sha": "7af16b550fc0ea71355d5e0cc955c41cbcedcd79",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpNE.java",
            "status": "modified",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpNE.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpNE.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpNE.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,8 +16,11 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -30,6 +33,7 @@ public class OpNE extends Operator {\n \n \tpublic OpNE(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"!=\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \t@Override\n@@ -39,4 +43,79 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \t\treturn BooleanTypedValue.forValue(!equalityCheck(state, left, right));\n \t}\n \n+\t// This check is different to the one in the other numeric operators (OpLt/etc)\n+\t// because we allow simple object comparison\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl left = getLeftOperand();\n+\t\tSpelNodeImpl right= getRightOperand();\n+\t\tif (!left.isCompilable() || !right.isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tString leftdesc = left.getExitDescriptor();\n+\t\tString rightdesc = right.getExitDescriptor();\n+\t\tif ((CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(leftdesc) ||\n+\t\t\t\tCodeFlow.isPrimitiveOrUnboxableSupportedNumber(rightdesc))) {\n+\t\t\tif (!CodeFlow.areBoxingCompatible(leftdesc, rightdesc)) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t}\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tString leftDesc = getLeftOperand().getExitDescriptor();\n+\t\tString rightDesc = getRightOperand().getExitDescriptor();\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tboolean leftPrim = CodeFlow.isPrimitive(leftDesc);\n+\t\tboolean rightPrim = CodeFlow.isPrimitive(rightDesc);\n+\n+\t\tif ((CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(leftDesc) || \n+\t\t\t CodeFlow.isPrimitiveOrUnboxableSupportedNumberOrBoolean(rightDesc)) && \n+\t\t\t CodeFlow.areBoxingCompatible(leftDesc,rightDesc)) {\n+\t\t\tchar targetType = CodeFlow.toPrimitiveTargetDesc(leftDesc);\n+\t\t\t\n+\t\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\t\tif (!leftPrim) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t\t}\n+\t\t\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tif (!rightPrim) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t\t}\n+\t\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n+\t\t\tif (targetType == 'D') {\n+\t\t\t\tmv.visitInsn(DCMPL);\n+\t\t\t\tmv.visitJumpInsn(IFEQ, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType == 'F') {\n+\t\t\t\tmv.visitInsn(FCMPL);\t\t\n+\t\t\t\tmv.visitJumpInsn(IFEQ, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType == 'J') {\n+\t\t\t\tmv.visitInsn(LCMP);\t\t\n+\t\t\t\tmv.visitJumpInsn(IFEQ, elseTarget);\n+\t\t\t}\n+\t\t\telse if (targetType == 'I' || targetType == 'Z') {\n+\t\t\t\tmv.visitJumpInsn(IF_ICMPEQ, elseTarget);\t\t\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \"+leftDesc);\n+\t\t\t}\n+\t\t} else {\n+\t\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tmv.visitJumpInsn(IF_ACMPEQ, elseTarget);\n+\t\t}\n+\t\tmv.visitInsn(ICONST_1);\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tmv.visitInsn(ICONST_0);\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(\"Z\");\n+\t}\n+\n }"
        },
        {
            "sha": "b7213c374fb5ce222301882583592cf70feb9e0e",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpOr.java",
            "status": "modified",
            "additions": 38,
            "deletions": 1,
            "changes": 39,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpOr.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpOr.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpOr.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,10 +16,13 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -34,6 +37,7 @@ public class OpOr extends Operator {\n \n \tpublic OpOr(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"or\", pos, operands);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \n@@ -64,4 +68,37 @@ private void assertValueNotNull(Boolean value) {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl left = getLeftOperand();\n+\t\tSpelNodeImpl right= getRightOperand();\n+\t\tif (!left.isCompilable() || !right.isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn\n+\t\t\t\tCodeFlow.isBooleanCompatible(left.getExitDescriptor()) &&\n+\t\t\t\tCodeFlow.isBooleanCompatible(right.getExitDescriptor());\t\t\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\t// pseudo: if (leftOperandValue) { result=true; } else { result=rightOperandValue; }\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tcodeflow.enterCompilationScope();\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tcodeflow.unboxBooleanIfNecessary(mv);\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitJumpInsn(IFEQ, elseTarget);\n+\t\tmv.visitLdcInsn(1); // TRUE\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tcodeflow.enterCompilationScope();\n+\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\tcodeflow.unboxBooleanIfNecessary(mv);\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\t\n }"
        },
        {
            "sha": "74a8ad93da1ed851422f226a9412797605c6976f",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OpPlus.java",
            "status": "modified",
            "additions": 65,
            "deletions": 4,
            "changes": 69,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpPlus.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpPlus.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOpPlus.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,6 +16,8 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+\n import java.math.BigDecimal;\n \n import org.springframework.core.convert.TypeDescriptor;\n@@ -24,6 +26,7 @@\n import org.springframework.expression.TypeConverter;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.util.Assert;\n import org.springframework.util.NumberUtils;\n \n@@ -63,11 +66,16 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\tObject operandOne = leftOp.getValueInternal(state).getValue();\n \t\t\tif (operandOne instanceof Number) {\n \t\t\t\tif (operandOne instanceof Double || operandOne instanceof Long || operandOne instanceof BigDecimal) {\n+\t\t\t\t\tif (operandOne instanceof Double || operandOne instanceof Long) {\n+\t\t\t\t\t\tthis.exitTypeDescriptor = (operandOne instanceof Double)?\"D\":\"J\";\n+\t\t\t\t\t}\n \t\t\t\t\treturn new TypedValue(operandOne);\n \t\t\t\t}\n \t\t\t\tif (operandOne instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n \t\t\t\t\treturn new TypedValue(((Number) operandOne).floatValue());\n \t\t\t\t}\n+\t\t\t\tthis.exitTypeDescriptor = \"I\";\n \t\t\t\treturn new TypedValue(((Number) operandOne).intValue());\n \t\t\t}\n \t\t\treturn state.operate(Operation.ADD, operandOne, null);\n@@ -88,20 +96,27 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t\tBigDecimal rightBigDecimal = NumberUtils.convertNumberToTargetClass(rightNumber, BigDecimal.class);\n \t\t\t\treturn new TypedValue(leftBigDecimal.add(rightBigDecimal));\n \t\t\t}\n-\n \t\t\tif (leftNumber instanceof Double || rightNumber instanceof Double) {\n+\t\t\t\tif (leftNumber instanceof Double && rightNumber instanceof Double) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"D\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.doubleValue() + rightNumber.doubleValue());\n \t\t\t}\n-\n \t\t\tif (leftNumber instanceof Float || rightNumber instanceof Float) {\n+\t\t\t\tif (leftNumber instanceof Float && rightNumber instanceof Float) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"F\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.floatValue() + rightNumber.floatValue());\n \t\t\t}\n-\n \t\t\tif (leftNumber instanceof Long || rightNumber instanceof Long) {\n+\t\t\t\tif (leftNumber instanceof Long && rightNumber instanceof Long) {\n+\t\t\t\t\tthis.exitTypeDescriptor = \"J\";\n+\t\t\t\t}\n \t\t\t\treturn new TypedValue(leftNumber.longValue() + rightNumber.longValue());\n \t\t\t}\n \n \t\t\t// TODO what about overflow?\n+\t\t\tthis.exitTypeDescriptor = \"I\";\n \t\t\treturn new TypedValue(leftNumber.intValue() + rightNumber.intValue());\n \t\t}\n \n@@ -164,4 +179,50 @@ private static String convertTypedValueToString(TypedValue value, ExpressionStat\n \t\treturn String.valueOf(value.getValue());\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (!getLeftOperand().isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\t if (!getRightOperand().isCompilable()) {\n+\t\t\t\t return false;\n+\t\t\t }\n+\t\t}\n+\t\treturn this.exitTypeDescriptor!=null;\n+\t}\n+\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tString leftdesc = getLeftOperand().getExitDescriptor();\n+\t\tif (!CodeFlow.isPrimitive(leftdesc)) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t}\n+\t\tif (this.children.length>1) {\n+\t\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\t\tString rightdesc = getRightOperand().getExitDescriptor();\n+\t\t\tif (!CodeFlow.isPrimitive(rightdesc)) {\n+\t\t\t\tCodeFlow.insertUnboxInsns(mv, this.exitTypeDescriptor.charAt(0), false);\n+\t\t\t}\n+\t\t\tswitch (this.exitTypeDescriptor.charAt(0)) {\n+\t\t\t\tcase 'I':\n+\t\t\t\t\tmv.visitInsn(IADD);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'J':\n+\t\t\t\t\tmv.visitInsn(LADD);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'F': \n+\t\t\t\t\tmv.visitInsn(FADD);\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 'D':\n+\t\t\t\t\tmv.visitInsn(DADD);\n+\t\t\t\t\tbreak;\t\t\t\t\n+\t\t\t\tdefault:\n+\t\t\t\t\tthrow new IllegalStateException(\"Unrecognized exit descriptor: '\"+this.exitTypeDescriptor+\"'\");\t\t\t\n+\t\t\t}\n+\t\t}\n+\t\tcodeflow.pushDescriptor(this.exitTypeDescriptor);\n+\t}\n+\n }"
        },
        {
            "sha": "0e7bd63f67a13528b6c736068fce62f251b0b1c8",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Operator.java",
            "status": "modified",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperator.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperator.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperator.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,6 +16,10 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.expression.spel.standard.CodeFlow;\n+\n import java.math.BigDecimal;\n \n import org.springframework.expression.spel.ExpressionState;\n@@ -72,6 +76,74 @@ public String toStringAST() {\n \t\treturn sb.toString();\n \t}\n \n+\tprotected boolean isCompilableOperatorUsingNumerics() {\n+\t\tSpelNodeImpl left = getLeftOperand();\n+\t\tSpelNodeImpl right= getRightOperand();\n+\t\tif (!left.isCompilable() || !right.isCompilable()) {\n+\t\t\treturn false;\n+\t\t}\n+\t\t// Supported operand types for equals (at the moment)\n+\t\tString leftDesc = left.getExitDescriptor();\n+\t\tString rightDesc= right.getExitDescriptor();\n+\t\tif (CodeFlow.isPrimitiveOrUnboxableSupportedNumber(leftDesc) && CodeFlow.isPrimitiveOrUnboxableSupportedNumber(rightDesc)) {\n+\t\t\tif (CodeFlow.areBoxingCompatible(leftDesc, rightDesc)) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/** \n+\t * Numeric comparison operators share very similar generated code, only differing in \n+\t * two comparison instructions.\n+\t */\n+\tprotected void generateComparisonCode(MethodVisitor mv, CodeFlow codeflow, int compareInstruction1,\n+\t\t\tint compareInstruction2) {\n+\t\tString leftDesc = getLeftOperand().getExitDescriptor();\n+\t\tString rightDesc = getRightOperand().getExitDescriptor();\n+\t\t\n+\t\tboolean unboxLeft = !CodeFlow.isPrimitive(leftDesc);\n+\t\tboolean unboxRight = !CodeFlow.isPrimitive(rightDesc);\n+\t\tchar targetType = CodeFlow.toPrimitiveTargetDesc(leftDesc);\n+\t\t\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tif (unboxLeft) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t}\n+\t\n+\t\tgetRightOperand().generateCode(mv, codeflow);\n+\t\tif (unboxRight) {\n+\t\t\tCodeFlow.insertUnboxInsns(mv, targetType, false);\n+\t\t}\n+\t\t// assert: SpelCompiler.boxingCompatible(leftDesc, rightDesc)\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tif (targetType=='D') {\n+\t\t\tmv.visitInsn(DCMPG);\n+\t\t\tmv.visitJumpInsn(compareInstruction1, elseTarget);\n+\t\t}\n+\t\telse if (targetType=='F') {\n+\t\t\tmv.visitInsn(FCMPG);\t\t\n+\t\t\tmv.visitJumpInsn(compareInstruction1, elseTarget);\n+\t\t}\n+\t\telse if (targetType=='J') {\n+\t\t\tmv.visitInsn(LCMP);\t\t\n+\t\t\tmv.visitJumpInsn(compareInstruction1, elseTarget);\n+\t\t}\n+\t\telse if (targetType=='I') {\n+\t\t\tmv.visitJumpInsn(compareInstruction2, elseTarget);\t\t\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new IllegalStateException(\"Unexpected descriptor \"+leftDesc);\n+\t\t}\n+\t\t// Other numbers are not yet supported (isCompilable will not have returned true)\n+\t\tmv.visitInsn(ICONST_1);\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tmv.visitInsn(ICONST_0);\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(\"Z\");\t\n+\t}\n \n \tprotected boolean equalityCheck(ExpressionState state, Object left, Object right) {\n \t\tif (left instanceof Number && right instanceof Number) {"
        },
        {
            "sha": "ed9c403440b8138fca4d7b52c3ffca8b6698bc67",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OperatorInstanceof.java",
            "status": "modified",
            "additions": 27,
            "deletions": 5,
            "changes": 32,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorInstanceof.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorInstanceof.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorInstanceof.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,13 +16,17 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Type;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n+\n /**\n  * The operator 'instanceof' checks if an object is of the class specified in the right\n  * hand operand, in the same way that {@code instanceof} does in Java.\n@@ -32,6 +36,8 @@\n  */\n public class OperatorInstanceof extends Operator {\n \n+\tprivate Class<?> type;\n+\t\n \tpublic OperatorInstanceof(int pos, SpelNodeImpl... operands) {\n \t\tsuper(\"instanceof\", pos, operands);\n \t}\n@@ -51,16 +57,32 @@ public BooleanTypedValue getValueInternal(ExpressionState state) throws Evaluati\n \t\tTypedValue right = getRightOperand().getValueInternal(state);\n \t\tObject leftValue = left.getValue();\n \t\tObject rightValue = right.getValue();\n-\t\tif (leftValue == null) {\n-\t\t\treturn BooleanTypedValue.FALSE;  // null is not an instanceof anything\n-\t\t}\n+\t\tBooleanTypedValue result = null;\n \t\tif (rightValue == null || !(rightValue instanceof Class<?>)) {\n \t\t\tthrow new SpelEvaluationException(getRightOperand().getStartPosition(),\n \t\t\t\t\tSpelMessage.INSTANCEOF_OPERATOR_NEEDS_CLASS_OPERAND,\n \t\t\t\t\t(rightValue == null ? \"null\" : rightValue.getClass().getName()));\n \t\t}\n \t\tClass<?> rightClass = (Class<?>) rightValue;\n-\t\treturn BooleanTypedValue.forValue(rightClass.isAssignableFrom(leftValue.getClass()));\n+\t\tif (leftValue == null) {\n+\t\t\tresult = BooleanTypedValue.FALSE;  // null is not an instanceof anything\n+\t\t} else {\n+\t\t\tresult = BooleanTypedValue.forValue(rightClass.isAssignableFrom(leftValue.getClass()));\n+\t\t}\n+\t\tthis.type = rightClass;\n+\t\tthis.exitTypeDescriptor = \"Z\";\n+\t\treturn result;\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn this.exitTypeDescriptor != null && getLeftOperand().isCompilable();\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tgetLeftOperand().generateCode(mv, codeflow);\n+\t\tmv.visitTypeInsn(INSTANCEOF,Type.getInternalName(this.type));\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n }"
        },
        {
            "sha": "f266b72cfc81c90176996ae5c56a05f1854e6948",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/OperatorNot.java",
            "status": "modified",
            "additions": 26,
            "deletions": 1,
            "changes": 27,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorNot.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorNot.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FOperatorNot.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,10 +16,13 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.BooleanTypedValue;\n \n /**\n@@ -34,6 +37,7 @@ public class OperatorNot extends SpelNodeImpl { // Not is a unary operator so do\n \n \tpublic OperatorNot(int pos, SpelNodeImpl operand) {\n \t\tsuper(pos, operand);\n+\t\tthis.exitTypeDescriptor = \"Z\";\n \t}\n \n \n@@ -58,5 +62,26 @@ public String toStringAST() {\n \t\tsb.append(\"!\").append(getChild(0).toStringAST());\n \t\treturn sb.toString();\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl child = this.children[0];\n+\t\treturn child.isCompilable() && CodeFlow.isBooleanCompatible(child.getExitDescriptor());\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tthis.children[0].generateCode(mv, codeflow);\n+\t\tcodeflow.unboxBooleanIfNecessary(mv);\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tmv.visitJumpInsn(IFNE,elseTarget);\t\t\n+\t\tmv.visitInsn(ICONST_1); // TRUE\n+\t\tmv.visitJumpInsn(GOTO,endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tmv.visitInsn(ICONST_0); // FALSE\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "097b93f03aa00e3550a0f7e8fafa087e6d0e041d",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java",
            "status": "modified",
            "additions": 37,
            "deletions": 3,
            "changes": 40,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -21,15 +21,18 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n+import org.springframework.expression.CompilablePropertyAccessor;\n import org.springframework.expression.EvaluationContext;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.PropertyAccessor;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.ReflectivePropertyAccessor;\n \n /**\n@@ -75,8 +78,17 @@ public ValueRef getValueRef(ExpressionState state) throws EvaluationException {\n \n \t@Override\n \tpublic TypedValue getValueInternal(ExpressionState state) throws EvaluationException {\n-\t\treturn getValueInternal(state.getActiveContextObject(), state.getEvaluationContext(),\n-\t\t\t\tstate.getConfiguration().isAutoGrowNullReferences());\n+\t\tTypedValue tv = getValueInternal(state.getActiveContextObject(), state.getEvaluationContext(), state.getConfiguration().isAutoGrowNullReferences());\n+\t\tif (cachedReadAccessor instanceof CompilablePropertyAccessor) {\n+\t\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor)cachedReadAccessor;\n+\t\t\texitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n+\t\t}\n+\t\treturn tv;\n+\t}\n+\n+\t@Override\n+\tpublic String getExitDescriptor() {\n+\t\treturn exitTypeDescriptor;\n \t}\n \n \tprivate TypedValue getValueInternal(TypedValue contextObject, EvaluationContext eContext,\n@@ -316,6 +328,23 @@ else if (clazz.isAssignableFrom(targetType)) {\n \t\tresolvers.addAll(generalAccessors);\n \t\treturn resolvers;\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tif (this.cachedReadAccessor == null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.cachedReadAccessor instanceof CompilablePropertyAccessor) {\n+\t\t\treturn ((CompilablePropertyAccessor)this.cachedReadAccessor).isCompilable();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv,CodeFlow codeflow) {\n+\t\t((CompilablePropertyAccessor)this.cachedReadAccessor).generateCode(this, mv, codeflow);\n+\t\tcodeflow.pushDescriptor(exitTypeDescriptor);\n+\t}\n \n \n \tprivate static class AccessorLValue implements ValueRef {\n@@ -338,7 +367,12 @@ public AccessorLValue(PropertyOrFieldReference propertyOrFieldReference, TypedVa\n \n \t\t@Override\n \t\tpublic TypedValue getValue() {\n-\t\t\treturn this.ref.getValueInternal(this.contextObject, this.eContext, this.autoGrowNullReferences);\n+\t\t\tTypedValue value = this.ref.getValueInternal(this.contextObject, this.eContext, this.autoGrowNullReferences);\n+\t\t\tif (ref.cachedReadAccessor instanceof CompilablePropertyAccessor) {\n+\t\t\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor)this.ref.cachedReadAccessor;\n+\t\t\t\tthis.ref.exitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n+\t\t\t}\n+\t\t\treturn value;\n \t\t}\n \n \t\t@Override"
        },
        {
            "sha": "6a03106ef0b00f27208e5a5a063e8ca642fb502f",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/RealLiteral.java",
            "status": "modified",
            "additions": 16,
            "deletions": 1,
            "changes": 17,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FRealLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FRealLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FRealLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,7 +16,9 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents a real literal.\n@@ -32,6 +34,7 @@ public class RealLiteral extends Literal {\n \tpublic RealLiteral(String payload, int pos, double value) {\n \t\tsuper(payload, pos);\n \t\tthis.value = new TypedValue(value);\n+\t\tthis.exitTypeDescriptor = \"D\";\n \t}\n \n \n@@ -40,4 +43,16 @@ public TypedValue getLiteralValue() {\n \t\treturn this.value;\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tmv.visitLdcInsn(this.value.getValue());\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n+\n }"
        },
        {
            "sha": "798923a2b864b2c1f44f9b932936656de8a6cb9a",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/SpelNodeImpl.java",
            "status": "modified",
            "additions": 41,
            "deletions": 1,
            "changes": 42,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FSpelNodeImpl.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FSpelNodeImpl.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FSpelNodeImpl.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,13 +16,16 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Opcodes;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.common.ExpressionUtils;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n import org.springframework.expression.spel.SpelNode;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.expression.spel.support.StandardEvaluationContext;\n import org.springframework.util.Assert;\n \n@@ -33,7 +36,7 @@\n  * @author Andy Clement\n  * @since 3.0\n  */\n-public abstract class SpelNodeImpl implements SpelNode {\n+public abstract class SpelNodeImpl implements SpelNode, Opcodes {\n \n \tprivate static SpelNodeImpl[] NO_CHILDREN = new SpelNodeImpl[0];\n \n@@ -44,6 +47,16 @@ public abstract class SpelNodeImpl implements SpelNode {\n \n \tprivate SpelNodeImpl parent;\n \n+\t/**\n+\t * Indicates the type descriptor for the result of this expression node. This is\n+\t * set as soon as it is known. For a literal node it is known immediately. For\n+\t * a property access or method invocation it is known after one evaluation of\n+\t * that node.\n+\t * The descriptor is like the bytecode form but is slightly easier to work with. It\n+\t * does not include the trailing semicolon (for non array reference types). Some examples:\n+\t * Ljava/lang/String, I, [I\n+     */\n+\tprotected String exitTypeDescriptor;\n \n \tpublic SpelNodeImpl(int pos, SpelNodeImpl... operands) {\n \t\tthis.pos = pos;\n@@ -167,6 +180,33 @@ protected ValueRef getValueRef(ExpressionState state) throws EvaluationException\n \t\tthrow new SpelEvaluationException(this.pos, SpelMessage.NOT_ASSIGNABLE, toStringAST());\n \t}\n \n+\t/**\n+\t * Check whether a node can be compiled to bytecode. The reasoning in each node may\n+\t * be different but will typically involve checking whether the exit type descriptor\n+\t * of the node is known and any relevant child nodes are compilable.\n+\t * \n+\t * @return true if this node can be compiled to bytecode\n+\t */\n+\tpublic boolean isCompilable() {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Generate the bytecode for this node into the supplied visitor. Context info about\n+\t * the current expression being compiled is available in the codeflow object. For\n+\t * example it will include information about the type of the object currently\n+\t * on the stack.\n+\t * \n+\t * @param mv the ASM MethodVisitor into which code should be generated\n+\t * @param codeflow a context object with info about what is on the stack\n+\t */\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tthrow new IllegalStateException(this.getClass().getName()+\" has no generateCode(..) method\");\n+\t}\n+\n+\tpublic String getExitDescriptor() {\n+\t\treturn this.exitTypeDescriptor;\n+\t}\n \n \tpublic abstract TypedValue getValueInternal(ExpressionState expressionState) throws EvaluationException;\n "
        },
        {
            "sha": "46f46da397494ac4bee6897d7c9595468fc61bb5",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/StringLiteral.java",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FStringLiteral.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FStringLiteral.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FStringLiteral.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -16,7 +16,9 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Expression language AST node that represents a string literal.\n@@ -32,9 +34,9 @@ public class StringLiteral extends Literal {\n \n \tpublic StringLiteral(String payload, int pos, String value) {\n \t\tsuper(payload,pos);\n-\t\t// TODO should these have been skipped being created by the parser rules? or not?\n \t\tvalue = value.substring(1, value.length() - 1);\n \t\tthis.value = new TypedValue(value.replaceAll(\"''\", \"'\").replaceAll(\"\\\"\\\"\", \"\\\"\"));\n+\t\tthis.exitTypeDescriptor = \"Ljava/lang/String\";\n \t}\n \n \n@@ -47,5 +49,16 @@ public TypedValue getLiteralValue() {\n \tpublic String toString() {\n \t\treturn \"'\" + getLiteralValue().getValue() + \"'\";\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn true;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tmv.visitLdcInsn(this.value.getValue());\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "eac2af4f9e30cca502278ad7235f7dacc515cfef",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/Ternary.java",
            "status": "modified",
            "additions": 71,
            "deletions": 4,
            "changes": 75,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTernary.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTernary.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTernary.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,11 +16,14 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.Label;\n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n import org.springframework.expression.spel.SpelMessage;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Represents a ternary expression, for example: \"someCheck()?true:false\".\n@@ -50,18 +53,82 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\tthrow new SpelEvaluationException(getChild(0).getStartPosition(),\n \t\t\t\t\tSpelMessage.TYPE_CONVERSION_ERROR, \"null\", \"boolean\");\n \t\t}\n+\t\tTypedValue result = null;\n \t\tif (value.booleanValue()) {\n-\t\t\treturn this.children[1].getValueInternal(state);\n+\t\t\tresult = this.children[1].getValueInternal(state);\n \t\t}\n \t\telse {\n-\t\t\treturn this.children[2].getValueInternal(state);\n+\t\t\tresult = this.children[2].getValueInternal(state);\n \t\t}\n+\t\tcomputeExitTypeDescriptor();\n+\t\treturn result;\n \t}\n-\n+\t\n \t@Override\n \tpublic String toStringAST() {\n \t\treturn new StringBuilder().append(getChild(0).toStringAST()).append(\" ? \").append(getChild(1).toStringAST())\n \t\t\t\t.append(\" : \").append(getChild(2).toStringAST()).toString();\n \t}\n \n+\tprivate void computeExitTypeDescriptor() {\n+\t\tif (exitTypeDescriptor == null && this.children[1].getExitDescriptor()!=null && this.children[2].getExitDescriptor()!=null) {\n+\t\t\tString leftDescriptor = this.children[1].exitTypeDescriptor;\n+\t\t\tString rightDescriptor = this.children[2].exitTypeDescriptor;\n+\t\t\tif (leftDescriptor.equals(rightDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = leftDescriptor;\n+\t\t\t}\n+\t\t\telse if (leftDescriptor.equals(\"Ljava/lang/Object\") && !CodeFlow.isPrimitive(rightDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = rightDescriptor;\n+\t\t\t}\n+\t\t\telse if (rightDescriptor.equals(\"Ljava/lang/Object\") && !CodeFlow.isPrimitive(leftDescriptor)) {\n+\t\t\t\tthis.exitTypeDescriptor = leftDescriptor;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// Use the easiest to compute common super type\n+\t\t\t\tthis.exitTypeDescriptor = \"Ljava/lang/Object\";\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\tSpelNodeImpl condition = this.children[0];\n+\t\tSpelNodeImpl left = this.children[1];\n+\t\tSpelNodeImpl right = this.children[2];\n+\t\tif (!(condition.isCompilable() && left.isCompilable() && right.isCompilable())) {\n+\t\t\treturn false;\n+\t\t}\n+\t\treturn CodeFlow.isBooleanCompatible(condition.exitTypeDescriptor) &&\n+\t\t\t\tleft.getExitDescriptor()!=null && \n+\t\t\t\tright.getExitDescriptor()!=null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\t// May reach here without it computed if all elements are literals\n+\t\tcomputeExitTypeDescriptor();\n+\t\tcodeflow.enterCompilationScope();\n+\t\tthis.children[0].generateCode(mv, codeflow);\n+\t\tcodeflow.exitCompilationScope();\n+\t\tLabel elseTarget = new Label();\n+\t\tLabel endOfIf = new Label();\n+\t\tmv.visitJumpInsn(IFEQ, elseTarget);\n+\t\tcodeflow.enterCompilationScope();\n+\t\tthis.children[1].generateCode(mv, codeflow);\n+\t\tif (!CodeFlow.isPrimitive(getExitDescriptor())) {\n+\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t}\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitJumpInsn(GOTO, endOfIf);\n+\t\tmv.visitLabel(elseTarget);\n+\t\tcodeflow.enterCompilationScope();\n+\t\tthis.children[2].generateCode(mv, codeflow);\n+\t\tif (!CodeFlow.isPrimitive(getExitDescriptor())) {\n+\t\t\tCodeFlow.insertBoxIfNecessary(mv, codeflow.lastDescriptor().charAt(0));\n+\t\t}\n+\t\tcodeflow.exitCompilationScope();\n+\t\tmv.visitLabel(endOfIf);\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n }"
        },
        {
            "sha": "963658294c6ef0fded349173a8380c1569d520ff",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/TypeReference.java",
            "status": "modified",
            "additions": 44,
            "deletions": 1,
            "changes": 45,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTypeReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTypeReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FTypeReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -18,9 +18,12 @@\n \n import java.lang.reflect.Array;\n \n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Type;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Represents a reference to a type, for example \"T(String)\" or \"T(com.somewhere.Foo)\"\n@@ -31,6 +34,7 @@ public class TypeReference extends SpelNodeImpl {\n \n \tprivate final int dimensions;\n \n+\tprivate transient Class<?> type;\n \n \tpublic TypeReference(int pos, SpelNodeImpl qualifiedId) {\n \t\tthis(pos,qualifiedId,0);\n@@ -52,11 +56,15 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\t\t\t// it is a primitive type\n \t\t\t\tClass<?> clazz = tc.getType();\n \t\t\t\tclazz = makeArrayIfNecessary(clazz);\n+\t\t\t\tthis.exitTypeDescriptor = \"Ljava/lang/Class\";\n+\t\t\t\tthis.type = clazz;\n \t\t\t\treturn new TypedValue(clazz);\n \t\t\t}\n \t\t}\n \t\tClass<?> clazz = state.findType(typename);\n \t\tclazz = makeArrayIfNecessary(clazz);\n+\t\tthis.exitTypeDescriptor = \"Ljava/lang/Class\";\n+\t\tthis.type = clazz;\n \t\treturn new TypedValue(clazz);\n \t}\n \n@@ -81,5 +89,40 @@ public String toStringAST() {\n \t\tsb.append(\")\");\n \t\treturn sb.toString();\n \t}\n+\t\n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn this.exitTypeDescriptor != null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\t// TODO Future optimization - if followed by a static method call, skip generating code here\n+\t\tif (type.isPrimitive()) {\n+\t\t\tif (type == Integer.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Integer\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Boolean.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Boolean\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Byte.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Byte\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Short.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Short\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Double.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Double\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Character.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Character\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Float.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Float\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Long.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Long\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t\t\t} else if (type == Boolean.TYPE) {\n+\t\t\t\tmv.visitFieldInsn(GETSTATIC, \"java/lang/Boolean\", \"TYPE\", \"Ljava/lang/Class;\");\n+\t        }\n+\t\t}\n+\t\telse {\n+\t\t\tmv.visitLdcInsn(Type.getType(type));\n+\t\t}\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n \n }"
        },
        {
            "sha": "6cbe3e1e30d9c2036a7d3dc137f8bef1b3db2441",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/VariableReference.java",
            "status": "modified",
            "additions": 25,
            "deletions": 2,
            "changes": 27,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FVariableReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FVariableReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FVariableReference.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -16,10 +16,12 @@\n \n package org.springframework.expression.spel.ast;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.expression.EvaluationContext;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.spel.ExpressionState;\n import org.springframework.expression.spel.SpelEvaluationException;\n+import org.springframework.expression.spel.standard.CodeFlow;\n \n /**\n  * Represents a variable reference, eg. #someVar. Note this is different to a *local*\n@@ -64,9 +66,12 @@ public TypedValue getValueInternal(ExpressionState state) throws SpelEvaluationE\n \t\t\treturn state.getActiveContextObject();\n \t\t}\n \t\tif (this.name.equals(ROOT)) {\n-\t\t\treturn state.getRootContextObject();\n+\t\t\tTypedValue result = state.getRootContextObject();\n+\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptorFromObject(result.getValue());\n+\t\t\treturn result;\n \t\t}\n \t\tTypedValue result = state.lookupVariable(this.name);\n+\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptorFromObject(result.getValue());\n \t\t// a null value will mean either the value was null or the variable was not found\n \t\treturn result;\n \t}\n@@ -120,5 +125,23 @@ public boolean isWritable() {\n \t\t}\n \t}\n \n+\t@Override\n+\tpublic boolean isCompilable() {\n+\t\treturn getExitDescriptor()!=null;\n+\t}\n+\t\n+\t@Override\n+\tpublic void generateCode(MethodVisitor mv, CodeFlow codeflow) {\n+\t\tif (this.name.equals(ROOT)) {\n+\t\t\tmv.visitVarInsn(ALOAD,1);\n+\t\t} else {\n+\t\t\tmv.visitVarInsn(ALOAD, 2);\n+\t\t\tmv.visitLdcInsn(name);\n+\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"org/springframework/expression/EvaluationContext\", \"lookupVariable\", \"(Ljava/lang/String;)Ljava/lang/Object;\",true);\n+\t\t}\n+\t\tCodeFlow.insertCheckCast(mv,getExitDescriptor());\n+\t\tcodeflow.pushDescriptor(getExitDescriptor());\n+\t}\n+\n \n }"
        },
        {
            "sha": "4cc1f1ad40794da728d0c6323267c808e697ee96",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/standard/CodeFlow.java",
            "status": "added",
            "additions": 603,
            "deletions": 0,
            "changes": 603,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FCodeFlow.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FCodeFlow.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FCodeFlow.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,603 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression.spel.standard;\n+\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Stack;\n+\n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Opcodes;\n+import org.springframework.util.Assert;\n+\n+/**\n+ * Records intermediate compilation state as the bytecode is generated for a parsed\n+ * expression. Also contains bytecode generation helper functions.\n+ *\n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public class CodeFlow implements Opcodes {\n+\n+\t/**\n+\t * Record the type of what is on top of the bytecode stack (i.e. the type of the\n+\t * output from the previous expression component). New scopes are used to evaluate\n+\t * sub-expressions like the expressions for the argument values in a method invocation\n+\t * expression.\n+\t */\n+\tprivate Stack<ArrayList<String>> compilationScopes;\n+\n+\tpublic CodeFlow() {\n+\t\tcompilationScopes = new Stack<ArrayList<String>>();\n+\t\tcompilationScopes.add(new ArrayList<String>());\n+\t}\n+\n+\t/**\n+\t * Push the byte code to load the target (i.e. what was passed as the first argument\n+\t * to CompiledExpression.getValue(target, context))\n+\t * @param mv the visitor into which the load instruction should be inserted\n+\t */\n+\tpublic void loadTarget(MethodVisitor mv) {\n+\t\tmv.visitVarInsn(ALOAD, 1);\n+\t}\n+\n+\t/**\n+\t * Record the descriptor for the most recently evaluated expression element.\n+\t * @param descriptor type descriptor for most recently evaluated element\n+\t */\n+\tpublic void pushDescriptor(String descriptor) {\n+\t\tAssert.notNull(descriptor);\n+\t\tcompilationScopes.peek().add(descriptor);\n+\t}\n+\n+\t/**\n+\t * Enter a new compilation scope, usually due to nested expression evaluation. For\n+\t * example when the arguments for a method invocation expression are being evaluated,\n+\t * each argument will be evaluated in a new scope.\n+\t */\n+\tpublic void enterCompilationScope() {\n+\t\tcompilationScopes.push(new ArrayList<String>());\n+\t}\n+\n+\t/**\n+\t * Exit a compilation scope, usually after a nested expression has been evaluated. For\n+\t * example after an argument for a method invocation has been evaluated this method\n+\t * returns us to the previous (outer) scope.\n+\t */\n+\tpublic void exitCompilationScope() {\n+\t\tcompilationScopes.pop();\n+\t}\n+\n+\t/**\n+\t * @return the descriptor for the item currently on top of the stack (in the current\n+\t *         scope)\n+\t */\n+\tpublic String lastDescriptor() {\n+\t\tif (compilationScopes.peek().size()==0) {\n+\t\t\treturn null;\n+\t\t}\n+\t\treturn compilationScopes.peek().get(compilationScopes.peek().size()-1);\n+\t}\n+\n+\t/**\n+\t * If the codeflow shows the last expression evaluated to java.lang.Boolean then\n+\t * insert the necessary instructions to unbox that to a boolean primitive.\n+\t * @param mv the visitor into which new instructions should be inserted\n+\t */\n+\tpublic void unboxBooleanIfNecessary(MethodVisitor mv) {\n+\t\tif (lastDescriptor().equals(\"Ljava/lang/Boolean\")) {\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Insert any necessary cast and value call to convert from a boxed type to a\n+\t * primitive value\n+\t * @param mv the method visitor into which instructions should be inserted\n+\t * @param ch the primitive type desired as output\n+\t * @param isObject indicates whether the type on the stack is being thought of as\n+\t *        Object (and so requires a cast)\n+\t */\n+\tpublic static void insertUnboxInsns(MethodVisitor mv, char ch, boolean isObject) {\n+\t\tswitch (ch) {\n+\t\tcase 'I':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Integer\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Integer\", \"intValue\", \"()I\", false);\n+\t\t\tbreak;\n+\t\tcase 'Z':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Boolean\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Boolean\", \"booleanValue\", \"()Z\", false);\n+\t\t\tbreak;\n+\t\tcase 'B':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Byte\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Byte\", \"byteValue\", \"()B\", false);\n+\t\t\tbreak;\n+\t\tcase 'C':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Character\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Character\", \"charValue\", \"()C\", false);\n+\t\t\tbreak;\n+\t\tcase 'D':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Double\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Double\", \"doubleValue\", \"()D\", false);\n+\t\t\tbreak;\n+\t\tcase 'S':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Short\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Short\", \"shortValue\", \"()S\", false);\n+\t\t\tbreak;\n+\t\tcase 'F':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Float\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Float\", \"floatValue\", \"()F\", false);\n+\t\t\tbreak;\n+\t\tcase 'J':\n+\t\t\tif (isObject) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, \"java/lang/Long\");\n+\t\t\t}\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, \"java/lang/Long\", \"longValue\", \"()J\", false);\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Unboxing should not be attempted for descriptor '\" + ch + \"'\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create the JVM signature descriptor for a method. This consists of the descriptors\n+\t * for the constructor parameters surrounded with parentheses, followed by the\n+\t * descriptor for the return type. Note the descriptors here are JVM descriptors,\n+\t * unlike the other descriptor forms the compiler is using which do not include the\n+\t * trailing semicolon.\n+\t * @param method the method\n+\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)V\")\n+\t */\n+\tpublic static String createSignatureDescriptor(Method method) {\n+\t\tClass<?>[] params = method.getParameterTypes();\n+\t\tStringBuilder s = new StringBuilder();\n+\t\ts.append(\"(\");\n+\t\tfor (int i = 0, max = params.length; i < max; i++) {\n+\t\t\ts.append(toJVMDescriptor(params[i]));\n+\t\t}\n+\t\ts.append(\")\");\n+\t\ts.append(toJVMDescriptor(method.getReturnType()));\n+\t\treturn s.toString();\n+\t}\n+\n+\t/**\n+\t * Create the JVM signature descriptor for a constructor. This consists of the\n+\t * descriptors for the constructor parameters surrounded with parentheses. Note the\n+\t * descriptors here are JVM descriptors, unlike the other descriptor forms the\n+\t * compiler is using which do not include the trailing semicolon.\n+\t * @param ctor the constructor\n+\t * @return a String signature descriptor (e.g. \"(ILjava/lang/String;)\")\n+\t */\n+\tpublic static String createSignatureDescriptor(Constructor<?> ctor) {\n+\t\tClass<?>[] params = ctor.getParameterTypes();\n+\t\tStringBuilder s = new StringBuilder();\n+\t\ts.append(\"(\");\n+\t\tfor (int i = 0, max = params.length; i < max; i++) {\n+\t\t\ts.append(toJVMDescriptor(params[i]));\n+\t\t}\n+\t\ts.append(\")V\");\n+\t\treturn s.toString();\n+\t}\n+\n+\t/**\n+\t * Determine the JVM descriptor for a specified class. Unlike the other descriptors\n+\t * used in the compilation process, this is the one the JVM wants, so this one\n+\t * includes any necessary trailing semicolon (e.g. Ljava/lang/String; rather than\n+\t * Ljava/lang/String)\n+\t *\n+\t * @param clazz a class\n+\t * @return the JVM descriptor for the class\n+\t */\n+\tpublic static String toJVMDescriptor(Class<?> clazz) {\n+\t\tStringBuilder s= new StringBuilder();\n+\t\tif (clazz.isArray()) {\n+\t\t\twhile (clazz.isArray()) {\n+\t\t\t\ts.append(\"[\");\n+\t\t\t\tclazz = clazz.getComponentType();\n+\t\t\t}\n+\t\t}\n+\t\tif (clazz.isPrimitive()) {\n+\t\t\tif (clazz == Void.TYPE) {\n+\t\t\t\ts.append('V');\n+\t\t\t}\n+\t\t\telse if (clazz == Integer.TYPE) {\n+\t\t\t\ts.append('I');\n+\t\t\t}\n+\t\t\telse if (clazz == Boolean.TYPE) {\n+\t\t\t\ts.append('Z');\n+\t\t\t}\n+\t\t\telse if (clazz == Character.TYPE) {\n+\t\t\t\ts.append('C');\n+\t\t\t}\n+\t\t\telse if (clazz == Long.TYPE) {\n+\t\t\t\ts.append('J');\n+\t\t\t}\n+\t\t\telse if (clazz == Double.TYPE) {\n+\t\t\t\ts.append('D');\n+\t\t\t}\n+\t\t\telse if (clazz == Float.TYPE) {\n+\t\t\t\ts.append('F');\n+\t\t\t}\n+\t\t\telse if (clazz == Byte.TYPE) {\n+\t\t\t\ts.append('B');\n+\t\t\t}\n+\t\t\telse if (clazz == Short.TYPE) {\n+\t\t\t\ts.append('S');\n+\t\t\t}\n+\t\t} else {\n+\t\t\ts.append(\"L\");\n+\t\t\ts.append(clazz.getName().replace('.', '/'));\n+\t\t\ts.append(\";\");\n+\t\t}\n+\t\treturn s.toString();\n+\t}\n+\n+\t/**\n+\t * Determine the descriptor for an object instance (or null).\n+\t * @param value an object (possibly null)\n+\t * @return the type descriptor for the object (descriptor is \"Ljava/lang/Object\" for\n+\t *         null value)\n+\t */\n+\tpublic static String toDescriptorFromObject(Object value) {\n+\t\tif (value == null) {\n+\t\t\treturn \"Ljava/lang/Object\";\n+\t\t} else {\n+\t\t\treturn toDescriptor(value.getClass());\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * @param descriptor type descriptor\n+\t * @return true if the descriptor is for a boolean primitive or boolean reference type\n+\t */\n+\tpublic static boolean isBooleanCompatible(String descriptor) {\n+\t\treturn descriptor != null\n+\t\t\t\t&& (descriptor.equals(\"Z\") || descriptor.equals(\"Ljava/lang/Boolean\"));\n+\t}\n+\n+\t/**\n+\t * @param descriptor type descriptor\n+\t * @return true if the descriptor is for a primitive type\n+\t */\n+\tpublic static boolean isPrimitive(String descriptor) {\n+\t\treturn descriptor!=null && descriptor.length()==1;\n+\t}\n+\n+\t/**\n+\t * @param descriptor the descriptor for a possible primitive array\n+\t * @return true if the descriptor is for a primitive array (e.g. \"[[I\")\n+\t */\n+\tpublic static boolean isPrimitiveArray(String descriptor) {\n+\t\tboolean primitive = true;\n+\t\tfor (int i = 0, max = descriptor.length(); i < max; i++) {\n+\t\t\tchar ch = descriptor.charAt(i);\n+\t\t\tif (ch == '[') {\n+\t\t\t\tcontinue;\n+\t\t\t}\n+\t\t\tprimitive = (ch != 'L');\n+\t\t\tbreak;\n+\t\t}\n+\t\treturn primitive;\n+\t}\n+\n+\t/**\n+\t * Determine if boxing/unboxing can get from one type to the other. Assumes at least\n+\t * one of the types is in boxed form (i.e. single char descriptor).\n+\t *\n+\t * @return true if it is possible to get (via boxing) from one descriptor to the other\n+\t */\n+\tpublic static boolean areBoxingCompatible(String desc1, String desc2) {\n+\t\tif (desc1.equals(desc2)) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (desc1.length()==1) {\n+\t\t\tif (desc1.equals(\"D\")) {\n+\t\t\t\treturn desc2.equals(\"Ljava/lang/Double\");\n+\t\t\t}\n+\t\t\telse if (desc1.equals(\"F\")) {\n+\t\t\t\treturn desc2.equals(\"Ljava/lang/Float\");\n+\t\t\t}\n+\t\t\telse if (desc1.equals(\"J\")) {\n+\t\t\t\treturn desc2.equals(\"Ljava/lang/Long\");\n+\t\t\t}\n+\t\t\telse if (desc1.equals(\"I\")) {\n+\t\t\t\treturn desc2.equals(\"Ljava/lang/Integer\");\n+\t\t\t}\n+\t\t\telse if (desc1.equals(\"Z\")) {\n+\t\t\t\treturn desc2.equals(\"Ljava/lang/Boolean\");\n+\t\t\t}\n+\t\t}\n+\t\telse if (desc2.length()==1) {\n+\t\t\tif (desc2.equals(\"D\")) {\n+\t\t\t\treturn desc1.equals(\"Ljava/lang/Double\");\n+\t\t\t}\n+\t\t\telse if (desc2.equals(\"F\")) {\n+\t\t\t\treturn desc1.equals(\"Ljava/lang/Float\");\n+\t\t\t}\n+\t\t\telse if (desc2.equals(\"J\")) {\n+\t\t\t\treturn desc1.equals(\"Ljava/lang/Long\");\n+\t\t\t}\n+\t\t\telse if (desc2.equals(\"I\")) {\n+\t\t\t\treturn desc1.equals(\"Ljava/lang/Integer\");\n+\t\t\t}\n+\t\t\telse if (desc2.equals(\"Z\")) {\n+\t\t\t\treturn desc1.equals(\"Ljava/lang/Boolean\");\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Determine if the supplied descriptor is for a supported number type or boolean. The\n+\t * compilation process only (currently) supports certain number types. These are\n+\t * double, float, long and int.\n+\t * @param descriptor the descriptor for a type\n+\t * @return true if the descriptor is for a supported numeric type or boolean\n+\t */\n+\tpublic static boolean isPrimitiveOrUnboxableSupportedNumberOrBoolean(String descriptor) {\n+\t\tif (descriptor==null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (descriptor.length()==1) {\n+\t\t\treturn \"DFJZI\".indexOf(descriptor.charAt(0))!=-1;\n+\t\t}\n+\t\tif (descriptor.startsWith(\"Ljava/lang/\")) {\n+\t\t\tif (descriptor.equals(\"Ljava/lang/Double\") || descriptor.equals(\"Ljava/lang/Integer\") ||\n+\t\t\t\tdescriptor.equals(\"Ljava/lang/Float\") || descriptor.equals(\"Ljava/lang/Long\") ||\n+\t\t\t\tdescriptor.equals(\"Ljava/lang/Boolean\")) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Determine if the supplied descriptor is for a supported number. The compilation\n+\t * process only (currently) supports certain number types. These are double, float,\n+\t * long and int.\n+\t * @param descriptor the descriptor for a type\n+\t * @return true if the descriptor is for a supported numeric type\n+\t */\n+\tpublic static boolean isPrimitiveOrUnboxableSupportedNumber(String descriptor) {\n+\t\tif (descriptor==null) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (descriptor.length()==1) {\n+\t\t\treturn \"DFJI\".indexOf(descriptor.charAt(0))!=-1;\n+\t\t}\n+\t\tif (descriptor.startsWith(\"Ljava/lang/\")) {\n+\t\t\tif (descriptor.equals(\"Ljava/lang/Double\") || descriptor.equals(\"Ljava/lang/Integer\") ||\n+\t\t\t\tdescriptor.equals(\"Ljava/lang/Float\") || descriptor.equals(\"Ljava/lang/Long\")) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * @param descriptor a descriptor for a type that should have a primitive\n+\t *        representation\n+\t * @return the single character descriptor for a primitive input descriptor\n+\t */\n+\tpublic static char toPrimitiveTargetDesc(String descriptor) {\n+\t\tif (descriptor.length()==1) {\n+\t\t\treturn descriptor.charAt(0);\n+\t\t}\n+\t\tif (descriptor.equals(\"Ljava/lang/Double\")) {\n+\t\t\treturn 'D';\n+\t\t}\n+\t\telse if (descriptor.equals(\"Ljava/lang/Integer\")) {\n+\t\t\treturn 'I';\n+\t\t}\n+\t\telse if (descriptor.equals(\"Ljava/lang/Float\")) {\n+\t\t\treturn 'F';\n+\t\t}\n+\t\telse if (descriptor.equals(\"Ljava/lang/Long\")) {\n+\t\t\treturn 'J';\n+\t\t}\n+\t\telse if (descriptor.equals(\"Ljava/lang/Boolean\")) {\n+\t\t\treturn 'Z';\n+\t\t}\n+\t\telse {\n+\t\t\tthrow new IllegalStateException(\"No primitive for '\"+descriptor+\"'\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Insert the appropriate CHECKCAST instruction for the supplied descriptor.\n+\t * @param mv the target visitor into which the instruction should be inserted\n+\t * @param descriptor the descriptor of the type to cast to\n+\t */\n+\tpublic static void insertCheckCast(MethodVisitor mv, String descriptor) {\n+\t\tif (descriptor.length()!=1) {\n+\t\t\tif (descriptor.charAt(0)=='[') {\n+\t\t\t\tif (CodeFlow.isPrimitiveArray(descriptor)) {\n+\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor);\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor+\";\");\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// This is chopping off the 'L' to leave us with \"java/lang/String\"\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, descriptor.substring(1));\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Determine the appropriate boxing instruction for a specific type (if it needs\n+\t * boxing) and insert the instruction into the supplied visitor.\n+\t * @param mv the target visitor for the new instructions\n+\t * @param descriptor the descriptor of a type that may or may not need boxing\n+\t */\n+\tpublic static void insertBoxIfNecessary(MethodVisitor mv, String descriptor) {\n+\t\tif (descriptor.length() == 1) {\n+\t\t\tinsertBoxIfNecessary(mv, descriptor.charAt(0));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Determine the appropriate boxing instruction for a specific type (if it needs\n+\t * boxing) and insert the instruction into the supplied visitor.\n+\t * @param mv the target visitor for the new instructions\n+\t * @param ch the descriptor of the type that might need boxing\n+\t */\n+\tpublic static void insertBoxIfNecessary(MethodVisitor mv, char ch) {\n+\t\tswitch (ch) {\n+\t\tcase 'I':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Integer\", \"valueOf\", \"(I)Ljava/lang/Integer;\", false);\n+\t\t\tbreak;\n+\t\tcase 'F':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Float\", \"valueOf\", \"(F)Ljava/lang/Float;\", false);\n+\t\t\tbreak;\n+\t\tcase 'S':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Short\", \"valueOf\", \"(S)Ljava/lang/Short;\", false);\n+\t\t\tbreak;\n+\t\tcase 'Z':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Boolean\", \"valueOf\", \"(Z)Ljava/lang/Boolean;\", false);\n+\t\t\tbreak;\n+\t\tcase 'J':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Long\", \"valueOf\", \"(J)Ljava/lang/Long;\", false);\n+\t\t\tbreak;\n+\t\tcase 'D':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Double\", \"valueOf\", \"(D)Ljava/lang/Double;\", false);\n+\t\t\tbreak;\n+\t\tcase 'C':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Character\", \"valueOf\", \"(C)Ljava/lang/Character;\", false);\n+\t\t\tbreak;\n+\t\tcase 'B':\n+\t\t\tmv.visitMethodInsn(INVOKESTATIC, \"java/lang/Byte\", \"valueOf\", \"(B)Ljava/lang/Byte;\", false);\n+\t\t\tbreak;\n+\t\tcase 'L':\n+\t\t\tcase 'V':\n+\t\tcase '[':\n+\t\t\t// no box needed\n+\t\t\tbreak;\n+\t\tdefault:\n+\t\t\tthrow new IllegalArgumentException(\"Boxing should not be attempted for descriptor '\" + ch + \"'\");\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Deduce the descriptor for a type. Descriptors are like JVM type names but missing\n+\t * the trailing ';' so for Object the descriptor is \"Ljava/lang/Object\" for int it is\n+\t * \"I\".\n+\t * @param type the type (may be primitive) for which to determine the descriptor\n+\t * @return the descriptor\n+\t */\n+\tpublic static String toDescriptor(Class<?> type) {\n+\t\tString name = type.getName();\n+\t\tif (type.isPrimitive()) {\n+\t\t\tswitch (name.length()) {\n+\t\t\t\tcase 3:\n+\t\t\t\t\treturn \"I\";\n+\t\t\t\tcase 4:\n+\t\t\t\t\tif (name.equals(\"long\")) {\n+\t\t\t\t\t\treturn \"J\";\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (name.equals(\"char\")) {\n+\t\t\t\t\t\treturn \"C\";\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (name.equals(\"byte\")) {\n+\t\t\t\t\t\treturn \"B\";\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (name.equals(\"void\")) {\n+\t\t\t\t\t\treturn \"V\";\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 5:\n+\t\t\t\t\tif (name.equals(\"float\")) {\n+\t\t\t\t\t\treturn \"F\";\n+\t\t\t\t\t}\n+\t\t\t\t\telse if (name.equals(\"short\")) {\n+\t\t\t\t\t\treturn \"S\";\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 6:\n+\t\t\t\t\tif (name.equals(\"double\")) {\n+\t\t\t\t\t\treturn \"D\";\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t\tcase 7:\n+\t\t\t\t\tif (name.equals(\"boolean\")) {\n+\t\t\t\t\t\treturn \"Z\";\n+\t\t\t\t\t}\n+\t\t\t\t\tbreak;\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tif (name.charAt(0) != '[') {\n+\t\t\t\treturn new StringBuilder(\"L\").append(type.getName().replace('.', '/')).toString();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tif (name.endsWith(\";\")) {\n+\t\t\t\t\treturn name.substring(0, name.length() - 1).replace('.', '/');\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\treturn name; // array has primitive component type\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\t/**\n+\t * Create an array of descriptors representing the parameter types for the supplied\n+\t * method. Returns a zero sized array if there are no parameters.\n+\t * @param method a Method\n+\t * @return a String array of descriptors, one entry for each method parameter\n+\t */\n+\tpublic static String[] toParamDescriptors(Method method) {\n+\t\treturn toDescriptors(method.getParameterTypes());\n+\t}\n+\n+\t/**\n+\t * Create an array of descriptors representing the parameter types for the supplied\n+\t * constructor. Returns a zero sized array if there are no parameters.\n+\t * @param ctor a Constructor\n+\t * @return a String array of descriptors, one entry for each constructor parameter\n+\t */\n+\tpublic static String[] toParamDescriptors(Constructor<?> ctor) {\n+\t\treturn toDescriptors(ctor.getParameterTypes());\n+\t}\n+\n+\tprivate static String[] toDescriptors(Class<?>[] types) {\n+\t\tint typesCount = types.length;\n+\t\tString[] descriptors = new String[typesCount];\n+\t\tfor (int p = 0; p < typesCount; p++) {\n+\t\t\tdescriptors[p] = CodeFlow.toDescriptor(types[p]);\n+\t\t}\n+\t\treturn descriptors;\n+\t}\n+\n+}"
        },
        {
            "sha": "5d32b6395db82ec21b910d395ed340497858c8c4",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/standard/SpelCompiler.java",
            "status": "added",
            "additions": 277,
            "deletions": 0,
            "changes": 277,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelCompiler.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelCompiler.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelCompiler.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,277 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.springframework.expression.spel.standard;\n+\n+import java.io.File;\n+import java.io.FileOutputStream;\n+import java.io.IOException;\n+import java.net.URL;\n+import java.net.URLClassLoader;\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+\n+import org.springframework.asm.ClassWriter;\n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.asm.Opcodes;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.spel.CompiledExpression;\n+import org.springframework.expression.spel.SpelParserConfiguration;\n+import org.springframework.expression.spel.ast.SpelNodeImpl;\n+import org.springframework.util.ClassUtils;\n+\n+/**\n+ * A SpelCompiler will take a regular parsed expression and create (and load) a class\n+ * containing byte code that does the same thing as that expression. The compiled form of\n+ * an expression will evaluate far faster than the interpreted form.\n+ * <p>\n+ * The SpelCompiler is not currently handling all expression types but covers many of the\n+ * common cases. The framework is extensible to cover more cases in the future. For\n+ * absolute maximum speed there is *no checking* in the compiled code. The compiled\n+ * version of the expression uses information learned during interpreted runs of the\n+ * expression when it generates the byte code. For example if it knows that a particular\n+ * property dereference always seems to return a Map then it will generate byte code that\n+ * expects the result of the property dereference to be a Map. This ensures maximal\n+ * performance but should the dereference result in something other than a map, the\n+ * compiled expression will fail - like a ClassCastException would occur if passing data\n+ * of an unexpected type in a regular Java program.\n+ * <p>\n+ * Due to the lack of checking there are likely some expressions that should never be\n+ * compiled, for example if an expression is continuously dealing with different types of\n+ * data. Due to these cases the compiler is something that must be selectively turned on\n+ * for an associated SpelExpressionParser (through the {@link SpelParserConfiguration}\n+ * object), it is not on by default.\n+ * <p>\n+ * Individual expressions can be compiled by calling\n+ * <tt>SpelCompiler.compile(expression)</tt>.\n+ *\n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public class SpelCompiler implements Opcodes {\n+\n+\t// Default number of times to interpret an expression before compiling it\n+\tprivate static int DEFAULT_INTERPRETED_COUNT_THRESHOLD = 100;\n+\n+\t// Once an expression is evaluated the threshold number of times, it will be a candidate for compilation\n+\tpublic static int interpretedCountThreshold = DEFAULT_INTERPRETED_COUNT_THRESHOLD;\n+\n+\t// Useful for debugging\n+\tpublic static final boolean verbose = false;\n+\n+\t// A compiler is created for each classloader, it manages a child class loader of that\n+\t// classloader and the child is used to load the compiled expressions.\n+\tprivate static Map<ClassLoader,SpelCompiler> compilers = Collections.synchronizedMap(new WeakHashMap<ClassLoader,SpelCompiler>());\n+\n+\t// The child classloader used to load the compiled expression classes\n+\tprivate ChildClassLoader ccl;\n+\n+\t// counter suffix for generated classes within this SpelCompiler instance\n+\tprivate int suffixId;\n+\n+\t/**\n+\t * Factory method for compiler instances. The returned SpelCompiler will\n+\t * attach a class loader as the child of the default class loader and this\n+\t * child will be used to load compiled expressions.\n+\t *\n+\t * @return a SpelCompiler instance\n+\t */\n+\tpublic static SpelCompiler getCompiler() {\n+\t\tClassLoader classloader = ClassUtils.getDefaultClassLoader();\n+\t\tsynchronized (compilers) {\n+\t\t\tSpelCompiler compiler = compilers.get(classloader);\n+\t\t\tif (compiler == null) {\n+\t\t\t\tcompiler = new SpelCompiler(classloader);\n+\t\t\t\tcompilers.put(classloader,compiler);\n+\t\t\t}\n+\t\t\treturn compiler;\n+\t\t}\n+\t}\n+\n+\tprivate SpelCompiler(ClassLoader classloader) {\n+\t\tthis.ccl = new ChildClassLoader(classloader);\n+\t\tthis.suffixId = 1;\n+\t}\n+\n+\t/**\n+\t * Attempt compilation of the supplied expression. A check is\n+\t * made to see if it is compilable before compilation proceeds. The\n+\t * check involves visiting all the nodes in the expression Ast and\n+\t * ensuring enough state is known about them that bytecode can\n+\t * be generated for them.\n+\t * @param expression the expression to compile\n+\t * @return an instance of the class implementing the compiled expression, or null\n+\t * if compilation is not possible\n+\t */\n+\tpublic CompiledExpression compile(SpelNodeImpl expression) {\n+\t\tif (expression.isCompilable()) {\n+\t\t\tif (verbose) {\n+\t\t\t\tSystem.out.println(\"SpEL: compiling \" + expression.toStringAST());\n+\t\t\t}\n+\t\t\tClass<? extends CompiledExpression> clazz = createExpressionClass(expression);\n+\t\t\ttry {\n+\t\t\t\tCompiledExpression instance = clazz.newInstance();\n+\t\t\t\treturn instance;\n+\t\t\t}\n+\t\t\tcatch (InstantiationException ie) {\n+\t\t\t\tie.printStackTrace();\n+\t\t\t}\n+\t\t\tcatch (IllegalAccessException iae) {\n+\t\t\t\tiae.printStackTrace();\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\tif (verbose) {\n+\t\t\t\tSystem.out.println(\"SpEL: unable to compile \" + expression.toStringAST());\n+\t\t\t}\n+\t\t}\n+\t\treturn null;\n+\t}\n+\n+\tprivate synchronized int getNextSuffix() {\n+\t\treturn suffixId++;\n+\t}\n+\n+\t/**\n+\t * Generate the class that encapsulates the compiled expression and define it. The\n+\t * generated class will be a subtype of CompiledExpression.\n+\t * @param expressionToCompile the expression to be compiled\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprivate Class<? extends CompiledExpression> createExpressionClass(SpelNodeImpl expressionToCompile) {\n+\n+\t\t// Create class outline 'spel/ExNNN extends org.springframework.expression.spel.CompiledExpression'\n+\t\tString clazzName = \"spel/Ex\" + getNextSuffix();\n+\t\tClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_MAXS|ClassWriter.COMPUTE_FRAMES);\n+\t\tcw.visit(V1_5, ACC_PUBLIC, clazzName, null,\n+\t\t\t\t\"org/springframework/expression/spel/CompiledExpression\", null);\n+\n+\t\t// Create default constructor\n+\t\tMethodVisitor mv = cw.visitMethod(ACC_PUBLIC, \"<init>\", \"()V\", null, null);\n+\t\tmv.visitCode();\n+\t\tmv.visitVarInsn(ALOAD, 0);\n+\t\tmv.visitMethodInsn(INVOKESPECIAL, \"org/springframework/expression/spel/CompiledExpression\", \"<init>\", \"()V\",false);\n+\t\tmv.visitInsn(RETURN);\n+\t\tmv.visitMaxs(1, 1);\n+\t\tmv.visitEnd();\n+\n+\t\t// Create getValue() method\n+\t\tmv = cw.visitMethod(ACC_PUBLIC, \"getValue\", \"(Ljava/lang/Object;Lorg/springframework/expression/EvaluationContext;)Ljava/lang/Object;\", null,\n+\t\t\t\tnew String[]{\"org/springframework/expression/EvaluationException\"});\n+\t\tmv.visitCode();\n+\n+\t\tCodeFlow codeflow = new CodeFlow();\n+\n+\t\t// Ask the expression Ast to generate the body of the method\n+\t\texpressionToCompile.generateCode(mv,codeflow);\n+\n+\t\tCodeFlow.insertBoxIfNecessary(mv,codeflow.lastDescriptor());\n+\t\tif (codeflow.lastDescriptor() == \"V\") {\n+\t\t\tmv.visitInsn(ACONST_NULL);\n+\t\t}\n+\t\tmv.visitInsn(ARETURN);\n+\n+\t\tmv.visitMaxs(0,0); // not supplied due to COMPUTE_MAXS\n+\t\tmv.visitEnd();\n+\t\tcw.visitEnd();\n+\t\tbyte[] data = cw.toByteArray();\n+\t\t// TODO need to make this conditionally occur based on a debug flag\n+\t\t// dump(expressionToCompile.toStringAST(), clazzName, data);\n+\t\tClass<? extends CompiledExpression> clazz = (Class<? extends CompiledExpression>) ccl.defineClass(clazzName.replaceAll(\"/\",\".\"),data);\n+\t\treturn clazz;\n+\t}\n+\n+\t/**\n+\t * For debugging purposes, dump the specified byte code into a file on the disk. Not\n+\t * yet hooked in, needs conditionally calling based on a sys prop.\n+\t *\n+\t * @param expressionText the text of the expression compiled\n+\t * @param name the name of the class being used for the compiled expression\n+\t * @param bytecode the bytecode for the generated class\n+\t */\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static void dump(String expressionText, String name, byte[] bytecode) {\n+\t\tname = name.replace('.', '/');\n+\t\tString dir = \"\";\n+\t\tif (name.indexOf('/') != -1) {\n+\t\t\tdir = name.substring(0, name.lastIndexOf('/'));\n+\t\t}\n+\t\tString dumplocation = null;\n+\t\ttry {\n+\t\t\tFile tempfile = null;\n+\t\t\ttempfile = File.createTempFile(\"tmp\", null);\n+\t\t\ttempfile.delete();\n+\t\t\tFile f = new File(tempfile, dir);\n+\t\t\tf.mkdirs();\n+\t\t\tdumplocation = tempfile + File.separator + name + \".class\";\n+\t\t\tSystem.out.println(\"Expression '\" + expressionText + \"' compiled code dumped to \"\n+\t\t\t\t\t+ dumplocation);\n+\t\t\tf = new File(dumplocation);\n+\t\t\tFileOutputStream fos = new FileOutputStream(f);\n+\t\t\tfos.write(bytecode);\n+\t\t\tfos.flush();\n+\t\t\tfos.close();\n+\t\t}\n+\t\tcatch (IOException ioe) {\n+\t\t\tthrow new IllegalStateException(\"Unexpected problem dumping class \"\n+\t\t\t\t\t+ name + \" into \" + dumplocation, ioe);\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * A ChildClassLoader will load the generated compiled expression classes\n+\t */\n+\tpublic static class ChildClassLoader extends URLClassLoader {\n+\n+\t\tprivate static URL[] NO_URLS = new URL[0];\n+\n+\t\tpublic ChildClassLoader(ClassLoader classloader) {\n+\t\t\tsuper(NO_URLS, classloader);\n+\t\t}\n+\n+\t\tpublic Class<?> defineClass(String name, byte[] bytes) {\n+\t\t\treturn super.defineClass(name, bytes, 0, bytes.length);\n+\t\t}\n+\n+\t}\n+\n+\t/**\n+\t * Request that an attempt is made to compile the specified expression. It may fail if\n+\t * components of the expression are not suitable for compilation or the data types\n+\t * involved are not suitable for compilation. Used for testing.\n+\t * @return true if the expression was successfully compiled\n+\t */\n+\tpublic static boolean compile(Expression expression) {\n+\t\tif (expression instanceof SpelExpression) {\n+\t\t\tSpelExpression spelExpression = (SpelExpression)expression;\n+\t\t\treturn spelExpression.compileExpression();\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Request to revert to the interpreter for expression evaluation. Any compiled form\n+\t * is discarded but can be recreated by later recompiling again.\n+\t * @param expression the expression\n+\t */\n+\tpublic static void revertToInterpreted(Expression expression) {\n+\t\tif (expression instanceof SpelExpression) {\n+\t\t\tSpelExpression spelExpression = (SpelExpression)expression;\n+\t\t\tspelExpression.revertToInterpreted();\n+\t\t}\n+\t}\n+}"
        },
        {
            "sha": "7d04a14b310623cb3cb491479edd36f5f251c307",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/standard/SpelExpression.java",
            "status": "modified",
            "additions": 246,
            "deletions": 8,
            "changes": 254,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelExpression.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelExpression.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fstandard%2FSpelExpression.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -22,7 +22,11 @@\n import org.springframework.expression.Expression;\n import org.springframework.expression.TypedValue;\n import org.springframework.expression.common.ExpressionUtils;\n+import org.springframework.expression.spel.CompiledExpression;\n import org.springframework.expression.spel.ExpressionState;\n+import org.springframework.expression.spel.SpelCompilerMode;\n+import org.springframework.expression.spel.SpelEvaluationException;\n+import org.springframework.expression.spel.SpelMessage;\n import org.springframework.expression.spel.SpelNode;\n import org.springframework.expression.spel.SpelParserConfiguration;\n import org.springframework.expression.spel.ast.SpelNodeImpl;\n@@ -42,13 +46,24 @@ public class SpelExpression implements Expression {\n \n \tprivate final String expression;\n \n-\tprivate final SpelNodeImpl ast;\n+\t// Holds the compiled form of the expression (if it has been compiled)\n+\tprivate CompiledExpression compiledAst;\n+\n+\tprivate SpelNodeImpl ast;\n \n \tprivate final SpelParserConfiguration configuration;\n \n \t// the default context is used if no override is supplied by the user\n \tprivate EvaluationContext defaultContext;\n \n+\t// Count of many times as the expression been interpreted - can trigger compilation\n+\t// when certain limit reached\n+\tprivate int interpretedCount = 0;\n+\t\n+\t// The number of times compilation was attempted and failed - enables us to eventually\n+\t// give up trying to compile it when it just doesn't seem to be possible.\n+\tprivate int failedAttempts = 0;\n+\n \n \t/**\n \t * Construct an expression, only used by the parser.\n@@ -64,51 +79,214 @@ public SpelExpression(String expression, SpelNodeImpl ast, SpelParserConfigurati\n \n \t@Override\n \tpublic Object getValue() throws EvaluationException {\n+\t\tObject result = null;\n+\t\tif (compiledAst != null) {\n+\t\t\ttry {\n+\t\t\t\treturn this.compiledAst.getValue(null,null);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n-\t\treturn this.ast.getValue(expressionState);\n+\t\tresult = this.ast.getValue(expressionState);\n+\t\tcheckCompile(expressionState);\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic Object getValue(Object rootObject) throws EvaluationException {\n+\t\tObject result = null;\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\treturn this.compiledAst.getValue(rootObject,null);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n-\t\treturn this.ast.getValue(expressionState);\n+\t\tresult = this.ast.getValue(expressionState);\n+\t\tcheckCompile(expressionState);\n+\t\treturn result;\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tpublic <T> T getValue(Class<T> expectedResultType) throws EvaluationException {\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\tObject result = this.compiledAst.getValue(null,null);\n+\t\t\t\tif (expectedResultType == null) {\n+\t\t\t\t\treturn (T)result;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ExpressionUtils.convertTypedValue(getEvaluationContext(), new TypedValue(result), expectedResultType);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), this.configuration);\n \t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n+\t\tcheckCompile(expressionState);\n \t\treturn ExpressionUtils.convertTypedValue(expressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tpublic <T> T getValue(Object rootObject, Class<T> expectedResultType) throws EvaluationException {\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\tObject result = this.compiledAst.getValue(rootObject,null);\n+\t\t\t\tif (expectedResultType == null) {\n+\t\t\t\t\treturn (T)result;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ExpressionUtils.convertTypedValue(getEvaluationContext(), new TypedValue(result), expectedResultType);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n \t\tExpressionState expressionState = new ExpressionState(getEvaluationContext(), toTypedValue(rootObject), this.configuration);\n \t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n+\t\tcheckCompile(expressionState);\n \t\treturn ExpressionUtils.convertTypedValue(expressionState.getEvaluationContext(), typedResultValue, expectedResultType);\n \t}\n \n \t@Override\n \tpublic Object getValue(EvaluationContext context) throws EvaluationException {\n \t\tAssert.notNull(context, \"The EvaluationContext is required\");\n-\t\treturn this.ast.getValue(new ExpressionState(context, this.configuration));\n+\t\tif (compiledAst!= null) {\n+\t\t\ttry {\n+\t\t\t\tObject result = this.compiledAst.getValue(null,context);\n+\t\t\t\treturn result;\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n+\t\tObject result = this.ast.getValue(expressionState);\n+\t\tcheckCompile(expressionState);\n+\t\treturn result;\n \t}\n \n \t@Override\n \tpublic Object getValue(EvaluationContext context, Object rootObject) throws EvaluationException {\n \t\tAssert.notNull(context, \"The EvaluationContext is required\");\n-\t\treturn this.ast.getValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\treturn this.compiledAst.getValue(rootObject,context);\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n+\t\tObject result = this.ast.getValue(expressionState);\n+\t\tcheckCompile(expressionState);\n+\t\treturn result;\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tpublic <T> T getValue(EvaluationContext context, Class<T> expectedResultType) throws EvaluationException {\n-\t\tTypedValue typedResultValue = this.ast.getTypedValue(new ExpressionState(context, this.configuration));\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\tObject result = this.compiledAst.getValue(null,context);\n+\t\t\t\tif (expectedResultType!=null) {\n+\t\t\t\t\treturn (T) result;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tExpressionState expressionState = new ExpressionState(context, this.configuration);\n+\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n+\t\tcheckCompile(expressionState);\n \t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n \t}\n \n+\t@SuppressWarnings(\"unchecked\")\n \t@Override\n \tpublic <T> T getValue(EvaluationContext context, Object rootObject, Class<T> expectedResultType) throws EvaluationException {\n-\t\tTypedValue typedResultValue = this.ast.getTypedValue(new ExpressionState(context, toTypedValue(rootObject), this.configuration));\n+\t\tif (compiledAst!=null) {\n+\t\t\ttry {\n+\t\t\t\tObject result = this.compiledAst.getValue(rootObject,context);\n+\t\t\t\tif (expectedResultType!=null) {\n+\t\t\t\t\treturn (T) result;\n+\t\t\t\t} else {\n+\t\t\t\t\treturn ExpressionUtils.convertTypedValue(context, new TypedValue(result), expectedResultType);\n+\t\t\t\t}\n+\t\t\t} catch (Throwable t) {\n+\t\t\t\t// If running in mixed mode, revert to interpreted\n+\t\t\t\tif (this.configuration.getCompilerMode() == SpelCompilerMode.mixed) {\n+\t\t\t\t\tinterpretedCount = 0;\n+\t\t\t\t\tcompiledAst = null;\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// Running in SpelCompilerMode.immediate mode - propagate exception to caller\n+\t\t\t\t\tthrow new SpelEvaluationException(t,SpelMessage.EXCEPTION_RUNNING_COMPILED_EXPRESSION);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tExpressionState expressionState = new ExpressionState(context, toTypedValue(rootObject), this.configuration);\n+\t\tTypedValue typedResultValue = this.ast.getTypedValue(expressionState);\n+\t\tcheckCompile(expressionState);\n \t\treturn ExpressionUtils.convertTypedValue(context, typedResultValue, expectedResultType);\n \t}\n \n@@ -203,6 +381,66 @@ public void setValue(EvaluationContext context, Object rootObject, Object value)\n \n \t// impl only\n \n+\t/**\n+\t * Compile the expression if it has been evaluated more than the threshold number of times to trigger compilation.\n+\t * @param expressionState the expression state used to determine compilation mode\n+\t */\n+\tprivate void checkCompile(ExpressionState expressionState) {\n+\t\tinterpretedCount++;\n+\t\tSpelCompilerMode compilerMode = expressionState.getConfiguration().getCompilerMode();\n+\t\tif (compilerMode != SpelCompilerMode.off) {\n+\t\t\tif (compilerMode == SpelCompilerMode.immediate) {\n+\t\t\t\tif (interpretedCount > 1) {\n+\t\t\t\t\tcompileExpression();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\t// compilerMode = SpelCompilerMode.mixed\n+\t\t\t\tif (interpretedCount > SpelCompiler.interpretedCountThreshold) {\n+\t\t\t\t\tcompileExpression();\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\n+\t/**\n+\t * Perform expression compilation. This will only succeed once exit descriptors for all nodes have \n+\t * been determined. If the compilation fails and has failed more than 100 times the expression is \n+\t * no longer considered suitable for compilation.\n+\t */\n+\tpublic boolean compileExpression() {\n+\t\tif (failedAttempts > 100) {\n+\t\t\t// Don't try again\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (this.compiledAst == null) {\n+\t\t\tsynchronized (expression) {\n+\t\t\t\t// Possibly compiled by another thread before this thread got into the\n+\t\t\t\t// sync block\n+\t\t\t\tif (this.compiledAst != null) {\n+\t\t\t\t\treturn true;\n+\t\t\t\t}\n+\t\t\t\tthis.compiledAst = SpelCompiler.getCompiler().compile(this.ast);\n+\t\t\t\tif (this.compiledAst == null) {\n+\t\t\t\t\tfailedAttempts++;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\treturn (this.compiledAst != null);\n+\t}\n+\n+\t/**\n+\t * Cause an expression to revert to being interpreted if it has been using a compiled\n+\t * form. It also resets the compilation attempt failure count (an expression is normally no\n+\t * longer considered compilable if it cannot be compiled after 100 attempts).\n+\t */\n+\tpublic void revertToInterpreted() {\n+\t\tthis.compiledAst = null;\n+\t\tthis.interpretedCount = 0;\n+\t\tthis.failedAttempts = 0;\n+\t}\n+\n \t/**\n \t * @return return the Abstract Syntax Tree for the expression\n \t */"
        },
        {
            "sha": "263bceed7a0fca93d4e7219daebed533f003170b",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectionHelper.java",
            "status": "modified",
            "additions": 14,
            "deletions": 5,
            "changes": 19,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectionHelper.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectionHelper.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectionHelper.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -228,38 +228,44 @@ else if (typeConverter.canConvert(suppliedArg, TypeDescriptor.valueOf(varargsPar\n \t * @param arguments the actual arguments that need conversion\n \t * @param methodOrCtor the target Method or Constructor\n \t * @param varargsPosition the known position of the varargs argument, if any\n+\t * @return true if some kind of conversion occurred on an argument\n \t * @throws EvaluationException if a problem occurs during conversion\n \t */\n-\tstatic void convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,\n+\tstatic boolean convertArguments(TypeConverter converter, Object[] arguments, Object methodOrCtor,\n \t\t\tInteger varargsPosition) throws EvaluationException {\n-\n+\t\tboolean conversionOccurred = false;\n \t\tif (varargsPosition == null) {\n \t\t\tfor (int i = 0; i < arguments.length; i++) {\n \t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i));\n \t\t\t\tObject argument = arguments[i];\n \t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n+\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n \t\t\t}\n \t\t}\n \t\telse {\n \t\t\tfor (int i = 0; i < varargsPosition; i++) {\n \t\t\t\tTypeDescriptor targetType = new TypeDescriptor(MethodParameter.forMethodOrConstructor(methodOrCtor, i));\n \t\t\t\tObject argument = arguments[i];\n \t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n+\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n \t\t\t}\n \t\t\tMethodParameter methodParam = MethodParameter.forMethodOrConstructor(methodOrCtor, varargsPosition);\n \t\t\tif (varargsPosition == arguments.length - 1) {\n \t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam);\n \t\t\t\tObject argument = arguments[varargsPosition];\n \t\t\t\targuments[varargsPosition] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n+\t\t\t\tconversionOccurred |= (argument != arguments[varargsPosition]);\n \t\t\t}\n \t\t\telse {\n \t\t\t\tTypeDescriptor targetType = new TypeDescriptor(methodParam).getElementTypeDescriptor();\n \t\t\t\tfor (int i = varargsPosition; i < arguments.length; i++) {\n \t\t\t\t\tObject argument = arguments[i];\n \t\t\t\t\targuments[i] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n+\t\t\t\t\tconversionOccurred |= (argument != arguments[i]);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn conversionOccurred;\n \t}\n \n \t/**\n@@ -272,15 +278,16 @@ static void convertArguments(TypeConverter converter, Object[] arguments, Object\n \t * @param converter the converter to use for type conversions\n \t * @param arguments the arguments to convert to the requested parameter types\n \t * @param method the target Method\n+\t * @return true if some kind of conversion occurred on the argument\n \t * @throws SpelEvaluationException if there is a problem with conversion\n \t */\n-\tpublic static void convertAllArguments(TypeConverter converter, Object[] arguments, Method method)\n-\t\t\tthrows SpelEvaluationException {\n-\n+\tpublic static boolean convertAllArguments(TypeConverter converter, Object[] arguments, Method method) throws SpelEvaluationException {\n \t\tInteger varargsPosition = null;\n+\t\tboolean conversionOccurred = false;\n \t\tif (method.isVarArgs()) {\n \t\t\tClass<?>[] paramTypes = method.getParameterTypes();\n \t\t\tvarargsPosition = paramTypes.length - 1;\n+\t\t\tconversionOccurred = true;\n \t\t}\n \t\tfor (int argPos = 0; argPos < arguments.length; argPos++) {\n \t\t\tTypeDescriptor targetType;\n@@ -299,6 +306,7 @@ public static void convertAllArguments(TypeConverter converter, Object[] argumen\n \t\t\t\t\t\t\t\tSpelMessage.TYPE_CONVERSION_ERROR, argument.getClass().getName(), targetType);\n \t\t\t\t\t}\n \t\t\t\t\targuments[argPos] = converter.convertValue(argument, TypeDescriptor.forObject(argument), targetType);\n+\t\t\t\t\tconversionOccurred |= (argument != arguments[argPos]);\n \t\t\t\t}\n \t\t\t}\n \t\t\tcatch (EvaluationException ex) {\n@@ -312,6 +320,7 @@ public static void convertAllArguments(TypeConverter converter, Object[] argumen\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\t\treturn conversionOccurred;\n \t}\n \n \t/**"
        },
        {
            "sha": "645f0a3fe31b9c0e8b632888409c39ee9ba8f1e0",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveConstructorExecutor.java",
            "status": "modified",
            "additions": 6,
            "deletions": 2,
            "changes": 8,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveConstructorExecutor.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveConstructorExecutor.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveConstructorExecutor.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2013 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -32,7 +32,7 @@\n  * @author Juergen Hoeller\n  * @since 3.0\n  */\n-class ReflectiveConstructorExecutor implements ConstructorExecutor {\n+public class ReflectiveConstructorExecutor implements ConstructorExecutor {\n \n \tprivate final Constructor<?> ctor;\n \n@@ -67,4 +67,8 @@ public TypedValue execute(EvaluationContext context, Object... arguments) throws\n \t\t}\n \t}\n \n+\tpublic Constructor<?> getConstructor() {\n+\t\treturn this.ctor;\n+\t}\n+\n }"
        },
        {
            "sha": "f9955479378553a559f43bc33e5e3e1f4677a7a6",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectiveMethodExecutor.java",
            "status": "modified",
            "additions": 12,
            "deletions": 3,
            "changes": 15,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveMethodExecutor.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveMethodExecutor.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectiveMethodExecutor.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -1,5 +1,5 @@\n /*\n- * Copyright 2002-2012 the original author or authors.\n+ * Copyright 2002-2014 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n@@ -31,12 +31,13 @@\n  * @author Juergen Hoeller\n  * @since 3.0\n  */\n-class ReflectiveMethodExecutor implements MethodExecutor {\n+public class ReflectiveMethodExecutor implements MethodExecutor {\n \n \tprivate final Method method;\n \n \tprivate final Integer varargsPosition;\n \n+\tprivate boolean argumentConversionOccurred = false;\n \n \tpublic ReflectiveMethodExecutor(Method method) {\n \t\tthis.method = method;\n@@ -49,12 +50,20 @@ public ReflectiveMethodExecutor(Method method) {\n \t\t}\n \t}\n \n+\tpublic Method getMethod() {\n+\t\treturn this.method;\n+\t}\n+\t\n+\tpublic boolean didArgumentConversionOccur() {\n+\t\treturn this.argumentConversionOccurred;\n+\t}\n+\n \n \t@Override\n \tpublic TypedValue execute(EvaluationContext context, Object target, Object... arguments) throws AccessException {\n \t\ttry {\n \t\t\tif (arguments != null) {\n-\t\t\t\tReflectionHelper.convertArguments(context.getTypeConverter(), arguments, this.method, this.varargsPosition);\n+\t\t\t\tthis.argumentConversionOccurred = ReflectionHelper.convertArguments(context.getTypeConverter(), arguments, this.method, this.varargsPosition);\n \t\t\t}\n \t\t\tif (this.method.isVarArgs()) {\n \t\t\t\targuments = ReflectionHelper.setupArgumentsForVarargsInvocation(this.method.getParameterTypes(), arguments);"
        },
        {
            "sha": "32d06fb40a721fdddd701f8ee2fb8ceca5a7607d",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/support/ReflectivePropertyAccessor.java",
            "status": "modified",
            "additions": 55,
            "deletions": 2,
            "changes": 57,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectivePropertyAccessor.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectivePropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fsupport%2FReflectivePropertyAccessor.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -29,15 +29,19 @@\n import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n \n+import org.springframework.asm.MethodVisitor;\n import org.springframework.core.MethodParameter;\n import org.springframework.core.convert.Property;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.core.style.ToStringCreator;\n import org.springframework.expression.AccessException;\n+import org.springframework.expression.CompilablePropertyAccessor;\n import org.springframework.expression.EvaluationContext;\n import org.springframework.expression.EvaluationException;\n import org.springframework.expression.PropertyAccessor;\n import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.ast.PropertyOrFieldReference;\n+import org.springframework.expression.spel.standard.CodeFlow;\n import org.springframework.util.ReflectionUtils;\n import org.springframework.util.StringUtils;\n \n@@ -72,6 +76,7 @@ public class ReflectivePropertyAccessor implements PropertyAccessor {\n \n \tprivate final Map<CacheKey, TypeDescriptor> typeDescriptorCache = new ConcurrentHashMap<CacheKey, TypeDescriptor>(64);\n \n+\tprivate InvokerPair lastReadInvokerPair;\n \n \t/**\n \t * Returns {@code null} which means this is a general purpose accessor.\n@@ -115,6 +120,10 @@ public boolean canRead(EvaluationContext context, Object target, String name) th\n \t\t}\n \t\treturn false;\n \t}\n+\t\n+\tpublic Member getLastReadInvokerPair() {\n+\t\treturn lastReadInvokerPair.member;\n+\t}\n \n \t@Override\n \tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n@@ -132,6 +141,7 @@ public TypedValue read(EvaluationContext context, Object target, String name) th\n \n \t\tCacheKey cacheKey = new CacheKey(type, name, target instanceof Class);\n \t\tInvokerPair invoker = this.readerCache.get(cacheKey);\n+\t\tlastReadInvokerPair = invoker;\n \n \t\tif (invoker == null || invoker.member instanceof Method) {\n \t\t\tMethod method = (Method) (invoker != null ? invoker.member : null);\n@@ -144,6 +154,7 @@ public TypedValue read(EvaluationContext context, Object target, String name) th\n \t\t\t\t\tProperty property = new Property(type, method, null);\n \t\t\t\t\tTypeDescriptor typeDescriptor = new TypeDescriptor(property);\n \t\t\t\t\tinvoker = new InvokerPair(method, typeDescriptor);\n+\t\t\t\t\tlastReadInvokerPair = invoker;\n \t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n \t\t\t\t}\n \t\t\t}\n@@ -165,6 +176,7 @@ public TypedValue read(EvaluationContext context, Object target, String name) th\n \t\t\t\tfield = findField(name, type, target);\n \t\t\t\tif (field != null) {\n \t\t\t\t\tinvoker = new InvokerPair(field, new TypeDescriptor(field));\n+\t\t\t\t\tlastReadInvokerPair = invoker;\n \t\t\t\t\tthis.readerCache.put(cacheKey, invoker);\n \t\t\t\t}\n \t\t\t}\n@@ -557,9 +569,9 @@ public String toString() {\n \t * accessor exists because looking up the appropriate reflective object by class/name\n \t * on each read is not cheap.\n \t */\n-\tprivate static class OptimalPropertyAccessor implements PropertyAccessor {\n+\tpublic static class OptimalPropertyAccessor implements CompilablePropertyAccessor {\n \n-\t\tprivate final Member member;\n+\t\tpublic final Member member;\n \n \t\tprivate final TypeDescriptor typeDescriptor;\n \n@@ -637,6 +649,16 @@ public TypedValue read(EvaluationContext context, Object target, String name) th\n \t\t\t}\n \t\t\tthrow new AccessException(\"Neither getter nor field found for property '\" + name + \"'\");\n \t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic Class<?> getPropertyType() {\n+\t\t\tif (member instanceof Field) {\n+\t\t\t\treturn ((Field)member).getType();\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\treturn ((Method)member).getReturnType();\n+\t\t\t}\n+\t\t}\n \n \t\t@Override\n \t\tpublic boolean canWrite(EvaluationContext context, Object target, String name) {\n@@ -647,6 +669,37 @@ public boolean canWrite(EvaluationContext context, Object target, String name) {\n \t\tpublic void write(EvaluationContext context, Object target, String name, Object newValue) {\n \t\t\tthrow new UnsupportedOperationException(\"Should not be called on an OptimalPropertyAccessor\");\n \t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean isCompilable() {\n+\t\t\t// If non public must continue to use reflection\n+\t\t\tif (!Modifier.isPublic(member.getModifiers()) || !Modifier.isPublic(member.getDeclaringClass().getModifiers())) {\n+\t\t\t\treturn false;\n+\t\t\t}\n+\t\t\treturn true;\n+\t\t}\n+\t\t \n+\t\t@Override\n+\t\tpublic void generateCode(PropertyOrFieldReference propertyReference, MethodVisitor mv,CodeFlow codeflow) {\n+\t\t\tboolean isStatic = Modifier.isStatic(member.getModifiers());\n+\n+\t\t\tString descriptor = codeflow.lastDescriptor();\n+\t\t\tString memberDeclaringClassSlashedDescriptor = member.getDeclaringClass().getName().replace('.','/');\n+\t\t\tif (!isStatic) {\n+\t\t\t\tif (descriptor == null) {\n+\t\t\t\t\tcodeflow.loadTarget(mv);\n+\t\t\t\t}\n+\t\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n+\t\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\tif (member instanceof Field) {\n+\t\t\t\tmv.visitFieldInsn(isStatic?GETSTATIC:GETFIELD,memberDeclaringClassSlashedDescriptor,member.getName(),CodeFlow.toJVMDescriptor(((Field) member).getType()));\n+\t\t\t} else {\n+\t\t\t\tmv.visitMethodInsn(isStatic?INVOKESTATIC:INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor, member.getName(),CodeFlow.createSignatureDescriptor((Method)member),false);\n+\t\t\t}\n+\t\t}\n+\n \t}\n \n }"
        },
        {
            "sha": "19e27f46c4e2992a577e36cc6d798b6e2b8d5772",
            "filename": "spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java",
            "status": "added",
            "additions": 2603,
            "deletions": 0,
            "changes": 2603,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,2603 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression.spel;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.StringTokenizer;\n+\n+import org.junit.Test;\n+import org.springframework.asm.MethodVisitor;\n+import org.springframework.expression.AccessException;\n+import org.springframework.expression.CompilablePropertyAccessor;\n+import org.springframework.expression.EvaluationContext;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.TypedValue;\n+import org.springframework.expression.spel.ast.CompoundExpression;\n+import org.springframework.expression.spel.ast.OpLT;\n+import org.springframework.expression.spel.ast.PropertyOrFieldReference;\n+import org.springframework.expression.spel.ast.SpelNodeImpl;\n+import org.springframework.expression.spel.ast.Ternary;\n+import org.springframework.expression.spel.standard.CodeFlow;\n+import org.springframework.expression.spel.standard.SpelCompiler;\n+import org.springframework.expression.spel.standard.SpelExpression;\n+import org.springframework.expression.spel.support.StandardEvaluationContext;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Checks the behaviour of the SpelCompiler. This should cover compilation all compiled node types.\n+ *\n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+public class SpelCompilationCoverageTests extends AbstractExpressionTests {\n+\t\n+\tprivate Expression expression;\n+\tprivate SpelNodeImpl ast;\n+\t\n+\t/*\n+\t * Further TODOs for compilation:\n+\t * \n+\t * - OpMinus with a single literal operand could be treated as a negative literal. Will save a\n+\t *   pointless loading of 0 and then a subtract instruction in code gen.\n+\t * - allow other accessors/resolvers to participate in compilation and create their own code\n+\t * - A TypeReference followed by (what ends up as) a static method invocation can really skip\n+\t *   code gen for the TypeReference since once that is used to locate the method it is not\n+\t *   used again.\n+\t * - The opEq implementation is quite basic. It will compare numbers of the same type (allowing\n+\t *   them to be their boxed or unboxed variants) or compare object references. It does not\n+\t *   compile expressions where numbers are of different types or when objects implement\n+\t *   Comparable.  \n+     *\n+\t * Compiled nodes:\n+\t * \n+\t * TypeReference\n+\t * OperatorInstanceOf\n+\t * StringLiteral\n+\t * NullLiteral\n+\t * RealLiteral\n+\t * IntLiteral\n+\t * LongLiteral\n+\t * BooleanLiteral\n+\t * FloatLiteral\n+\t * OpOr\n+\t * OpAnd\n+\t * OperatorNot\n+\t * Ternary\n+\t * Elvis\n+\t * VariableReference\n+\t * OpLt\n+\t * OpLe\n+\t * OpGt\n+\t * OpGe\n+\t * OpEq\n+\t * OpNe\n+\t * OpPlus\n+\t * OpMinus\n+\t * OpMultiply\n+\t * OpDivide\n+\t * MethodReference\n+\t * PropertyOrFieldReference\n+\t * Indexer\n+\t * CompoundExpression\n+\t * ConstructorReference\n+\t * FunctionReference\n+\t * \n+\t * Not yet compiled (some may never need to be):\n+\t * Assign\n+\t * BeanReference\n+\t * Identifier\n+\t * InlineList\n+\t * OpDec\n+\t * OpBetween\n+\t * OpMatches\n+\t * OpPower\n+\t * OpInc\n+\t * OpModulus\n+\t * Projection\n+\t * QualifiedId\n+\t * Selection\n+\t */\n+\t\n+\t@Test\n+\tpublic void typeReference() throws Exception {\n+\t\texpression = parse(\"T(String)\");\n+\t\tassertEquals(String.class,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(String.class,expression.getValue());\n+\t\t \n+\t\texpression = parse(\"T(java.io.IOException)\");\n+\t\tassertEquals(IOException.class,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(IOException.class,expression.getValue());\n+\n+\t\texpression = parse(\"T(java.io.IOException[])\");\n+\t\tassertEquals(IOException[].class,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(IOException[].class,expression.getValue());\n+\n+\t\texpression = parse(\"T(int[][])\");\n+\t\tassertEquals(int[][].class,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(int[][].class,expression.getValue());\n+\n+\t\texpression = parse(\"T(int)\");\n+\t\tassertEquals(Integer.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Integer.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(byte)\");\n+\t\tassertEquals(Byte.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Byte.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(char)\");\n+\t\tassertEquals(Character.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Character.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(short)\");\n+\t\tassertEquals(Short.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Short.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(long)\");\n+\t\tassertEquals(Long.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Long.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(float)\");\n+\t\tassertEquals(Float.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Float.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(double)\");\n+\t\tassertEquals(Double.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Double.TYPE,expression.getValue());\n+\n+\t\texpression = parse(\"T(boolean)\");\n+\t\tassertEquals(Boolean.TYPE,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(Boolean.TYPE,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Missing)\");\n+\t\tassertGetValueFail(expression);\n+\t\tassertCantCompile(expression);\n+\t}\n+\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Test\n+\tpublic void operatorInstanceOf() throws Exception {\n+\t\texpression = parse(\"'xyz' instanceof T(String)\");\n+\t\tassertEquals(true,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue());\n+\n+\t\texpression = parse(\"'xyz' instanceof T(Integer)\");\n+\t\tassertEquals(false,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(false,expression.getValue());\n+\n+\t\tList<String> list = new ArrayList<String>();\n+\t\texpression = parse(\"#root instanceof T(java.util.List)\");\n+\t\tassertEquals(true,expression.getValue(list));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue(list));\n+\n+\t\tList<String>[] arrayOfLists = new List[]{new ArrayList<String>()};\n+\t\texpression = parse(\"#root instanceof T(java.util.List[])\");\n+\t\tassertEquals(true,expression.getValue(arrayOfLists));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue(arrayOfLists));\n+\t\t\n+\t\tint[] intArray = new int[]{1,2,3};\n+\t\texpression = parse(\"#root instanceof T(int[])\");\n+\t\tassertEquals(true,expression.getValue(intArray));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue(intArray));\n+\n+\t\tString root = null;\n+\t\texpression = parse(\"#root instanceof T(Integer)\");\n+\t\tassertEquals(false,expression.getValue(root));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(false,expression.getValue(root));\n+\n+\t\t// root still null\n+\t\texpression = parse(\"#root instanceof T(java.lang.Object)\");\n+\t\tassertEquals(false,expression.getValue(root));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(false,expression.getValue(root));\n+\n+\t\troot = \"howdy!\";\n+\t\texpression = parse(\"#root instanceof T(java.lang.Object)\");\n+\t\tassertEquals(true,expression.getValue(root));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue(root));\n+\t}\n+\n+\t@Test\n+\tpublic void stringLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"'abcde'\");\t\t\n+\t\tassertEquals(\"abcde\",expression.getValue(new TestClass1(),String.class));\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(new TestClass1(),String.class);\n+\t\tassertEquals(\"abcde\",resultC);\n+\t\tassertEquals(\"abcde\",expression.getValue(String.class));\n+\t\tassertEquals(\"abcde\",expression.getValue());\n+\t\tassertEquals(\"abcde\",expression.getValue(new StandardEvaluationContext()));\n+\t\texpression = parser.parseExpression(\"\\\"abcde\\\"\");\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"abcde\",expression.getValue(String.class));\n+\t}\n+\t\n+\t@Test\n+\tpublic void nullLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"null\");\n+\t\tObject resultI = expression.getValue(new TestClass1(),Object.class);\n+\t\tassertCanCompile(expression);\n+\t\tObject resultC = expression.getValue(new TestClass1(),Object.class);\n+\t\tassertEquals(null,resultI);\n+\t\tassertEquals(null,resultC);\n+\t}\n+\t\n+\t@Test\n+\tpublic void realLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"3.4d\");\n+\t\tdouble resultI = expression.getValue(new TestClass1(),Double.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tdouble resultC = expression.getValue(new TestClass1(),Double.TYPE);\n+\t\tassertEquals(3.4d,resultI,0.1d);\n+\t\tassertEquals(3.4d,resultC,0.1d);\n+\n+\t\tassertEquals(3.4d,expression.getValue());\n+\t}\n+\n+\t@Test\n+\tpublic void intLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"42\");\n+\t\tint resultI = expression.getValue(new TestClass1(),Integer.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tint resultC = expression.getValue(new TestClass1(),Integer.TYPE);\n+\t\tassertEquals(42,resultI);\n+\t\tassertEquals(42,resultC);\n+\n+\t\texpression = parser.parseExpression(\"T(Integer).valueOf(42)\");\n+\t\texpression.getValue(Integer.class);\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(new Integer(42),expression.getValue(null,Integer.class));\n+\t\t\n+\t\t// Code gen is different for -1 .. 6 because there are bytecode instructions specifically for those\n+\t\t// values\n+\t\t\n+\t\t// Not an int literal but an opminus with one operand:\n+//\t\texpression = parser.parseExpression(\"-1\");\n+//\t\tassertCanCompile(expression);\n+//\t\tassertEquals(-1,expression.getValue());\n+\t\texpression = parser.parseExpression(\"0\");\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(0,expression.getValue());\n+\t\texpression = parser.parseExpression(\"2\");\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue());\n+\t\texpression = parser.parseExpression(\"7\");\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(7,expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void longLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"99L\");\n+\t\tlong resultI = expression.getValue(new TestClass1(),Long.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tlong resultC = expression.getValue(new TestClass1(),Long.TYPE);\n+\t\tassertEquals(99L,resultI);\n+\t\tassertEquals(99L,resultC);\t\t\n+\t}\n+\t\t\n+\t@Test\n+\tpublic void booleanLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"true\");\n+\t\tboolean resultI = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertTrue(SpelCompiler.compile(expression));\n+\t\tboolean resultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"false\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultI);\n+\t\tassertTrue(SpelCompiler.compile(expression));\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultC);\n+\t}\n+\t\n+\t@Test\n+\tpublic void floatLiteral() throws Exception {\n+\t\texpression = parser.parseExpression(\"3.4f\");\n+\t\tfloat resultI = expression.getValue(new TestClass1(),Float.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tfloat resultC = expression.getValue(new TestClass1(),Float.TYPE);\n+\t\tassertEquals(3.4f,resultI,0.1f);\n+\t\tassertEquals(3.4f,resultC,0.1f);\n+\n+\t\tassertEquals(3.4f,expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void opOr() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"false or false\");\n+\t\tboolean resultI = expression.getValue(1,Boolean.TYPE);\n+\t\tSpelCompiler.compile(expression);\n+\t\tboolean resultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultI);\n+\t\tassertEquals(false,resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"false or true\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertEquals(true,resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"true or false\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertEquals(true,resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"true or true\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertEquals(true,resultC);\n+\n+\t\tTestClass4 tc = new TestClass4();\n+\t\texpression = parser.parseExpression(\"getfalse() or gettrue()\");\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertEquals(true,resultC);\n+\n+\t\t// Can't compile this as we aren't going down the getfalse() branch in our evaluation\n+\t\texpression = parser.parseExpression(\"gettrue() or getfalse()\");\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parser.parseExpression(\"getA() or getB()\");\n+\t\ttc.a = true;\n+\t\ttc.b = true;\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCantCompile(expression); // Haven't yet been into second branch\n+\t\ttc.a = false;\n+\t\ttc.b = true;\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCanCompile(expression); // Now been down both\n+\t\tassertTrue(resultI);\n+\t\t\n+\t\tboolean b = false;\n+\t\texpression = parse(\"#root or #root\");\n+\t\tObject resultI2 = expression.getValue(b);\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)resultI2);\n+\t\tassertFalse((Boolean)expression.getValue(b));\n+\t}\n+\t\n+\t@Test\n+\tpublic void opAnd() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"false and false\");\n+\t\tboolean resultI = expression.getValue(1,Boolean.TYPE);\n+\t\tSpelCompiler.compile(expression);\n+\t\tboolean resultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultI);\n+\t\tassertEquals(false,resultC);\n+\n+\t\texpression = parser.parseExpression(\"false and true\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tSpelCompiler.compile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultI);\n+\t\tassertEquals(false,resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"true and false\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tSpelCompiler.compile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(false,resultI);\n+\t\tassertEquals(false,resultC);\n+\n+\t\texpression = parser.parseExpression(\"true and true\");\n+\t\tresultI = expression.getValue(1,Boolean.TYPE);\n+\t\tSpelCompiler.compile(expression);\n+\t\tresultC = expression.getValue(1,Boolean.TYPE);\n+\t\tassertEquals(true,resultI);\n+\t\tassertEquals(true,resultC);\n+\t\t\n+\t\tTestClass4 tc = new TestClass4();\n+\n+\t\t// Can't compile this as we aren't going down the gettrue() branch in our evaluation\n+\t\texpression = parser.parseExpression(\"getfalse() and gettrue()\");\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parser.parseExpression(\"getA() and getB()\");\n+\t\ttc.a = false;\n+\t\ttc.b = false;\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCantCompile(expression); // Haven't yet been into second branch\n+\t\ttc.a = true;\n+\t\ttc.b = false;\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertCanCompile(expression); // Now been down both\n+\t\tassertFalse(resultI);\n+\t\ttc.a = true;\n+\t\ttc.b = true;\n+\t\tresultI = expression.getValue(tc,Boolean.TYPE);\n+\t\tassertTrue(resultI);\n+\t\t\n+\t\tboolean b = true;\n+\t\texpression = parse(\"#root and #root\");\n+\t\tObject resultI2 = expression.getValue(b);\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)resultI2);\n+\t\tassertTrue((Boolean)expression.getValue(b));\n+\t}\n+\t\n+\t@Test\n+\tpublic void operatorNot() throws Exception {\n+\t\texpression = parse(\"!true\");\n+\t\tassertEquals(false,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(false,expression.getValue());\n+\n+\t\texpression = parse(\"!false\");\n+\t\tassertEquals(true,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue());\n+\n+\t\tboolean b = true;\n+\t\texpression = parse(\"!#root\");\n+\t\tassertEquals(false,expression.getValue(b));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(false,expression.getValue(b));\n+\n+\t\tb = false;\n+\t\texpression = parse(\"!#root\");\n+\t\tassertEquals(true,expression.getValue(b));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(true,expression.getValue(b));\n+\t}\n+\n+\t@Test\n+\tpublic void ternary() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"true?'a':'b'\");\n+\t\tString resultI = expression.getValue(String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(String.class);\n+\t\tassertEquals(\"a\",resultI);\n+\t\tassertEquals(\"a\",resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"false?'a':'b'\");\n+\t\tresultI = expression.getValue(String.class);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(String.class);\n+\t\tassertEquals(\"b\",resultI);\n+\t\tassertEquals(\"b\",resultC);\n+\n+\t\texpression = parser.parseExpression(\"false?1:'b'\");\n+\t\t// All literals so we can do this straight away\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"b\",expression.getValue());\n+\n+\t\tboolean root = true;\n+\t\texpression = parser.parseExpression(\"(#root and true)?T(Integer).valueOf(1):T(Long).valueOf(3L)\");\n+\t\tassertEquals(1,expression.getValue(root));\n+\t\tassertCantCompile(expression); // Have not gone down false branch\n+\t\troot = false;\n+\t\tassertEquals(3L,expression.getValue(root));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(3L,expression.getValue(root));\n+\t\troot = true;\n+\t\tassertEquals(1,expression.getValue(root));\t\t\n+\t}\n+\t\n+\t@Test\n+\tpublic void elvis() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"'a'?:'b'\");\n+\t\tString resultI = expression.getValue(String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(String.class);\n+\t\tassertEquals(\"a\",resultI);\n+\t\tassertEquals(\"a\",resultC);\n+\t\t\n+\t\texpression = parser.parseExpression(\"null?:'a'\");\n+\t\tresultI = expression.getValue(String.class);\n+\t\tassertCanCompile(expression);\n+\t\tresultC = expression.getValue(String.class);\n+\t\tassertEquals(\"a\",resultI);\n+\t\tassertEquals(\"a\",resultC);\n+\t\t\n+\t\tString s = \"abc\";\n+\t\texpression = parser.parseExpression(\"#root?:'b'\");\n+\t\tassertCantCompile(expression);\n+\t\tresultI = expression.getValue(s,String.class);\n+\t\tassertEquals(\"abc\",resultI);\n+\t\tassertCanCompile(expression);\n+\t}\n+\t\n+\t@Test\n+\tpublic void variableReference_root() throws Exception {\n+\t\tString s = \"hello\";\n+\t\tExpression expression = parser.parseExpression(\"#root\");\n+\t\tString resultI = expression.getValue(s,String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(s,String.class);\n+\t\tassertEquals(s,resultI);\n+\t\tassertEquals(s,resultC);\t\t\n+\n+\t\texpression = parser.parseExpression(\"#root\");\n+\t\tint i = (Integer)expression.getValue(42);\n+\t\tassertEquals(42,i);\n+\t\tassertCanCompile(expression);\n+\t\ti = (Integer)expression.getValue(42);\n+\t\tassertEquals(42,i);\n+\t}\n+\t\n+\tpublic static String concat(String a, String b) {\n+\t\treturn a+b;\n+\t}\n+\t\n+\t@Test\n+\tpublic void functionReference() throws Exception {\n+\t\tEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tMethod m = this.getClass().getDeclaredMethod(\"concat\",String.class,String.class);\n+\t\tctx.setVariable(\"concat\",m);\n+\t\t\n+\t\texpression = parser.parseExpression(\"#concat('a','b')\");\n+\t\tassertEquals(\"ab\",expression.getValue(ctx));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"ab\",expression.getValue(ctx));\n+\t\t\n+\t\texpression = parser.parseExpression(\"#concat(#concat('a','b'),'c').charAt(1)\");\n+\t\tassertEquals('b',expression.getValue(ctx));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals('b',expression.getValue(ctx));\n+\t\t\n+\t\texpression = parser.parseExpression(\"#concat(#a,#b)\");\n+\t\tctx.setVariable(\"a\", \"foo\");\n+\t\tctx.setVariable(\"b\", \"bar\");\n+\t\tassertEquals(\"foobar\",expression.getValue(ctx));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"foobar\",expression.getValue(ctx));\n+\t\tctx.setVariable(\"b\", \"boo\");\n+\t\tassertEquals(\"fooboo\",expression.getValue(ctx));\n+\t}\n+\t\n+\t@Test\n+\tpublic void variableReference_userDefined() throws Exception {\n+\t\tEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tctx.setVariable(\"target\", \"abc\");\n+\t\texpression = parser.parseExpression(\"#target\");\n+\t\tassertEquals(\"abc\",expression.getValue(ctx));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"abc\",expression.getValue(ctx));\t\n+\t\tctx.setVariable(\"target\", \"123\");\n+\t\tassertEquals(\"123\",expression.getValue(ctx));\t\n+\t\tctx.setVariable(\"target\", 42);\n+\t\ttry {\n+\t\t\tassertEquals(42,expression.getValue(ctx));\n+\t\t\tfail();\n+\t\t} catch (SpelEvaluationException see) {\n+\t\t\tassertTrue(see.getCause() instanceof ClassCastException);\n+\t\t}\n+\t\n+\t\tctx.setVariable(\"target\", \"abc\");\n+\t\texpression = parser.parseExpression(\"#target.charAt(0)\");\n+\t\tassertEquals('a',expression.getValue(ctx));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals('a',expression.getValue(ctx));\t\n+\t\tctx.setVariable(\"target\", \"1\");\n+\t\tassertEquals('1',expression.getValue(ctx));\t\n+\t\tctx.setVariable(\"target\", 42);\n+\t\ttry {\n+\t\t\tassertEquals('4',expression.getValue(ctx));\n+\t\t\tfail();\n+\t\t} catch (SpelEvaluationException see) {\n+\t\t\tassertTrue(see.getCause() instanceof ClassCastException);\n+\t\t}\n+\t}\n+\t\n+\t@Test\n+\tpublic void opLt() throws Exception {\n+\t\texpression = parse(\"3.0d < 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d < 1123.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 < 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"2 < 4\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f < 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"1.0f < 5.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"30L < 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L < 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\t// Differing types of number, not yet supported\n+\t\texpression = parse(\"1 < 3.0d\");\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(3) < 4\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) < T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 < T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void opLe() throws Exception {\n+\t\texpression = parse(\"3.0d <= 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d <= 1123.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d <= 3446.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 <= 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"2 <= 4\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3 <= 3\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f <= 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"1.0f <= 5.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"2.0f <= 2.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"30L <= 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L <= 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\t// Differing types of number, not yet supported\n+\t\texpression = parse(\"1 <= 3.0d\");\n+\t\tassertCantCompile(expression);\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) <= 4\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) <= T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 <= T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t}\n+\t\n+\t\n+\t@Test\n+\tpublic void opGt() throws Exception {\n+\t\texpression = parse(\"3.0d > 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d > 1123.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 > 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"2 > 4\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f > 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"1.0f > 5.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"30L > 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L > 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\t// Differing types of number, not yet supported\n+\t\texpression = parse(\"1 > 3.0d\");\n+\t\tassertCantCompile(expression);\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) > 4\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(3) > T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 > T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void opGe() throws Exception {\n+\t\texpression = parse(\"3.0d >= 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d >= 1123.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d >= 3446.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 >= 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"2 >= 4\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3 >= 3\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f >= 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"1.0f >= 5.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3.0f >= 3.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"40L >= 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L >= 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"30L >= 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\t// Differing types of number, not yet supported\n+\t\texpression = parse(\"1 >= 3.0d\");\n+\t\tassertCantCompile(expression);\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) >= 4\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(3) >= T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 >= T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t}\n+\n+\t@Test\n+\tpublic void opEq() throws Exception {\n+\t\t\n+\t\tTestClass7 tc7 = new TestClass7();\n+\t\texpression = parse(\"property == 'UK'\");\n+\t\tassertTrue((Boolean)expression.getValue(tc7));\n+\t\tTestClass7.property = null;\n+\t\tassertFalse((Boolean)expression.getValue(tc7));\n+\t\tassertCanCompile(expression);\n+\t\tTestClass7.reset();\n+\t\tassertTrue((Boolean)expression.getValue(tc7));\n+\t\tTestClass7.property = \"UK\";\n+\t\tassertTrue((Boolean)expression.getValue(tc7));\n+\t\tTestClass7.reset();\n+\t\tTestClass7.property = null;\n+\t\tassertFalse((Boolean)expression.getValue(tc7));\n+\t\texpression = parse(\"property == null\");\n+\t\tassertTrue((Boolean)expression.getValue(tc7));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(tc7));\n+\t\t\n+\t\t\n+\t\texpression = parse(\"3.0d == 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d == 3446.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 == 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"3 == 3\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f == 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"2.0f == 2.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"30L == 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L == 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\t// number types are not the same\n+\t\texpression = parse(\"1 == 3.0d\");\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\tDouble d = 3.0d;\n+\t\texpression = parse(\"#root==3.0d\");\n+\t\tassertTrue((Boolean)expression.getValue(d));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(d));\n+\t\t\n+\t\tInteger i = 3;\n+\t\texpression = parse(\"#root==3\");\n+\t\tassertTrue((Boolean)expression.getValue(i));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(i));\n+\n+\t\tFloat f = 3.0f;\n+\t\texpression = parse(\"#root==3.0f\");\n+\t\tassertTrue((Boolean)expression.getValue(f));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(f));\n+\t\t\n+\t\tlong l = 300l;\n+\t\texpression = parse(\"#root==300l\");\n+\t\tassertTrue((Boolean)expression.getValue(l));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(l));\n+\t\t\n+\t\tboolean b = true;\n+\t\texpression = parse(\"#root==true\");\n+\t\tassertTrue((Boolean)expression.getValue(b));\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue(b));\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) == 4\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(3) == T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 == T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(3.0f) == 4.0f\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(3.0f) == T(Float).valueOf(3.0f)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5.0f == T(Float).valueOf(3.0f)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(3L) == 4L\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(3L) == T(Long).valueOf(3L)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5L == T(Long).valueOf(3L)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\t\n+\t\t\n+\t\texpression = parse(\"T(Double).valueOf(3.0d) == 4.0d\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Double).valueOf(3.0d) == T(Double).valueOf(3.0d)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5.0d == T(Double).valueOf(3.0d)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"false == true\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Boolean).valueOf('true') == T(Boolean).valueOf('true')\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Boolean).valueOf('true') == true\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"false == T(Boolean).valueOf('false')\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t}\n+\n+\t@Test\n+\tpublic void opNe() throws Exception {\n+\t\texpression = parse(\"3.0d != 4.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3446.0d != 3446.0d\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"3 != 1\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"3 != 3\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"3.0f != 1.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\texpression = parse(\"2.0f != 2.0f\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"30L != 30L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\texpression = parse(\"15L != 20L\");\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\t// not compatible number types\n+\t\texpression = parse(\"1 != 3.0d\");\t\n+\t\tassertCantCompile(expression);\n+\n+\t\texpression = parse(\"T(Integer).valueOf(3) != 4\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(3) != T(Integer).valueOf(3)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5 != T(Integer).valueOf(3)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(3.0f) != 4.0f\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(3.0f) != T(Float).valueOf(3.0f)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5.0f != T(Float).valueOf(3.0f)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(3L) != 4L\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(3L) != T(Long).valueOf(3L)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5L != T(Long).valueOf(3L)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\t\n+\t\t\n+\t\texpression = parse(\"T(Double).valueOf(3.0d) == 4.0d\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Double).valueOf(3.0d) == T(Double).valueOf(3.0d)\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"5.0d == T(Double).valueOf(3.0d)\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"false == true\");\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertFalse((Boolean)expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Boolean).valueOf('true') == T(Boolean).valueOf('true')\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"T(Boolean).valueOf('true') == true\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\n+\t\texpression = parse(\"false == T(Boolean).valueOf('false')\");\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertTrue((Boolean)expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void opPlus() throws Exception {\n+\t\texpression = parse(\"2+2\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"2L+2L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4L,expression.getValue());\n+\n+\t\texpression = parse(\"2.0f+2.0f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4.0f,expression.getValue());\n+\n+\t\texpression = parse(\"3.0d+4.0d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(7.0d,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"+1\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"+1L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1L,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"+1.5f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1.5f,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"+2.5d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2.5d,expression.getValue());\t\n+\n+\t\texpression = parse(\"+T(Double).valueOf(2.5d)\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2.5d,expression.getValue());\t\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(2)+6\");\n+\t\tassertEquals(8,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(8,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(1)+T(Integer).valueOf(3)\");\n+\t\tassertEquals(4,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4,expression.getValue());\n+\n+\t\texpression = parse(\"1+T(Integer).valueOf(3)\");\n+\t\tassertEquals(4,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(2.0f)+6\");\n+\t\tassertEquals(8.0f,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(2.0f)+T(Float).valueOf(3.0f)\");\n+\t\tassertEquals(5.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(5.0f,expression.getValue());\n+\n+\t\texpression = parse(\"3L+T(Long).valueOf(4L)\");\n+\t\tassertEquals(7L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(7L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Long).valueOf(2L)+6\");\n+\t\tassertEquals(8L,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(2L)+T(Long).valueOf(3L)\");\n+\t\tassertEquals(5L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(5L,expression.getValue());\n+\n+\t\texpression = parse(\"1L+T(Long).valueOf(2L)\");\n+\t\tassertEquals(3L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(3L,expression.getValue());\n+\t}\n+\n+\t@Test\n+\tpublic void opMinus() throws Exception {\n+\t\texpression = parse(\"2-2\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(0,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"4L-2L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2L,expression.getValue());\n+\n+\t\texpression = parse(\"4.0f-2.0f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2.0f,expression.getValue());\n+\n+\t\texpression = parse(\"3.0d-4.0d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-1.0d,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"-1\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-1,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"-1L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-1L,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"-1.5f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-1.5f,expression.getValue());\t\t\n+\n+\t\texpression = parse(\"-2.5d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-2.5d,expression.getValue());\t\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(2)-6\");\n+\t\tassertEquals(-4,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-4,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"T(Integer).valueOf(1)-T(Integer).valueOf(3)\");\n+\t\tassertEquals(-2,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-2,expression.getValue());\n+\n+\t\texpression = parse(\"4-T(Integer).valueOf(3)\");\n+\t\tassertEquals(1,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(2.0f)-6\");\n+\t\tassertEquals(-4.0f,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(8.0f)-T(Float).valueOf(3.0f)\");\n+\t\tassertEquals(5.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(5.0f,expression.getValue());\n+\n+\t\texpression = parse(\"11L-T(Long).valueOf(4L)\");\n+\t\tassertEquals(7L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(7L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Long).valueOf(9L)-6\");\n+\t\tassertEquals(3L,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(4L)-T(Long).valueOf(3L)\");\n+\t\tassertEquals(1L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1L,expression.getValue());\n+\n+\t\texpression = parse(\"8L-T(Long).valueOf(2L)\");\n+\t\tassertEquals(6L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(6L,expression.getValue());\n+\t}\n+\t\n+\t\n+\t@Test\n+\tpublic void opMultiply() throws Exception {\n+\t\texpression = parse(\"2*2\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"2L*2L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4L,expression.getValue());\n+\n+\t\texpression = parse(\"2.0f*2.0f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4.0f,expression.getValue());\n+\n+\t\texpression = parse(\"3.0d*4.0d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(12.0d,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(2.0f)*6\");\n+\t\tassertEquals(12.0f,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(8.0f)*T(Float).valueOf(3.0f)\");\n+\t\tassertEquals(24.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(24.0f,expression.getValue());\n+\n+\t\texpression = parse(\"11L*T(Long).valueOf(4L)\");\n+\t\tassertEquals(44L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(44L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Long).valueOf(9L)*6\");\n+\t\tassertEquals(54L,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(4L)*T(Long).valueOf(3L)\");\n+\t\tassertEquals(12L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(12L,expression.getValue());\n+\n+\t\texpression = parse(\"8L*T(Long).valueOf(2L)\");\n+\t\tassertEquals(16L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(16L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(8.0f)*-T(Float).valueOf(3.0f)\");\n+\t\tassertEquals(-24.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-24.0f,expression.getValue());\n+\t}\n+\t\n+\t@Test\n+\tpublic void opDivide() throws Exception {\n+\t\texpression = parse(\"2/2\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1,expression.getValue());\n+\t\t\n+\t\texpression = parse(\"2L/2L\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1L,expression.getValue());\n+\n+\t\texpression = parse(\"2.0f/2.0f\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(1.0f,expression.getValue());\n+\n+\t\texpression = parse(\"3.0d/4.0d\");\n+\t\texpression.getValue();\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(0.75d,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(6.0f)/2\");\n+\t\tassertEquals(3.0f,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Float).valueOf(8.0f)/T(Float).valueOf(2.0f)\");\n+\t\tassertEquals(4.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4.0f,expression.getValue());\n+\n+\t\texpression = parse(\"12L/T(Long).valueOf(4L)\");\n+\t\tassertEquals(3L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(3L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Long).valueOf(44L)/11\");\n+\t\tassertEquals(4L,expression.getValue());\n+\t\tassertCantCompile(expression);\n+\t\t\n+\t\texpression = parse(\"T(Long).valueOf(4L)/T(Long).valueOf(2L)\");\n+\t\tassertEquals(2L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2L,expression.getValue());\n+\n+\t\texpression = parse(\"8L/T(Long).valueOf(2L)\");\n+\t\tassertEquals(4L,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4L,expression.getValue());\n+\n+\t\texpression = parse(\"T(Float).valueOf(8.0f)/-T(Float).valueOf(4.0f)\");\n+\t\tassertEquals(-2.0f,expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(-2.0f,expression.getValue());\n+\t}\n+\t\n+\n+\t@Test\n+\tpublic void constructorReference() throws Exception {\n+\t\t// simple ctor\n+\t\texpression = parser.parseExpression(\"new String('123')\");\n+\t\tassertEquals(\"123\",expression.getValue());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"123\",expression.getValue());\n+\n+\t\tString testclass8 = \"org.springframework.expression.spel.SpelCompilationCoverageTests$TestClass8\"; \n+\t\t// multi arg ctor that includes primitives\n+\t\texpression = parser.parseExpression(\"new \"+testclass8+\"(42,'123',4.0d,true)\");\n+\t\tassertEquals(testclass8,expression.getValue().getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\tObject o = expression.getValue();\n+\t\tassertEquals(testclass8,o.getClass().getName());\n+\t\tTestClass8 tc8 = (TestClass8)o;\n+\t\tassertEquals(42,tc8.i);\n+\t\tassertEquals(\"123\",tc8.s);\n+\t\tassertEquals(4.0d,tc8.d,0.5d);\n+\t\tassertEquals(true,tc8.z);\n+\t\t\n+\t\t// no-arg ctor\n+\t\texpression = parser.parseExpression(\"new \"+testclass8+\"()\");\n+\t\tassertEquals(testclass8,expression.getValue().getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\to = expression.getValue();\n+\t\tassertEquals(testclass8,o.getClass().getName());\n+\t\t\n+\t\t// pass primitive to reference type ctor\n+\t\texpression = parser.parseExpression(\"new \"+testclass8+\"(42)\");\n+\t\tassertEquals(testclass8,expression.getValue().getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\to = expression.getValue();\n+\t\tassertEquals(testclass8,o.getClass().getName());\n+\t\ttc8 = (TestClass8)o;\n+\t\tassertEquals(42,tc8.i);\n+\n+\t\t// private class, can't compile it\n+\t\tString testclass9 = \"org.springframework.expression.spel.SpelCompilationCoverageTests$TestClass9\"; \n+\t\texpression = parser.parseExpression(\"new \"+testclass9+\"(42)\");\n+\t\tassertEquals(testclass9,expression.getValue().getClass().getName());\n+\t\tassertCantCompile(expression);\n+\t}\n+\t\n+\t@Test\n+\tpublic void methodReference() throws Exception {\n+\t\tTestClass5 tc = new TestClass5();\n+\t\t\n+\t\t// non-static method, no args, void return\n+\t\texpression = parser.parseExpression(\"one()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(1,tc.i);\n+\t\ttc.reset();\n+\t\t\n+\t\t// static method, no args, void return\n+\t\texpression = parser.parseExpression(\"two()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(1,TestClass5._i);\n+\t\ttc.reset();\n+\t\t\n+\t\t// non-static method, reference type return\n+\t\texpression = parser.parseExpression(\"three()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\tassertEquals(\"hello\",expression.getValue(tc));\n+\t\ttc.reset();\n+\n+\t\t// non-static method, primitive type return\n+\t\texpression = parser.parseExpression(\"four()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\tassertEquals(3277700L,expression.getValue(tc));\n+\t\ttc.reset();\n+\t\t\n+\t\t// static method, reference type return\n+\t\texpression = parser.parseExpression(\"five()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\tassertEquals(\"hello\",expression.getValue(tc));\n+\t\ttc.reset();\n+\n+\t\t// static method, primitive type return\n+\t\texpression = parser.parseExpression(\"six()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\tassertEquals(3277700L,expression.getValue(tc));\n+\t\ttc.reset();\n+\t\t\n+\t\t// non-static method, one parameter of reference type\n+\t\texpression = parser.parseExpression(\"seven(\\\"foo\\\")\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"foo\",tc.s);\n+\t\ttc.reset();\n+\t\t\n+\t\t// static method, one parameter of reference type\n+\t\texpression = parser.parseExpression(\"eight(\\\"bar\\\")\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"bar\",TestClass5._s);\n+\t\ttc.reset();\n+\t\t\n+\t\t// non-static method, one parameter of primitive type\n+\t\texpression = parser.parseExpression(\"nine(231)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(231,tc.i);\n+\t\ttc.reset();\n+\t\t\n+\t\t// static method, one parameter of primitive type\n+\t\texpression = parser.parseExpression(\"ten(111)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(111,TestClass5._i);\n+\t\ttc.reset();\n+\t\t\n+\t\t// non-static method, varargs with reference type\n+\t\texpression = parser.parseExpression(\"eleven(\\\"a\\\",\\\"b\\\",\\\"c\\\")\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCantCompile(expression); // Varargs is not yet supported\n+\t\t\n+\t\texpression = parser.parseExpression(\"eleven()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCantCompile(expression); // Varargs is not yet supported\n+\t\t\n+\t\t// static method, varargs with primitive type\n+\t\texpression = parser.parseExpression(\"twelve(1,2,3)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCantCompile(expression); // Varargs is not yet supported\n+\t\t\n+\t\texpression = parser.parseExpression(\"twelve()\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertCantCompile(expression); // Varargs is not yet supported\n+\t\t\n+\t\t// method that gets type converted parameters\n+\t\t\n+\t\t// Converting from an int to a string\n+\t\texpression = parser.parseExpression(\"seven(123)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"123\",tc.s);\n+\t\tassertCantCompile(expression); // Uncompilable as argument conversion is occurring\n+\t\t\n+\t\tExpression expression = parser.parseExpression(\"'abcd'.substring(index1,index2)\");\n+\t\tString resultI = expression.getValue(new TestClass1(),String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(new TestClass1(),String.class);\n+\t\tassertEquals(\"bc\",resultI);\n+\t\tassertEquals(\"bc\",resultC);\n+\t\t\n+\t\t// Converting from an int to a Number\n+\t\texpression = parser.parseExpression(\"takeNumber(123)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"123\",tc.s);\n+\t\ttc.reset();\n+\t\tassertCanCompile(expression); // The generated code should include boxing of the int to a Number\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"123\",tc.s);\n+\n+\t\t// Passing a subtype\n+\t\texpression = parser.parseExpression(\"takeNumber(T(Integer).valueOf(42))\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"42\",tc.s);\n+\t\ttc.reset();\n+\t\tassertCanCompile(expression); // The generated code should include boxing of the int to a Number\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"42\",tc.s);\n+\n+\t\t// Passing a subtype\n+\t\texpression = parser.parseExpression(\"takeString(T(Integer).valueOf(42))\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"42\",tc.s);\n+\t\ttc.reset();\n+\t\tassertCantCompile(expression); // method takes a string and we are passing an Integer\n+\t}\n+\t\t\n+\t\n+\t@Test \n+\tpublic void errorHandling() throws Exception {\n+\t\tTestClass5 tc = new TestClass5();\n+\t\t\n+\t\t// changing target\n+\t\t\n+\t\t// from primitive array to reference type array\n+\t\tint[] is = new int[]{1,2,3};\n+\t\tString[] strings = new String[]{\"a\",\"b\",\"c\"};\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(2,expression.getValue(is));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue(is));\n+\t\t\n+\t\ttry {\n+\t\t\tassertEquals(2,expression.getValue(strings));\n+\t\t\tfail();\n+\t\t} catch (SpelEvaluationException see) {\n+\t\t\tassertTrue(see.getCause() instanceof ClassCastException);\n+\t\t}\n+\t\tSpelCompiler.revertToInterpreted(expression);\n+\t\tassertEquals(\"b\",expression.getValue(strings));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"b\",expression.getValue(strings));\n+\t\t\n+\t\t\n+\t\ttc.field = \"foo\";\n+\t\texpression = parser.parseExpression(\"seven(field)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"foo\",tc.s);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\ttc.field=\"bar\";\n+\t\texpression.getValue(tc);\n+\t\t\n+\t\t// method with changing parameter types (change reference type)\n+\t\ttc.obj = \"foo\";\n+\t\texpression = parser.parseExpression(\"seven(obj)\");\n+\t\tassertCantCompile(expression);\n+\t\texpression.getValue(tc);\n+\t\tassertEquals(\"foo\",tc.s);\n+\t\tassertCanCompile(expression);\n+\t\ttc.reset();\n+\t\ttc.obj=new Integer(42);\n+\t\ttry {\n+\t\t\texpression.getValue(tc);\n+\t\t\tfail();\n+\t\t} catch (SpelEvaluationException see) {\n+\t\t\tassertTrue(see.getCause() instanceof ClassCastException);\n+\t\t}\n+\t\t\n+\t\t\n+\t\t// method with changing target\n+\t\texpression = parser.parseExpression(\"#root.charAt(0)\");\n+\t\tassertEquals('a',expression.getValue(\"abc\"));\n+\t\tassertCanCompile(expression);\n+\t\ttry {\n+\t\t\texpression.getValue(new Integer(42));\n+\t\t\tfail();\n+\t\t} catch (SpelEvaluationException see) {\n+\t\t\t// java.lang.Integer cannot be cast to java.lang.String\n+\t\t\tassertTrue(see.getCause() instanceof ClassCastException);\n+\t\t}\t\t\n+\t}\n+\t\n+\t@Test\n+\tpublic void methodReference_staticMethod() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"T(Integer).valueOf(42)\");\n+\t\tint resultI = expression.getValue(new TestClass1(),Integer.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tint resultC = expression.getValue(new TestClass1(),Integer.TYPE);\n+\t\tassertEquals(42,resultI);\n+\t\tassertEquals(42,resultC);\t\t\n+\t}\n+\t\n+\t@Test\n+\tpublic void methodReference_literalArguments_int() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"'abcd'.substring(1,3)\");\n+\t\tString resultI = expression.getValue(new TestClass1(),String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(new TestClass1(),String.class);\n+\t\tassertEquals(\"bc\",resultI);\n+\t\tassertEquals(\"bc\",resultC);\n+\t}\n+\n+\t@Test\n+\tpublic void methodReference_simpleInstanceMethodNoArg() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"toString()\");\n+\t\tString resultI = expression.getValue(42,String.class);\n+\t\tassertCanCompile(expression);\n+\t\tString resultC = expression.getValue(42,String.class);\n+\t\tassertEquals(\"42\",resultI);\n+\t\tassertEquals(\"42\",resultC);\n+\t}\n+\n+\t@Test\n+\tpublic void methodReference_simpleInstanceMethodNoArgReturnPrimitive() throws Exception {\n+\t\texpression = parser.parseExpression(\"intValue()\");\n+\t\tint resultI = expression.getValue(new Integer(42),Integer.TYPE);\n+\t\tassertEquals(42,resultI);\n+\t\tassertCanCompile(expression);\n+\t\tint resultC = expression.getValue(new Integer(42),Integer.TYPE);\n+\t\tassertEquals(42,resultC);\n+\t}\n+\t\n+\t@Test\n+\tpublic void methodReference_simpleInstanceMethodOneArgReturnPrimitive1() throws Exception {\n+\t\tExpression expression = parser.parseExpression(\"indexOf('b')\");\n+\t\tint resultI = expression.getValue(\"abc\",Integer.TYPE);\n+\t\tassertCanCompile(expression);\n+\t\tint resultC = expression.getValue(\"abc\",Integer.TYPE);\n+\t\tassertEquals(1,resultI);\n+\t\tassertEquals(1,resultC);\n+\t}\n+\n+\t@Test\n+\tpublic void methodReference_simpleInstanceMethodOneArgReturnPrimitive2() throws Exception {\n+\t\texpression = parser.parseExpression(\"charAt(2)\");\n+\t\tchar resultI = expression.getValue(\"abc\",Character.TYPE);\n+\t\tassertEquals('c',resultI);\n+\t\tassertCanCompile(expression);\n+\t\tchar resultC = expression.getValue(\"abc\",Character.TYPE);\n+\t\tassertEquals('c',resultC);\n+\t}\n+\n+\n+\t@Test\n+\tpublic void compoundExpression() throws Exception {\n+\t\tPayload payload = new Payload();\n+\t\texpression = parser.parseExpression(\"DR[0]\");\n+\t\tassertEquals(\"instanceof Two\",expression.getValue(payload).toString());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"instanceof Two\",expression.getValue(payload).toString());\n+\t\tast = getAst();\n+\t\tassertEquals(\"Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Two\",ast.getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"holder.three\");\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Three\",expression.getValue(payload).getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Three\",expression.getValue(payload).getClass().getName());\n+\t\tast = getAst();\n+\t\tassertEquals(\"Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Three\",ast.getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"DR[0]\");\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Two\",expression.getValue(payload).getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Two\",expression.getValue(payload).getClass().getName());\n+\t\tassertEquals(\"Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Two\",getAst().getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"DR[0].three\");\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Three\",expression.getValue(payload).getClass().getName());\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"org.springframework.expression.spel.SpelCompilationCoverageTests$Three\",expression.getValue(payload).getClass().getName());\n+\t\tast = getAst();\n+\t\tassertEquals(\"Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Three\",ast.getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"DR[0].three.four\");\n+\t\tassertEquals(0.04d,expression.getValue(payload));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(0.04d,expression.getValue(payload));\n+\t\tassertEquals(\"D\",getAst().getExitDescriptor());\n+\t}\n+\t\n+\t\n+\t@Test\n+\tpublic void mixingItUp_indexerOpEqTernary() throws Exception {\n+\t\tMap<String, String> m = new HashMap<String,String>();\n+\t\tm.put(\"andy\",\"778\");\n+\n+\t\texpression = parse(\"['andy']==null?1:2\");\n+\t\tSystem.out.println(expression.getValue(m));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue(m));\n+\t\tm.remove(\"andy\");\n+\t\tassertEquals(1,expression.getValue(m));\n+\t}\n+\t\n+\t@Test\n+\tpublic void propertyReference() throws Exception {\n+\t\tTestClass6 tc = new TestClass6();\n+\t\t\n+\t\t// non static field\n+\t\texpression = parser.parseExpression(\"orange\");\n+\t\tassertCantCompile(expression);\n+\t\tassertEquals(\"value1\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value1\",expression.getValue(tc));\n+\t\t\n+\t\t// static field\n+\t\texpression = parser.parseExpression(\"apple\");\n+\t\tassertCantCompile(expression);\n+\t\tassertEquals(\"value2\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value2\",expression.getValue(tc));\t\n+\t\t\n+\t\t// non static getter\n+\t\texpression = parser.parseExpression(\"banana\");\n+\t\tassertCantCompile(expression);\n+\t\tassertEquals(\"value3\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value3\",expression.getValue(tc));\n+\n+\t\t// static getter\n+\t\texpression = parser.parseExpression(\"plum\");\n+\t\tassertCantCompile(expression);\n+\t\tassertEquals(\"value4\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value4\",expression.getValue(tc));\n+\t}\n+\t\n+\t@SuppressWarnings(\"unchecked\")\n+\t@Test\n+\tpublic void indexer() throws Exception {\n+\t\tString[] sss = new String[]{\"a\",\"b\",\"c\"};\n+\t\tNumber[] ns = new Number[]{2,8,9};\n+\t\tint[] is = new int[]{8,9,10};\n+\t\tdouble[] ds = new double[]{3.0d,4.0d,5.0d};\n+\t\tlong[] ls = new long[]{2L,3L,4L};\n+\t\tshort[] ss = new short[]{(short)33,(short)44,(short)55};\n+\t\tfloat[] fs = new float[]{6.0f,7.0f,8.0f};\n+\t\tbyte[] bs = new byte[]{(byte)2,(byte)3,(byte)4};\n+\t\tchar[] cs = new char[]{'a','b','c'};\n+\t\t\t\t\n+\t\t// Access String (reference type) array\n+\t\texpression = parser.parseExpression(\"[0]\");\n+\t\tassertEquals(\"a\",expression.getValue(sss));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"a\",expression.getValue(sss));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(8,expression.getValue(ns));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(8,expression.getValue(ns));\n+\t\tassertEquals(\"Ljava/lang/Number\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Access int array\n+\t\texpression = parser.parseExpression(\"[2]\");\n+\t\tassertEquals(10,expression.getValue(is));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(10,expression.getValue(is));\n+\t\tassertEquals(\"I\",getAst().getExitDescriptor());\n+\n+\t\t// Access double array\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(4.0d,expression.getValue(ds));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(4.0d,expression.getValue(ds));\n+\t\tassertEquals(\"D\",getAst().getExitDescriptor());\n+\n+\t\t// Access long array\n+\t\texpression = parser.parseExpression(\"[0]\");\n+\t\tassertEquals(2L,expression.getValue(ls));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2L,expression.getValue(ls));\n+\t\tassertEquals(\"J\",getAst().getExitDescriptor());\n+\n+\t\t// Access short array\n+\t\texpression = parser.parseExpression(\"[2]\");\n+\t\tassertEquals((short)55,expression.getValue(ss));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals((short)55,expression.getValue(ss));\n+\t\tassertEquals(\"S\",getAst().getExitDescriptor());\n+\n+\t\t// Access float array\n+\t\texpression = parser.parseExpression(\"[0]\");\n+\t\tassertEquals(6.0f,expression.getValue(fs));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(6.0f,expression.getValue(fs));\n+\t\tassertEquals(\"F\",getAst().getExitDescriptor());\n+\n+\t\t// Access byte array\n+\t\texpression = parser.parseExpression(\"[2]\");\n+\t\tassertEquals((byte)4,expression.getValue(bs));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals((byte)4,expression.getValue(bs));\n+\t\tassertEquals(\"B\",getAst().getExitDescriptor());\n+\n+\t\t// Access char array\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals('b',expression.getValue(cs));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals('b',expression.getValue(cs));\n+\t\tassertEquals(\"C\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Collections\n+\t\tList<String> strings = new ArrayList<String>();\n+\t\tstrings.add(\"aaa\");\n+\t\tstrings.add(\"bbb\");\n+\t\tstrings.add(\"ccc\");\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"bbb\",expression.getValue(strings));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"bbb\",expression.getValue(strings));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\tList<Integer> ints = new ArrayList<Integer>();\n+\t\tints.add(123);\n+\t\tints.add(456);\n+\t\tints.add(789);\n+\t\texpression = parser.parseExpression(\"[2]\");\n+\t\tassertEquals(789,expression.getValue(ints));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(789,expression.getValue(ints));\n+\t\tassertEquals(\"Ljava/lang/Integer\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Maps\n+\t\tMap<String,Integer> map1 = new HashMap<String,Integer>();\n+\t\tmap1.put(\"aaa\", 111);\n+\t\tmap1.put(\"bbb\", 222);\n+\t\tmap1.put(\"ccc\", 333);\n+\t\texpression = parser.parseExpression(\"['aaa']\");\n+\t\tassertEquals(111,expression.getValue(map1));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(111,expression.getValue(map1));\n+\t\tassertEquals(\"Ljava/lang/Integer\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Object\n+\t\tTestClass6 tc = new TestClass6();\n+\t\texpression = parser.parseExpression(\"['orange']\");\n+\t\tassertEquals(\"value1\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value1\",expression.getValue(tc));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"['peach']\");\n+\t\tassertEquals(34L,expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(34L,expression.getValue(tc));\n+\t\tassertEquals(\"J\",getAst().getExitDescriptor());\n+\n+\t\t// getter\n+\t\texpression = parser.parseExpression(\"['banana']\");\n+\t\tassertEquals(\"value3\",expression.getValue(tc));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value3\",expression.getValue(tc));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// list of arrays\n+\t\t\n+\t\tList<String[]> listOfStringArrays = new ArrayList<String[]>();\n+\t\tlistOfStringArrays.add(new String[]{\"a\",\"b\",\"c\"});\n+\t\tlistOfStringArrays.add(new String[]{\"d\",\"e\",\"f\"});\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(listOfStringArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(listOfStringArrays)));\n+\t\tassertEquals(\"[Ljava/lang/String\",getAst().getExitDescriptor());\n+\n+\t\tList<Integer[]> listOfIntegerArrays = new ArrayList<Integer[]>();\n+\t\tlistOfIntegerArrays.add(new Integer[]{1,2,3});\n+\t\tlistOfIntegerArrays.add(new Integer[]{4,5,6});\n+\t\texpression = parser.parseExpression(\"[0]\");\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(listOfIntegerArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(listOfIntegerArrays)));\n+\t\tassertEquals(\"[Ljava/lang/Integer\",getAst().getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"[0][1]\");\n+\t\tassertEquals(2,expression.getValue(listOfIntegerArrays));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue(listOfIntegerArrays));\n+\t\tassertEquals(\"Ljava/lang/Integer\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// array of lists\n+\t\tList<String>[] stringArrayOfLists = new ArrayList[2];\n+\t\tstringArrayOfLists[0] = new ArrayList<String>();\n+\t\tstringArrayOfLists[0].add(\"a\");\n+\t\tstringArrayOfLists[0].add(\"b\");\n+\t\tstringArrayOfLists[0].add(\"c\");\n+\t\tstringArrayOfLists[1] = new ArrayList<String>();\n+\t\tstringArrayOfLists[1].add(\"d\");\n+\t\tstringArrayOfLists[1].add(\"e\");\n+\t\tstringArrayOfLists[1].add(\"f\");\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(stringArrayOfLists)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(stringArrayOfLists)));\n+\t\tassertEquals(\"Ljava/util/ArrayList\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"[1][2]\");\n+\t\tassertEquals(\"f\",stringify(expression.getValue(stringArrayOfLists)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"f\",stringify(expression.getValue(stringArrayOfLists)));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// array of arrays\n+\t\tString[][] referenceTypeArrayOfArrays = new String[][]{new String[]{\"a\",\"b\",\"c\"},new String[]{\"d\",\"e\",\"f\"}};\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(referenceTypeArrayOfArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"[Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(referenceTypeArrayOfArrays)));\n+\t\tassertEquals(\"[Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"[1][2]\");\n+\t\tassertEquals(\"f\",stringify(expression.getValue(referenceTypeArrayOfArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"f\",stringify(expression.getValue(referenceTypeArrayOfArrays)));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\tint[][] primitiveTypeArrayOfArrays = new int[][]{new int[]{1,2,3},new int[]{4,5,6}};\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"4 5 6\",stringify(expression.getValue(primitiveTypeArrayOfArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"4 5 6\",stringify(expression.getValue(primitiveTypeArrayOfArrays)));\n+\t\tassertEquals(\"[I\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"[1][2]\");\n+\t\tassertEquals(\"6\",stringify(expression.getValue(primitiveTypeArrayOfArrays)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"6\",stringify(expression.getValue(primitiveTypeArrayOfArrays)));\n+\t\tassertEquals(\"I\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// list of lists of reference types\n+\t\tList<List<String>> listOfListOfStrings = new ArrayList<List<String>>();\n+\t\tList<String> list = new ArrayList<String>();\n+\t\tlist.add(\"a\");\n+\t\tlist.add(\"b\");\n+\t\tlist.add(\"c\");\n+\t\tlistOfListOfStrings.add(list);\n+\t\tlist = new ArrayList<String>();\n+\t\tlist.add(\"d\");\n+\t\tlist.add(\"e\");\n+\t\tlist.add(\"f\");\n+\t\tlistOfListOfStrings.add(list);\n+\t\t\n+\t\texpression = parser.parseExpression(\"[1]\");\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(listOfListOfStrings)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"Ljava/util/ArrayList\",getAst().getExitDescriptor());\n+\t\tassertEquals(\"d e f\",stringify(expression.getValue(listOfListOfStrings)));\n+\t\tassertEquals(\"Ljava/util/ArrayList\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"[1][2]\");\n+\t\tassertEquals(\"f\",stringify(expression.getValue(listOfListOfStrings)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"f\",stringify(expression.getValue(listOfListOfStrings)));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Map of lists\n+\t\tMap<String,List<String>> mapToLists = new HashMap<String,List<String>>();\n+\t\tlist = new ArrayList<String>();\n+\t\tlist.add(\"a\");\n+\t\tlist.add(\"b\");\n+\t\tlist.add(\"c\");\n+\t\tmapToLists.put(\"foo\", list);\n+\t\texpression = parser.parseExpression(\"['foo']\");\n+\t\tassertEquals(\"a b c\",stringify(expression.getValue(mapToLists)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"Ljava/util/ArrayList\",getAst().getExitDescriptor());\n+\t\tassertEquals(\"a b c\",stringify(expression.getValue(mapToLists)));\n+\t\tassertEquals(\"Ljava/util/ArrayList\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"['foo'][2]\");\n+\t\tassertEquals(\"c\",stringify(expression.getValue(mapToLists)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"c\",stringify(expression.getValue(mapToLists)));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Map to array\n+\t\tMap<String,int[]> mapToIntArray = new HashMap<String,int[]>();\n+\t\tStandardEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tctx.addPropertyAccessor(new CompilableMapAccessor());\n+\t\tmapToIntArray.put(\"foo\",new int[]{1,2,3});\n+\t\texpression = parser.parseExpression(\"['foo']\");\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(mapToIntArray)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"[I\",getAst().getExitDescriptor());\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(mapToIntArray)));\n+\t\tassertEquals(\"[I\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"['foo'][1]\");\n+\t\tassertEquals(2,expression.getValue(mapToIntArray));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue(mapToIntArray));\n+\t\t\n+\t\texpression = parser.parseExpression(\"foo\");\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(ctx,mapToIntArray)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"1 2 3\",stringify(expression.getValue(ctx,mapToIntArray)));\n+\t\tassertEquals(\"Ljava/lang/Object\",getAst().getExitDescriptor());\n+\n+\t\texpression = parser.parseExpression(\"foo[1]\");\n+\t\tassertEquals(2,expression.getValue(ctx,mapToIntArray));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(2,expression.getValue(ctx,mapToIntArray));\n+\n+\t\texpression = parser.parseExpression(\"['foo'][2]\");\n+\t\tassertEquals(\"3\",stringify(expression.getValue(ctx,mapToIntArray)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"3\",stringify(expression.getValue(ctx,mapToIntArray)));\n+\t\tassertEquals(\"I\",getAst().getExitDescriptor());\n+\t\t\n+\t\t// Map array\n+\t\tMap<String,String>[] mapArray = new Map[1];\n+\t\tmapArray[0] = new HashMap<String,String>();\n+\t\tmapArray[0].put(\"key\", \"value1\");\n+\t\texpression = parser.parseExpression(\"[0]\");\n+\t\tassertEquals(\"{key=value1}\",stringify(expression.getValue(mapArray)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"Ljava/util/Map\",getAst().getExitDescriptor());\n+\t\tassertEquals(\"{key=value1}\",stringify(expression.getValue(mapArray)));\n+\t\tassertEquals(\"Ljava/util/Map\",getAst().getExitDescriptor());\n+\t\t\n+\t\texpression = parser.parseExpression(\"[0]['key']\");\n+\t\tassertEquals(\"value1\",stringify(expression.getValue(mapArray)));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"value1\",stringify(expression.getValue(mapArray)));\n+\t\tassertEquals(\"Ljava/lang/String\",getAst().getExitDescriptor());\n+\t}\n+\t\n+\t@Test\n+\tpublic void mixingItUp_propertyAccessIndexerOpLtTernaryRootNull() throws Exception {\n+\t\tPayload payload = new Payload();\n+\t\t\n+\t\texpression = parser.parseExpression(\"DR[0].three\");\n+\t\tObject v = expression.getValue(payload);\n+\t\tassertEquals(\"Lorg/springframework/expression/spel/SpelCompilationCoverageTests$Three\",getAst().getExitDescriptor());\n+\t\t\n+\t\tExpression expression = parser.parseExpression(\"DR[0].three.four lt 0.1d?#root:null\");\n+\t\tv = expression.getValue(payload);\n+\t\t\n+\t\tSpelExpression sExpr = (SpelExpression)expression;\n+\t\tTernary ternary = (Ternary)sExpr.getAST();\n+\t\tOpLT oplt = (OpLT)ternary.getChild(0);\n+\t\tCompoundExpression cExpr = (CompoundExpression)oplt.getLeftOperand();\n+\t\tString cExprExitDescriptor = cExpr.getExitDescriptor();\n+\t\tassertEquals(\"D\",cExprExitDescriptor);\n+\t\tassertEquals(\"Z\",oplt.getExitDescriptor());\n+\t\t\n+\t\tassertCanCompile(expression);\n+\t\tObject vc = expression.getValue(payload);\n+\t\tassertEquals(payload,v);\n+\t\tassertEquals(payload,vc);\n+\t\tpayload.DR[0].three.four = 0.13d;\n+\t\tvc = expression.getValue(payload);\n+\t\tassertNull(vc);\n+\t}\n+\t\n+\tstatic class MyAccessor implements CompilablePropertyAccessor {\n+\t\t\n+\t\tprivate Method method;\n+\t\t\n+\t\tpublic Class<?>[] getSpecificTargetClasses() {\n+\t\t\treturn new Class[]{Payload2.class};\n+\t\t}\n+\n+\t\tpublic boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\t// target is a Payload2 instance\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\tPayload2 payload2 = (Payload2)target;\n+\t\t\treturn new TypedValue(payload2.getField(name));\n+\t\t}\n+\n+\t\tpublic boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tpublic void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException {\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic boolean isCompilable() {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic void generateCode(PropertyOrFieldReference propertyReference, MethodVisitor mv,CodeFlow codeflow) {\n+\t\t\tif (method == null) {\n+\t\t\t\ttry {\n+\t\t\t\t\tmethod = Payload2.class.getDeclaredMethod(\"getField\", String.class);\n+\t\t\t\t} catch (Exception e) {}\n+\t\t\t}\n+\t\t\tString descriptor = codeflow.lastDescriptor();\n+\t\t\tString memberDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.','/');\n+\t\t\tif (descriptor == null) {\n+\t\t\t\tcodeflow.loadTarget(mv);\n+\t\t\t}\n+\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n+\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n+\t\t\t}\n+\t\t\tmv.visitLdcInsn(propertyReference.getName());\n+\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor, method.getName(),CodeFlow.createSignatureDescriptor(method),false);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<?> getPropertyType() {\n+\t\t\treturn Object.class;\n+\t\t}\n+\n+\t}\n+\t\n+\t@Test\n+\tpublic void variantGetter() throws Exception {\n+\t\tPayload2Holder holder = new Payload2Holder();\n+\t\tStandardEvaluationContext ctx = new StandardEvaluationContext();\n+\t\tctx.addPropertyAccessor(new MyAccessor());\n+\t\texpression = parser.parseExpression(\"payload2.var1\");\n+\t\tObject v = expression.getValue(ctx,holder);\n+\t\tassertEquals(\"abc\",v);\n+\t\t\n+//\t\t// time it interpreted\n+//\t\tlong stime = System.currentTimeMillis();\n+//\t\tfor (int i=0;i<100000;i++) {\n+//\t\t\tv = expression.getValue(ctx,holder);\n+//\t\t}\n+//\t\tSystem.out.println((System.currentTimeMillis()-stime));\n+//\n+\t\tassertCanCompile(expression);\n+\t\tv = expression.getValue(ctx,holder);\n+\t\tassertEquals(\"abc\",v);\n+//\t\t\n+//\t\t// time it compiled\n+//\t\tstime = System.currentTimeMillis();\n+//\t\tfor (int i=0;i<100000;i++) {\n+//\t\t\tv = expression.getValue(ctx,holder);\n+//\t\t}\n+//\t\tSystem.out.println((System.currentTimeMillis()-stime));\n+\n+\t}\n+\t\n+\tstatic class CompilableMapAccessor implements CompilablePropertyAccessor {\n+\n+\t\t@Override\n+\t\tpublic boolean canRead(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\tMap<?,?> map = (Map<?,?>) target;\n+\t\t\treturn map.containsKey(name);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic TypedValue read(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\tMap<?,?> map = (Map<?,?>) target;\n+\t\t\tObject value = map.get(name);\n+\t\t\tif (value == null && !map.containsKey(name)) {\n+\t\t\t\tthrow new MapAccessException(name);\n+\t\t\t}\n+\t\t\treturn new TypedValue(value);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean canWrite(EvaluationContext context, Object target, String name) throws AccessException {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\t@Override\n+\t\t@SuppressWarnings(\"unchecked\")\n+\t\tpublic void write(EvaluationContext context, Object target, String name, Object newValue) throws AccessException {\n+\t\t\tMap<String,Object> map = (Map<String,Object>) target;\n+\t\t\tmap.put(name, newValue);\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<?>[] getSpecificTargetClasses() {\n+\t\t\treturn new Class[] {Map.class};\n+\t\t}\n+\n+\n+\t\t/**\n+\t\t * Exception thrown from {@code read} in order to reset a cached\n+\t\t * PropertyAccessor, allowing other accessors to have a try.\n+\t\t */\n+\t\t@SuppressWarnings(\"serial\")\n+\t\tprivate static class MapAccessException extends AccessException {\n+\n+\t\t\tprivate final String key;\n+\n+\t\t\tpublic MapAccessException(String key) {\n+\t\t\t\tsuper(null);\n+\t\t\t\tthis.key = key;\n+\t\t\t}\n+\n+\t\t\t@Override\n+\t\t\tpublic String getMessage() {\n+\t\t\t\treturn \"Map does not contain a value for key '\" + this.key + \"'\";\n+\t\t\t}\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic boolean isCompilable() {\n+\t\t\treturn true;\n+\t\t}\n+\t\t\n+\t\t@Override\n+\t\tpublic void generateCode(PropertyOrFieldReference propertyReference,\n+\t\t\t\tMethodVisitor mv, CodeFlow codeflow) {\n+\t\t\tString descriptor = codeflow.lastDescriptor();\n+\t\t\tif (descriptor == null) {\n+\t\t\t\tcodeflow.loadTarget(mv);\n+\t\t\t}\n+\t\t\tmv.visitLdcInsn(propertyReference.getName());\n+\t\t\tmv.visitMethodInsn(INVOKEINTERFACE, \"java/util/Map\", \"get\",\"(Ljava/lang/Object;)Ljava/lang/Object;\",true);\n+\n+//\t\t\tif (method == null) {\n+//\t\t\t\ttry {\n+//\t\t\t\t\tmethod = Payload2.class.getDeclaredMethod(\"getField\", String.class);\n+//\t\t\t\t} catch (Exception e) {}\n+//\t\t\t}\n+//\t\t\tString descriptor = codeflow.lastDescriptor();\n+//\t\t\tString memberDeclaringClassSlashedDescriptor = method.getDeclaringClass().getName().replace('.','/');\n+//\t\t\tif (descriptor == null) {\n+//\t\t\t\tcodeflow.loadTarget(mv);\n+//\t\t\t}\n+//\t\t\tif (descriptor == null || !memberDeclaringClassSlashedDescriptor.equals(descriptor.substring(1))) {\n+//\t\t\t\tmv.visitTypeInsn(CHECKCAST, memberDeclaringClassSlashedDescriptor);\n+//\t\t\t}\n+//\t\t\tmv.visitLdcInsn(propertyReference.getName());\n+//\t\t\tmv.visitMethodInsn(INVOKEVIRTUAL, memberDeclaringClassSlashedDescriptor, method.getName(),CodeFlow.createDescriptor(method));\n+//\t\t\t   6:\tinvokeinterface\t#6,  2; //InterfaceMethod java/util/Map.get:(Ljava/lang/Object;)Ljava/lang/Object;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic Class<?> getPropertyType() {\n+\t\t\treturn Object.class;\n+\t\t}\n+\n+\t}\n+\n+\t\n+\t// helpers\n+\n+\tprivate SpelNodeImpl getAst() {\n+\t\tSpelExpression spelExpression = (SpelExpression)expression;\n+\t\tSpelNode ast = spelExpression.getAST();\n+\t\treturn (SpelNodeImpl)ast;\n+\t}\n+\n+\tprivate String stringify(Object object) {\n+\t\tStringBuilder s = new StringBuilder();\n+\t\tif (object instanceof List) {\n+\t\t\tList<?> ls = (List<?>)object;\n+\t\t\tfor (Object l: ls) {\n+\t\t\t\ts.append(l);\n+\t\t\t\ts.append(\" \");\n+\t\t\t}\n+\t\t}\n+\t\telse if (object instanceof Object[]) {\n+\t\t\tObject[] os = (Object[])object;\n+\t\t\tfor (Object o: os) {\n+\t\t\t\ts.append(o);\n+\t\t\t\ts.append(\" \");\n+\t\t\t}\n+\t\t}\n+\t\telse if (object instanceof int[]) {\n+\t\t\tint[] is = (int[])object;\n+\t\t\tfor (int i: is) {\n+\t\t\t\ts.append(i);\n+\t\t\t\ts.append(\" \");\n+\t\t\t}\n+\t\t}\n+\t\telse {\n+\t\t\ts.append(object.toString());\n+\t\t}\n+\t\treturn s.toString().trim();\n+\t}\n+\t\n+\tprivate void assertCanCompile(Expression expression) {\n+\t\tassertTrue(SpelCompiler.compile(expression));\n+\t}\n+\t\n+\tprivate void assertCantCompile(Expression expression) {\n+\t\tassertFalse(SpelCompiler.compile(expression));\n+\t}\n+\t\n+\tprivate Expression parse(String expression) {\n+\t\treturn parser.parseExpression(expression);\n+\t}\n+\t\n+\tprivate void assertGetValueFail(Expression expression) {\n+\t\ttry {\n+\t\t\tObject o = expression.getValue();\n+\t\t\tfail(\"Calling getValue on the expression should have failed but returned \"+o);\n+\t\t} catch (Exception ex) {\n+\t\t\t// success!\n+\t\t}\n+\t}\n+\t\n+\t// test classes\n+\t\t\n+\tpublic static class Payload {\n+\t\tTwo[] DR = new Two[]{new Two()};\n+\t\tpublic Two holder = new Two();\n+\t\t\n+\t\tpublic Two[] getDR() {\n+\t\t\treturn DR;\n+\t\t}\n+\t}\n+\t\n+\tpublic static class Payload2 {\n+\t\tString var1 = \"abc\";\n+\t\tString var2 = \"def\";\n+\t\tpublic Object getField(String name) {\n+\t\t\tif (name.equals(\"var1\")) {\n+\t\t\t\treturn var1;\n+\t\t\t} else if (name.equals(\"var2\")) {\n+\t\t\t\treturn var2;\n+\t\t\t}\n+\t\t\treturn null;\n+\t\t}\n+\t}\n+\n+\tpublic static class Payload2Holder {\n+\t\tpublic Payload2 payload2 = new Payload2();\n+\t}\n+\t\n+\tpublic static class Two {\n+\t\tThree three = new Three();\n+\t\tpublic Three getThree() {\n+\t\t\treturn three;\n+\t\t}\n+\t\tpublic String toString() {\n+\t\t\treturn \"instanceof Two\";\n+\t\t}\n+\t}\n+\t\n+\tpublic static class Three {\n+\t\tdouble four = 0.04d;\n+\t\tpublic double getFour() {\n+\t\t\treturn four;\n+\t\t}\n+\t}\n+\n+\tpublic static class TestClass1 {\n+\t\tpublic int index1 = 1;\n+\t\tpublic int index2 = 3;\n+\t\tpublic String word = \"abcd\";\t\t\n+\t}\n+\t\n+\tpublic static class TestClass4 {\n+\t\tpublic boolean a,b;\n+\t\tpublic boolean gettrue() { return true; }\n+\t\tpublic boolean getfalse() { return false; }\n+\t\tpublic boolean getA() { return a; }\n+\t\tpublic boolean getB() { return b; }\n+\t}\n+\t\n+\tpublic static class TestClass5 {\n+\t\tpublic int i = 0;\n+\t\tpublic String s = null;\n+\t\tpublic static int _i = 0;\n+\t\tpublic static String _s = null;\n+\t\t\n+\t\tpublic Object obj = null;\n+\t\t\n+\t\tpublic String field = null;\n+\t\t\n+\t\tpublic void reset() {\n+\t\t\ti = 0;\n+\t\t\t_i=0;\n+\t\t\ts = null;\n+\t\t\t_s = null;\n+\t\t\tfield = null;\n+\t\t}\n+\t\t\n+\t\tpublic void one() { i = 1; }\n+\t\t\n+\t\tpublic static void two() { _i = 1; }\n+\t\t\n+\t\tpublic String three() { return \"hello\"; }\n+\t\tpublic long four() { return 3277700L; }\n+\n+\t\tpublic static String five() { return \"hello\"; }\n+\t\tpublic static long six() { return 3277700L; }\n+\t\t\n+\t\tpublic void seven(String toset) { s = toset; }\n+//\t\tpublic void seven(Number n) { s = n.toString(); }\n+\t\t\n+\t\tpublic void takeNumber(Number n) { s = n.toString(); }\n+\t\tpublic void takeString(String s) { this.s = s; }\n+\t\tpublic static void eight(String toset) { _s = toset; }\n+\t\t\n+\t\tpublic void nine(int toset) { i = toset; }\n+\t\tpublic static void ten(int toset) { _i = toset; }\n+\t\t\n+\t\tpublic void eleven(String... vargs) { \n+\t\t\tif (vargs==null) {\n+\t\t\t\ts = \"\";\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ts = \"\";\n+\t\t\t\tfor (String varg: vargs) {\n+\t\t\t\t\ts+=varg;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\n+\t\tpublic void twelve(int... vargs) { \n+\t\t\tif (vargs==null) {\n+\t\t\t\ti = 0;\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\ti = 0;\n+\t\t\t\tfor (int varg: vargs) {\n+\t\t\t\t\ti+=varg;\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t}\n+\t\n+\tpublic static class TestClass6 {\n+\t\tpublic String orange = \"value1\";\n+\t\tpublic static String apple = \"value2\";\n+\t\t\n+\t\tpublic long peach = 34L;\n+\t\t\n+\t\tpublic String getBanana() {\n+\t\t\treturn \"value3\";\n+\t\t}\n+\n+\t\tpublic static String getPlum() {\n+\t\t\treturn \"value4\";\n+\t\t}\n+\t}\n+\t\n+\tpublic static class TestClass7 {\n+\t\tpublic static String property;\n+\t\tstatic {\n+\t\t\tString s = \"UK 123\";\n+\t\t\tStringTokenizer st = new StringTokenizer(s);\n+\t\t\tproperty = st.nextToken();\n+\t\t}\n+\t\t\n+\t\tpublic static void reset() {\n+\t\t\tString s = \"UK 123\";\n+\t\t\tStringTokenizer st = new StringTokenizer(s);\n+\t\t\tproperty = st.nextToken();\n+\t\t}\n+\t\t\n+\t}\n+\n+\tpublic static class TestClass8 {\n+\t\tpublic int i;\n+\t\tpublic String s;\n+\t\tpublic double d;\n+\t\tpublic boolean z;\n+\t\t\n+\t\tpublic TestClass8(int i, String s, double d, boolean z) {\n+\t\t\tthis.i = i;\n+\t\t\tthis.s = s;\n+\t\t\tthis.d = d;\n+\t\t\tthis.z = z;\n+\t\t}\n+\t\t\n+\t\tpublic TestClass8() {\n+\t\t\t\n+\t\t}\n+\t\t\n+\t\tpublic TestClass8(Integer i) {\n+\t\t\tthis.i = i;\n+\t\t}\n+\t\t\n+\t\t@SuppressWarnings(\"unused\")\n+\t\tprivate TestClass8(String a, String b) {\n+\t\t\tthis.s = a+b;\n+\t\t}\n+\t}\n+\t\n+\t@SuppressWarnings(\"unused\")\n+\tprivate static class TestClass9 {\n+\t\tpublic TestClass9(int i) {}\n+\t}\n+\t\n+}"
        },
        {
            "sha": "8d904a6b83da531172994b8af5afe1f92d4b14c0",
            "filename": "spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationPerformanceTests.java",
            "status": "added",
            "additions": 471,
            "deletions": 0,
            "changes": 471,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationPerformanceTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/2eeb2e92359381328789585233e54c9bbd41e6dc/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationPerformanceTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationPerformanceTests.java?ref=2eeb2e92359381328789585233e54c9bbd41e6dc",
            "patch": "@@ -0,0 +1,471 @@\n+/*\n+ * Copyright 2014 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.expression.spel;\n+\n+import org.junit.Ignore;\n+import org.junit.Test;\n+import org.springframework.expression.Expression;\n+import org.springframework.expression.spel.standard.SpelCompiler;\n+\n+import static org.junit.Assert.*;\n+\n+/**\n+ * Checks the speed of compiled SpEL expressions.\n+ * By default these tests are marked Ignore since they can fail on a busy machine because they\n+ * compare relative performance of interpreted vs compiled.\n+ *\n+ * @author Andy Clement\n+ * @since 4.1\n+ */\n+@Ignore\n+public class SpelCompilationPerformanceTests extends AbstractExpressionTests {\n+\n+\tint count = 50000; // Number of evaluations that are timed in one run\n+\tint iterations = 10; // Number of times to repeat 'count' evaluations (for averaging)\n+\tprivate final static boolean noisyTests = true;\n+\n+\tExpression expression;\n+\n+\tpublic static class Payload {\n+\t\tTwo[] DR = new Two[]{new Two()};\n+\n+\t\tpublic Two[] getDR() {\n+\t\t\treturn DR;\n+\t\t}\n+\t}\n+\n+\tpublic static class Two {\n+\t\tThree DRFixedSection = new Three();\n+\t\tpublic Three getDRFixedSection() {\n+\t\t\treturn DRFixedSection;\n+\t\t}\n+\t}\n+\n+\tpublic static class Three {\n+\t\tdouble duration = 0.4d;\n+\t\tpublic double getDuration() {\n+\t\t\treturn duration;\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void complexExpressionPerformance() throws Exception {\n+\t\tPayload payload = new Payload();\n+\t\tExpression expression = parser.parseExpression(\"DR[0].DRFixedSection.duration lt 0.1\");\n+\t\tboolean b = false;\n+\t\tlong iTotal = 0,cTotal = 0;\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\tb = expression.getValue(payload,Boolean.TYPE);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tlong stime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tb = expression.getValue(payload,Boolean.TYPE);\n+\t\t\t}\n+\t\t\tlong etime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tiTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\t\tboolean bc = false;\n+\t\texpression.getValue(payload,Boolean.TYPE);\n+\t\tlog(\"timing compiled: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tlong stime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tbc = expression.getValue(payload,Boolean.TYPE);\n+\t\t\t}\n+\t\t\tlong etime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\treportPerformance(\"complex expression\",iTotal, cTotal);\n+\n+\t\t// Verify the result\n+\t\tassertFalse(b);\n+\n+\t\t// Verify the same result for compiled vs interpreted\n+\t\tassertEquals(b,bc);\n+\n+\t\t// Verify if the input changes, the result changes\n+\t\tpayload.DR[0].DRFixedSection.duration = 0.04d;\n+\t\tbc = expression.getValue(payload,Boolean.TYPE);\n+\t\tassertTrue(bc);\n+\t}\n+\n+\tpublic static class HW {\n+\t\tpublic String hello() {\n+\t\t\treturn \"foobar\";\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void compilingMethodReference() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0;\n+\t\tlong stime,etime;\n+\t\tString interpretedResult = null,compiledResult = null;\n+\n+\t\tHW testdata = new HW();\n+\t\tExpression expression = parser.parseExpression(\"hello()\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\t\treportPerformance(\"method reference\", interpretedTotal, compiledTotal);\n+\t\tif (compiledTotal>=interpretedTotal) {\n+\t\t\tfail(\"Compiled version is slower than interpreted!\");\n+\t\t}\n+\t}\n+\n+\n+\n+\n+\tpublic static class TestClass2 {\n+\t\tpublic String name = \"Santa\";\n+\t\tprivate String name2 = \"foobar\";\n+\t\tpublic String getName2() {\n+\t\t\treturn name2;\n+\t\t}\n+\t\tpublic Foo foo = new Foo();\n+\t\tpublic static class Foo {\n+\t\t\tpublic Bar bar = new Bar();\n+\t\t\tBar b = new Bar();\n+\t\t\tpublic Bar getBaz() {\n+\t\t\t\treturn b;\n+\t\t\t}\n+\t\t\tpublic Bar bay() {\n+\t\t\t\treturn b;\n+\t\t\t}\n+\t\t}\n+\t\tpublic static class Bar {\n+\t\t\tpublic String boo = \"oranges\";\n+\t\t}\n+\t}\n+\n+\t@Test\n+\tpublic void compilingPropertyReferenceField() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0, stime, etime;\n+\t\tString interpretedResult = null, compiledResult = null;\n+\n+\t\tTestClass2 testdata = new TestClass2();\n+\t\tExpression expression = parser.parseExpression(\"name\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\texpression.getValue(testdata,String.class);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\t\treportPerformance(\"property reference (field)\",interpretedTotal, compiledTotal);\n+\t}\n+\n+\t@Test\n+\tpublic void compilingPropertyReferenceNestedField() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0, stime, etime;\n+\t\tString interpretedResult = null, compiledResult = null;\n+\n+\t\tTestClass2 testdata = new TestClass2();\n+\n+\t\tExpression expression = parser.parseExpression(\"foo.bar.boo\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\texpression.getValue(testdata,String.class);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\t\treportPerformance(\"property reference (nested field)\",interpretedTotal, compiledTotal);\n+\t}\n+\n+\t@Test\n+\tpublic void compilingPropertyReferenceNestedMixedFieldGetter() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0, stime, etime;\n+\t\tString interpretedResult = null, compiledResult = null;\n+\n+\t\tTestClass2 testdata = new TestClass2();\n+\t\tExpression expression = parser.parseExpression(\"foo.baz.boo\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\texpression.getValue(testdata,String.class);\n+\t\t}\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\t\treportPerformance(\"nested property reference (mixed field/getter)\",interpretedTotal, compiledTotal);\n+\t}\n+\n+\t@Test\n+\tpublic void compilingNestedMixedFieldPropertyReferenceMethodReference() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0, stime, etime;\n+\t\tString interpretedResult = null, compiledResult = null;\n+\n+\t\tTestClass2 testdata = new TestClass2();\n+\t\tExpression expression = parser.parseExpression(\"foo.bay().boo\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\texpression.getValue(testdata,String.class);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\t\treportPerformance(\"nested reference (mixed field/method)\",interpretedTotal, compiledTotal);\n+\t}\n+\n+\t@Test\n+\tpublic void compilingPropertyReferenceGetter() throws Exception {\n+\t\tlong interpretedTotal = 0, compiledTotal = 0, stime, etime;\n+\t\tString interpretedResult = null, compiledResult = null;\n+\n+\t\tTestClass2 testdata = new TestClass2();\n+\t\tExpression expression = parser.parseExpression(\"name2\");\n+\n+\t\t// warmup\n+\t\tfor (int i=0;i<count;i++) {\n+\t\t\texpression.getValue(testdata,String.class);\n+\t\t}\n+\n+\t\tlog(\"timing interpreted: \");\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tinterpretedResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong interpretedSpeed = (etime - stime);\n+\t\t\tinterpretedTotal+=interpretedSpeed;\n+\t\t\tlog(interpretedSpeed+\"ms \");\n+\t\t}\n+\t\tlogln();\n+\n+\n+\t\tcompile(expression);\n+\n+\t\tlog(\"timing compiled: \");\n+\t\texpression.getValue(testdata,String.class);\n+\t\tfor (int iter=0;iter<iterations;iter++) {\n+\t\t\tstime = System.currentTimeMillis();\n+\t\t\tfor (int i=0;i<count;i++) {\n+\t\t\t\tcompiledResult = expression.getValue(testdata,String.class);\n+\t\t\t}\n+\t\t\tetime = System.currentTimeMillis();\n+\t\t\tlong compiledSpeed = (etime - stime);\n+\t\t\tcompiledTotal+=compiledSpeed;\n+\t\t\tlog(compiledSpeed+\"ms \");\n+\n+\t\t}\n+\t\tlogln();\n+\n+\t\tassertEquals(interpretedResult,compiledResult);\n+\n+\t\treportPerformance(\"property reference (getter)\", interpretedTotal, compiledTotal);\n+\t\tif (compiledTotal>=interpretedTotal) {\n+\t\t\tfail(\"Compiled version is slower than interpreted!\");\n+\t\t}\n+\t}\n+\n+\t// ---\n+\n+\tprivate void reportPerformance(String title, long interpretedTotal, long compiledTotal) {\n+\t\tdouble averageInterpreted = interpretedTotal/(iterations);\n+\t\tdouble averageCompiled = compiledTotal/(iterations);\n+\t\tdouble ratio = (averageCompiled/averageInterpreted)*100.0d;\n+\t\tlogln(\">>\"+title+\": average for \"+count+\": compiled=\"+averageCompiled+\"ms interpreted=\"+averageInterpreted+\"ms: compiled takes \"+((int)ratio)+\"% of the interpreted time\");\n+\t\tif (averageCompiled>averageInterpreted) {\n+\t\t\tfail(\"Compiled version took longer than interpreted!  CompiledSpeed=~\"+averageCompiled+\n+\t\t\t\t\t\"ms InterpretedSpeed=\"+averageInterpreted+\"ms\");\n+\t\t}\n+\t\tlogln();\n+\t}\n+\n+\tprivate void log(String message) {\n+\t\tif (noisyTests) {\n+\t\t\tSystem.out.print(message);\n+\t\t}\n+\t}\n+\n+\tprivate void logln(String... message) {\n+\t\tif (noisyTests) {\n+\t\t\tif (message!=null && message.length>0) {\n+\t\t\t\tSystem.out.println(message[0]);\n+\t\t\t} else {\n+\t\t\t\tSystem.out.println();\n+\t\t\t}\n+\t\t}\n+\t}\n+\n+\tprivate void compile(Expression expression) {\n+\t\tassertTrue(SpelCompiler.compile(expression));\n+\t}\n+}"
        }
    ]
}
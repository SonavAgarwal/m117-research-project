{
    "sha": "b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
    "node_id": "MDY6Q29tbWl0MTYwOTk5OmIwZmJkYmEwYzJhMDMzNDcwNGY0Yzg5NjlmMmQwZGViNWQ3M2NmOTU=",
    "commit": {
        "author": {
            "name": "Michael Han",
            "email": "hanm@cloudera.com",
            "date": "2016-11-24T16:18:08Z"
        },
        "committer": {
            "name": "fpj",
            "email": "fpj@apache.org",
            "date": "2016-11-24T16:19:55Z"
        },
        "message": "ZOOKEEPER-2628: Fix findbug warnings.\n\nThis PR fixed 19 find bug warnings and disabled one find bug warning:\n\nMalicious code vulnerability Warnings\norg.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE is a mutable collection\nBug type MS_MUTABLE_COLLECTION (click for details)\nIn class org.apache.zookeeper.ZooDefs$Ids\nField org.apache.zookeeper.ZooDefs$Ids.OPEN_ACL_UNSAFE\nAt ZooDefs.java:[line 116]\n\nWe will use ZOOKEEPER-1362 for fixing this specific warning, which might require change to ZooDefs interface.\n\nAuthor: Michael Han <hanm@cloudera.com>\n\nReviewers: fpj <fpj@apache.org>, breed <breed@apache.org>, Edward Ribeiro <edward.ribeiro@gmail.com>, Allan Lyu <lvfangmin@gmail.com>\n\nCloses #102 from hanm/ZOOKEEPER-2628\n\n(cherry picked from commit b9beabf5cfbb8e447f67a8050486ca2821132f61)\nSigned-off-by: fpj <fpj@apache.org>",
        "tree": {
            "sha": "2d37dd5d04b82b611a7407150dfe5ed9c1a757a8",
            "url": "https://api.github.com/repos/apache/zookeeper/git/trees/2d37dd5d04b82b611a7407150dfe5ed9c1a757a8"
        },
        "url": "https://api.github.com/repos/apache/zookeeper/git/commits/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/zookeeper/commits/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
    "html_url": "https://github.com/apache/zookeeper/commit/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
    "comments_url": "https://api.github.com/repos/apache/zookeeper/commits/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/comments",
    "author": null,
    "committer": {
        "login": "fpj",
        "id": 572920,
        "node_id": "MDQ6VXNlcjU3MjkyMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/572920?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/fpj",
        "html_url": "https://github.com/fpj",
        "followers_url": "https://api.github.com/users/fpj/followers",
        "following_url": "https://api.github.com/users/fpj/following{/other_user}",
        "gists_url": "https://api.github.com/users/fpj/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/fpj/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/fpj/subscriptions",
        "organizations_url": "https://api.github.com/users/fpj/orgs",
        "repos_url": "https://api.github.com/users/fpj/repos",
        "events_url": "https://api.github.com/users/fpj/events{/privacy}",
        "received_events_url": "https://api.github.com/users/fpj/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "65d2572d98b4c93df180448cfccea27024585a75",
            "url": "https://api.github.com/repos/apache/zookeeper/commits/65d2572d98b4c93df180448cfccea27024585a75",
            "html_url": "https://github.com/apache/zookeeper/commit/65d2572d98b4c93df180448cfccea27024585a75"
        }
    ],
    "stats": {
        "total": 1164,
        "additions": 585,
        "deletions": 579
    },
    "files": [
        {
            "sha": "af931c9a847024b347419b6834066193a1913c0d",
            "filename": "src/java/main/org/apache/jute/compiler/CGenerator.java",
            "status": "modified",
            "additions": 57,
            "deletions": 58,
            "changes": 115,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCGenerator.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCGenerator.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCGenerator.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -61,70 +61,69 @@ void genCode() throws IOException {\n                         + outputDirectory);\n             }\n         }\n-        FileWriter c = new FileWriter(new File(outputDirectory, mName+\".c\"));\n-        FileWriter h = new FileWriter(new File(outputDirectory, mName+\".h\"));\n \n-        h.write(\"/**\\n\");\n-        h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        h.write(\"* distributed with this work for additional information\\n\");\n-        h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        h.write(\"*\\n\");\n-        h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        h.write(\"*\\n\");\n-        h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        h.write(\"* See the License for the specific language governing permissions and\\n\");\n-        h.write(\"* limitations under the License.\\n\");\n-        h.write(\"*/\\n\");\n-        h.write(\"\\n\");\n+        try (FileWriter c = new FileWriter(new File(outputDirectory, mName + \".c\"));\n+             FileWriter h = new FileWriter(new File(outputDirectory, mName + \".h\"));\n+        ) {\n+            h.write(\"/**\\n\");\n+            h.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            h.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            h.write(\"* distributed with this work for additional information\\n\");\n+            h.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            h.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            h.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            h.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            h.write(\"*\\n\");\n+            h.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            h.write(\"*\\n\");\n+            h.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            h.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            h.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            h.write(\"* See the License for the specific language governing permissions and\\n\");\n+            h.write(\"* limitations under the License.\\n\");\n+            h.write(\"*/\\n\");\n+            h.write(\"\\n\");\n \n-        c.write(\"/**\\n\");\n-        c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        c.write(\"* distributed with this work for additional information\\n\");\n-        c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        c.write(\"*\\n\");\n-        c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        c.write(\"*\\n\");\n-        c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        c.write(\"* See the License for the specific language governing permissions and\\n\");\n-        c.write(\"* limitations under the License.\\n\");\n-        c.write(\"*/\\n\");\n-        c.write(\"\\n\");\n+            c.write(\"/**\\n\");\n+            c.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            c.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            c.write(\"* distributed with this work for additional information\\n\");\n+            c.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            c.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            c.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            c.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            c.write(\"*\\n\");\n+            c.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            c.write(\"*\\n\");\n+            c.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            c.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            c.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            c.write(\"* See the License for the specific language governing permissions and\\n\");\n+            c.write(\"* limitations under the License.\\n\");\n+            c.write(\"*/\\n\");\n+            c.write(\"\\n\");\n \n-        h.write(\"#ifndef __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n-        h.write(\"#define __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n+            h.write(\"#ifndef __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n+            h.write(\"#define __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n \n-        h.write(\"#include \\\"recordio.h\\\"\\n\");\n-        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {\n-            JFile f = i.next();\n-            h.write(\"#include \\\"\"+f.getName()+\".h\\\"\\n\");\n-        }\n-        // required for compilation from C++\n-        h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n-\n-        c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n-        c.write(\"#include \\\"\"+mName+\".h\\\"\\n\\n\");\n+            h.write(\"#include \\\"recordio.h\\\"\\n\");\n+            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {\n+                JFile f = i.next();\n+                h.write(\"#include \\\"\" + f.getName() + \".h\\\"\\n\");\n+            }\n+            // required for compilation from C++\n+            h.write(\"\\n#ifdef __cplusplus\\nextern \\\"C\\\" {\\n#endif\\n\\n\");\n \n-        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {\n-            JRecord jr = i.next();\n-            jr.genCCode(h, c);\n-        }\n+            c.write(\"#include <stdlib.h>\\n\"); // need it for calloc() & free()\n+            c.write(\"#include \\\"\" + mName + \".h\\\"\\n\\n\");\n \n-        h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n-        h.write(\"#endif //\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n+            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {\n+                JRecord jr = i.next();\n+                jr.genCCode(h, c);\n+            }\n \n-        h.close();\n-        c.close();\n+            h.write(\"\\n#ifdef __cplusplus\\n}\\n#endif\\n\\n\");\n+            h.write(\"#endif //\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n+        }\n     }\n }"
        },
        {
            "sha": "9b1227871a3c10514c639b6389d6142a73fca873",
            "filename": "src/java/main/org/apache/jute/compiler/CppGenerator.java",
            "status": "modified",
            "additions": 53,
            "deletions": 54,
            "changes": 107,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCppGenerator.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCppGenerator.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FCppGenerator.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -61,65 +61,64 @@ void genCode() throws IOException {\n                         + outputDirectory);\n             }\n         }\n-        FileWriter cc = new FileWriter(new File(outputDirectory, mName+\".cc\"));\n-        FileWriter hh = new FileWriter(new File(outputDirectory, mName+\".hh\"));\n \n-        hh.write(\"/**\\n\");\n-        hh.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        hh.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        hh.write(\"* distributed with this work for additional information\\n\");\n-        hh.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        hh.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        hh.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        hh.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        hh.write(\"*\\n\");\n-        hh.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        hh.write(\"*\\n\");\n-        hh.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        hh.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        hh.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        hh.write(\"* See the License for the specific language governing permissions and\\n\");\n-        hh.write(\"* limitations under the License.\\n\");\n-        hh.write(\"*/\\n\");\n-        hh.write(\"\\n\");\n+        try (FileWriter cc = new FileWriter(new File(outputDirectory, mName + \".cc\"));\n+             FileWriter hh = new FileWriter(new File(outputDirectory, mName + \".hh\"));\n+        ) {\n+            hh.write(\"/**\\n\");\n+            hh.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            hh.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            hh.write(\"* distributed with this work for additional information\\n\");\n+            hh.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            hh.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            hh.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            hh.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            hh.write(\"*\\n\");\n+            hh.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            hh.write(\"*\\n\");\n+            hh.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            hh.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            hh.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            hh.write(\"* See the License for the specific language governing permissions and\\n\");\n+            hh.write(\"* limitations under the License.\\n\");\n+            hh.write(\"*/\\n\");\n+            hh.write(\"\\n\");\n \n-        cc.write(\"/**\\n\");\n-        cc.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        cc.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        cc.write(\"* distributed with this work for additional information\\n\");\n-        cc.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        cc.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        cc.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        cc.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        cc.write(\"*\\n\");\n-        cc.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        cc.write(\"*\\n\");\n-        cc.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        cc.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        cc.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        cc.write(\"* See the License for the specific language governing permissions and\\n\");\n-        cc.write(\"* limitations under the License.\\n\");\n-        cc.write(\"*/\\n\");\n-        cc.write(\"\\n\");\n+            cc.write(\"/**\\n\");\n+            cc.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            cc.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            cc.write(\"* distributed with this work for additional information\\n\");\n+            cc.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            cc.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            cc.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            cc.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            cc.write(\"*\\n\");\n+            cc.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            cc.write(\"*\\n\");\n+            cc.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            cc.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            cc.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            cc.write(\"* See the License for the specific language governing permissions and\\n\");\n+            cc.write(\"* limitations under the License.\\n\");\n+            cc.write(\"*/\\n\");\n+            cc.write(\"\\n\");\n \n-        hh.write(\"#ifndef __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n-        hh.write(\"#define __\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n+            hh.write(\"#ifndef __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n+            hh.write(\"#define __\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n \n-        hh.write(\"#include \\\"recordio.hh\\\"\\n\");\n-        for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext();) {\n-            JFile f = i.next();\n-            hh.write(\"#include \\\"\"+f.getName()+\".hh\\\"\\n\");\n-        }\n-        cc.write(\"#include \\\"\"+mName+\".hh\\\"\\n\");\n-\n-        for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext();) {\n-            JRecord jr = i.next();\n-            jr.genCppCode(hh, cc);\n-        }\n+            hh.write(\"#include \\\"recordio.hh\\\"\\n\");\n+            for (Iterator<JFile> i = mInclFiles.iterator(); i.hasNext(); ) {\n+                JFile f = i.next();\n+                hh.write(\"#include \\\"\" + f.getName() + \".hh\\\"\\n\");\n+            }\n+            cc.write(\"#include \\\"\" + mName + \".hh\\\"\\n\");\n \n-        hh.write(\"#endif //\"+mName.toUpperCase().replace('.','_')+\"__\\n\");\n+            for (Iterator<JRecord> i = mRecList.iterator(); i.hasNext(); ) {\n+                JRecord jr = i.next();\n+                jr.genCppCode(hh, cc);\n+            }\n \n-        hh.close();\n-        cc.close();\n+            hh.write(\"#endif //\" + mName.toUpperCase().replace('.', '_') + \"__\\n\");\n+        }\n     }\n }"
        },
        {
            "sha": "65bccccbbb0ae68ca69046eea0132483b0b384bf",
            "filename": "src/java/main/org/apache/jute/compiler/JRecord.java",
            "status": "modified",
            "additions": 412,
            "deletions": 408,
            "changes": 820,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fjute%2Fcompiler%2FJRecord.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -141,109 +141,116 @@ public String genCsharpWriteWrapper(String fname, String tag) {\n \n     static HashMap<String, String> vectorStructs = new HashMap<String, String>();\n     public void genCCode(FileWriter h, FileWriter c) throws IOException {\n-        for (JField f : mFields) {\n-            if (f.getType() instanceof JVector) {\n-                JVector jv = (JVector)f.getType();\n-                JType jvType = jv.getElementType();\n-                String struct_name = JVector.extractVectorName(jvType);\n-                if (vectorStructs.get(struct_name) == null) {\n-                    vectorStructs.put(struct_name, struct_name);\n-                    h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n-                    h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n-                    h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n-                    h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n-                    h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n-                    c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n-                    c.write(\"    if (!len) {\\n\");\n-                    c.write(\"        v->count = 0;\\n\");\n-                    c.write(\"        v->data = 0;\\n\");\n-                    c.write(\"    } else {\\n\");\n-                    c.write(\"        v->count = len;\\n\");\n-                    c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n-                    c.write(\"    }\\n\");\n-                    c.write(\"    return 0;\\n\");\n-                    c.write(\"}\\n\");\n-                    c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n-                    c.write(\"    if (v->data) {\\n\");\n-                    c.write(\"        int32_t i;\\n\");\n-                    c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n-                    c.write(\"            deallocate_\"+JRecord.extractMethodSuffix(jvType)+\"(&v->data[i]);\\n\");\n-                    c.write(\"        }\\n\");\n-                    c.write(\"        free(v->data);\\n\");\n-                    c.write(\"        v->data = 0;\\n\");\n-                    c.write(\"    }\\n\");\n-                    c.write(\"    return 0;\\n\");\n-                    c.write(\"}\\n\");\n-                    c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n-                    c.write(\"{\\n\");\n-                    c.write(\"    int32_t count = v->count;\\n\");\n-                    c.write(\"    int rc = 0;\\n\");\n-                    c.write(\"    int32_t i;\\n\");\n-                    c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n-                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n-                    genSerialize(c, jvType, \"data\", \"data[i]\");\n-                    c.write(\"    }\\n\");\n-                    c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n-                    c.write(\"    return rc;\\n\");\n-                    c.write(\"}\\n\");\n-                    c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n-                    c.write(\"{\\n\");\n-                    c.write(\"    int rc = 0;\\n\");\n-                    c.write(\"    int32_t i;\\n\");\n-                    c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n-                    c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n-                    c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n-                    genDeserialize(c, jvType, \"value\", \"data[i]\");\n-                    c.write(\"    }\\n\");\n-                    c.write(\"    rc = in->end_vector(in, tag);\\n\");\n-                    c.write(\"    return rc;\\n\");\n-                    c.write(\"}\\n\");\n-\n+        try {\n+            for (JField f : mFields) {\n+                if (f.getType() instanceof JVector) {\n+                    JVector jv = (JVector) f.getType();\n+                    JType jvType = jv.getElementType();\n+                    String struct_name = JVector.extractVectorName(jvType);\n+                    if (vectorStructs.get(struct_name) == null) {\n+                        vectorStructs.put(struct_name, struct_name);\n+                        h.write(\"struct \" + struct_name + \" {\\n    int32_t count;\\n\" + jv.getElementType().genCDecl(\"*data\") + \"\\n};\\n\");\n+                        h.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v);\\n\");\n+                        h.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v);\\n\");\n+                        h.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len);\\n\");\n+                        h.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v);\\n\");\n+                        c.write(\"int allocate_\" + struct_name + \"(struct \" + struct_name + \" *v, int32_t len) {\\n\");\n+                        c.write(\"    if (!len) {\\n\");\n+                        c.write(\"        v->count = 0;\\n\");\n+                        c.write(\"        v->data = 0;\\n\");\n+                        c.write(\"    } else {\\n\");\n+                        c.write(\"        v->count = len;\\n\");\n+                        c.write(\"        v->data = calloc(sizeof(*v->data), len);\\n\");\n+                        c.write(\"    }\\n\");\n+                        c.write(\"    return 0;\\n\");\n+                        c.write(\"}\\n\");\n+                        c.write(\"int deallocate_\" + struct_name + \"(struct \" + struct_name + \" *v) {\\n\");\n+                        c.write(\"    if (v->data) {\\n\");\n+                        c.write(\"        int32_t i;\\n\");\n+                        c.write(\"        for(i=0;i<v->count; i++) {\\n\");\n+                        c.write(\"            deallocate_\" + JRecord.extractMethodSuffix(jvType) + \"(&v->data[i]);\\n\");\n+                        c.write(\"        }\\n\");\n+                        c.write(\"        free(v->data);\\n\");\n+                        c.write(\"        v->data = 0;\\n\");\n+                        c.write(\"    }\\n\");\n+                        c.write(\"    return 0;\\n\");\n+                        c.write(\"}\\n\");\n+                        c.write(\"int serialize_\" + struct_name + \"(struct oarchive *out, const char *tag, struct \" + struct_name + \" *v)\\n\");\n+                        c.write(\"{\\n\");\n+                        c.write(\"    int32_t count = v->count;\\n\");\n+                        c.write(\"    int rc = 0;\\n\");\n+                        c.write(\"    int32_t i;\\n\");\n+                        c.write(\"    rc = out->start_vector(out, tag, &count);\\n\");\n+                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n+                        genSerialize(c, jvType, \"data\", \"data[i]\");\n+                        c.write(\"    }\\n\");\n+                        c.write(\"    rc = rc ? rc : out->end_vector(out, tag);\\n\");\n+                        c.write(\"    return rc;\\n\");\n+                        c.write(\"}\\n\");\n+                        c.write(\"int deserialize_\" + struct_name + \"(struct iarchive *in, const char *tag, struct \" + struct_name + \" *v)\\n\");\n+                        c.write(\"{\\n\");\n+                        c.write(\"    int rc = 0;\\n\");\n+                        c.write(\"    int32_t i;\\n\");\n+                        c.write(\"    rc = in->start_vector(in, tag, &v->count);\\n\");\n+                        c.write(\"    v->data = calloc(v->count, sizeof(*v->data));\\n\");\n+                        c.write(\"    for(i=0;i<v->count;i++) {\\n\");\n+                        genDeserialize(c, jvType, \"value\", \"data[i]\");\n+                        c.write(\"    }\\n\");\n+                        c.write(\"    rc = in->end_vector(in, tag);\\n\");\n+                        c.write(\"    return rc;\\n\");\n+                        c.write(\"}\\n\");\n+\n+                    }\n                 }\n             }\n-        }\n-        String rec_name = getName();\n-        h.write(\"struct \" + rec_name + \" {\\n\");\n-        for (JField f : mFields) {\n-            h.write(f.genCDecl());\n-        }\n-        h.write(\"};\\n\");\n-        h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n-        h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n-        h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n-        c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n-        c.write(\"{\\n\");\n-        c.write(\"    int rc;\\n\");\n-        c.write(\"    rc = out->start_record(out, tag);\\n\");\n-        for(JField f : mFields) {\n-            genSerialize(c, f.getType(), f.getTag(), f.getName());\n-        }\n-        c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n-        c.write(\"    return rc;\\n\");\n-        c.write(\"}\\n\");\n-        c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n-        c.write(\"{\\n\");\n-        c.write(\"    int rc;\\n\");\n-        c.write(\"    rc = in->start_record(in, tag);\\n\");\n-        for(JField f : mFields) {\n-            genDeserialize(c, f.getType(), f.getTag(), f.getName());\n-        }\n-        c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n-        c.write(\"    return rc;\\n\");\n-        c.write(\"}\\n\");\n-        c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n-        c.write(\"{\\n\");\n-        for(JField f : mFields) {\n-            if (f.getType() instanceof JRecord) {\n-                c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n-            } else if (f.getType() instanceof JVector) {\n-                JVector vt = (JVector)f.getType();\n-                c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType())+ \"(&v->\"+f.getName()+\");\\n\");\n-            } else if (f.getType() instanceof JCompType) {\n-                c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\"+f.getName()+\");\\n\");\n+            String rec_name = getName();\n+            h.write(\"struct \" + rec_name + \" {\\n\");\n+            for (JField f : mFields) {\n+                h.write(f.genCDecl());\n+            }\n+            h.write(\"};\\n\");\n+            h.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v);\\n\");\n+            h.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v);\\n\");\n+            h.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*);\\n\");\n+            c.write(\"int serialize_\" + rec_name + \"(struct oarchive *out, const char *tag, struct \" + rec_name + \" *v)\");\n+            c.write(\"{\\n\");\n+            c.write(\"    int rc;\\n\");\n+            c.write(\"    rc = out->start_record(out, tag);\\n\");\n+            for (JField f : mFields) {\n+                genSerialize(c, f.getType(), f.getTag(), f.getName());\n+            }\n+            c.write(\"    rc = rc ? rc : out->end_record(out, tag);\\n\");\n+            c.write(\"    return rc;\\n\");\n+            c.write(\"}\\n\");\n+            c.write(\"int deserialize_\" + rec_name + \"(struct iarchive *in, const char *tag, struct \" + rec_name + \"*v)\");\n+            c.write(\"{\\n\");\n+            c.write(\"    int rc;\\n\");\n+            c.write(\"    rc = in->start_record(in, tag);\\n\");\n+            for (JField f : mFields) {\n+                genDeserialize(c, f.getType(), f.getTag(), f.getName());\n+            }\n+            c.write(\"    rc = rc ? rc : in->end_record(in, tag);\\n\");\n+            c.write(\"    return rc;\\n\");\n+            c.write(\"}\\n\");\n+            c.write(\"void deallocate_\" + rec_name + \"(struct \" + rec_name + \"*v)\");\n+            c.write(\"{\\n\");\n+            for (JField f : mFields) {\n+                if (f.getType() instanceof JRecord) {\n+                    c.write(\"    deallocate_\" + extractStructName(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n+                } else if (f.getType() instanceof JVector) {\n+                    JVector vt = (JVector) f.getType();\n+                    c.write(\"    deallocate_\" + JVector.extractVectorName(vt.getElementType()) + \"(&v->\" + f.getName() + \");\\n\");\n+                } else if (f.getType() instanceof JCompType) {\n+                    c.write(\"    deallocate_\" + extractMethodSuffix(f.getType()) + \"(&v->\" + f.getName() + \");\\n\");\n+                }\n             }\n+            c.write(\"}\\n\");\n+        } catch (IOException e) {\n+            throw e;\n+        } finally {\n+            h.close();\n+            c.close();\n         }\n-        c.write(\"}\\n\");\n     }\n \n     private void genSerialize(FileWriter c, JType type, String tag, String name) throws IOException {\n@@ -403,168 +410,165 @@ public void genJavaCode(File outputDirectory) throws IOException {\n         } else if (!pkgdir.isDirectory()) {\n             throw new IOException(pkgpath + \" is not a directory.\");\n         }\n-        File jfile = new File(pkgdir, getName()+\".java\");\n-        FileWriter jj = new FileWriter(jfile);\n-        jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n-        jj.write(\"/**\\n\");\n-        jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        jj.write(\"* distributed with this work for additional information\\n\");\n-        jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        jj.write(\"*\\n\");\n-        jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        jj.write(\"*\\n\");\n-        jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        jj.write(\"* See the License for the specific language governing permissions and\\n\");\n-        jj.write(\"* limitations under the License.\\n\");\n-        jj.write(\"*/\\n\");\n-        jj.write(\"\\n\");\n-        jj.write(\"package \"+getJavaPackage()+\";\\n\\n\");\n-        jj.write(\"import org.apache.jute.*;\\n\");\n-        jj.write(\"public class \"+getName()+\" implements Record {\\n\");\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext();) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaDecl());\n-        }\n-        jj.write(\"  public \"+getName()+\"() {\\n\");\n-        jj.write(\"  }\\n\");\n+        try (FileWriter jj = new FileWriter(new File(pkgdir, getName()+\".java\"))) {\n+            jj.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n+            jj.write(\"/**\\n\");\n+            jj.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            jj.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            jj.write(\"* distributed with this work for additional information\\n\");\n+            jj.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            jj.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            jj.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            jj.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            jj.write(\"*\\n\");\n+            jj.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            jj.write(\"*\\n\");\n+            jj.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            jj.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            jj.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            jj.write(\"* See the License for the specific language governing permissions and\\n\");\n+            jj.write(\"* limitations under the License.\\n\");\n+            jj.write(\"*/\\n\");\n+            jj.write(\"\\n\");\n+            jj.write(\"package \" + getJavaPackage() + \";\\n\\n\");\n+            jj.write(\"import org.apache.jute.*;\\n\");\n+            jj.write(\"public class \" + getName() + \" implements Record {\\n\");\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); ) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaDecl());\n+            }\n+            jj.write(\"  public \" + getName() + \"() {\\n\");\n+            jj.write(\"  }\\n\");\n \n-        jj.write(\"  public \"+getName()+\"(\\n\");\n-        int fIdx = 0;\n-        int fLen = mFields.size();\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaConstructorParam(jf.getName()));\n-            jj.write((fLen-1 == fIdx)?\"\":\",\\n\");\n-        }\n-        jj.write(\") {\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaConstructorSet(jf.getName()));\n-        }\n-        jj.write(\"  }\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaGetSet(fIdx));\n-        }\n-        jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n-        jj.write(\"    a_.startRecord(this,tag);\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaWriteMethodName());\n-        }\n-        jj.write(\"    a_.endRecord(this,tag);\\n\");\n-        jj.write(\"  }\\n\");\n+            jj.write(\"  public \" + getName() + \"(\\n\");\n+            int fIdx = 0;\n+            int fLen = mFields.size();\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaConstructorParam(jf.getName()));\n+                jj.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n+            }\n+            jj.write(\") {\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaConstructorSet(jf.getName()));\n+            }\n+            jj.write(\"  }\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaGetSet(fIdx));\n+            }\n+            jj.write(\"  public void serialize(OutputArchive a_, String tag) throws java.io.IOException {\\n\");\n+            jj.write(\"    a_.startRecord(this,tag);\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaWriteMethodName());\n+            }\n+            jj.write(\"    a_.endRecord(this,tag);\\n\");\n+            jj.write(\"  }\\n\");\n \n-        jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n-        jj.write(\"    a_.startRecord(tag);\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaReadMethodName());\n-        }\n-        jj.write(\"    a_.endRecord(tag);\\n\");\n-        jj.write(\"}\\n\");\n-\n-        jj.write(\"  public String toString() {\\n\");\n-        jj.write(\"    try {\\n\");\n-        jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n-        jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n-        jj.write(\"      CsvOutputArchive a_ = \\n\");\n-        jj.write(\"        new CsvOutputArchive(s);\\n\");\n-        jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaWriteMethodName());\n-        }\n-        jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n-        jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n-        jj.write(\"    } catch (Throwable ex) {\\n\");\n-        jj.write(\"      ex.printStackTrace();\\n\");\n-        jj.write(\"    }\\n\");\n-        jj.write(\"    return \\\"ERROR\\\";\\n\");\n-        jj.write(\"  }\\n\");\n-\n-        jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n-        jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n-        jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n-        jj.write(\"  }\\n\");\n-\n-        jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n-        jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n-        jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n-        jj.write(\"  }\\n\");\n-\n-        jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n-        boolean unimplemented = false;\n-        for (JField f : mFields) {\n-            if ((f.getType() instanceof JMap)\n-                    || (f.getType() instanceof JVector))\n-            {\n-                unimplemented = true;\n+            jj.write(\"  public void deserialize(InputArchive a_, String tag) throws java.io.IOException {\\n\");\n+            jj.write(\"    a_.startRecord(tag);\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaReadMethodName());\n             }\n-        }\n-        if (unimplemented) {\n-            jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n-                    + getName() + \" is unimplemented\\\");\\n\");\n-        } else {\n-            jj.write(\"    if (!(peer_ instanceof \"+getName()+\")) {\\n\");\n-            jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n+            jj.write(\"    a_.endRecord(tag);\\n\");\n+            jj.write(\"}\\n\");\n+\n+            jj.write(\"  public String toString() {\\n\");\n+            jj.write(\"    try {\\n\");\n+            jj.write(\"      java.io.ByteArrayOutputStream s =\\n\");\n+            jj.write(\"        new java.io.ByteArrayOutputStream();\\n\");\n+            jj.write(\"      CsvOutputArchive a_ = \\n\");\n+            jj.write(\"        new CsvOutputArchive(s);\\n\");\n+            jj.write(\"      a_.startRecord(this,\\\"\\\");\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaWriteMethodName());\n+            }\n+            jj.write(\"      a_.endRecord(this,\\\"\\\");\\n\");\n+            jj.write(\"      return new String(s.toByteArray(), \\\"UTF-8\\\");\\n\");\n+            jj.write(\"    } catch (Throwable ex) {\\n\");\n+            jj.write(\"      ex.printStackTrace();\\n\");\n             jj.write(\"    }\\n\");\n-            jj.write(\"    \"+getName()+\" peer = (\"+getName()+\") peer_;\\n\");\n-            jj.write(\"    int ret = 0;\\n\");\n+            jj.write(\"    return \\\"ERROR\\\";\\n\");\n+            jj.write(\"  }\\n\");\n+\n+            jj.write(\"  public void write(java.io.DataOutput out) throws java.io.IOException {\\n\");\n+            jj.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(out);\\n\");\n+            jj.write(\"    serialize(archive, \\\"\\\");\\n\");\n+            jj.write(\"  }\\n\");\n+\n+            jj.write(\"  public void readFields(java.io.DataInput in) throws java.io.IOException {\\n\");\n+            jj.write(\"    BinaryInputArchive archive = new BinaryInputArchive(in);\\n\");\n+            jj.write(\"    deserialize(archive, \\\"\\\");\\n\");\n+            jj.write(\"  }\\n\");\n+\n+            jj.write(\"  public int compareTo (Object peer_) throws ClassCastException {\\n\");\n+            boolean unimplemented = false;\n+            for (JField f : mFields) {\n+                if ((f.getType() instanceof JMap)\n+                        || (f.getType() instanceof JVector)) {\n+                    unimplemented = true;\n+                }\n+            }\n+            if (unimplemented) {\n+                jj.write(\"    throw new UnsupportedOperationException(\\\"comparing \"\n+                        + getName() + \" is unimplemented\\\");\\n\");\n+            } else {\n+                jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n+                jj.write(\"      throw new ClassCastException(\\\"Comparing different types of records.\\\");\\n\");\n+                jj.write(\"    }\\n\");\n+                jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n+                jj.write(\"    int ret = 0;\\n\");\n+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                    JField jf = i.next();\n+                    jj.write(jf.genJavaCompareTo());\n+                    jj.write(\"    if (ret != 0) return ret;\\n\");\n+                }\n+                jj.write(\"     return ret;\\n\");\n+            }\n+            jj.write(\"  }\\n\");\n+\n+            jj.write(\"  public boolean equals(Object peer_) {\\n\");\n+            jj.write(\"    if (!(peer_ instanceof \" + getName() + \")) {\\n\");\n+            jj.write(\"      return false;\\n\");\n+            jj.write(\"    }\\n\");\n+            jj.write(\"    if (peer_ == this) {\\n\");\n+            jj.write(\"      return true;\\n\");\n+            jj.write(\"    }\\n\");\n+            jj.write(\"    \" + getName() + \" peer = (\" + getName() + \") peer_;\\n\");\n+            jj.write(\"    boolean ret = false;\\n\");\n             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                 JField jf = i.next();\n-                jj.write(jf.genJavaCompareTo());\n-                jj.write(\"    if (ret != 0) return ret;\\n\");\n+                jj.write(jf.genJavaEquals());\n+                jj.write(\"    if (!ret) return ret;\\n\");\n             }\n             jj.write(\"     return ret;\\n\");\n-        }\n-        jj.write(\"  }\\n\");\n-\n-        jj.write(\"  public boolean equals(Object peer_) {\\n\");\n-        jj.write(\"    if (!(peer_ instanceof \"+getName()+\")) {\\n\");\n-        jj.write(\"      return false;\\n\");\n-        jj.write(\"    }\\n\");\n-        jj.write(\"    if (peer_ == this) {\\n\");\n-        jj.write(\"      return true;\\n\");\n-        jj.write(\"    }\\n\");\n-        jj.write(\"    \"+getName()+\" peer = (\"+getName()+\") peer_;\\n\");\n-        jj.write(\"    boolean ret = false;\\n\");\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaEquals());\n-            jj.write(\"    if (!ret) return ret;\\n\");\n-        }\n-        jj.write(\"     return ret;\\n\");\n-        jj.write(\"  }\\n\");\n+            jj.write(\"  }\\n\");\n \n-        jj.write(\"  public int hashCode() {\\n\");\n-        jj.write(\"    int result = 17;\\n\");\n-        jj.write(\"    int ret;\\n\");\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            jj.write(jf.genJavaHashCode());\n-            jj.write(\"    result = 37*result + ret;\\n\");\n-        }\n-        jj.write(\"    return result;\\n\");\n-        jj.write(\"  }\\n\");\n-        jj.write(\"  public static String signature() {\\n\");\n-        jj.write(\"    return \\\"\"+getSignature()+\"\\\";\\n\");\n-        jj.write(\"  }\\n\");\n-\n-        jj.write(\"}\\n\");\n+            jj.write(\"  public int hashCode() {\\n\");\n+            jj.write(\"    int result = 17;\\n\");\n+            jj.write(\"    int ret;\\n\");\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                jj.write(jf.genJavaHashCode());\n+                jj.write(\"    result = 37*result + ret;\\n\");\n+            }\n+            jj.write(\"    return result;\\n\");\n+            jj.write(\"  }\\n\");\n+            jj.write(\"  public static String signature() {\\n\");\n+            jj.write(\"    return \\\"\" + getSignature() + \"\\\";\\n\");\n+            jj.write(\"  }\\n\");\n \n-        jj.close();\n+            jj.write(\"}\\n\");\n+        }\n     }\n \n     public void genCsharpCode(File outputDirectory) throws IOException {\n@@ -576,174 +580,174 @@ public void genCsharpCode(File outputDirectory) throws IOException {\n         } else if (!outputDirectory.isDirectory()) {\n             throw new IOException(outputDirectory + \" is not a directory.\");\n         }\n-        File csharpFile = new File(outputDirectory, getName()+\".cs\");\n-        FileWriter cs = new FileWriter(csharpFile);\n-        cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n-        cs.write(\"/**\\n\");\n-        cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n-        cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n-        cs.write(\"* distributed with this work for additional information\\n\");\n-        cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n-        cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n-        cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n-        cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n-        cs.write(\"*\\n\");\n-        cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n-        cs.write(\"*\\n\");\n-        cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n-        cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n-        cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n-        cs.write(\"* See the License for the specific language governing permissions and\\n\");\n-        cs.write(\"* limitations under the License.\\n\");\n-        cs.write(\"*/\\n\");\n-        cs.write(\"\\n\");\n-        cs.write(\"using System;\\n\");\n-        cs.write(\"using Org.Apache.Jute;\\n\");\n-        cs.write(\"\\n\");        \n-        cs.write(\"namespace \"+getCsharpNameSpace()+\"\\n\");\n-        cs.write(\"{\\n\");\n-\n-        String className = getCsharpName();\n-        cs.write(\"public class \"+className+\" : IRecord, IComparable \\n\");\n-        cs.write(\"{\\n\");\n-        cs.write(\"  public \"+ className +\"() {\\n\");\n-        cs.write(\"  }\\n\");\n-\n-        cs.write(\"  public \"+className+\"(\\n\");\n-        int fIdx = 0;\n-        int fLen = mFields.size();\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n-            cs.write((fLen-1 == fIdx)?\"\":\",\\n\");\n-        }\n-        cs.write(\") {\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n-        }\n-        cs.write(\"  }\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpGetSet(fIdx));\n+\n+        try (FileWriter cs = new FileWriter(new File(outputDirectory, getName() + \".cs\"));) {\n+            cs.write(\"// File generated by hadoop record compiler. Do not edit.\\n\");\n+            cs.write(\"/**\\n\");\n+            cs.write(\"* Licensed to the Apache Software Foundation (ASF) under one\\n\");\n+            cs.write(\"* or more contributor license agreements.  See the NOTICE file\\n\");\n+            cs.write(\"* distributed with this work for additional information\\n\");\n+            cs.write(\"* regarding copyright ownership.  The ASF licenses this file\\n\");\n+            cs.write(\"* to you under the Apache License, Version 2.0 (the\\n\");\n+            cs.write(\"* \\\"License\\\"); you may not use this file except in compliance\\n\");\n+            cs.write(\"* with the License.  You may obtain a copy of the License at\\n\");\n+            cs.write(\"*\\n\");\n+            cs.write(\"*     http://www.apache.org/licenses/LICENSE-2.0\\n\");\n+            cs.write(\"*\\n\");\n+            cs.write(\"* Unless required by applicable law or agreed to in writing, software\\n\");\n+            cs.write(\"* distributed under the License is distributed on an \\\"AS IS\\\" BASIS,\\n\");\n+            cs.write(\"* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\\n\");\n+            cs.write(\"* See the License for the specific language governing permissions and\\n\");\n+            cs.write(\"* limitations under the License.\\n\");\n+            cs.write(\"*/\\n\");\n             cs.write(\"\\n\");\n-        }\n-        cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n-        cs.write(\"    a_.StartRecord(this,tag);\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpWriteMethodName());\n-        }\n-        cs.write(\"    a_.EndRecord(this,tag);\\n\");\n-        cs.write(\"  }\\n\");\n+            cs.write(\"using System;\\n\");\n+            cs.write(\"using Org.Apache.Jute;\\n\");\n+            cs.write(\"\\n\");\n+            cs.write(\"namespace \" + getCsharpNameSpace() + \"\\n\");\n+            cs.write(\"{\\n\");\n+\n+            String className = getCsharpName();\n+            cs.write(\"public class \" + className + \" : IRecord, IComparable \\n\");\n+            cs.write(\"{\\n\");\n+            cs.write(\"  public \" + className + \"() {\\n\");\n+            cs.write(\"  }\\n\");\n+\n+            cs.write(\"  public \" + className + \"(\\n\");\n+            int fIdx = 0;\n+            int fLen = mFields.size();\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpConstructorParam(jf.getCsharpName()));\n+                cs.write((fLen - 1 == fIdx) ? \"\" : \",\\n\");\n+            }\n+            cs.write(\") {\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpConstructorSet(jf.getCsharpName()));\n+            }\n+            cs.write(\"  }\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpGetSet(fIdx));\n+                cs.write(\"\\n\");\n+            }\n+            cs.write(\"  public void Serialize(IOutputArchive a_, String tag) {\\n\");\n+            cs.write(\"    a_.StartRecord(this,tag);\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpWriteMethodName());\n+            }\n+            cs.write(\"    a_.EndRecord(this,tag);\\n\");\n+            cs.write(\"  }\\n\");\n \n-        cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n-        cs.write(\"    a_.StartRecord(tag);\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpReadMethodName());\n-        }\n-        cs.write(\"    a_.EndRecord(tag);\\n\");\n-        cs.write(\"}\\n\");\n-\n-        cs.write(\"  public override String ToString() {\\n\");\n-        cs.write(\"    try {\\n\");\n-        cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n-        cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n-        cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n-        cs.write(\"      BinaryOutputArchive a_ = \\n\");\n-        cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n-        cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n-        fIdx = 0;\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpWriteMethodName());\n-        }\n-        cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n-        cs.write(\"      ms.Position = 0;\\n\");\n-        cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n-        cs.write(\"    } catch (Exception ex) {\\n\");\n-        cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n-        cs.write(\"    }\\n\");\n-        cs.write(\"    return \\\"ERROR\\\";\\n\");\n-        cs.write(\"  }\\n\");\n-\n-        cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n-        cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n-        cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n-        cs.write(\"  }\\n\");\n-\n-        cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n-        cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n-        cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n-        cs.write(\"  }\\n\");\n-\n-        cs.write(\"  public int CompareTo (object peer_) {\\n\");\n-        boolean unimplemented = false;\n-        for (JField f : mFields) {\n-            if ((f.getType() instanceof JMap)\n-                    || (f.getType() instanceof JVector))\n-            {\n-                unimplemented = true;\n+            cs.write(\"  public void Deserialize(IInputArchive a_, String tag) {\\n\");\n+            cs.write(\"    a_.StartRecord(tag);\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpReadMethodName());\n             }\n-        }\n-        if (unimplemented) {\n-            cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n-                    + getCsharpName() + \" is unimplemented\\\");\\n\");\n-        } else {\n-            cs.write(\"    if (!(peer_ is \"+getCsharpName()+\")) {\\n\");\n-            cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n+            cs.write(\"    a_.EndRecord(tag);\\n\");\n+            cs.write(\"}\\n\");\n+\n+            cs.write(\"  public override String ToString() {\\n\");\n+            cs.write(\"    try {\\n\");\n+            cs.write(\"      System.IO.MemoryStream ms = new System.IO.MemoryStream();\\n\");\n+            cs.write(\"      MiscUtil.IO.EndianBinaryWriter writer =\\n\");\n+            cs.write(\"        new MiscUtil.IO.EndianBinaryWriter(MiscUtil.Conversion.EndianBitConverter.Big, ms, System.Text.Encoding.UTF8);\\n\");\n+            cs.write(\"      BinaryOutputArchive a_ = \\n\");\n+            cs.write(\"        new BinaryOutputArchive(writer);\\n\");\n+            cs.write(\"      a_.StartRecord(this,\\\"\\\");\\n\");\n+            fIdx = 0;\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpWriteMethodName());\n+            }\n+            cs.write(\"      a_.EndRecord(this,\\\"\\\");\\n\");\n+            cs.write(\"      ms.Position = 0;\\n\");\n+            cs.write(\"      return System.Text.Encoding.UTF8.GetString(ms.ToArray());\\n\");\n+            cs.write(\"    } catch (Exception ex) {\\n\");\n+            cs.write(\"      Console.WriteLine(ex.StackTrace);\\n\");\n             cs.write(\"    }\\n\");\n-            cs.write(\"    \"+getCsharpName()+\" peer = (\"+getCsharpName()+\") peer_;\\n\");\n-            cs.write(\"    int ret = 0;\\n\");\n+            cs.write(\"    return \\\"ERROR\\\";\\n\");\n+            cs.write(\"  }\\n\");\n+\n+            cs.write(\"  public void Write(MiscUtil.IO.EndianBinaryWriter writer) {\\n\");\n+            cs.write(\"    BinaryOutputArchive archive = new BinaryOutputArchive(writer);\\n\");\n+            cs.write(\"    Serialize(archive, \\\"\\\");\\n\");\n+            cs.write(\"  }\\n\");\n+\n+            cs.write(\"  public void ReadFields(MiscUtil.IO.EndianBinaryReader reader) {\\n\");\n+            cs.write(\"    BinaryInputArchive archive = new BinaryInputArchive(reader);\\n\");\n+            cs.write(\"    Deserialize(archive, \\\"\\\");\\n\");\n+            cs.write(\"  }\\n\");\n+\n+            cs.write(\"  public int CompareTo (object peer_) {\\n\");\n+            boolean unimplemented = false;\n+            for (JField f : mFields) {\n+                if ((f.getType() instanceof JMap)\n+                        || (f.getType() instanceof JVector)) {\n+                    unimplemented = true;\n+                }\n+            }\n+            if (unimplemented) {\n+                cs.write(\"    throw new InvalidOperationException(\\\"comparing \"\n+                        + getCsharpName() + \" is unimplemented\\\");\\n\");\n+            } else {\n+                cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n+                cs.write(\"      throw new InvalidOperationException(\\\"Comparing different types of records.\\\");\\n\");\n+                cs.write(\"    }\\n\");\n+                cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \") peer_;\\n\");\n+                cs.write(\"    int ret = 0;\\n\");\n+                for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                    JField jf = i.next();\n+                    cs.write(jf.genCsharpCompareTo());\n+                    cs.write(\"    if (ret != 0) return ret;\\n\");\n+                }\n+                cs.write(\"     return ret;\\n\");\n+            }\n+            cs.write(\"  }\\n\");\n+\n+            cs.write(\"  public override bool Equals(object peer_) {\\n\");\n+            cs.write(\"    if (!(peer_ is \" + getCsharpName() + \")) {\\n\");\n+            cs.write(\"      return false;\\n\");\n+            cs.write(\"    }\\n\");\n+            cs.write(\"    if (peer_ == this) {\\n\");\n+            cs.write(\"      return true;\\n\");\n+            cs.write(\"    }\\n\");\n+            cs.write(\"    bool ret = false;\\n\");\n+            cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \")peer_;\\n\");\n             for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n                 JField jf = i.next();\n-                cs.write(jf.genCsharpCompareTo());\n-                cs.write(\"    if (ret != 0) return ret;\\n\");\n+                cs.write(jf.genCsharpEquals());\n+                cs.write(\"    if (!ret) return ret;\\n\");\n             }\n             cs.write(\"     return ret;\\n\");\n-        }\n-        cs.write(\"  }\\n\");\n-\n-        cs.write(\"  public override bool Equals(object peer_) {\\n\");\n-        cs.write(\"    if (!(peer_ is \"+getCsharpName()+\")) {\\n\");\n-        cs.write(\"      return false;\\n\");\n-        cs.write(\"    }\\n\");\n-        cs.write(\"    if (peer_ == this) {\\n\");\n-        cs.write(\"      return true;\\n\");\n-        cs.write(\"    }\\n\");\n-        cs.write(\"    bool ret = false;\\n\");\n-        cs.write(\"    \" + getCsharpName() + \" peer = (\" + getCsharpName() + \")peer_;\\n\");\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpEquals());\n-            cs.write(\"    if (!ret) return ret;\\n\");\n-        }\n-        cs.write(\"     return ret;\\n\");\n-        cs.write(\"  }\\n\");\n+            cs.write(\"  }\\n\");\n \n-        cs.write(\"  public override int GetHashCode() {\\n\");\n-        cs.write(\"    int result = 17;\\n\");\n-        cs.write(\"    int ret;\\n\");\n-        for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n-            JField jf = i.next();\n-            cs.write(jf.genCsharpHashCode());\n-            cs.write(\"    result = 37*result + ret;\\n\");\n-        }\n-        cs.write(\"    return result;\\n\");\n-        cs.write(\"  }\\n\");\n-        cs.write(\"  public static string Signature() {\\n\");\n-        cs.write(\"    return \\\"\"+getSignature()+\"\\\";\\n\");\n-        cs.write(\"  }\\n\");\n+            cs.write(\"  public override int GetHashCode() {\\n\");\n+            cs.write(\"    int result = 17;\\n\");\n+            cs.write(\"    int ret;\\n\");\n+            for (Iterator<JField> i = mFields.iterator(); i.hasNext(); fIdx++) {\n+                JField jf = i.next();\n+                cs.write(jf.genCsharpHashCode());\n+                cs.write(\"    result = 37*result + ret;\\n\");\n+            }\n+            cs.write(\"    return result;\\n\");\n+            cs.write(\"  }\\n\");\n+            cs.write(\"  public static string Signature() {\\n\");\n+            cs.write(\"    return \\\"\" + getSignature() + \"\\\";\\n\");\n+            cs.write(\"  }\\n\");\n \n-        cs.write(\"}\\n\");\n-        cs.write(\"}\\n\");\n+            cs.write(\"}\\n\");\n+            cs.write(\"}\\n\");\n \n-        cs.close();\n+            cs.close();\n+        }\n     }\n \n     public static String getCsharpFQName(String name) {"
        },
        {
            "sha": "8e39022b4a9c5c7e622ffe00bc60346e99a937b6",
            "filename": "src/java/main/org/apache/zookeeper/ZooKeeperMain.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FZooKeeperMain.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -74,8 +74,8 @@\n  */\n public class ZooKeeperMain {\n     private static final Logger LOG = LoggerFactory.getLogger(ZooKeeperMain.class);\n-    protected static final Map<String,String> commandMap = new HashMap<String,String>( );\n-    protected static final Map<String,CliCommand> commandMapCli = \n+    static final Map<String,String> commandMap = new HashMap<String,String>( );\n+    static final Map<String,CliCommand> commandMapCli =\n             new HashMap<String,CliCommand>( );\n \n     protected MyCommandOptions cl = new MyCommandOptions();"
        },
        {
            "sha": "e2be2143046af3408f6b9939fbf1133e185ea3f5",
            "filename": "src/java/main/org/apache/zookeeper/cli/DeleteCommand.java",
            "status": "modified",
            "additions": 0,
            "deletions": 7,
            "changes": 7,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FDeleteCommand.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FDeleteCommand.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fcli%2FDeleteCommand.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -56,14 +56,7 @@ public CliCommand parse(String[] cmdArgs) throws CliParseException {\n     }\n \n     private void retainCompatibility(String[] cmdArgs) throws CliParseException {\n-        // delete path [version]\n         if (args.length > 2) {\n-            // rewrite to option\n-            String [] newCmd = new String[4];\n-            newCmd[0] = cmdArgs[0];\n-            newCmd[1] = \"-v\";\n-            newCmd[2] = cmdArgs[2]; // version\n-            newCmd[3] = cmdArgs[1]; // path            \n             err.println(\"'delete path [version]' has been deprecated. \"\n                     + \"Please use 'delete [-v version] path' instead.\");\n             Parser parser = new PosixParser();"
        },
        {
            "sha": "57eb952ab0d8823d58f09a30609407b591fed9af",
            "filename": "src/java/main/org/apache/zookeeper/server/DataTree.java",
            "status": "modified",
            "additions": 4,
            "deletions": 5,
            "changes": 9,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FDataTree.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -1267,13 +1267,12 @@ public synchronized WatchesSummary getWatchesSummary() {\n      * @param pwriter the output to write to\n      */\n     public void dumpEphemerals(PrintWriter pwriter) {\n-        Set<Long> keys = ephemerals.keySet();\n         pwriter.println(\"Sessions with Ephemerals (\"\n-                + keys.size() + \"):\");\n-        for (long k : keys) {\n-            pwriter.print(\"0x\" + Long.toHexString(k));\n+                + ephemerals.keySet().size() + \"):\");\n+        for (Entry<Long, HashSet<String>> entry : ephemerals.entrySet()) {\n+            pwriter.print(\"0x\" + Long.toHexString(entry.getKey()));\n             pwriter.println(\":\");\n-            HashSet<String> tmp = ephemerals.get(k);\n+            HashSet<String> tmp = entry.getValue();\n             if (tmp != null) {\n                 synchronized (tmp) {\n                     for (String path : tmp) {"
        },
        {
            "sha": "b974059d74e3b648b1b7548c94405ef0efa7446b",
            "filename": "src/java/main/org/apache/zookeeper/server/NIOServerCnxn.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNIOServerCnxn.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -478,7 +478,7 @@ private boolean checkFourLetterWord(final SelectionKey k, final int len)\n     {\n         // We take advantage of the limited size of the length to look\n         // for cmds. They are all 4-bytes which fits inside of an int\n-        String cmd = FourLetterCommands.cmd2String.get(len);\n+        String cmd = FourLetterCommands.getCmdMapView().get(len);\n         if (cmd == null) {\n             return false;\n         }"
        },
        {
            "sha": "c48f6b1afe4b115406859b9980a60270101c30a2",
            "filename": "src/java/main/org/apache/zookeeper/server/NettyServerCnxn.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FNettyServerCnxn.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -267,7 +267,7 @@ private boolean checkFourLetterWord(final Channel channel,\n     {\n         // We take advantage of the limited size of the length to look\n         // for cmds. They are all 4-bytes which fits inside of an int\n-        String cmd = FourLetterCommands.cmd2String.get(len);\n+        String cmd = FourLetterCommands.getCmdMapView().get(len);\n         if (cmd == null) {\n             return false;\n         }"
        },
        {
            "sha": "d3cdfbb6ab54cc55d32de748d104db0b08d23ecc",
            "filename": "src/java/main/org/apache/zookeeper/server/PurgeTxnLog.java",
            "status": "modified",
            "additions": 11,
            "deletions": 4,
            "changes": 15,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnLog.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnLog.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FPurgeTxnLog.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -100,11 +100,18 @@ public boolean accept(File f){\n             }\n         }\n         // add all non-excluded log files\n-        List<File> files = new ArrayList<File>(Arrays.asList(txnLog\n-                .getDataDir().listFiles(new MyFileFilter(PREFIX_LOG))));\n+        File[] logs = txnLog.getDataDir().listFiles(new MyFileFilter(PREFIX_LOG));\n+        List<File> files = new ArrayList<>();\n+        if (logs != null) {\n+            files.addAll(Arrays.asList(logs));\n+        }\n+\n         // add all non-excluded snapshot files to the deletion list\n-        files.addAll(Arrays.asList(txnLog.getSnapDir().listFiles(\n-                new MyFileFilter(PREFIX_SNAPSHOT))));\n+        File[] snapshots = txnLog.getSnapDir().listFiles(new MyFileFilter(PREFIX_SNAPSHOT));\n+        if (snapshots != null) {\n+            files.addAll(Arrays.asList(snapshots));\n+        }\n+\n         // remove the old files\n         for(File f: files)\n         {"
        },
        {
            "sha": "06848d2994344d30328a398d08c6179395f70337",
            "filename": "src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java",
            "status": "modified",
            "additions": 5,
            "deletions": 2,
            "changes": 7,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -332,8 +332,11 @@ public long getLogDirSize() {\n     private long getDirSize(File file) {\n         long size = 0L;\n         if (file.isDirectory()) {\n-            for (File f: file.listFiles()) {\n-                size += getDirSize(f);\n+            File[] files = file.listFiles();\n+            if (files != null) {\n+                for (File f : files) {\n+                    size += getDirSize(f);\n+                }\n             }\n         } else {\n             size = file.length();"
        },
        {
            "sha": "0364f44c0246196b1910c24de3931860340b4241",
            "filename": "src/java/main/org/apache/zookeeper/server/command/FourLetterCommands.java",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fcommand%2FFourLetterCommands.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fcommand%2FFourLetterCommands.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fcommand%2FFourLetterCommands.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -19,7 +19,9 @@\n package org.apache.zookeeper.server.command;\n \n import java.nio.ByteBuffer;\n+import java.util.Collections;\n import java.util.HashMap;\n+import java.util.Map;\n \n /**\n  * This class contains constants for all the four letter commands\n@@ -151,9 +153,13 @@ public class FourLetterCommands {\n      */\n     public final static int telnetCloseCmd = 0xfff4fffd;\n \n-    public final static HashMap<Integer, String> cmd2String =\n+    final static HashMap<Integer, String> cmd2String =\n         new HashMap<Integer, String>();\n \n+    public static Map<Integer, String> getCmdMapView() {\n+        return Collections.unmodifiableMap(cmd2String);\n+    }\n+\n     // specify all of the commands that are available\n     static {\n         cmd2String.put(confCmd, \"conf\");"
        },
        {
            "sha": "404aa8ceadf23e37ae807e4ad358421a06b21a6d",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/flexible/QuorumHierarchical.java",
            "status": "modified",
            "additions": 24,
            "deletions": 23,
            "changes": 47,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumHierarchical.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumHierarchical.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fflexible%2FQuorumHierarchical.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -102,16 +102,16 @@ public boolean equals(Object o){\n            QuorumServer qso = qm.getAllMembers().get(qs.id);\n            if (qso == null || !qs.equals(qso)) return false;\n        }\n-       for (Long sid: serverWeight.keySet()){\n-           if (!serverWeight.get(sid).equals(qm.serverWeight.get(sid)))\n+       for (Entry<Long, Long> entry : serverWeight.entrySet()) {\n+           if (!entry.getValue().equals(qm.serverWeight.get(entry.getKey())))\n                return false;\n        }\n-       for (Long sid: groupWeight.keySet()){\n-           if (!groupWeight.get(sid).equals(qm.groupWeight.get(sid)))\n+       for (Entry<Long, Long> entry : groupWeight.entrySet()) {\n+           if (!entry.getValue().equals(qm.groupWeight.get(entry.getKey())))\n                return false;\n        }\n-       for (Long sid: serverGroup.keySet()){\n-           if (!serverGroup.get(sid).equals(qm.serverGroup.get(sid)))\n+       for (Entry<Long, Long> entry : serverGroup.entrySet()) {\n+           if (!entry.getValue().equals(qm.serverGroup.get(entry.getKey())))\n                return false;\n        }\n        return true;\n@@ -295,15 +295,16 @@ public String toString(){\n      * different places, so we have a separate method.\n      */\n     private void computeGroupWeight(){\n-        for(long sid : serverGroup.keySet()){\n-            Long gid = serverGroup.get(sid);\n+        for (Entry<Long, Long> entry : serverGroup.entrySet()) {\n+            Long sid = entry.getKey();\n+            Long gid = entry.getValue();\n             if(!groupWeight.containsKey(gid))\n                 groupWeight.put(gid, serverWeight.get(sid));\n             else {\n                 long totalWeight = serverWeight.get(sid) + groupWeight.get(gid);\n                 groupWeight.put(gid, totalWeight);\n-            } \n-        }    \n+            }\n+        }\n         \n         /*\n          * Do not consider groups with weight zero\n@@ -344,27 +345,27 @@ public boolean containsQuorum(Set<Long> set){\n          * Check if all groups have majority\n          */\n         int majGroupCounter = 0;\n-        for(long gid : expansion.keySet()) {\n-            LOG.debug(\"Group info: \" + expansion.get(gid) + \", \" + gid + \", \" + groupWeight.get(gid));\n-            if(expansion.get(gid) > (groupWeight.get(gid) / 2) )\n+        for (Entry<Long, Long> entry : expansion.entrySet()) {\n+            Long gid = entry.getKey();\n+            LOG.debug(\"Group info: {}, {}, {}\", entry.getValue(), gid, groupWeight.get(gid));\n+            if (entry.getValue() > (groupWeight.get(gid) / 2))\n                 majGroupCounter++;\n         }\n-        \n-        LOG.debug(\"Majority group counter: \" + majGroupCounter + \", \" + numGroups); \n-        if((majGroupCounter > (numGroups / 2))){\n-            LOG.debug(\"Positive set size: \" + set.size());\n+\n+        LOG.debug(\"Majority group counter: {}, {}\", majGroupCounter, numGroups);\n+        if ((majGroupCounter > (numGroups / 2))){\n+            LOG.debug(\"Positive set size: {}\", set.size());\n             return true;\n-        }\n-        else {\n-            LOG.debug(\"Negative set size: \" + set.size());\n+        } else {\n+            LOG.debug(\"Negative set size: {}\", set.size());\n             return false;\n         }\n-    }  \n-    public Map<Long, QuorumServer> getVotingMembers() {        \n+    }\n+    public Map<Long, QuorumServer> getVotingMembers() {\n        return participatingMembers;\n    }\n \n-   public Map<Long, QuorumServer> getObservingMembers() {      \n+   public Map<Long, QuorumServer> getObservingMembers() {\n        return observingMembers;\n    }\n "
        },
        {
            "sha": "d3e973102dd57d3d09e3a382f6648c31a8985113",
            "filename": "src/java/main/org/apache/zookeeper/version/util/VerGen.java",
            "status": "modified",
            "additions": 2,
            "deletions": 13,
            "changes": 15,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fversion%2Futil%2FVerGen.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fversion%2Futil%2FVerGen.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fversion%2Futil%2FVerGen.java?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -50,10 +50,8 @@ public static void generateFile(File outputDir, Version version, int rev, String\n             System.out.println(path + \" is not a directory.\");\n             System.exit(1);\n         }\n-        File file = new File(pkgdir, TYPE_NAME + \".java\");\n-        FileWriter w = null;\n-        try {\n-            w = new FileWriter(file);\n+\n+        try (FileWriter w = new FileWriter(new File(pkgdir, TYPE_NAME + \".java\"))) {\n             w.write(\"// Do not edit!\\n// File generated by org.apache.zookeeper\"\n                     + \".version.util.VerGen.\\n\");\n             w.write(\"/**\\n\");\n@@ -94,15 +92,6 @@ public static void generateFile(File outputDir, Version version, int rev, String\n             System.out.println(\"Unable to generate version.Info file: \"\n                     + e.getMessage());\n             System.exit(1);\n-        } finally {\n-            if (w != null) {\n-                try {\n-                    w.close();\n-                } catch (IOException e) {\n-                    System.out.println(\"Unable to close file writer\"\n-                            + e.getMessage());\n-                }\n-            }\n         }\n     }\n "
        },
        {
            "sha": "7a7fa4b49674f70209a398b0a6fab666ca07f252",
            "filename": "src/java/test/config/findbugsExcludeFile.xml",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/apache/zookeeper/blob/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml?ref=b0fbdba0c2a0334704f4c8969f2d0deb5d73cf95",
            "patch": "@@ -144,4 +144,10 @@\n     <Bug pattern=\"DM_DEFAULT_ENCODING\" />\n   </Match>\n \n+  <!-- Disable 'Malicious code vulnerability warnings' due to mutable collection types in interface.\n+       Undo this when ZOOKEEPER-1362 is done. -->\n+  <Match>\n+    <Class name=\"org.apache.zookeeper.ZooDefs$Ids\"/>\n+      <Bug pattern=\"MS_MUTABLE_COLLECTION\" />\n+  </Match>\n </FindBugsFilter>"
        }
    ]
}
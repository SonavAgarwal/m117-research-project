{
    "sha": "ed3823b045fd19cdb801609eb034c93dd4d75c3f",
    "node_id": "MDY6Q29tbWl0MTE0ODc1MzplZDM4MjNiMDQ1ZmQxOWNkYjgwMTYwOWViMDM0YzkzZGQ0ZDc1YzNm",
    "commit": {
        "author": {
            "name": "Arjen Poutsma",
            "email": "apoutsma@vmware.com",
            "date": "2012-06-08T12:47:22Z"
        },
        "committer": {
            "name": "Rossen Stoyanchev",
            "email": "rstoyanchev@vmware.com",
            "date": "2012-08-22T20:20:36Z"
        },
        "message": "Support generic target types in the RestTemplate\n\nThis change makes it possible to use the RestTemplate to read an HTTP\nresponse into a target generic type object. The RestTemplate has three\nnew exchange(...) methods that accept ParameterizedTypeReference -- a\nnew class that enables capturing and passing generic type info.\nSee the Javadoc of the three new methods in RestOperations for a\nshort example.\n\nTo support this feature, the HttpMessageConverter is now extended by\nGenericHttpMessageConverter, which adds a method for reading an\nHttpInputMessage to a specific generic type. The new interface\nis implemented by the MappingJacksonHttpMessageConverter and also by a\nnew Jaxb2CollectionHttpMessageConverter that can read read a generic\nCollection where the generic type is a JAXB type annotated with\n@XmlRootElement or @XmlType.\n\nIssue: SPR-7023",
        "tree": {
            "sha": "02637eb7e43e8afe4f6d199da0f06da01a7bae19",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/git/trees/02637eb7e43e8afe4f6d199da0f06da01a7bae19"
        },
        "url": "https://api.github.com/repos/spring-projects/spring-framework/git/commits/ed3823b045fd19cdb801609eb034c93dd4d75c3f",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/ed3823b045fd19cdb801609eb034c93dd4d75c3f",
    "html_url": "https://github.com/spring-projects/spring-framework/commit/ed3823b045fd19cdb801609eb034c93dd4d75c3f",
    "comments_url": "https://api.github.com/repos/spring-projects/spring-framework/commits/ed3823b045fd19cdb801609eb034c93dd4d75c3f/comments",
    "author": {
        "login": "poutsma",
        "id": 330665,
        "node_id": "MDQ6VXNlcjMzMDY2NQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/330665?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/poutsma",
        "html_url": "https://github.com/poutsma",
        "followers_url": "https://api.github.com/users/poutsma/followers",
        "following_url": "https://api.github.com/users/poutsma/following{/other_user}",
        "gists_url": "https://api.github.com/users/poutsma/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/poutsma/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/poutsma/subscriptions",
        "organizations_url": "https://api.github.com/users/poutsma/orgs",
        "repos_url": "https://api.github.com/users/poutsma/repos",
        "events_url": "https://api.github.com/users/poutsma/events{/privacy}",
        "received_events_url": "https://api.github.com/users/poutsma/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "rstoyanchev",
        "id": 401908,
        "node_id": "MDQ6VXNlcjQwMTkwOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/401908?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rstoyanchev",
        "html_url": "https://github.com/rstoyanchev",
        "followers_url": "https://api.github.com/users/rstoyanchev/followers",
        "following_url": "https://api.github.com/users/rstoyanchev/following{/other_user}",
        "gists_url": "https://api.github.com/users/rstoyanchev/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rstoyanchev/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rstoyanchev/subscriptions",
        "organizations_url": "https://api.github.com/users/rstoyanchev/orgs",
        "repos_url": "https://api.github.com/users/rstoyanchev/repos",
        "events_url": "https://api.github.com/users/rstoyanchev/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rstoyanchev/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "789e12a0c72c37a3f3796fd14bc2f61c8f6b909a",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/789e12a0c72c37a3f3796fd14bc2f61c8f6b909a",
            "html_url": "https://github.com/spring-projects/spring-framework/commit/789e12a0c72c37a3f3796fd14bc2f61c8f6b909a"
        }
    ],
    "stats": {
        "total": 1312,
        "additions": 1213,
        "deletions": 99
    },
    "files": [
        {
            "sha": "8c52650414daad9b08033136cc3ef5abcc1a2f6e",
            "filename": "spring-core/src/main/java/org/springframework/core/ParameterizedTypeReference.java",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReference.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,99 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.core;\n+\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+\n+import org.springframework.util.Assert;\n+\n+/**\n+ * The purpose of this class is to enable capturing and passing a generic\n+ * {@link Type}. In order to capture the generic type and retain it at runtime,\n+ * you need to create a sub-class as follows:\n+ *\n+ * <pre class=\"code\">\n+ * ParameterizedTypeReference&lt;List&lt;String&gt;&gt; typeRef = new ParameterizedTypeReference&lt;List&lt;String&gt;&gt;() {};\n+ * </pre>\n+ *\n+ * <p>The resulting {@code typeReference} instance can then be used to obtain a\n+ * {@link Type} instance that carries parameterized type information.\n+ * For more information on \"super type tokens\" see the link to Neal Gafter's blog post.\n+ *\n+ * @author Arjen Poutsma\n+ * @author Rossen Stoyanchev\n+ * @since 3.2\n+ *\n+ * @see http://gafter.blogspot.nl/2006/12/super-type-tokens.html\n+ */\n+public abstract class ParameterizedTypeReference<T> {\n+\n+\tprivate final Type type;\n+\n+\tprotected ParameterizedTypeReference() {\n+\t\tClass<?> parameterizedTypeReferenceSubClass = findParameterizedTypeReferenceSubClass(getClass());\n+\n+\t\tType type = parameterizedTypeReferenceSubClass.getGenericSuperclass();\n+\t\tAssert.isInstanceOf(ParameterizedType.class, type);\n+\n+\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n+\t\tAssert.isTrue(parameterizedType.getActualTypeArguments().length == 1);\n+\n+\t\tthis.type = parameterizedType.getActualTypeArguments()[0];\n+\t}\n+\n+\tprivate static Class<?> findParameterizedTypeReferenceSubClass(Class<?> child) {\n+\n+\t\tClass<?> parent = child.getSuperclass();\n+\n+\t\tif (Object.class.equals(parent)) {\n+\t\t\tthrow new IllegalStateException(\"Expected ParameterizedTypeReference superclass\");\n+\t\t}\n+\t\telse if (ParameterizedTypeReference.class.equals(parent)) {\n+\t\t\treturn child;\n+\t\t}\n+\t\telse {\n+\t\t\treturn findParameterizedTypeReferenceSubClass(parent);\n+\t\t}\n+\t}\n+\n+\tpublic Type getType() {\n+\t\treturn this.type;\n+\t}\n+\n+\t@Override\n+\tpublic boolean equals(Object o) {\n+\t\tif (this == o) {\n+\t\t\treturn true;\n+\t\t}\n+\t\tif (o instanceof ParameterizedTypeReference) {\n+\t\t\tParameterizedTypeReference<?> other = (ParameterizedTypeReference<?>) o;\n+\t\t\treturn this.type.equals(other.type);\n+\t\t}\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tpublic int hashCode() {\n+\t\treturn this.type.hashCode();\n+\t}\n+\n+\t@Override\n+\tpublic String toString() {\n+\t\treturn \"ParameterizedTypeReference<\" + this.type + \">\";\n+\t}\n+}"
        },
        {
            "sha": "7162d9ad93c65491c251c37884b6b5a1c2947584",
            "filename": "spring-core/src/test/java/org/springframework/core/ParameterizedTypeReferenceTest.java",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReferenceTest.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReferenceTest.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fcore%2FParameterizedTypeReferenceTest.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.core;\n+\n+import java.lang.reflect.Type;\n+import java.util.List;\n+import java.util.Map;\n+\n+import static org.junit.Assert.assertEquals;\n+import org.junit.Test;\n+\n+/**\n+ * Test fixture for {@link ParameterizedTypeReference}.\n+ *\n+ * @author Arjen Poutsma\n+ * @author Rossen Stoyanchev\n+ */\n+public class ParameterizedTypeReferenceTest {\n+\n+\t@Test\n+\tpublic void map() throws NoSuchMethodException {\n+\t\tType mapType = getClass().getMethod(\"mapMethod\").getGenericReturnType();\n+\t\tParameterizedTypeReference<Map<Object,String>> mapTypeReference = new ParameterizedTypeReference<Map<Object,String>>() {};\n+\t\tassertEquals(mapType, mapTypeReference.getType());\n+\t}\n+\n+\t@Test\n+\tpublic void list() throws NoSuchMethodException {\n+\t\tType mapType = getClass().getMethod(\"listMethod\").getGenericReturnType();\n+\t\tParameterizedTypeReference<List<String>> mapTypeReference = new ParameterizedTypeReference<List<String>>() {};\n+\t\tassertEquals(mapType, mapTypeReference.getType());\n+\t}\n+\n+\t@Test\n+\tpublic void string() {\n+\t\tParameterizedTypeReference<String> typeReference = new ParameterizedTypeReference<String>() {};\n+\t\tassertEquals(String.class, typeReference.getType());\n+\t}\n+\n+\tpublic static Map<Object, String> mapMethod() {\n+\t\treturn null;\n+\t}\n+\n+\tpublic static List<String> listMethod() {\n+\t\treturn null;\n+\t}\n+}"
        },
        {
            "sha": "89bc5909b4c3fc884e92e4998130534e3644a9f5",
            "filename": "spring-web/src/main/java/org/springframework/http/converter/GenericHttpMessageConverter.java",
            "status": "added",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2FGenericHttpMessageConverter.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2FGenericHttpMessageConverter.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2FGenericHttpMessageConverter.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.converter;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpInputMessage;\n+import org.springframework.http.MediaType;\n+\n+/**\n+ * A specialization of {@link HttpMessageConverter} that can convert an HTTP\n+ * request into a target object of a specified generic type.\n+ *\n+ * @author Arjen Poutsma\n+ * @since 3.2\n+ *\n+ * @see ParameterizedTypeReference\n+ */\n+public interface GenericHttpMessageConverter<T> extends HttpMessageConverter<T> {\n+\n+\t/**\n+\t * Indicates whether the given type can be read by this converter.\n+\t * @param type the type to test for readability\n+\t * @param mediaType the media type to read, can be {@code null} if not specified.\n+\t * Typically the value of a {@code Content-Type} header.\n+\t * @return {@code true} if readable; {@code false} otherwise\n+\t */\n+\tboolean canRead(Type type, MediaType mediaType);\n+\n+\t/**\n+\t * Read an object of the given type form the given input message, and returns it.\n+\t * @param clazz the type of object to return. This type must have previously\n+\t * been passed to the {@link #canRead canRead} method of this interface,\n+\t * which must have returned {@code true}.\n+\t * @param type the type of the target object\n+\t * @param inputMessage the HTTP input message to read from\n+\t * @return the converted object\n+\t * @throws IOException in case of I/O errors\n+\t * @throws HttpMessageNotReadableException in case of conversion errors\n+\t */\n+\tT read(Type type, HttpInputMessage inputMessage)\n+\t\t\tthrows IOException, HttpMessageNotReadableException;\n+\n+}"
        },
        {
            "sha": "31f236a6bd5368ebf64787e5489f7e6c2ca6fce3",
            "filename": "spring-web/src/main/java/org/springframework/http/converter/json/MappingJackson2HttpMessageConverter.java",
            "status": "modified",
            "additions": 38,
            "deletions": 19,
            "changes": 57,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverter.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverter.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverter.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -17,17 +17,10 @@\n package org.springframework.http.converter.json;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.nio.charset.Charset;\n import java.util.List;\n \n-import org.springframework.http.HttpInputMessage;\n-import org.springframework.http.HttpOutputMessage;\n-import org.springframework.http.MediaType;\n-import org.springframework.http.converter.AbstractHttpMessageConverter;\n-import org.springframework.http.converter.HttpMessageNotReadableException;\n-import org.springframework.http.converter.HttpMessageNotWritableException;\n-import org.springframework.util.Assert;\n-\n import com.fasterxml.jackson.core.JsonEncoding;\n import com.fasterxml.jackson.core.JsonGenerator;\n import com.fasterxml.jackson.core.JsonProcessingException;\n@@ -36,6 +29,15 @@\n import com.fasterxml.jackson.databind.ObjectMapper;\n import com.fasterxml.jackson.databind.SerializationFeature;\n \n+import org.springframework.http.HttpInputMessage;\n+import org.springframework.http.HttpOutputMessage;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.converter.AbstractHttpMessageConverter;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n+import org.springframework.http.converter.HttpMessageNotReadableException;\n+import org.springframework.http.converter.HttpMessageNotWritableException;\n+import org.springframework.util.Assert;\n+\n /**\n  * Implementation of {@link org.springframework.http.converter.HttpMessageConverter HttpMessageConverter}\n  * that can read and write JSON using <a href=\"http://jackson.codehaus.org/\">Jackson 2's</a> {@link ObjectMapper}.\n@@ -50,7 +52,8 @@\n  * @since 3.1.2\n  * @see org.springframework.web.servlet.view.json.MappingJackson2JsonView\n  */\n-public class MappingJackson2HttpMessageConverter extends AbstractHttpMessageConverter<Object> {\n+public class MappingJackson2HttpMessageConverter extends AbstractHttpMessageConverter<Object>\n+\timplements GenericHttpMessageConverter<Object> {\n \n \tpublic static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n \n@@ -63,7 +66,7 @@ public class MappingJackson2HttpMessageConverter extends AbstractHttpMessageConv\n \n \n \t/**\n-\t * Construct a new {@code BindingJacksonHttpMessageConverter}.\n+\t * Construct a new {@code MappingJackson2HttpMessageConverter}.\n \t */\n \tpublic MappingJackson2HttpMessageConverter() {\n \t\tsuper(new MediaType(\"application\", \"json\", DEFAULT_CHARSET));\n@@ -125,7 +128,11 @@ public void setPrettyPrint(boolean prettyPrint) {\n \n \t@Override\n \tpublic boolean canRead(Class<?> clazz, MediaType mediaType) {\n-\t\tJavaType javaType = getJavaType(clazz);\n+\t\treturn canRead((Type) clazz, mediaType);\n+\t}\n+\n+\tpublic boolean canRead(Type type, MediaType mediaType) {\n+\t\tJavaType javaType = getJavaType(type);\n \t\treturn (this.objectMapper.canDeserialize(javaType) && canRead(mediaType));\n \t}\n \n@@ -145,6 +152,17 @@ protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n \t\t\tthrows IOException, HttpMessageNotReadableException {\n \n \t\tJavaType javaType = getJavaType(clazz);\n+\t\treturn readJavaType(javaType, inputMessage);\n+\t}\n+\n+\tpublic Object read(Type type, HttpInputMessage inputMessage)\n+\t\t\tthrows IOException, HttpMessageNotReadableException {\n+\n+\t\tJavaType javaType = getJavaType(type);\n+\t\treturn readJavaType(javaType, inputMessage);\n+\t}\n+\n+\tprivate Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) {\n \t\ttry {\n \t\t\treturn this.objectMapper.readValue(inputMessage.getBody(), javaType);\n \t\t}\n@@ -153,6 +171,7 @@ protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n \t\t}\n \t}\n \n+\n \t@Override\n \tprotected void writeInternal(Object object, HttpOutputMessage outputMessage)\n \t\t\tthrows IOException, HttpMessageNotWritableException {\n@@ -180,24 +199,24 @@ protected void writeInternal(Object object, HttpOutputMessage outputMessage)\n \n \n \t/**\n-\t * Return the Jackson {@link JavaType} for the specified class.\n+\t * Return the Jackson {@link JavaType} for the specified type.\n \t * <p>The default implementation returns {@link ObjectMapper#constructType(java.lang.reflect.Type)},\n \t * but this can be overridden in subclasses, to allow for custom generic collection handling.\n \t * For instance:\n \t * <pre class=\"code\">\n-\t * protected JavaType getJavaType(Class&lt;?&gt; clazz) {\n-\t *   if (List.class.isAssignableFrom(clazz)) {\n-\t *     return objectMapper.getTypeFactory().constructCollectionType(ArrayList.class, MyBean.class);\n+\t * protected JavaType getJavaType(Type type) {\n+\t *   if (type instanceof Class && List.class.isAssignableFrom((Class)type)) {\n+\t *     return TypeFactory.collectionType(ArrayList.class, MyBean.class);\n \t *   } else {\n-\t *     return super.getJavaType(clazz);\n+\t *     return super.getJavaType(type);\n \t *   }\n \t * }\n \t * </pre>\n-\t * @param clazz the class to return the java type for\n+\t * @param type the type to return the java type for\n \t * @return the java type\n \t */\n-\tprotected JavaType getJavaType(Class<?> clazz) {\n-\t\treturn objectMapper.constructType(clazz);\n+\tprotected JavaType getJavaType(Type type) {\n+\t\treturn this.objectMapper.constructType(type);\n \t}\n \n \t/**"
        },
        {
            "sha": "51976c380bc7e22da1c120b283b9499bdc31c9c1",
            "filename": "spring-web/src/main/java/org/springframework/http/converter/json/MappingJacksonHttpMessageConverter.java",
            "status": "modified",
            "additions": 32,
            "deletions": 14,
            "changes": 46,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverter.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverter.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverter.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -1,11 +1,11 @@\n /*\n- * Copyright 2002-2011 the original author or authors.\n+ * Copyright 2002-2012 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -17,26 +17,28 @@\n package org.springframework.http.converter.json;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.nio.charset.Charset;\n import java.util.List;\n \n+import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n import org.codehaus.jackson.JsonEncoding;\n import org.codehaus.jackson.JsonGenerator;\n import org.codehaus.jackson.JsonProcessingException;\n import org.codehaus.jackson.map.ObjectMapper;\n import org.codehaus.jackson.map.SerializationConfig;\n import org.codehaus.jackson.map.type.TypeFactory;\n import org.codehaus.jackson.type.JavaType;\n+\n import org.springframework.http.HttpInputMessage;\n import org.springframework.http.HttpOutputMessage;\n import org.springframework.http.MediaType;\n import org.springframework.http.converter.AbstractHttpMessageConverter;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n import org.springframework.http.converter.HttpMessageNotReadableException;\n import org.springframework.http.converter.HttpMessageNotWritableException;\n import org.springframework.util.Assert;\n \n-import com.fasterxml.jackson.core.util.DefaultPrettyPrinter;\n-\n /**\n  * Implementation of {@link org.springframework.http.converter.HttpMessageConverter HttpMessageConverter}\n  * that can read and write JSON using <a href=\"http://jackson.codehaus.org/\">Jackson's</a> {@link ObjectMapper}.\n@@ -50,7 +52,8 @@\n  * @since 3.0\n  * @see org.springframework.web.servlet.view.json.MappingJacksonJsonView\n  */\n-public class MappingJacksonHttpMessageConverter extends AbstractHttpMessageConverter<Object> {\n+public class MappingJacksonHttpMessageConverter extends AbstractHttpMessageConverter<Object>\n+\timplements GenericHttpMessageConverter<Object> {\n \n \tpublic static final Charset DEFAULT_CHARSET = Charset.forName(\"UTF-8\");\n \n@@ -63,7 +66,7 @@ public class MappingJacksonHttpMessageConverter extends AbstractHttpMessageConve\n \n \n \t/**\n-\t * Construct a new {@code BindingJacksonHttpMessageConverter}.\n+\t * Construct a new {@code MappingJacksonHttpMessageConverter}.\n \t */\n \tpublic MappingJacksonHttpMessageConverter() {\n \t\tsuper(new MediaType(\"application\", \"json\", DEFAULT_CHARSET));\n@@ -125,7 +128,11 @@ public void setPrettyPrint(boolean prettyPrint) {\n \n \t@Override\n \tpublic boolean canRead(Class<?> clazz, MediaType mediaType) {\n-\t\tJavaType javaType = getJavaType(clazz);\n+\t\treturn canRead((Type) clazz, mediaType);\n+\t}\n+\n+\tpublic boolean canRead(Type type, MediaType mediaType) {\n+\t\tJavaType javaType = getJavaType(type);\n \t\treturn (this.objectMapper.canDeserialize(javaType) && canRead(mediaType));\n \t}\n \n@@ -145,6 +152,17 @@ protected Object readInternal(Class<?> clazz, HttpInputMessage inputMessage)\n \t\t\tthrows IOException, HttpMessageNotReadableException {\n \n \t\tJavaType javaType = getJavaType(clazz);\n+\t\treturn readJavaType(javaType, inputMessage);\n+\t}\n+\n+\tpublic Object read(Type type, HttpInputMessage inputMessage)\n+\t\t\tthrows IOException, HttpMessageNotReadableException {\n+\n+\t\tJavaType javaType = getJavaType(type);\n+\t\treturn readJavaType(javaType, inputMessage);\n+\t}\n+\n+\tprivate Object readJavaType(JavaType javaType, HttpInputMessage inputMessage) {\n \t\ttry {\n \t\t\treturn this.objectMapper.readValue(inputMessage.getBody(), javaType);\n \t\t}\n@@ -180,24 +198,24 @@ protected void writeInternal(Object object, HttpOutputMessage outputMessage)\n \n \n \t/**\n-\t * Return the Jackson {@link JavaType} for the specified class.\n+\t * Return the Jackson {@link JavaType} for the specified type.\n \t * <p>The default implementation returns {@link TypeFactory#type(java.lang.reflect.Type)},\n \t * but this can be overridden in subclasses, to allow for custom generic collection handling.\n \t * For instance:\n \t * <pre class=\"code\">\n-\t * protected JavaType getJavaType(Class&lt;?&gt; clazz) {\n-\t *   if (List.class.isAssignableFrom(clazz)) {\n+\t * protected JavaType getJavaType(Type type) {\n+\t *   if (type instanceof Class && List.class.isAssignableFrom((Class)type)) {\n \t *     return TypeFactory.collectionType(ArrayList.class, MyBean.class);\n \t *   } else {\n-\t *     return super.getJavaType(clazz);\n+\t *     return super.getJavaType(type);\n \t *   }\n \t * }\n \t * </pre>\n-\t * @param clazz the class to return the java type for\n+\t * @param type the type to return the java type for\n \t * @return the java type\n \t */\n-\tprotected JavaType getJavaType(Class<?> clazz) {\n-\t\treturn TypeFactory.type(clazz);\n+\tprotected JavaType getJavaType(Type type) {\n+\t\treturn TypeFactory.type(type);\n \t}\n \n \t/**"
        },
        {
            "sha": "376becb1dfda3527ebe7cbf23245b29836177475",
            "filename": "spring-web/src/main/java/org/springframework/http/converter/xml/Jaxb2CollectionHttpMessageConverter.java",
            "status": "added",
            "additions": 228,
            "deletions": 0,
            "changes": 228,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverter.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverter.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverter.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,228 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.converter.xml;\n+\n+import java.io.IOException;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.LinkedHashSet;\n+import java.util.List;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+\n+import javax.xml.bind.JAXBException;\n+import javax.xml.bind.UnmarshalException;\n+import javax.xml.bind.Unmarshaller;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+import javax.xml.stream.XMLInputFactory;\n+import javax.xml.stream.XMLStreamException;\n+import javax.xml.stream.XMLStreamReader;\n+import javax.xml.transform.Result;\n+import javax.xml.transform.Source;\n+\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpInputMessage;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n+import org.springframework.http.converter.HttpMessageConversionException;\n+import org.springframework.http.converter.HttpMessageNotReadableException;\n+\n+/**\n+ * An {@code HttpMessageConverter} that can read XML collections using JAXB2.\n+ *\n+ * <p>This converter can read {@linkplain Collection collections} that contain classes\n+ * annotated with {@link XmlRootElement} and {@link XmlType}. Note that this converter\n+ * does not support writing.\n+ *\n+ * @author Arjen Poutsma\n+ * @since 3.2\n+ */\n+public class Jaxb2CollectionHttpMessageConverter<T extends Collection>\n+\t\textends AbstractJaxb2HttpMessageConverter<T> implements GenericHttpMessageConverter<T> {\n+\n+\tprivate final XMLInputFactory inputFactory = createXmlInputFactory();\n+\n+\t/**\n+\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n+\t * required generic type information in order to read a Collection.\n+\t */\n+\t@Override\n+\tpublic boolean canRead(Class<?> clazz, MediaType mediaType) {\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * {@inheritDoc}\n+\t * <p>Jaxb2CollectionHttpMessageConverter can read a generic\n+\t * {@link Collection} where the generic type is a JAXB type annotated with\n+\t * {@link XmlRootElement} or {@link XmlType}.\n+\t */\n+\tpublic boolean canRead(Type type, MediaType mediaType) {\n+\t\tif (!(type instanceof ParameterizedType)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n+\t\tif (!(parameterizedType.getRawType() instanceof Class)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tClass<?> rawType = (Class<?>) parameterizedType.getRawType();\n+\t\tif (!(Collection.class.isAssignableFrom(rawType))) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tif (parameterizedType.getActualTypeArguments().length != 1) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tType typeArgument = parameterizedType.getActualTypeArguments()[0];\n+\t\tif (!(typeArgument instanceof Class)) {\n+\t\t\treturn false;\n+\t\t}\n+\t\tClass<?> typeArgumentClass = (Class<?>) typeArgument;\n+\t\treturn (typeArgumentClass.isAnnotationPresent(XmlRootElement.class) ||\n+\t\t\t\ttypeArgumentClass.isAnnotationPresent(XmlType.class)) && canRead(mediaType);\n+\t}\n+\n+\t/**\n+\t * Always returns {@code false} since Jaxb2CollectionHttpMessageConverter\n+\t * does not convert collections to XML.\n+\t */\n+\t@Override\n+\tpublic boolean canWrite(Class<?> clazz, MediaType mediaType) {\n+\t\treturn false;\n+\t}\n+\n+\t@Override\n+\tprotected boolean supports(Class<?> clazz) {\n+\t\t// should not be called, since we override canRead/Write\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t@Override\n+\tprotected T readFromSource(Class<? extends T> clazz, HttpHeaders headers, Source source) throws IOException {\n+\t\t// should not be called, since we return false for canRead(Class)\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\tpublic T read(Type type, HttpInputMessage inputMessage) throws IOException, HttpMessageNotReadableException {\n+\t\tParameterizedType parameterizedType = (ParameterizedType) type;\n+\t\tT result = createCollection((Class<?>) parameterizedType.getRawType());\n+\t\tClass<?> elementClass = (Class<?>) parameterizedType.getActualTypeArguments()[0];\n+\n+\t\ttry {\n+\t\t\tUnmarshaller unmarshaller = createUnmarshaller(elementClass);\n+\t\t\tXMLStreamReader streamReader = this.inputFactory.createXMLStreamReader(inputMessage.getBody());\n+\t\t\tint event = moveToFirstChildOfRootElement(streamReader);\n+\n+\t\t\twhile (event != XMLStreamReader.END_DOCUMENT) {\n+\t\t\t\tif (elementClass.isAnnotationPresent(XmlRootElement.class)) {\n+\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader));\n+\t\t\t\t}\n+\t\t\t\telse if (elementClass.isAnnotationPresent(XmlType.class)) {\n+\t\t\t\t\tresult.add(unmarshaller.unmarshal(streamReader, elementClass).getValue());\n+\t\t\t\t}\n+\t\t\t\telse {\n+\t\t\t\t\t// should not happen, since we check in canRead(Type)\n+\t\t\t\t\tthrow new HttpMessageConversionException(\"Could not unmarshal to [\" + elementClass + \"]\");\n+\t\t\t\t}\n+\t\t\t\tevent = moveToNextElement(streamReader);\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n+\t\tcatch (UnmarshalException ex) {\n+\t\t\tthrow new HttpMessageNotReadableException(\"Could not unmarshal to [\" + elementClass + \"]: \" + ex.getMessage(), ex);\n+\t\t}\n+\t\tcatch (JAXBException ex) {\n+\t\t\tthrow new HttpMessageConversionException(\"Could not instantiate JAXBContext: \" + ex.getMessage(), ex);\n+\t\t}\n+\t\tcatch (XMLStreamException ex) {\n+\t\t\tthrow new HttpMessageConversionException(ex.getMessage(), ex);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Create a Collection of the given type, with the given initial capacity\n+\t * (if supported by the Collection type).\n+\t *\n+\t * @param collectionClass the type of Collection to instantiate\n+\t * @return the created Collection instance\n+\t */\n+\t@SuppressWarnings(\"unchecked\")\n+\tprotected T createCollection(Class<?> collectionClass) {\n+\t\tif (!collectionClass.isInterface()) {\n+\t\t\ttry {\n+\t\t\t\treturn (T) collectionClass.newInstance();\n+\t\t\t}\n+\t\t\tcatch (Exception ex) {\n+\t\t\t\tthrow new IllegalArgumentException(\n+\t\t\t\t\t\t\"Could not instantiate collection class [\" +\n+\t\t\t\t\t\t\t\tcollectionClass.getName() + \"]: \" + ex.getMessage());\n+\t\t\t}\n+\t\t}\n+\t\telse if (List.class.equals(collectionClass)) {\n+\t\t\treturn (T) new ArrayList();\n+\t\t}\n+\t\telse if (SortedSet.class.equals(collectionClass)) {\n+\t\t\treturn (T) new TreeSet();\n+\t\t}\n+\t\telse {\n+\t\t\treturn (T) new LinkedHashSet();\n+\t\t}\n+\t}\n+\n+\tprivate int moveToFirstChildOfRootElement(XMLStreamReader streamReader) throws XMLStreamException {\n+\t\t// root\n+\t\tint event = streamReader.next();\n+\t\twhile (event != XMLStreamReader.START_ELEMENT) {\n+\t\t\tevent = streamReader.next();\n+\t\t}\n+\n+\t\t// first child\n+\t\tevent = streamReader.next();\n+\t\twhile ((event != XMLStreamReader.START_ELEMENT) && (event != XMLStreamReader.END_DOCUMENT)) {\n+\t\t\tevent = streamReader.next();\n+\t\t}\n+\t\treturn event;\n+\t}\n+\n+\tprivate int moveToNextElement(XMLStreamReader streamReader) throws XMLStreamException {\n+\t\tint event = streamReader.getEventType();\n+\t\twhile (event != XMLStreamReader.START_ELEMENT && event != XMLStreamReader.END_DOCUMENT) {\n+\t\t\tevent = streamReader.next();\n+\t\t}\n+\t\treturn event;\n+\t}\n+\n+\t@Override\n+\tprotected void writeToResult(T t, HttpHeaders headers, Result result) throws IOException {\n+\t\tthrow new UnsupportedOperationException();\n+\t}\n+\n+\t/**\n+\t * Create a {@code XMLInputFactory} that this converter will use to create {@link\n+\t * javax.xml.stream.XMLStreamReader} and {@link javax.xml.stream.XMLEventReader} objects.\n+\t * <p/> Can be overridden in subclasses, adding further initialization of the factory.\n+\t * The resulting factory is cached, so this method will only be called once.\n+\t *\n+\t * @return the created factory\n+\t */\n+\tprotected XMLInputFactory createXmlInputFactory() {\n+\t\treturn XMLInputFactory.newInstance();\n+\t}\n+\n+}"
        },
        {
            "sha": "dd9de11d6d9b19d6dfcd978d5d50c267d2e0a8c6",
            "filename": "spring-web/src/main/java/org/springframework/web/client/HttpMessageConverterExtractor.java",
            "status": "modified",
            "additions": 57,
            "deletions": 22,
            "changes": 79,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractor.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractor.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractor.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -17,6 +17,7 @@\n package org.springframework.web.client;\n \n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.util.List;\n \n import org.apache.commons.logging.Log;\n@@ -25,34 +26,45 @@\n import org.springframework.http.HttpStatus;\n import org.springframework.http.MediaType;\n import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n import org.springframework.http.converter.HttpMessageConverter;\n import org.springframework.util.Assert;\n \n /**\n- * Response extractor that uses the given {@linkplain HttpMessageConverter entity converters} to convert the response\n- * into a type <code>T</code>.\n+ * Response extractor that uses the given {@linkplain HttpMessageConverter entity\n+ * converters} to convert the response into a type <code>T</code>.\n  *\n  * @author Arjen Poutsma\n  * @see RestTemplate\n  * @since 3.0\n  */\n public class HttpMessageConverterExtractor<T> implements ResponseExtractor<T> {\n \n-\tprivate final Class<T> responseType;\n+\tprivate final Type responseType;\n \n \tprivate final List<HttpMessageConverter<?>> messageConverters;\n \n \tprivate final Log logger;\n \n \t/**\n-\t * Creates a new instance of the {@code HttpMessageConverterExtractor} with the given response type and message\n-\t * converters. The given converters must support the response type.\n+\t * Creates a new instance of the {@code HttpMessageConverterExtractor} with the given\n+\t * response type and message converters. The given converters must support the response\n+\t * type.\n \t */\n \tpublic HttpMessageConverterExtractor(Class<T> responseType, List<HttpMessageConverter<?>> messageConverters) {\n+\t\tthis((Type) responseType, messageConverters);\n+\t}\n+\n+\t/**\n+\t * Creates a new instance of the {@code HttpMessageConverterExtractor} with the given\n+\t * response type and message converters. The given converters must support the response\n+\t * type.\n+\t */\n+\tpublic HttpMessageConverterExtractor(Type responseType, List<HttpMessageConverter<?>> messageConverters) {\n \t\tthis(responseType, messageConverters, LogFactory.getLog(HttpMessageConverterExtractor.class));\n \t}\n \n-\tHttpMessageConverterExtractor(Class<T> responseType, List<HttpMessageConverter<?>> messageConverters, Log logger) {\n+\tHttpMessageConverterExtractor(Type responseType, List<HttpMessageConverter<?>> messageConverters, Log logger) {\n \t\tAssert.notNull(responseType, \"'responseType' must not be null\");\n \t\tAssert.notEmpty(messageConverters, \"'messageConverters' must not be empty\");\n \t\tthis.responseType = responseType;\n@@ -65,39 +77,62 @@ public T extractData(ClientHttpResponse response) throws IOException {\n \t\tif (!hasMessageBody(response)) {\n \t\t\treturn null;\n \t\t}\n+\t\tMediaType contentType = getContentType(response);\n+\n+\t\tClass<T> responseClass = null;\n+\t\tif (this.responseType instanceof Class) {\n+\t\t\tresponseClass = (Class) this.responseType;\n+\t\t}\n+\t\tfor (HttpMessageConverter messageConverter : this.messageConverters) {\n+\t\t\tif (responseClass != null) {\n+\t\t\t\tif (messageConverter.canRead(responseClass, contentType)) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Reading [\" + responseClass.getName() + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t}\n+\t\t\t\t\treturn (T) messageConverter.read(responseClass, response);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t\telse if (messageConverter instanceof GenericHttpMessageConverter) {\n+\t\t\t\tGenericHttpMessageConverter genericMessageConverter = (GenericHttpMessageConverter) messageConverter;\n+\t\t\t\tif (genericMessageConverter.canRead(this.responseType, contentType)) {\n+\t\t\t\t\tif (logger.isDebugEnabled()) {\n+\t\t\t\t\t\tlogger.debug(\"Reading [\" + this.responseType + \"] as \\\"\" +\n+\t\t\t\t\t\t\t\tcontentType + \"\\\" using [\" + messageConverter + \"]\");\n+\t\t\t\t\t}\n+\t\t\t\t\treturn (T) genericMessageConverter.read(this.responseType, response);\n+\t\t\t\t}\n+\t\t\t}\n+\t\t}\n+\t\tthrow new RestClientException(\n+\t\t\t\t\"Could not extract response: no suitable HttpMessageConverter found for response type [\" +\n+\t\t\t\t\t\tthis.responseType + \"] and content type [\" + contentType + \"]\");\n+\t}\n+\n+\tprivate MediaType getContentType(ClientHttpResponse response) {\n \t\tMediaType contentType = response.getHeaders().getContentType();\n \t\tif (contentType == null) {\n \t\t\tif (logger.isTraceEnabled()) {\n \t\t\t\tlogger.trace(\"No Content-Type header found, defaulting to application/octet-stream\");\n \t\t\t}\n \t\t\tcontentType = MediaType.APPLICATION_OCTET_STREAM;\n \t\t}\n-\t\tfor (HttpMessageConverter messageConverter : messageConverters) {\n-\t\t\tif (messageConverter.canRead(responseType, contentType)) {\n-\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\tlogger.debug(\"Reading [\" + responseType.getName() + \"] as \\\"\" + contentType\n-\t\t\t\t\t\t\t+\"\\\" using [\" + messageConverter + \"]\");\n-\t\t\t\t}\n-\t\t\t\treturn (T) messageConverter.read(this.responseType, response);\n-\t\t\t}\n-\t\t}\n-\t\tthrow new RestClientException(\n-\t\t\t\t\"Could not extract response: no suitable HttpMessageConverter found for response type [\" +\n-\t\t\t\t\t\tthis.responseType.getName() + \"] and content type [\" + contentType + \"]\");\n+\t\treturn contentType;\n \t}\n \n \t/**\n-\t * Indicates whether the given response has a message body.\n-\t * <p>Default implementation returns {@code false} for a response status of {@code 204} or {@code 304}, or a\n-\t * {@code Content-Length} of {@code 0}.\n+\t * Indicates whether the given response has a message body. <p>Default implementation\n+\t * returns {@code false} for a response status of {@code 204} or {@code 304}, or a {@code\n+\t * Content-Length} of {@code 0}.\n \t *\n \t * @param response the response to check for a message body\n \t * @return {@code true} if the response has a body, {@code false} otherwise\n \t * @throws IOException in case of I/O errors\n \t */\n \tprotected boolean hasMessageBody(ClientHttpResponse response) throws IOException {\n \t\tHttpStatus responseStatus = response.getStatusCode();\n-\t\tif (responseStatus == HttpStatus.NO_CONTENT || responseStatus == HttpStatus.NOT_MODIFIED) {\n+\t\tif (responseStatus == HttpStatus.NO_CONTENT ||\n+\t\t\t\tresponseStatus == HttpStatus.NOT_MODIFIED) {\n \t\t\treturn false;\n \t\t}\n \t\tlong contentLength = response.getHeaders().getContentLength();"
        },
        {
            "sha": "1528643e76b9bac8507d5252721fe96a588e7739",
            "filename": "spring-web/src/main/java/org/springframework/web/client/RestOperations.java",
            "status": "modified",
            "additions": 66,
            "deletions": 2,
            "changes": 68,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestOperations.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestOperations.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestOperations.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -1,11 +1,11 @@\n /*\n- * Copyright 2002-2010 the original author or authors.\n+ * Copyright 2002-2012 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -20,6 +20,7 @@\n import java.util.Map;\n import java.util.Set;\n \n+import org.springframework.core.ParameterizedTypeReference;\n import org.springframework.http.HttpEntity;\n import org.springframework.http.HttpHeaders;\n import org.springframework.http.HttpMethod;\n@@ -396,6 +397,69 @@ <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requ\n \t<T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,\n \t\t\tClass<T> responseType) throws RestClientException;\n \n+\t/**\n+\t * Execute the HTTP method to the given URI template, writing the given\n+\t * request entity to the request, and returns the response as {@link ResponseEntity}.\n+\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n+\t *\n+\t * <pre class=\"code\">\n+\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n+\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;http://example.com&quot;,HttpMethod.GET, null, myBean);\n+\t * </pre>\n+\t *\n+\t * @param url the URL\n+\t * @param method the HTTP method (GET, POST, etc)\n+\t * @param requestEntity the entity (headers and/or body) to write to the\n+\t * request, may be {@code null}\n+\t * @param responseType the type of the return value\n+\t * @param uriVariables the variables to expand in the template\n+\t * @return the response as entity\n+\t * @since 3.2.0\n+\t */\n+\t<T> ResponseEntity<T> exchange(String url,HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException;\n+\n+\t/**\n+\t * Execute the HTTP method to the given URI template, writing the given\n+\t * request entity to the request, and returns the response as {@link ResponseEntity}.\n+\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n+\t *\n+\t * <pre class=\"code\">\n+\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n+\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;http://example.com&quot;,HttpMethod.GET, null, myBean);\n+\t * </pre>\n+\t *\n+\t * @param url the URL\n+\t * @param method the HTTP method (GET, POST, etc)\n+\t * @param requestEntity the entity (headers and/or body) to write to the request, may be {@code null}\n+\t * @param responseType the type of the return value\n+\t * @param uriVariables the variables to expand in the template\n+\t * @return the response as entity\n+\t * @since 3.2.0\n+\t */\n+\t<T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException;\n+\n+\t/**\n+\t * Execute the HTTP method to the given URI template, writing the given\n+\t * request entity to the request, and returns the response as {@link ResponseEntity}.\n+\t * The given {@link ParameterizedTypeReference} is used to pass generic type information:\n+\t *\n+\t * <pre class=\"code\">\n+\t * ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt; myBean = new ParameterizedTypeReference&lt;List&lt;MyBean&gt;&gt;() {};\n+\t * ResponseEntity&lt;List&lt;MyBean&gt;&gt; response = template.exchange(&quot;http://example.com&quot;,HttpMethod.GET, null, myBean);\n+\t * </pre>\n+\t *\n+\t * @param url the URL\n+\t * @param method the HTTP method (GET, POST, etc)\n+\t * @param requestEntity the entity (headers and/or body) to write to the request, may be {@code null}\n+\t * @param responseType the type of the return value\n+\t * @return the response as entity\n+\t * @since 3.2.0\n+\t */\n+\t<T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException;\n+\n \t// general execution\n \n \t/**"
        },
        {
            "sha": "032ea53b9608ba7c54b68688162cf09934506788",
            "filename": "spring-web/src/main/java/org/springframework/web/client/RestTemplate.java",
            "status": "modified",
            "additions": 72,
            "deletions": 14,
            "changes": 86,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplate.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplate.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplate.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -5,7 +5,7 @@\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -18,13 +18,15 @@\n \n import java.io.IOException;\n import java.io.UnsupportedEncodingException;\n+import java.lang.reflect.Type;\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.ArrayList;\n import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import org.springframework.core.ParameterizedTypeReference;\n import org.springframework.http.HttpEntity;\n import org.springframework.http.HttpHeaders;\n import org.springframework.http.HttpMethod;\n@@ -35,6 +37,7 @@\n import org.springframework.http.client.ClientHttpResponse;\n import org.springframework.http.client.support.InterceptingHttpAccessor;\n import org.springframework.http.converter.ByteArrayHttpMessageConverter;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n import org.springframework.http.converter.HttpMessageConverter;\n import org.springframework.http.converter.ResourceHttpMessageConverter;\n import org.springframework.http.converter.StringHttpMessageConverter;\n@@ -384,25 +387,55 @@ public Set<HttpMethod> optionsForAllow(URI url) throws RestClientException {\n \n \tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method,\n \t\t\tHttpEntity<?> requestEntity, Class<T> responseType, Object... uriVariables) throws RestClientException {\n+\n \t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, responseType);\n \t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(responseType);\n \t\treturn execute(url, method, requestCallback, responseExtractor, uriVariables);\n \t}\n \n \tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method,\n \t\t\tHttpEntity<?> requestEntity, Class<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n+\n \t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, responseType);\n \t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(responseType);\n \t\treturn execute(url, method, requestCallback, responseExtractor, uriVariables);\n \t}\n \n \tpublic <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,\n \t\t\tClass<T> responseType) throws RestClientException {\n+\n \t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, responseType);\n \t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(responseType);\n \t\treturn execute(url, method, requestCallback, responseExtractor);\n \t}\n \n+\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType, Object... uriVariables) throws RestClientException {\n+\n+\t\tType type = responseType.getType();\n+\t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, type);\n+\t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(type);\n+\t\treturn execute(url, method, requestCallback, responseExtractor, uriVariables);\n+\t}\n+\n+\tpublic <T> ResponseEntity<T> exchange(String url, HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType, Map<String, ?> uriVariables) throws RestClientException {\n+\n+\t\tType type = responseType.getType();\n+\t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, type);\n+\t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(type);\n+\t\treturn execute(url, method, requestCallback, responseExtractor, uriVariables);\n+\t}\n+\n+\tpublic <T> ResponseEntity<T> exchange(URI url, HttpMethod method, HttpEntity<?> requestEntity,\n+\t\t\tParameterizedTypeReference<T> responseType) throws RestClientException {\n+\n+\t\tType type = responseType.getType();\n+\t\tHttpEntityRequestCallback requestCallback = new HttpEntityRequestCallback(requestEntity, type);\n+\t\tResponseEntityResponseExtractor<T> responseExtractor = new ResponseEntityResponseExtractor<T>(type);\n+\t\treturn execute(url, method, requestCallback, responseExtractor);\n+\t}\n+\n \t// general execution\n \n \tpublic <T> T execute(String url, HttpMethod method, RequestCallback requestCallback,\n@@ -504,37 +537,62 @@ private void handleResponseError(HttpMethod method, URI url, ClientHttpResponse\n \t */\n \tprivate class AcceptHeaderRequestCallback implements RequestCallback {\n \n-\t\tprivate final Class<?> responseType;\n+\t\tprivate final Type responseType;\n \n-\t\tprivate AcceptHeaderRequestCallback(Class<?> responseType) {\n+\t\tprivate AcceptHeaderRequestCallback(Type responseType) {\n \t\t\tthis.responseType = responseType;\n \t\t}\n \n \t\t@SuppressWarnings(\"unchecked\")\n \t\tpublic void doWithRequest(ClientHttpRequest request) throws IOException {\n \t\t\tif (responseType != null) {\n+\t\t\t\tClass<?> responseClass = null;\n+\t\t\t\tif (responseType instanceof Class) {\n+\t\t\t\t\tresponseClass = (Class) responseType;\n+\t\t\t\t}\n+\n \t\t\t\tList<MediaType> allSupportedMediaTypes = new ArrayList<MediaType>();\n \t\t\t\tfor (HttpMessageConverter<?> messageConverter : getMessageConverters()) {\n-\t\t\t\t\tif (messageConverter.canRead(responseType, null)) {\n-\t\t\t\t\t\tList<MediaType> supportedMediaTypes = messageConverter.getSupportedMediaTypes();\n-\t\t\t\t\t\tfor (MediaType supportedMediaType : supportedMediaTypes) {\n-\t\t\t\t\t\t\tif (supportedMediaType.getCharSet() != null) {\n-\t\t\t\t\t\t\t\tsupportedMediaType =\n-\t\t\t\t\t\t\t\t\t\tnew MediaType(supportedMediaType.getType(), supportedMediaType.getSubtype());\n-\t\t\t\t\t\t\t}\n-\t\t\t\t\t\t\tallSupportedMediaTypes.add(supportedMediaType);\n+\t\t\t\t\tif (responseClass != null) {\n+\t\t\t\t\t\tif (messageConverter.canRead(responseClass, null)) {\n+\t\t\t\t\t\t\tallSupportedMediaTypes\n+\t\t\t\t\t\t\t\t\t.addAll(getSupportedMediaTypes(messageConverter));\n \t\t\t\t\t\t}\n \t\t\t\t\t}\n+\t\t\t\t\telse if (messageConverter instanceof GenericHttpMessageConverter) {\n+\n+\t\t\t\t\t\tGenericHttpMessageConverter genericMessageConverter =\n+\t\t\t\t\t\t\t\t(GenericHttpMessageConverter) messageConverter;\n+\t\t\t\t\t\tif (genericMessageConverter.canRead(responseType, null)) {\n+\t\t\t\t\t\t\tallSupportedMediaTypes\n+\t\t\t\t\t\t\t\t\t.addAll(getSupportedMediaTypes(messageConverter));\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\n \t\t\t\t}\n \t\t\t\tif (!allSupportedMediaTypes.isEmpty()) {\n \t\t\t\t\tMediaType.sortBySpecificity(allSupportedMediaTypes);\n \t\t\t\t\tif (logger.isDebugEnabled()) {\n-\t\t\t\t\t\tlogger.debug(\"Setting request Accept header to \" + allSupportedMediaTypes);\n+\t\t\t\t\t\tlogger.debug(\"Setting request Accept header to \" +\n+\t\t\t\t\t\t\t\tallSupportedMediaTypes);\n \t\t\t\t\t}\n \t\t\t\t\trequest.getHeaders().setAccept(allSupportedMediaTypes);\n \t\t\t\t}\n \t\t\t}\n \t\t}\n+\n+\t\tprivate List<MediaType> getSupportedMediaTypes(HttpMessageConverter<?> messageConverter) {\n+\t\t\tList<MediaType> supportedMediaTypes = messageConverter.getSupportedMediaTypes();\n+\t\t\tList<MediaType> result = new ArrayList<MediaType>(supportedMediaTypes.size());\n+\t\t\tfor (MediaType supportedMediaType : supportedMediaTypes) {\n+\t\t\t\tif (supportedMediaType.getCharSet() != null) {\n+\t\t\t\t\tsupportedMediaType =\n+\t\t\t\t\t\t\tnew MediaType(supportedMediaType.getType(), supportedMediaType.getSubtype());\n+\t\t\t\t}\n+\t\t\t\tresult.add(supportedMediaType);\n+\t\t\t}\n+\t\t\treturn result;\n+\t\t}\n \t}\n \n \n@@ -550,7 +608,7 @@ private HttpEntityRequestCallback(Object requestBody) {\n \t\t}\n \n \t\t@SuppressWarnings(\"unchecked\")\n-\t\tprivate HttpEntityRequestCallback(Object requestBody, Class<?> responseType) {\n+\t\tprivate HttpEntityRequestCallback(Object requestBody, Type responseType) {\n \t\t\tsuper(responseType);\n \t\t\tif (requestBody instanceof HttpEntity) {\n \t\t\t\tthis.requestEntity = (HttpEntity) requestBody;\n@@ -618,7 +676,7 @@ private class ResponseEntityResponseExtractor<T> implements ResponseExtractor<Re\n \n \t\tprivate final HttpMessageConverterExtractor<T> delegate;\n \n-\t\tpublic ResponseEntityResponseExtractor(Class<T> responseType) {\n+\t\tpublic ResponseEntityResponseExtractor(Type responseType) {\n \t\t\tif (responseType != null && !Void.class.equals(responseType)) {\n \t\t\t\tthis.delegate = new HttpMessageConverterExtractor<T>(responseType, getMessageConverters(), logger);\n \t\t\t} else {"
        },
        {
            "sha": "603b6613abec9e2731ba86d5a4cb3eae7b6a5d53",
            "filename": "spring-web/src/test/java/org/springframework/http/converter/json/MappingJackson2HttpMessageConverterTests.java",
            "status": "modified",
            "additions": 32,
            "deletions": 10,
            "changes": 42,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverterTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverterTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJackson2HttpMessageConverterTests.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -16,23 +16,22 @@\n \n package org.springframework.http.converter.json;\n \n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.List;\n \n+import com.fasterxml.jackson.databind.JavaType;\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+import static org.junit.Assert.*;\n import org.junit.Test;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n import org.springframework.http.MediaType;\n import org.springframework.http.MockHttpInputMessage;\n import org.springframework.http.MockHttpOutputMessage;\n \n-import com.fasterxml.jackson.databind.JavaType;\n-import com.fasterxml.jackson.databind.ObjectMapper;\n-\n /**\n  * Jackson 2.x converter tests.\n  *\n@@ -52,12 +51,12 @@ public void readGenerics() throws IOException {\n \t\tMappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter() {\n \n \t\t\t@Override\n-\t\t\tprotected JavaType getJavaType(Class<?> clazz) {\n-\t\t\t\tif (List.class.isAssignableFrom(clazz)) {\n+\t\t\tprotected JavaType getJavaType(Type type) {\n+\t\t\t\tif (type instanceof Class && List.class.isAssignableFrom((Class)type)) {\n \t\t\t\t\treturn new ObjectMapper().getTypeFactory().constructCollectionType(ArrayList.class, MyBean.class);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\treturn super.getJavaType(clazz);\n+\t\t\t\t\treturn super.getJavaType(type);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n@@ -77,6 +76,29 @@ protected JavaType getJavaType(Class<?> clazz) {\n \t\tassertArrayEquals(new byte[]{0x1, 0x2}, result.getBytes());\n \t}\n \n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readParameterizedType() throws IOException {\n+\t\tParameterizedTypeReference<List<MyBean>> beansList = new ParameterizedTypeReference<List<MyBean>>() {};\n+\n+\t\tString body =\n+\t\t\t\t\"[{\\\"bytes\\\":\\\"AQI=\\\",\\\"array\\\":[\\\"Foo\\\",\\\"Bar\\\"],\\\"number\\\":42,\\\"string\\\":\\\"Foo\\\",\\\"bool\\\":true,\\\"fraction\\\":42.0}]\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(body.getBytes(\"UTF-8\"));\n+\t\tinputMessage.getHeaders().setContentType(new MediaType(\"application\", \"json\"));\n+\n+\t\tMappingJackson2HttpMessageConverter converter = new MappingJackson2HttpMessageConverter();\n+\t\tList<MyBean> results = (List<MyBean>) converter.read(beansList.getType(), inputMessage);\n+\t\tassertEquals(1, results.size());\n+\t\tMyBean result = results.get(0);\n+\t\tassertEquals(\"Foo\", result.getString());\n+\t\tassertEquals(42, result.getNumber());\n+\t\tassertEquals(42F, result.getFraction(), 0F);\n+\t\tassertArrayEquals(new String[]{\"Foo\", \"Bar\"}, result.getArray());\n+\t\tassertTrue(result.isBool());\n+\t\tassertArrayEquals(new byte[]{0x1, 0x2}, result.getBytes());\n+\t}\n+\n+\n \t@Test\n \tpublic void prettyPrint() throws Exception {\n \t\tMockHttpOutputMessage outputMessage = new MockHttpOutputMessage();"
        },
        {
            "sha": "c3fe567a69cbdc03d95e579e06d7d2f560af6059",
            "filename": "spring-web/src/test/java/org/springframework/http/converter/json/MappingJacksonHttpMessageConverterTests.java",
            "status": "modified",
            "additions": 29,
            "deletions": 7,
            "changes": 36,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverterTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverterTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fjson%2FMappingJacksonHttpMessageConverterTests.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -16,18 +16,18 @@\n \n package org.springframework.http.converter.json;\n \n-import static org.junit.Assert.assertArrayEquals;\n-import static org.junit.Assert.assertEquals;\n-import static org.junit.Assert.assertTrue;\n-\n import java.io.IOException;\n+import java.lang.reflect.Type;\n import java.nio.charset.Charset;\n import java.util.ArrayList;\n import java.util.List;\n \n import org.codehaus.jackson.map.type.TypeFactory;\n import org.codehaus.jackson.type.JavaType;\n+import static org.junit.Assert.*;\n import org.junit.Test;\n+\n+import org.springframework.core.ParameterizedTypeReference;\n import org.springframework.http.MediaType;\n import org.springframework.http.MockHttpInputMessage;\n import org.springframework.http.MockHttpOutputMessage;\n@@ -49,12 +49,12 @@ protected MappingJacksonHttpMessageConverter createConverter() {\n \tpublic void readGenerics() throws IOException {\n \t\tMappingJacksonHttpMessageConverter converter = new MappingJacksonHttpMessageConverter() {\n \t\t\t@Override\n-\t\t\tprotected JavaType getJavaType(Class<?> clazz) {\n-\t\t\t\tif (List.class.isAssignableFrom(clazz)) {\n+\t\t\tprotected JavaType getJavaType(Type type) {\n+\t\t\t\tif (type instanceof Class && List.class.isAssignableFrom((Class)type)) {\n \t\t\t\t\treturn TypeFactory.collectionType(ArrayList.class, MyBean.class);\n \t\t\t\t}\n \t\t\t\telse {\n-\t\t\t\t\treturn super.getJavaType(clazz);\n+\t\t\t\t\treturn super.getJavaType(type);\n \t\t\t\t}\n \t\t\t}\n \t\t};\n@@ -74,6 +74,28 @@ protected JavaType getJavaType(Class<?> clazz) {\n \t\tassertArrayEquals(new byte[]{0x1, 0x2}, result.getBytes());\n \t}\n \n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readParameterizedType() throws IOException {\n+\t\tParameterizedTypeReference<List<MyBean>> beansList = new ParameterizedTypeReference<List<MyBean>>() {};\n+\n+\t\tString body =\n+\t\t\t\t\"[{\\\"bytes\\\":\\\"AQI=\\\",\\\"array\\\":[\\\"Foo\\\",\\\"Bar\\\"],\\\"number\\\":42,\\\"string\\\":\\\"Foo\\\",\\\"bool\\\":true,\\\"fraction\\\":42.0}]\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(body.getBytes(\"UTF-8\"));\n+\t\tinputMessage.getHeaders().setContentType(new MediaType(\"application\", \"json\"));\n+\n+\t\tMappingJacksonHttpMessageConverter converter = new MappingJacksonHttpMessageConverter();\n+\t\tList<MyBean> results = (List<MyBean>) converter.read(beansList.getType(), inputMessage);\n+\t\tassertEquals(1, results.size());\n+\t\tMyBean result = results.get(0);\n+\t\tassertEquals(\"Foo\", result.getString());\n+\t\tassertEquals(42, result.getNumber());\n+\t\tassertEquals(42F, result.getFraction(), 0F);\n+\t\tassertArrayEquals(new String[]{\"Foo\", \"Bar\"}, result.getArray());\n+\t\tassertTrue(result.isBool());\n+\t\tassertArrayEquals(new byte[]{0x1, 0x2}, result.getBytes());\n+\t}\n+\n \t@Test\n \tpublic void prettyPrint() throws Exception {\n \t\tMockHttpOutputMessage outputMessage = new MockHttpOutputMessage();"
        },
        {
            "sha": "44715ac6cbe33cb01df2351b10c56015735258ad",
            "filename": "spring-web/src/test/java/org/springframework/http/converter/xml/Jaxb2CollectionHttpMessageConverterTests.java",
            "status": "added",
            "additions": 189,
            "deletions": 0,
            "changes": 189,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverterTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverterTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fhttp%2Fconverter%2Fxml%2FJaxb2CollectionHttpMessageConverterTests.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,189 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.http.converter.xml;\n+\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertTrue;\n+\n+import java.lang.reflect.Type;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Set;\n+\n+import javax.xml.bind.annotation.XmlAttribute;\n+import javax.xml.bind.annotation.XmlElement;\n+import javax.xml.bind.annotation.XmlRootElement;\n+import javax.xml.bind.annotation.XmlType;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.MockHttpInputMessage;\n+\n+/**\n+ * Test fixture for {@link Jaxb2CollectionHttpMessageConverter}.\n+ *\n+ * @author Arjen Poutsma\n+ */\n+public class Jaxb2CollectionHttpMessageConverterTests {\n+\n+\tprivate Jaxb2CollectionHttpMessageConverter<?> converter;\n+\n+\tprivate Type rootElementListType;\n+\n+\tprivate Type rootElementSetType;\n+\n+\tprivate Type typeListType;\n+\n+\tprivate Type typeSetType;\n+\n+\n+\t@Before\n+\tpublic void setUp() {\n+\t\tconverter = new Jaxb2CollectionHttpMessageConverter<Collection<Object>>();\n+\t\trootElementListType = new ParameterizedTypeReference<List<RootElement>>() {}.getType();\n+\t\trootElementSetType = new ParameterizedTypeReference<Set<RootElement>>() {}.getType();\n+\t\ttypeListType = new ParameterizedTypeReference<List<TestType>>() {}.getType();\n+\t\ttypeSetType = new ParameterizedTypeReference<Set<TestType>>() {}.getType();\n+\t}\n+\n+\t@Test\n+\tpublic void canRead() throws Exception {\n+\t\tassertTrue(converter.canRead(rootElementListType, null));\n+\t\tassertTrue(converter.canRead(rootElementSetType, null));\n+\t\tassertTrue(converter.canRead(typeSetType, null));\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readXmlRootElementList() throws Exception {\n+\t\tString content = \"<list><rootElement><type s=\\\"1\\\"/></rootElement><rootElement><type s=\\\"2\\\"/></rootElement></list>\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(content.getBytes(\"UTF-8\"));\n+\n+\t\tList<RootElement> result = (List<RootElement>) converter.read(rootElementListType, inputMessage);\n+\n+\t\tassertEquals(\"Invalid result\", 2, result.size());\n+\t\tassertEquals(\"Invalid result\", \"1\", result.get(0).type.s);\n+\t\tassertEquals(\"Invalid result\", \"2\", result.get(1).type.s);\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readXmlRootElementSet() throws Exception {\n+\t\tString content = \"<set><rootElement><type s=\\\"1\\\"/></rootElement><rootElement><type s=\\\"2\\\"/></rootElement></set>\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(content.getBytes(\"UTF-8\"));\n+\n+\t\tSet<RootElement> result = (Set<RootElement>) converter.read(rootElementSetType, inputMessage);\n+\n+\t\tassertEquals(\"Invalid result\", 2, result.size());\n+\t\tassertTrue(\"Invalid result\", result.contains(new RootElement(\"1\")));\n+\t\tassertTrue(\"Invalid result\", result.contains(new RootElement(\"2\")));\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readXmlTypeList() throws Exception {\n+\t\tString content = \"<list><foo s=\\\"1\\\"/><bar s=\\\"2\\\"/></list>\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(content.getBytes(\"UTF-8\"));\n+\n+\t\tList<TestType> result = (List<TestType>) converter.read(typeListType, inputMessage);\n+\n+\t\tassertEquals(\"Invalid result\", 2, result.size());\n+\t\tassertEquals(\"Invalid result\", \"1\", result.get(0).s);\n+\t\tassertEquals(\"Invalid result\", \"2\", result.get(1).s);\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void readXmlTypeSet() throws Exception {\n+\t\tString content = \"<set><foo s=\\\"1\\\"/><bar s=\\\"2\\\"/></set>\";\n+\t\tMockHttpInputMessage inputMessage = new MockHttpInputMessage(content.getBytes(\"UTF-8\"));\n+\n+\t\tSet<TestType> result = (Set<TestType>) converter.read(typeSetType, inputMessage);\n+\n+\t\tassertEquals(\"Invalid result\", 2, result.size());\n+\t\tassertTrue(\"Invalid result\", result.contains(new TestType(\"1\")));\n+\t\tassertTrue(\"Invalid result\", result.contains(new TestType(\"2\")));\n+\t}\n+\n+\n+\t@XmlRootElement\n+\tpublic static class RootElement {\n+\n+\t\tpublic RootElement() {\n+\t\t}\n+\n+\t\tpublic RootElement(String s) {\n+\t\t\tthis.type = new TestType(s);\n+\t\t}\n+\n+\t\t@XmlElement\n+\t\tpublic TestType type = new TestType();\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o instanceof RootElement) {\n+\t\t\t\tRootElement other = (RootElement) o;\n+\t\t\t\treturn this.type.equals(other.type);\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn type.hashCode();\n+\t\t}\n+\t}\n+\n+\t@XmlType\n+\tpublic static class TestType {\n+\n+\t\tpublic TestType() {\n+\t\t}\n+\n+\t\tpublic TestType(String s) {\n+\t\t\tthis.s = s;\n+\t\t}\n+\n+\t\t@XmlAttribute\n+\t\tpublic String s = \"Hello World\";\n+\n+\t\t@Override\n+\t\tpublic boolean equals(Object o) {\n+\t\t\tif (this == o) {\n+\t\t\t\treturn true;\n+\t\t\t}\n+\t\t\tif (o instanceof TestType) {\n+\t\t\t\tTestType other = (TestType) o;\n+\t\t\t\treturn this.s.equals(other.s);\n+\t\t\t}\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\t@Override\n+\t\tpublic int hashCode() {\n+\t\t\treturn s.hashCode();\n+\t\t}\n+\n+\n+\n+\t}\n+\n+}"
        },
        {
            "sha": "a8e9a418e661bb92614a9f14eeaaffda28af8fc3",
            "filename": "spring-web/src/test/java/org/springframework/web/client/HttpMessageConverterExtractorTests.java",
            "status": "added",
            "additions": 196,
            "deletions": 0,
            "changes": 196,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractorTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractorTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FHttpMessageConverterExtractorTests.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -0,0 +1,196 @@\n+/*\n+ * Copyright 2002-2012 the original author or authors.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.springframework.web.client;\n+\n+import static org.easymock.EasyMock.createMock;\n+import static org.easymock.EasyMock.expect;\n+import static org.easymock.EasyMock.replay;\n+import static org.easymock.EasyMock.verify;\n+import static org.junit.Assert.assertEquals;\n+import static org.junit.Assert.assertNull;\n+import static org.junit.Assert.fail;\n+\n+import java.io.IOException;\n+import java.lang.reflect.Type;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.springframework.core.ParameterizedTypeReference;\n+import org.springframework.http.HttpHeaders;\n+import org.springframework.http.HttpStatus;\n+import org.springframework.http.MediaType;\n+import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n+import org.springframework.http.converter.HttpMessageConverter;\n+\n+/**\n+ * Test fixture for {@link HttpMessageConverter}.\n+ *\n+ * @author Arjen Poutsma\n+ */\n+public class HttpMessageConverterExtractorTests {\n+\n+\tprivate HttpMessageConverterExtractor extractor;\n+\n+\tprivate ClientHttpResponse response;\n+\n+\t@Before\n+\tpublic void createMocks() {\n+\t\tresponse = createMock(ClientHttpResponse.class);\n+\t}\n+\n+\t@Test\n+\tpublic void noContent() throws IOException {\n+\t\tHttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);\n+\n+\t\textractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.NO_CONTENT);\n+\n+\t\treplay(response, converter);\n+\t\tObject result = extractor.extractData(response);\n+\n+\t\tassertNull(result);\n+\t\tverify(response, converter);\n+\t}\n+\n+\t@Test\n+\tpublic void notModified() throws IOException {\n+\t\tHttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);\n+\n+\t\textractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.NOT_MODIFIED);\n+\n+\t\treplay(response, converter);\n+\t\tObject result = extractor.extractData(response);\n+\n+\t\tassertNull(result);\n+\t\tverify(response, converter);\n+\t}\n+\n+\t@Test\n+\tpublic void zeroContentLength() throws IOException {\n+\t\tHttpMessageConverter<?> converter = createMock(HttpMessageConverter.class);\n+\t\tHttpHeaders responseHeaders = new HttpHeaders();\n+\t\tresponseHeaders.setContentLength(0);\n+\n+\t\textractor = new HttpMessageConverterExtractor<String>(String.class, createConverterList(converter));\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\texpect(response.getHeaders()).andReturn(responseHeaders);\n+\n+\t\treplay(response, converter);\n+\t\tObject result = extractor.extractData(response);\n+\n+\t\tassertNull(result);\n+\t\tverify(response, converter);\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void normal() throws IOException {\n+\t\tHttpMessageConverter<String> converter = createMock(HttpMessageConverter.class);\n+\t\tList<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();\n+\t\tconverters.add(converter);\n+\n+\t\tHttpHeaders responseHeaders = new HttpHeaders();\n+\t\tMediaType contentType = MediaType.TEXT_PLAIN;\n+\t\tresponseHeaders.setContentType(contentType);\n+\t\tString expected = \"Foo\";\n+\n+\t\textractor = new HttpMessageConverterExtractor<String>(String.class, converters);\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\texpect(response.getHeaders()).andReturn(responseHeaders).times(2);\n+\t\texpect(converter.canRead(String.class, contentType)).andReturn(true);\n+\t\texpect(converter.read(String.class, response)).andReturn(expected);\n+\n+\t\treplay(response, converter);\n+\t\tObject result = extractor.extractData(response);\n+\n+\t\tassertEquals(expected, result);\n+\t\tverify(response, converter);\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void cannotRead() throws IOException {\n+\t\tHttpMessageConverter<String> converter = createMock(HttpMessageConverter.class);\n+\t\tList<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>();\n+\t\tconverters.add(converter);\n+\n+\t\tHttpHeaders responseHeaders = new HttpHeaders();\n+\t\tMediaType contentType = MediaType.TEXT_PLAIN;\n+\t\tresponseHeaders.setContentType(contentType);\n+\n+\t\textractor = new HttpMessageConverterExtractor<String>(String.class, converters);\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\texpect(response.getHeaders()).andReturn(responseHeaders).times(2);\n+\t\texpect(converter.canRead(String.class, contentType)).andReturn(false);\n+\n+\t\treplay(response, converter);\n+\t\ttry {\n+\t\t\textractor.extractData(response);\n+\t\t\tfail(\"RestClientException expected\");\n+\t\t}\n+\t\tcatch (RestClientException expected) {\n+\t\t\t// expected\n+\t\t}\n+\n+\t\tverify(response, converter);\n+\t}\n+\n+\t@Test\n+\t@SuppressWarnings(\"unchecked\")\n+\tpublic void generics() throws IOException {\n+\t\tGenericHttpMessageConverter<String> converter = createMock(GenericHttpMessageConverter.class);\n+\t\tList<HttpMessageConverter<?>> converters = createConverterList(converter);\n+\n+\t\tHttpHeaders responseHeaders = new HttpHeaders();\n+\t\tMediaType contentType = MediaType.TEXT_PLAIN;\n+\t\tresponseHeaders.setContentType(contentType);\n+\t\tString expected = \"Foo\";\n+\n+\t\tParameterizedTypeReference<List<String>> reference = new ParameterizedTypeReference<List<String>>() {};\n+\t\tType type = reference.getType();\n+\n+\t\textractor = new HttpMessageConverterExtractor<List<String>>(type, converters);\n+\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\texpect(response.getHeaders()).andReturn(responseHeaders).times(2);\n+\t\texpect(converter.canRead(type, contentType)).andReturn(true);\n+\t\texpect(converter.read(type, response)).andReturn(expected);\n+\n+\t\treplay(response, converter);\n+\t\tObject result = extractor.extractData(response);\n+\n+\t\tassertEquals(expected, result);\n+\t\tverify(response, converter);\n+\t}\n+\n+\tprivate List<HttpMessageConverter<?>> createConverterList(HttpMessageConverter converter) {\n+\t\tList<HttpMessageConverter<?>> converters = new ArrayList<HttpMessageConverter<?>>(1);\n+\t\tconverters.add(converter);\n+\t\treturn converters;\n+\t}\n+\n+\n+}"
        },
        {
            "sha": "d12c5cf8e3946aa294af6fe9e6580ccc9918b88d",
            "filename": "spring-web/src/test/java/org/springframework/web/client/RestTemplateTests.java",
            "status": "modified",
            "additions": 54,
            "deletions": 11,
            "changes": 65,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplateTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/ed3823b045fd19cdb801609eb034c93dd4d75c3f/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplateTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fweb%2Fclient%2FRestTemplateTests.java?ref=ed3823b045fd19cdb801609eb034c93dd4d75c3f",
            "patch": "@@ -1,11 +1,11 @@\n /*\n- * Copyright 2002-2011 the original author or authors.\n+ * Copyright 2002-2012 the original author or authors.\n  *\n  * Licensed under the Apache License, Version 2.0 (the \"License\");\n  * you may not use this file except in compliance with the License.\n  * You may obtain a copy of the License at\n  *\n- *      http://www.apache.org/licenses/LICENSE-2.0\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n  *\n  * Unless required by applicable law or agreed to in writing, software\n  * distributed under the License is distributed on an \"AS IS\" BASIS,\n@@ -21,12 +21,16 @@\n import java.util.Collections;\n import java.util.EnumSet;\n import java.util.HashMap;\n+import java.util.List;\n import java.util.Map;\n import java.util.Set;\n \n+import static org.easymock.EasyMock.*;\n+import static org.junit.Assert.*;\n import org.junit.Before;\n import org.junit.Test;\n \n+import org.springframework.core.ParameterizedTypeReference;\n import org.springframework.http.HttpEntity;\n import org.springframework.http.HttpHeaders;\n import org.springframework.http.HttpMethod;\n@@ -36,11 +40,9 @@\n import org.springframework.http.client.ClientHttpRequest;\n import org.springframework.http.client.ClientHttpRequestFactory;\n import org.springframework.http.client.ClientHttpResponse;\n+import org.springframework.http.converter.GenericHttpMessageConverter;\n import org.springframework.http.converter.HttpMessageConverter;\n \n-import static org.easymock.EasyMock.*;\n-import static org.junit.Assert.*;\n-\n /** @author Arjen Poutsma */\n @SuppressWarnings(\"unchecked\")\n public class RestTemplateTests {\n@@ -600,9 +602,8 @@ public void ioException() throws Exception {\n \n \t@Test\n \tpublic void exchange() throws Exception {\n-\t\tMediaType textPlain = new MediaType(\"text\", \"plain\");\n \t\texpect(converter.canRead(Integer.class, null)).andReturn(true);\n-\t\texpect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(textPlain));\n+\t\texpect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));\n \t\texpect(requestFactory.createRequest(new URI(\"http://example.com\"), HttpMethod.POST)).andReturn(this.request);\n \t\tHttpHeaders requestHeaders = new HttpHeaders();\n \t\texpect(this.request.getHeaders()).andReturn(requestHeaders).times(2);\n@@ -612,12 +613,12 @@ public void exchange() throws Exception {\n \t\texpect(this.request.execute()).andReturn(response);\n \t\texpect(errorHandler.hasError(response)).andReturn(false);\n \t\tHttpHeaders responseHeaders = new HttpHeaders();\n-\t\tresponseHeaders.setContentType(textPlain);\n+\t\tresponseHeaders.setContentType(MediaType.TEXT_PLAIN);\n \t\tresponseHeaders.setContentLength(10);\n \t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n \t\texpect(response.getHeaders()).andReturn(responseHeaders).times(3);\n \t\tInteger expected = 42;\n-\t\texpect(converter.canRead(Integer.class, textPlain)).andReturn(true);\n+\t\texpect(converter.canRead(Integer.class, MediaType.TEXT_PLAIN)).andReturn(true);\n \t\texpect(converter.read(Integer.class, response)).andReturn(expected);\n \t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n \t\tresponse.close();\n@@ -629,14 +630,56 @@ public void exchange() throws Exception {\n \t\tHttpEntity<String> requestEntity = new HttpEntity<String>(body, entityHeaders);\n \t\tResponseEntity<Integer> result = template.exchange(\"http://example.com\", HttpMethod.POST, requestEntity, Integer.class);\n \t\tassertEquals(\"Invalid POST result\", expected, result.getBody());\n-\t\tassertEquals(\"Invalid Content-Type\", textPlain, result.getHeaders().getContentType());\n-\t\tassertEquals(\"Invalid Accept header\", textPlain.toString(), requestHeaders.getFirst(\"Accept\"));\n+\t\tassertEquals(\"Invalid Content-Type\", MediaType.TEXT_PLAIN, result.getHeaders().getContentType());\n+\t\tassertEquals(\"Invalid Accept header\", MediaType.TEXT_PLAIN_VALUE, requestHeaders.getFirst(\"Accept\"));\n \t\tassertEquals(\"Invalid custom header\", \"MyValue\", requestHeaders.getFirst(\"MyHeader\"));\n \t\tassertEquals(\"Invalid status code\", HttpStatus.OK, result.getStatusCode());\n \n \t\tverifyMocks();\n \t}\n \n+\t@Test\n+\tpublic void exchangeParameterizedType() throws Exception {\n+\t\tGenericHttpMessageConverter converter = createMock(GenericHttpMessageConverter.class);\n+\t\ttemplate.setMessageConverters(Collections.<HttpMessageConverter<?>>singletonList(converter));\n+\n+\t\tParameterizedTypeReference<List<Integer>> intList = new ParameterizedTypeReference<List<Integer>>() {};\n+\t\texpect(converter.canRead(intList.getType(), null)).andReturn(true);\n+\t\texpect(converter.getSupportedMediaTypes()).andReturn(Collections.singletonList(MediaType.TEXT_PLAIN));\n+\t\texpect(requestFactory.createRequest(new URI(\"http://example.com\"), HttpMethod.POST)).andReturn(this.request);\n+\t\tHttpHeaders requestHeaders = new HttpHeaders();\n+\t\texpect(this.request.getHeaders()).andReturn(requestHeaders).times(2);\n+\t\texpect(converter.canWrite(String.class, null)).andReturn(true);\n+\t\tString requestBody = \"Hello World\";\n+\t\tconverter.write(requestBody, null, this.request);\n+\t\texpect(this.request.execute()).andReturn(response);\n+\t\texpect(errorHandler.hasError(response)).andReturn(false);\n+\t\tHttpHeaders responseHeaders = new HttpHeaders();\n+\t\tresponseHeaders.setContentType(MediaType.TEXT_PLAIN);\n+\t\tresponseHeaders.setContentLength(10);\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\texpect(response.getHeaders()).andReturn(responseHeaders).times(3);\n+\t\tList<Integer> expected = Collections.singletonList(42);\n+\t\texpect(converter.canRead(intList.getType(), MediaType.TEXT_PLAIN)).andReturn(true);\n+\t\texpect(converter.read(intList.getType(), response)).andReturn(expected);\n+\t\texpect(response.getStatusCode()).andReturn(HttpStatus.OK);\n+\t\tresponse.close();\n+\n+\t\treplay(requestFactory, request, response, errorHandler, converter);\n+\n+\t\tHttpHeaders entityHeaders = new HttpHeaders();\n+\t\tentityHeaders.set(\"MyHeader\", \"MyValue\");\n+\t\tHttpEntity<String> requestEntity = new HttpEntity<String>(requestBody, entityHeaders);\n+\t\tResponseEntity<List<Integer>> result = template.exchange(\"http://example.com\", HttpMethod.POST, requestEntity, intList);\n+\t\tassertEquals(\"Invalid POST result\", expected, result.getBody());\n+\t\tassertEquals(\"Invalid Content-Type\", MediaType.TEXT_PLAIN, result.getHeaders().getContentType());\n+\t\tassertEquals(\"Invalid Accept header\", MediaType.TEXT_PLAIN_VALUE, requestHeaders.getFirst(\"Accept\"));\n+\t\tassertEquals(\"Invalid custom header\", \"MyValue\", requestHeaders.getFirst(\"MyHeader\"));\n+\t\tassertEquals(\"Invalid status code\", HttpStatus.OK, result.getStatusCode());\n+\n+\t\tverify(requestFactory, request, response, errorHandler, converter);\n+\t}\n+\n \n \tprivate void replayMocks() {\n \t\treplay(requestFactory, request, response, errorHandler, converter);"
        }
    ]
}
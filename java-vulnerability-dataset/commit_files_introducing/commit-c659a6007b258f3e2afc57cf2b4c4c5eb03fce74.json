{
    "sha": "c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
    "node_id": "MDY6Q29tbWl0MTEzMzUyMzk6YzY1OWE2MDA3YjI1OGYzZTJhZmM1N2NmMmI0YzRjNWViMDNmY2U3NA==",
    "commit": {
        "author": {
            "name": "Damjan Jovanovic",
            "email": "damjan@apache.org",
            "date": "2011-04-10T09:08:42Z"
        },
        "committer": {
            "name": "Damjan Jovanovic",
            "email": "damjan@apache.org",
            "date": "2011-04-10T09:08:42Z"
        },
        "message": "Fix some JPEG marker names, improve JPEG parsing,\nadd support for reading baseline JPEG images,\nand enable JPEG round-trip read tests.\n\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/sanselan/trunk@1090754 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "a34a2467dcb5caef54c490c3c5deb77a7d934621",
            "url": "https://api.github.com/repos/apache/commons-imaging/git/trees/a34a2467dcb5caef54c490c3c5deb77a7d934621"
        },
        "url": "https://api.github.com/repos/apache/commons-imaging/git/commits/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/commons-imaging/commits/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
    "html_url": "https://github.com/apache/commons-imaging/commit/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
    "comments_url": "https://api.github.com/repos/apache/commons-imaging/commits/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "cb1f096543f1294821c194173150be526d640ebf",
            "url": "https://api.github.com/repos/apache/commons-imaging/commits/cb1f096543f1294821c194173150be526d640ebf",
            "html_url": "https://github.com/apache/commons-imaging/commit/cb1f096543f1294821c194173150be526d640ebf"
        }
    ],
    "stats": {
        "total": 1794,
        "additions": 1725,
        "deletions": 69
    },
    "files": [
        {
            "sha": "d22df245d5ecf3be75d6c940ba32001205cef713",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/Block.java",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FBlock.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FBlock.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FBlock.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,30 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg;\n+\n+public final class Block\n+{\n+    public final int[] samples;\n+    public final int width;\n+    public final int height;\n+\n+    public Block(int width, int height)\n+    {\n+        samples = new int[width*height];\n+        this.width = width;\n+        this.height = height;\n+    }\n+}"
        },
        {
            "sha": "39793a2e69aac4c68e72119e419d83701d8e5b4c",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/JpegConstants.java",
            "status": "modified",
            "additions": 12,
            "deletions": 8,
            "changes": 20,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegConstants.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegConstants.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegConstants.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -77,8 +77,6 @@ public interface JpegConstants\n     public static final byte SOI[] = new byte[] { (byte) 0xff, (byte) 0xd8 };\n     public static final byte EOI[] = new byte[] { (byte) 0xff, (byte) 0xd9 };\n \n-    public static final int SOS_Marker = (0xff00) | (0xda);\n-\n     public static final int JPEG_APP0 = 0xE0;\n     // public static final int JPEG_APP1 = JPEG_APP0 + 1;\n     // public static final int JPEG_APP1_Marker = (0xff00) | JPEG_APP1;\n@@ -95,26 +93,32 @@ public interface JpegConstants\n     public static final int SOF1Marker = 0xFFc0 + 0x1;\n     public static final int SOF2Marker = 0xFFc0 + 0x2;\n     public static final int SOF3Marker = 0xFFc0 + 0x3;\n-    public static final int SOF4Marker = 0xFFc0 + 0x4;\n+    public static final int DHTMarker = 0xFFc0 + 0x4;\n     public static final int SOF5Marker = 0xFFc0 + 0x5;\n     public static final int SOF6Marker = 0xFFc0 + 0x6;\n     public static final int SOF7Marker = 0xFFc0 + 0x7;\n     public static final int SOF8Marker = 0xFFc0 + 0x8;\n     public static final int SOF9Marker = 0xFFc0 + 0x9;\n     public static final int SOF10Marker = 0xFFc0 + 0xa;\n     public static final int SOF11Marker = 0xFFc0 + 0xb;\n-    public static final int SOF12Marker = 0xFFc0 + 0xc;\n+    public static final int DACMarker = 0xFFc0 + 0xc;\n     public static final int SOF13Marker = 0xFFc0 + 0xd;\n     public static final int SOF14Marker = 0xFFc0 + 0xe;\n     public static final int SOF15Marker = 0xFFc0 + 0xf;\n \n-    public static final int MARKERS[] = { SOS_Marker, JPEG_APP0,\n+    public static final int EOIMarker = 0xFFd9;\n+    public static final int SOS_Marker = 0xFFda;\n+    public static final int DQTMarker = 0xFFdb;\n+    public static final int DNLMarker = 0xFFdc;\n+\n+    public static final int MARKERS[] = { JPEG_APP0,\n             JPEG_APP0_Marker, JPEG_APP1_Marker, JPEG_APP2_Marker,\n             JPEG_APP13_Marker, JPEG_APP14_Marker, JPEG_APP15_Marker,\n             JFIFMarker, SOF0Marker, SOF1Marker, SOF2Marker, SOF3Marker,\n-            SOF4Marker, SOF5Marker, SOF6Marker, SOF7Marker, SOF8Marker,\n-            SOF9Marker, SOF10Marker, SOF11Marker, SOF12Marker, SOF13Marker,\n-            SOF14Marker, SOF15Marker, };\n+            DHTMarker, SOF5Marker, SOF6Marker, SOF7Marker, SOF8Marker,\n+            SOF9Marker, SOF10Marker, SOF11Marker, DACMarker, SOF13Marker,\n+            SOF14Marker, SOF15Marker, EOIMarker, SOS_Marker,\n+            DQTMarker, DNLMarker };\n \n     public static final byte icc_profile_label[] = { 0x49, 0x43, 0x43, 0x5F,\n             0x50, 0x52, 0x4F, 0x46, 0x49, 0x4C, 0x45, 0x0 };"
        },
        {
            "sha": "f9cfde59f61f0b79feb77b43d0e4160942742e16",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/JpegImageParser.java",
            "status": "modified",
            "additions": 18,
            "deletions": 4,
            "changes": 22,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegImageParser.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegImageParser.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegImageParser.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -23,6 +23,7 @@\n import java.io.PrintWriter;\n import java.text.NumberFormat;\n import java.util.ArrayList;\n+import java.util.Arrays;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n@@ -34,10 +35,12 @@\n import org.apache.sanselan.ImageReadException;\n import org.apache.sanselan.common.IImageMetadata;\n import org.apache.sanselan.common.byteSources.ByteSource;\n+import org.apache.sanselan.formats.jpeg.decoder.JpegDecoder;\n import org.apache.sanselan.formats.jpeg.iptc.IPTCParser;\n import org.apache.sanselan.formats.jpeg.iptc.PhotoshopApp13Data;\n import org.apache.sanselan.formats.jpeg.segments.App13Segment;\n import org.apache.sanselan.formats.jpeg.segments.App2Segment;\n+import org.apache.sanselan.formats.jpeg.segments.DQTSegment;\n import org.apache.sanselan.formats.jpeg.segments.GenericSegment;\n import org.apache.sanselan.formats.jpeg.segments.JFIFSegment;\n import org.apache.sanselan.formats.jpeg.segments.SOFNSegment;\n@@ -87,8 +90,8 @@ protected String[] getAcceptedExtensions()\n     public final BufferedImage getBufferedImage(ByteSource byteSource,\n             Map params) throws ImageReadException, IOException\n     {\n-        throw new ImageReadException(\n-                \"Sanselan cannot read or write JPEG images.\");\n+        JpegDecoder jpegDecoder = new JpegDecoder();\n+        return jpegDecoder.decode(byteSource);\n     }\n \n     private boolean keepMarker(int marker, int markers[])\n@@ -111,6 +114,14 @@ public ArrayList readSegments(ByteSource byteSource, final int markers[],\n     {\n         final ArrayList result = new ArrayList();\n         final JpegImageParser parser = this;\n+        final int[] sofnSegments = {\n+                // kJFIFMarker,\n+                SOF0Marker,\n+\n+                SOF1Marker, SOF2Marker, SOF3Marker, SOF5Marker, SOF6Marker,\n+                SOF7Marker, SOF9Marker, SOF10Marker, SOF11Marker, SOF13Marker,\n+                SOF14Marker, SOF15Marker,\n+        };\n \n         JpegUtils.Visitor visitor = new JpegUtils.Visitor() {\n             // return false to exit before reading image data.\n@@ -129,7 +140,7 @@ public boolean visitSegment(int marker, byte markerBytes[],\n                     int markerLength, byte markerLengthBytes[],\n                     byte segmentData[]) throws ImageReadException, IOException\n             {\n-                if (marker == 0xffd9)\n+                if (marker == EOIMarker)\n                     return false;\n \n                 // Debug.debug(\"visitSegment marker\", marker);\n@@ -151,9 +162,12 @@ public boolean visitSegment(int marker, byte markerBytes[],\n                 } else if (marker == JFIFMarker)\n                 {\n                     result.add(new JFIFSegment(marker, segmentData));\n-                } else if ((marker >= SOF0Marker) && (marker <= SOF15Marker))\n+                } else if (Arrays.binarySearch(sofnSegments, marker) >= 0)\n                 {\n                     result.add(new SOFNSegment(marker, segmentData));\n+                } else if (marker == DQTMarker)\n+                {\n+                    result.add(new DQTSegment(marker, segmentData));\n                 } else if ((marker >= JPEG_APP1_Marker)\n                         && (marker <= JPEG_APP15_Marker))\n                 {"
        },
        {
            "sha": "d28cdf386760f0bc145df754a8aabdb96f3d6a98",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/JpegUtils.java",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegUtils.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegUtils.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FJpegUtils.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -73,7 +73,7 @@ public void traverseJFIF(ByteSource byteSource, Visitor visitor)\n //                Debug.debug(\"marker\", marker + \" (0x\" + Integer.toHexString(marker) + \")\");\n //                Debug.debug(\"markerBytes\", markerBytes);\n \n-                if (marker == 0xffd9 || marker == SOS_Marker)\n+                if (marker == EOIMarker || marker == SOS_Marker)\n                 {\n                     if (!visitor.beginSOS())\n                         return;\n@@ -146,7 +146,7 @@ public static String getMarkerName(int marker)\n             return \"SOF2Marker\";\n         case SOF3Marker:\n             return \"SOF3Marker\";\n-        case SOF4Marker:\n+        case DHTMarker:\n             return \"SOF4Marker\";\n         case SOF5Marker:\n             return \"SOF5Marker\";\n@@ -162,14 +162,16 @@ public static String getMarkerName(int marker)\n             return \"SOF10Marker\";\n         case SOF11Marker:\n             return \"SOF11Marker\";\n-        case SOF12Marker:\n-            return \"SOF12Marker\";\n+        case DACMarker:\n+            return \"DACMarker\";\n         case SOF13Marker:\n             return \"SOF13Marker\";\n         case SOF14Marker:\n             return \"SOF14Marker\";\n         case SOF15Marker:\n             return \"SOF15Marker\";\n+        case DQTMarker:\n+            return \"DQTMarker\";\n         default:\n             return \"Unknown\";\n         }"
        },
        {
            "sha": "bbd2fc25b6338a59ade9dbb7d7dc646957408961",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/ZigZag.java",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FZigZag.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FZigZag.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2FZigZag.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,47 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg;\n+\n+public class ZigZag\n+{\n+    private static final int zigZag[] =\n+    {\n+         0,  1,  5,  6, 14, 15, 27, 28,\n+         2,  4,  7, 13, 16, 26, 29, 42,\n+         3,  8, 12, 17, 25, 30, 41, 43,\n+         9, 11, 18, 24, 31, 40, 44, 53,\n+        10, 19, 23, 32, 39, 45, 52, 54,\n+        20, 22, 33, 38, 46, 51, 55, 60,\n+        21, 34, 37, 47, 50, 56, 59, 61,\n+        35, 36, 48, 49, 57, 58, 62, 63\n+    };\n+\n+    public static void zigZagToBlock(int[] zz, int[] block)\n+    {\n+        for (int i = 0; i < 64; i++)\n+        {\n+            block[i] = zz[zigZag[i]];\n+        }\n+    }\n+\n+    public static void blockToZigZag(int[] block, int[] zz)\n+    {\n+        for (int i = 0; i < 64; i++)\n+        {\n+            zz[zigZag[i]] = block[i];\n+        }\n+    }\n+}"
        },
        {
            "sha": "0a339e29055250f53dd80d0c9dce25515e8b2054",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/decoder/DCT.java",
            "status": "added",
            "additions": 594,
            "deletions": 0,
            "changes": 594,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FDCT.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FDCT.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FDCT.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,594 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ *\n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.decoder;\n+\n+public class DCT\n+{\n+    /*\n+     * The book \"JPEG still image data compression standard\",\n+     * by Pennebaker and Mitchell, Chapter 4, discusses a number of\n+     * approaches to the fast DCT. Here's the cost, exluding modified\n+     * (de)quantization, for transforming an 8x8 block:\n+     *\n+     * Algorithm         Adds Multiplies RightShifts  Total\n+     * Naive              896       1024           0   1920\n+     * \"Symmetries\"       448        224           0    672\n+     * Vetterli and       464        208           0    672\n+     *   Ligtenberg\n+     * Arai, Agui and     464         80           0    544\n+     *   Nakajima (AA&N)\n+     * Feig 8x8           462         54           6    522\n+     * Fused mul/add                                    416\n+     *   (a pipe dream)\n+     *\n+     * IJG's libjpeg, FFmpeg, and a number of others use AA&N.\n+     *\n+     * It would appear that Feig does 4-5% less operations, and\n+     * multiplications are reduced from 80 in AA&N to only 54.\n+     * But in practice:\n+     *\n+     * Benchmarks, Intel Core i3 @ 2.93 GHz in long mode, 4 GB RAM\n+     * Time taken to do 100 million IDCTs (less is better):\n+     * Rene' St\ufffdckel's Feig, int: 45.07 seconds\n+     * My Feig, floating point: 36.252 seconds\n+     * AA&N, unrolled loops, double[][] -> double[][]: 25.167 seconds\n+     *\n+     * Clearly Feig is hopeless. I suspect the performance killer is simply\n+     * the weight of the algorithm: massive number of local variables,\n+     * large code size, and lots of random array accesses.\n+     *\n+     * Also, AA&N can be optimized a lot:\n+     * AA&N, rolled loops, double[][] -> double[][]: 21.162 seconds\n+     * AA&N, rolled loops, float[][] -> float[][]: no improvement, but\n+     *     at some stage Hotspot might start doing SIMD, so let's use float\n+     * AA&N, rolled loops, float[] -> float[][]: 19.979 seconds\n+     *     apparently 2D arrays are slow!\n+     * AA&N, rolled loops, inlined 1D AA&N transform, float[]\n+     *     transformed in-place: 18.5 seconds\n+     * AA&N, previous version rewritten in C and compiled with \"gcc -O3\"\n+     *     takes: 8.5 seconds (probably due to heavy use of SIMD)\n+     *\n+     * Other brave attempts:\n+     * AA&N, best float version converted to 16:16 fixed point: 23.923 seconds\n+     *\n+     * Anyway the best float version stays.\n+     * 18.5 seconds = 5.4 million transforms per second per core :-)\n+     */\n+\n+    private static final float[] dctScalingFactors =\n+    {\n+        (float)(0.5 / Math.sqrt(2.0)),\n+        (float)(0.25 / Math.cos(Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(2.0*Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(3.0*Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(4.0*Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(5.0*Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(6.0*Math.PI/16.0)),\n+        (float)(0.25 / Math.cos(7.0*Math.PI/16.0)),\n+    };\n+\n+    private static final float[] idctScalingFactors =\n+    {\n+        (float)(2.0 * 4.0 / Math.sqrt(2.0) * 0.0625),\n+        (float)(4.0 * Math.cos(Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(2.0*Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(3.0*Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(4.0*Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(5.0*Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(6.0*Math.PI/16.0) * 0.125),\n+        (float)(4.0 * Math.cos(7.0*Math.PI/16.0) * 0.125),\n+    };\n+\n+    private static final float A1 = (float)(Math.cos(2.0*Math.PI/8.0));\n+    private static final float A2 = (float)(Math.cos(Math.PI/8.0) - Math.cos(3.0*Math.PI/8.0));\n+    private static final float A3 = A1;\n+    private static final float A4 = (float)(Math.cos(Math.PI/8.0) + Math.cos(3.0*Math.PI/8.0));\n+    private static final float A5 = (float)(Math.cos(3.0*Math.PI/8.0));\n+\n+    private static final float C2 = (float)(2.0 * Math.cos(Math.PI/8));\n+    private static final float C4 = (float)(2.0 * Math.cos(2*Math.PI/8));\n+    private static final float C6 = (float)(2.0 * Math.cos(3*Math.PI/8));\n+    private static final float Q = C2 - C6;\n+    private static final float R = C2 + C6;\n+\n+    public static void scaleQuantizationVector(float[] vector)\n+    {\n+        for (int x = 0; x < 8; x++)\n+            vector[x] *= dctScalingFactors[x];\n+    }\n+\n+    public static void scaleDequantizationVector(float[] vector)\n+    {\n+        for (int x = 0; x < 8; x++)\n+            vector[x] *= idctScalingFactors[x];\n+    }\n+\n+    public static void scaleQuantizationMatrix(float[] matrix)\n+    {\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+                matrix[8*y + x] *= dctScalingFactors[y] * dctScalingFactors[x];\n+        }\n+    }\n+\n+    public static void scaleDequantizationMatrix(float[] matrix)\n+    {\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+                matrix[8*y + x] *= idctScalingFactors[y] * idctScalingFactors[x];\n+        }\n+    }\n+\n+    /**\n+     * Fast forward DCT using AA&N.\n+     * Taken from the book \"JPEG still image data compression standard\",\n+     * by Pennebaker and Mitchell, chapter 4, figure \"4-8\".\n+     */\n+    public static void forwardDCT8(float[] vector)\n+    {\n+        float a00 = vector[0] + vector[7];\n+        float a10 = vector[1] + vector[6];\n+        float a20 = vector[2] + vector[5];\n+        float a30 = vector[3] + vector[4];\n+        float a40 = vector[3] - vector[4];\n+        float a50 = vector[2] - vector[5];\n+        float a60 = vector[1] - vector[6];\n+        float a70 = vector[0] - vector[7];\n+\n+        float a01 = a00 + a30;\n+        float a11 = a10 + a20;\n+        float a21 = a10 - a20;\n+        float a31 = a00 - a30;\n+        // Avoid some negations:\n+        // float a41 = -a40 - a50;\n+        float neg_a41 = a40 + a50;\n+        float a51 = a50 + a60;\n+        float a61 = a60 + a70;\n+\n+        float a22 = a21 + a31;\n+\n+        float a23 = a22*A1;\n+        float mul5 = (a61 - neg_a41)*A5;\n+        float a43 = neg_a41*A2 - mul5;\n+        float a53 = a51*A3;\n+        float a63 = a61*A4 - mul5;\n+\n+        float a54 = a70 + a53;\n+        float a74 = a70 - a53;\n+\n+        vector[0] = a01 + a11;\n+        vector[4] = a01 - a11;\n+        vector[2] = a31 + a23;\n+        vector[6] = a31 - a23;\n+        vector[5] = a74 + a43;\n+        vector[1] = a54 + a63;\n+        vector[7] = a54 - a63;\n+        vector[3] = a74 - a43;\n+    }\n+\n+    public static void forwardDCT8x8(float[] matrix)\n+    {\n+        float a00, a10, a20, a30, a40, a50, a60, a70;\n+        float a01, a11, a21, a31, neg_a41, a51, a61;\n+        float a22, a23, mul5, a43, a53, a63;\n+        float a54, a74;\n+\n+        for (int i = 0; i < 8; i++)\n+        {\n+            a00 = matrix[8*i] + matrix[8*i + 7];\n+            a10 = matrix[8*i + 1] + matrix[8*i + 6];\n+            a20 = matrix[8*i + 2] + matrix[8*i + 5];\n+            a30 = matrix[8*i + 3] + matrix[8*i + 4];\n+            a40 = matrix[8*i + 3] - matrix[8*i + 4];\n+            a50 = matrix[8*i + 2] - matrix[8*i + 5];\n+            a60 = matrix[8*i + 1] - matrix[8*i + 6];\n+            a70 = matrix[8*i] - matrix[8*i + 7];\n+            a01 = a00 + a30;\n+            a11 = a10 + a20;\n+            a21 = a10 - a20;\n+            a31 = a00 - a30;\n+            neg_a41 = a40 + a50;\n+            a51 = a50 + a60;\n+            a61 = a60 + a70;\n+            a22 = a21 + a31;\n+            a23 = a22*A1;\n+            mul5 = (a61 - neg_a41)*A5;\n+            a43 = neg_a41*A2 - mul5;\n+            a53 = a51*A3;\n+            a63 = a61*A4 - mul5;\n+            a54 = a70 + a53;\n+            a74 = a70 - a53;\n+            matrix[8*i] = a01 + a11;\n+            matrix[8*i + 4] = a01 - a11;\n+            matrix[8*i + 2] = a31 + a23;\n+            matrix[8*i + 6] = a31 - a23;\n+            matrix[8*i + 5] = a74 + a43;\n+            matrix[8*i + 1] = a54 + a63;\n+            matrix[8*i + 7] = a54 - a63;\n+            matrix[8*i + 3] = a74 - a43;\n+        }\n+\n+        for (int i = 0; i < 8; i++)\n+        {\n+            a00 = matrix[i] + matrix[56 + i];\n+            a10 = matrix[8 + i] + matrix[48 + i];\n+            a20 = matrix[16 + i] + matrix[40 + i];\n+            a30 = matrix[24 + i] + matrix[32 + i];\n+            a40 = matrix[24 + i] - matrix[32 + i];\n+            a50 = matrix[16 + i] - matrix[40 + i];\n+            a60 = matrix[8 + i] - matrix[48 + i];\n+            a70 = matrix[i] - matrix[56 + i];\n+            a01 = a00 + a30;\n+            a11 = a10 + a20;\n+            a21 = a10 - a20;\n+            a31 = a00 - a30;\n+            neg_a41 = a40 + a50;\n+            a51 = a50 + a60;\n+            a61 = a60 + a70;\n+            a22 = a21 + a31;\n+            a23 = a22*A1;\n+            mul5 = (a61 - neg_a41)*A5;\n+            a43 = neg_a41*A2 - mul5;\n+            a53 = a51*A3;\n+            a63 = a61*A4 - mul5;\n+            a54 = a70 + a53;\n+            a74 = a70 - a53;\n+            matrix[i] = a01 + a11;\n+            matrix[32 + i] = a01 - a11;\n+            matrix[16 + i] = a31 + a23;\n+            matrix[48 + i] = a31 - a23;\n+            matrix[40 + i] = a74 + a43;\n+            matrix[8 + i] = a54 + a63;\n+            matrix[56 + i] = a54 - a63;\n+            matrix[24 + i] = a74 - a43;\n+        }\n+    }\n+\n+    /**\n+     * Fast inverse DCT using AA&N. This is taken from the beautiful\n+     * http://vsr.informatik.tu-chemnitz.de/~jan/MPEG/HTML/IDCT.html\n+     * which gives easy equations and properly explains constants and\n+     * scaling factors. Terms have been inlined and the negation\n+     * optimized out of existence.\n+     */\n+    public static void inverseDCT8(float[] vector)\n+    {\n+        // B1\n+        float a2 = vector[2] - vector[6];\n+        float a3 = vector[2] + vector[6];\n+        float a4 = vector[5] - vector[3];\n+        float tmp1 = vector[1] + vector[7];\n+        float tmp2 = vector[3] + vector[5];\n+        float a5 = tmp1 - tmp2;\n+        float a6 = vector[1] - vector[7];\n+        float a7 = tmp1 + tmp2;\n+\n+        // M\n+        float tmp4 = C6*(a4 + a6);\n+        // Eliminate the negative:\n+        // float b4 = -Q*a4 - tmp4;\n+        float neg_b4 = Q*a4 + tmp4;\n+        float b6 = R*a6 - tmp4;\n+        float b2 = a2*C4;\n+        float b5 = a5*C4;\n+\n+        // A1\n+        float tmp3 = b6 - a7;\n+        float n0 = tmp3 - b5;\n+        float n1 = vector[0] - vector[4];\n+        float n2 = b2 - a3;\n+        float n3 = vector[0] + vector[4];\n+        float neg_n5 = neg_b4;\n+\n+        // A2\n+        float m3 = n1 + n2;\n+        float m4 = n3 + a3;\n+        float m5 = n1 - n2;\n+        float m6 = n3 - a3;\n+        // float m7 = n5 - n0;\n+        float neg_m7 = neg_n5 + n0;\n+\n+        // A3\n+        vector[0] = m4 + a7;\n+        vector[1] = m3 + tmp3;\n+        vector[2] = m5 - n0;\n+        vector[3] = m6 + neg_m7;\n+        vector[4] = m6 - neg_m7;\n+        vector[5] = m5 + n0;\n+        vector[6] = m3 - tmp3;\n+        vector[7] = m4 - a7;\n+    }\n+\n+    public static void inverseDCT8x8(float[] matrix)\n+    {\n+        float a2, a3, a4, tmp1, tmp2, a5, a6, a7;\n+        float tmp4, neg_b4, b6, b2, b5;\n+        float tmp3, n0, n1, n2, n3, neg_n5;\n+        float m3, m4, m5, m6, neg_m7;\n+\n+        for (int i = 0; i < 8; i++)\n+        {\n+            a2 = matrix[8*i + 2] - matrix[8*i + 6];\n+            a3 = matrix[8*i + 2] + matrix[8*i + 6];\n+            a4 = matrix[8*i + 5] - matrix[8*i + 3];\n+            tmp1 = matrix[8*i + 1] + matrix[8*i + 7];\n+            tmp2 = matrix[8*i + 3] + matrix[8*i + 5];\n+            a5 = tmp1 - tmp2;\n+            a6 = matrix[8*i + 1] - matrix[8*i + 7];\n+            a7 = tmp1 + tmp2;\n+            tmp4 = C6*(a4 + a6);\n+            neg_b4 = Q*a4 + tmp4;\n+            b6 = R*a6 - tmp4;\n+            b2 = a2*C4;\n+            b5 = a5*C4;\n+            tmp3 = b6 - a7;\n+            n0 = tmp3 - b5;\n+            n1 = matrix[8*i] - matrix[8*i + 4];\n+            n2 = b2 - a3;\n+            n3 = matrix[8*i] + matrix[8*i + 4];\n+            neg_n5 = neg_b4;\n+            m3 = n1 + n2;\n+            m4 = n3 + a3;\n+            m5 = n1 - n2;\n+            m6 = n3 - a3;\n+            neg_m7 = neg_n5 + n0;\n+            matrix[8*i] = m4 + a7;\n+            matrix[8*i + 1] = m3 + tmp3;\n+            matrix[8*i + 2] = m5 - n0;\n+            matrix[8*i + 3] = m6 + neg_m7;\n+            matrix[8*i + 4] = m6 - neg_m7;\n+            matrix[8*i + 5] = m5 + n0;\n+            matrix[8*i + 6] = m3 - tmp3;\n+            matrix[8*i + 7] = m4 - a7;\n+        }\n+\n+        for (int i = 0; i < 8; i++)\n+        {\n+            a2 = matrix[16 + i] - matrix[48 + i];\n+            a3 = matrix[16 + i] + matrix[48 + i];\n+            a4 = matrix[40 + i] - matrix[24 + i];\n+            tmp1 = matrix[8 + i] + matrix[56 + i];\n+            tmp2 = matrix[24 + i] + matrix[40 + i];\n+            a5 = tmp1 - tmp2;\n+            a6 = matrix[8 + i] - matrix[56 + i];\n+            a7 = tmp1 + tmp2;\n+            tmp4 = C6*(a4 + a6);\n+            neg_b4 = Q*a4 + tmp4;\n+            b6 = R*a6 - tmp4;\n+            b2 = a2*C4;\n+            b5 = a5*C4;\n+            tmp3 = b6 - a7;\n+            n0 = tmp3 - b5;\n+            n1 = matrix[i] - matrix[32 + i];\n+            n2 = b2 - a3;\n+            n3 = matrix[i] + matrix[32 + i];\n+            neg_n5 = neg_b4;\n+            m3 = n1 + n2;\n+            m4 = n3 + a3;\n+            m5 = n1 - n2;\n+            m6 = n3 - a3;\n+            neg_m7 = neg_n5 + n0;\n+            matrix[i] = m4 + a7;\n+            matrix[8 + i] = m3 + tmp3;\n+            matrix[16 + i] = m5 - n0;\n+            matrix[24 + i] = m6 + neg_m7;\n+            matrix[32 + i] = m6 - neg_m7;\n+            matrix[40 + i] = m5 + n0;\n+            matrix[48 + i] = m3 - tmp3;\n+            matrix[56 + i] = m4 - a7;\n+        }\n+    }\n+\n+    private static float[][] REFERENCE_inverseDCT(float[][] matrix)\n+    {\n+        float[][] ret = new float[8][8];\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+            {\n+                float sum = 0;\n+                for (int u = 0; u < 8; u++)\n+                {\n+                    for (int v = 0; v < 8; v++)\n+                    {\n+                        float cu = (u == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+                        float cv = (v == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+                        sum += cu*cv*matrix[v][u]*\n+                                Math.cos((2*x + 1)*u*Math.PI/16)*\n+                                Math.cos((2*y + 1)*v*Math.PI/16);\n+                    }\n+                }\n+                ret[y][x] = 0.25f * sum;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private static float[] REFERENCE_inverseDCT(float[] vector)\n+    {\n+        float[] ret = new float[8];\n+        for (int x = 0; x < 8; x++)\n+        {\n+            float sum = 0;\n+            for (int u = 0; u < 8; u++)\n+            {\n+                float cu = (u == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+                sum += cu*vector[u]*\n+                        Math.cos((2*x + 1)*u*Math.PI/16);\n+            }\n+            ret[x] = 0.5f * sum;\n+        }\n+        return ret;\n+    }\n+\n+    private static float[][] REFERENCE_forwardDCT(float[][] matrix)\n+    {\n+        float[][] ret = new float[8][8];\n+        for (int u = 0; u < 8; u++)\n+        {\n+            for (int v = 0; v < 8; v++)\n+            {\n+                float sum = 0;\n+                float cu = (u == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+                float cv = (v == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+                for (int x = 0; x < 8; x++)\n+                {\n+                    for (int y = 0; y < 8; y++)\n+                    {\n+                        sum += matrix[y][x] *\n+                                Math.cos((2*x + 1)*u*Math.PI/16) *\n+                                Math.cos((2*y + 1)*v*Math.PI/16);\n+                    }\n+                }\n+                ret[v][u] = 0.25f * cu * cv * sum;\n+            }\n+        }\n+        return ret;\n+    }\n+\n+    private static float[] REFERENCE_forwardDCT(float[] vector)\n+    {\n+        float[] ret = new float[8];\n+        for (int u = 0; u < 8; u++)\n+        {\n+            float sum = 0;\n+            float cu = (u == 0) ? ((float)(1.0/Math.sqrt(2))) : 1;\n+            for (int x = 0; x < 8; x++)\n+            {\n+                sum += vector[x]*\n+                        Math.cos((2*x + 1)*u*Math.PI/16);\n+            }\n+            ret[u] = 0.5f * cu * sum;\n+        }\n+        return ret;\n+    }\n+\n+    private static boolean isClose(float a, float b)\n+    {\n+        return Math.abs(a - b) < 0.001;\n+    }\n+\n+    private static void testVectors() throws Exception\n+    {\n+        float[] originalData = new float[8];\n+        for (int i = 0; i < 8; i++)\n+            originalData[i] = i;\n+\n+        float[] transformed = REFERENCE_forwardDCT(originalData);\n+        float[] reversed = REFERENCE_inverseDCT(transformed);\n+        for (int i = 0; i < 8; i++)\n+        {\n+            if (!isClose(originalData[i], reversed[i]))\n+            {\n+                throw new Exception(\"Reference transforms broken, \" +\n+                        \"at x=\" + i + \", \" +\n+                        \"original \" + originalData[i] + \" \" +\n+                        \"actual \" + reversed[i]);\n+            }\n+        }\n+\n+        float[] data = (float[]) originalData.clone();\n+        forwardDCT8(data);\n+        scaleQuantizationVector(data);\n+        for (int i = 0; i < 8; i++)\n+        {\n+            if (!isClose(data[i], transformed[i]))\n+            {\n+                throw new Exception(\"Forward transform broken, \" +\n+                        \"at x=\" + i + \" \" +\n+                        \"reference \" + originalData[i] + \", \" +\n+                        \"actual \" + data[i]);\n+            }\n+        }\n+        scaleDequantizationVector(data);\n+        inverseDCT8(data);\n+        for (int i = 0; i < 8; i++)\n+        {\n+            if (!isClose(data[i], originalData[i]))\n+            {\n+                throw new Exception(\"Inverse transform broken, \" +\n+                        \"at x=\" + i + \" \" +\n+                        \"reference \" + originalData[i] + \", \" +\n+                        \"actual \" + data[i]);\n+            }\n+        }\n+    }\n+\n+    private static void testMatrices() throws Exception\n+    {\n+        float[] originalData = new float[8*8];\n+        float[][] originalData8x8 = new float[8][8];\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+            {\n+                float value = 8*y + x;\n+                originalData8x8[y][x] = value;\n+                originalData[8*y + x] = value;\n+            }\n+        }\n+\n+        float[][] transformed8x8 = REFERENCE_forwardDCT(originalData8x8);\n+        float[][] reversed8x8 = REFERENCE_inverseDCT(transformed8x8);\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+            {\n+                if (!isClose(originalData8x8[y][x], reversed8x8[y][x]))\n+                {\n+                    throw new Exception(\"Reference transforms broken, \" +\n+                            \"at x=\" + x + \",y=\" + y + \" \" +\n+                            \"original \" + originalData8x8[y][x] + \", \" +\n+                            \"actual \" + reversed8x8[y][x]);\n+                }\n+            }\n+        }\n+\n+        float[] data = (float[]) originalData.clone();\n+        forwardDCT8x8(data);\n+        scaleQuantizationMatrix(data);\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+            {\n+                if (!isClose(transformed8x8[y][x], data[8*y + x]))\n+                {\n+                    throw new Exception(\"Forward transform broken, \" +\n+                            \"at x=\" + x + \",y=\" + y + \" \" +\n+                            \"reference \" + originalData8x8[y][x] + \", \" +\n+                            \"actual \" + data[8*y  + x]);\n+                }\n+            }\n+        }\n+        scaleDequantizationMatrix(data);\n+        inverseDCT8x8(data);\n+        for (int y = 0; y < 8; y++)\n+        {\n+            for (int x = 0; x < 8; x++)\n+            {\n+                if (!isClose(originalData8x8[y][x], data[8*y + x]))\n+                {\n+                    throw new Exception(\"Inverse transform broken, \" +\n+                            \"at x=\" + x + \",y=\" + y + \" \" +\n+                            \"reference \" + originalData8x8[y][x] + \", \" +\n+                            \"actual \" + data[8*y  + x]);\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "6f1097fe823189ce264cb6e07757564c221f4dd7",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/decoder/JpegDecoder.java",
            "status": "added",
            "additions": 485,
            "deletions": 0,
            "changes": 485,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegDecoder.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegDecoder.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegDecoder.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,485 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.decoder;\n+\n+import java.awt.image.BufferedImage;\n+import java.awt.image.ColorModel;\n+import java.awt.image.DataBuffer;\n+import java.awt.image.DirectColorModel;\n+import java.awt.image.WritableRaster;\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import org.apache.sanselan.ImageReadException;\n+import org.apache.sanselan.common.BinaryFileParser;\n+import org.apache.sanselan.common.byteSources.ByteSource;\n+import org.apache.sanselan.formats.jpeg.Block;\n+import org.apache.sanselan.formats.jpeg.JpegConstants;\n+import org.apache.sanselan.formats.jpeg.JpegUtils;\n+import org.apache.sanselan.formats.jpeg.ZigZag;\n+import org.apache.sanselan.formats.jpeg.segments.DHTSegment;\n+import org.apache.sanselan.formats.jpeg.segments.DQTSegment;\n+import org.apache.sanselan.formats.jpeg.segments.SOFNSegment;\n+import org.apache.sanselan.formats.jpeg.segments.SOSSegment;\n+\n+public class JpegDecoder extends BinaryFileParser implements JpegUtils.Visitor,\n+        JpegConstants\n+{\n+    /*\n+     * JPEG is an advanced image format that takes\n+     * significant computation to decode. Keep\n+     * decoding fast:\n+     * - Don't allocate memory inside loops,\n+     *   allocate it once and reuse.\n+     * - Minimize calculations\n+     *   per pixel and per block (using lookup tables\n+     *   for YCbCr->RGB conversion doubled performance).\n+     * - Math.round() is slow, use (int)(x+0.5f) instead\n+     *   for positive numbers.\n+     */\n+\n+    private DQTSegment.QuantizationTable[] quantizationTables = new DQTSegment.QuantizationTable[4];\n+    private DHTSegment.HuffmanTable[] huffmanDCTables = new DHTSegment.HuffmanTable[4];\n+    private DHTSegment.HuffmanTable[] huffmanACTables = new DHTSegment.HuffmanTable[4];\n+    private SOFNSegment sofnSegment;\n+    private SOSSegment sosSegment;\n+    private float[][] scaledQuantizationTables = new float[4][];\n+    private BufferedImage image = null;\n+    private ImageReadException imageReadException = null;\n+    private IOException ioException = null;\n+\n+    public boolean beginSOS()\n+    {\n+        return true;\n+    }\n+\n+    public void visitSOS(int marker, byte markerBytes[],\n+                    byte imageData[])\n+    {\n+        ByteArrayInputStream is = new ByteArrayInputStream(imageData);\n+        try\n+        {\n+            int segmentLength = read2Bytes(\"segmentLength\", is,\n+                    \"Not a Valid JPEG File\");\n+            byte[] sosSegmentBytes = readByteArray(\"SOSSegment\",\n+                    segmentLength - 2, is, \"Not a Valid JPEG File\");\n+            sosSegment = new SOSSegment(marker, sosSegmentBytes);\n+\n+            int hMax = 0;\n+            int vMax = 0;\n+            for (int i = 0; i < sofnSegment.numberOfComponents; i++)\n+            {\n+                hMax = Math.max(hMax, sofnSegment.components[i].horizontalSamplingFactor);\n+                vMax = Math.max(vMax, sofnSegment.components[i].verticalSamplingFactor);\n+            }\n+            int hSize = 8*hMax;\n+            int vSize = 8*vMax;\n+\n+            JpegInputStream bitInputStream = new JpegInputStream(is);\n+            int xMCUs = (sofnSegment.width + hSize - 1) / hSize;\n+            int yMCUs = (sofnSegment.height + vSize - 1) / vSize;\n+            Block[] mcu = allocateMCUMemory();\n+            Block[] scaledMCU = new Block[mcu.length];\n+            for (int i = 0; i < scaledMCU.length; i++)\n+                scaledMCU[i] = new Block(hSize, vSize);\n+            int[] preds = new int[sofnSegment.numberOfComponents];\n+            ColorModel colorModel;\n+            WritableRaster raster;\n+            if (sofnSegment.numberOfComponents == 3)\n+            {\n+                colorModel = new DirectColorModel(24,\n+                        0x00ff0000, 0x0000ff00, 0x000000ff);\n+                raster = WritableRaster.createPackedRaster(DataBuffer.TYPE_INT,\n+                        sofnSegment.width, sofnSegment.height,\n+                        new int[]{0x00ff0000,0x0000ff00,0x000000ff}, null);\n+            }\n+            else if (sofnSegment.numberOfComponents == 1)\n+            {\n+                colorModel = new DirectColorModel(24,\n+                        0x00ff0000, 0x0000ff00, 0x000000ff);\n+                raster = WritableRaster.createPackedRaster(DataBuffer.TYPE_INT,\n+                        sofnSegment.width, sofnSegment.height,\n+                        new int[]{0x00ff0000,0x0000ff00,0x000000ff}, null);\n+                // FIXME: why do images come out too bright with CS_GRAY?\n+//                colorModel = new ComponentColorModel(\n+//                        ColorSpace.getInstance(ColorSpace.CS_GRAY), false, true,\n+//                        Transparency.OPAQUE, DataBuffer.TYPE_BYTE);\n+//                raster = colorModel.createCompatibleWritableRaster(\n+//                        sofnSegment.width, sofnSegment.height);\n+            }\n+            else\n+                throw new ImageReadException(sofnSegment.numberOfComponents +\n+                        \" components are invalid or unsupported\");\n+            DataBuffer dataBuffer = raster.getDataBuffer();\n+\n+            \n+            for (int y1 = 0; y1 < vSize*yMCUs; y1 += vSize)\n+            {\n+                for (int x1 = 0; x1 < hSize*xMCUs; x1 += hSize)\n+                {\n+                    readMCU(bitInputStream, preds, mcu);\n+                    rescaleMCU(mcu, hSize, vSize, scaledMCU);\n+                    int srcRowOffset = 0;\n+                    int dstRowOffset = y1*sofnSegment.width + x1;\n+                    for (int y2 = 0; y2 < vSize && y1 + y2 < sofnSegment.height; y2++)\n+                    {\n+                        for (int x2 = 0; x2 < hSize && x1 + x2 < sofnSegment.width; x2++)\n+                        {\n+                            if (scaledMCU.length == 3)\n+                            {\n+                                int Y = scaledMCU[0].samples[srcRowOffset + x2];\n+                                int Cb = scaledMCU[1].samples[srcRowOffset + x2];\n+                                int Cr = scaledMCU[2].samples[srcRowOffset + x2];\n+                                int rgb = YCbCrConverter.convertYCbCrToRGB(Y, Cb, Cr);\n+                                dataBuffer.setElem(dstRowOffset + x2, rgb);\n+                            }\n+                            else if (mcu.length == 1)\n+                            {\n+                                int Y = scaledMCU[0].samples[srcRowOffset + x2];\n+                                dataBuffer.setElem(dstRowOffset + x2,\n+                                        (Y << 16) | (Y << 8) | Y);\n+                            }\n+                            else\n+                                throw new ImageReadException(\"Unsupported JPEG with \" +\n+                                        mcu.length + \" components\");\n+                        }\n+                        srcRowOffset += hSize;\n+                        dstRowOffset += sofnSegment.width;\n+                    }\n+                }\n+            }\n+            image = new BufferedImage(colorModel, raster,\n+                    colorModel.isAlphaPremultiplied(), new Properties());\n+            //byte[] remainder = super.getStreamBytes(is);\n+            //for (int i = 0; i < remainder.length; i++)\n+            //{\n+            //    System.out.println(\"\" + i + \" = \" + Integer.toHexString(remainder[i]));\n+            //}\n+        }\n+        catch (ImageReadException imageReadEx)\n+        {\n+            imageReadException = imageReadEx;\n+        }\n+        catch (IOException ioEx)\n+        {\n+            ioException = ioEx;\n+        }\n+        catch (RuntimeException ex)\n+        {\n+            // Corrupt images can throw NPE and IOOBE\n+            imageReadException = new ImageReadException(\"Error parsing JPEG\", ex);\n+        }\n+    }\n+\n+    public boolean visitSegment(int marker, byte[] markerBytes,\n+            int segmentLength, byte[] segmentLengthBytes,\n+            byte[] segmentData) throws ImageReadException, IOException\n+    {\n+        final int[] sofnSegments = {\n+            SOF0Marker,\n+            SOF1Marker, SOF2Marker, SOF3Marker, SOF5Marker, SOF6Marker,\n+            SOF7Marker, SOF9Marker, SOF10Marker, SOF11Marker, SOF13Marker,\n+            SOF14Marker, SOF15Marker,\n+        };\n+\n+        if (Arrays.binarySearch(sofnSegments, marker) >= 0)\n+        {\n+            if (marker != SOF0Marker)\n+                throw new ImageReadException(\"Only sequential, baseline JPEGs \" +\n+                        \"are supported at the moment\");\n+            sofnSegment = new SOFNSegment(marker, segmentData);\n+        }\n+        else if (marker == DQTMarker)\n+        {\n+            DQTSegment dqtSegment = new DQTSegment(marker, segmentData);\n+            for (int i = 0; i < dqtSegment.quantizationTables.size(); i++)\n+            {\n+                DQTSegment.QuantizationTable table = (DQTSegment.QuantizationTable)\n+                        dqtSegment.quantizationTables.get(i);\n+                if (0 > table.destinationIdentifier ||\n+                        table.destinationIdentifier >= quantizationTables.length)\n+                    throw new ImageReadException(\"Invalid quantization table identifier \" +\n+                            table.destinationIdentifier);\n+                quantizationTables[table.destinationIdentifier] = table;\n+                int[] quantizationMatrixInt = new int[64];\n+                ZigZag.zigZagToBlock(table.elements, quantizationMatrixInt);\n+                float[] quantizationMatrixFloat = new float[64];\n+                for (int j = 0; j < 64; j++)\n+                    quantizationMatrixFloat[j] = quantizationMatrixInt[j];\n+                DCT.scaleDequantizationMatrix(quantizationMatrixFloat);\n+                scaledQuantizationTables[table.destinationIdentifier] =\n+                        quantizationMatrixFloat;\n+            }\n+        }\n+        else if (marker == DHTMarker)\n+        {\n+            DHTSegment dhtSegment = new DHTSegment(marker, segmentData);\n+            for (int i = 0; i < dhtSegment.huffmanTables.size(); i++)\n+            {\n+                DHTSegment.HuffmanTable table = (DHTSegment.HuffmanTable)\n+                        dhtSegment.huffmanTables.get(i);\n+                DHTSegment.HuffmanTable[] tables;\n+                if (table.tableClass == 0)\n+                    tables = huffmanDCTables;\n+                else if (table.tableClass == 1)\n+                    tables = huffmanACTables;\n+                else\n+                    throw new ImageReadException(\"Invalid huffman table class \" +\n+                            table.tableClass);\n+                if (0 > table.destinationIdentifier ||\n+                        table.destinationIdentifier >= tables.length)\n+                    throw new ImageReadException(\"Invalid huffman table identifier \" +\n+                            table.destinationIdentifier);\n+                tables[table.destinationIdentifier] = table;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    private void rescaleMCU(Block[] dataUnits, int hSize, int vSize, Block[] ret)\n+    {\n+        for (int i = 0; i < dataUnits.length; i++)\n+        {\n+            Block block = dataUnits[i];\n+            if (block.width == hSize && block.height == vSize)\n+                System.arraycopy(block.samples, 0, ret[i].samples, 0, hSize*vSize);\n+            else\n+            {\n+                int hScale = hSize / block.width;\n+                int vScale = vSize / block.height;\n+                if (hScale == 2 && vScale == 2)\n+                {\n+                    int srcRowOffset = 0;\n+                    int dstRowOffset = 0;\n+                    for (int y = 0; y < block.height; y++)\n+                    {\n+                        for (int x = 0; x < hSize; x++)\n+                        {\n+                            int sample = block.samples[srcRowOffset + (x >> 1)];\n+                            ret[i].samples[dstRowOffset + x] = sample;\n+                            ret[i].samples[dstRowOffset + hSize + x] = sample;\n+                        }\n+                        srcRowOffset += block.width;\n+                        dstRowOffset += 2*hSize;\n+                    }\n+                }\n+                else\n+                {\n+                    // FIXME: optimize\n+                    int dstRowOffset = 0;\n+                    for (int y = 0; y < vSize; y++)\n+                    {\n+                        for (int x = 0; x < hSize; x++)\n+                        {\n+                            ret[i].samples[dstRowOffset + x] =\n+                                    block.samples[(y/vScale)*block.width + (x/hScale)];\n+                        }\n+                        dstRowOffset += hSize;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Block[] allocateMCUMemory() throws ImageReadException\n+    {\n+        Block[] mcu = new Block[sosSegment.numberOfComponents];\n+        for (int i = 0; i < sosSegment.numberOfComponents; i++)\n+        {\n+            SOSSegment.Component scanComponent = sosSegment.components[i];\n+            SOFNSegment.Component frameComponent = null;\n+            for (int j = 0; j < sofnSegment.numberOfComponents; j++)\n+            {\n+                if (sofnSegment.components[j].componentIdentifier ==\n+                    scanComponent.scanComponentSelector)\n+                {\n+                    frameComponent = sofnSegment.components[j];\n+                    break;\n+                }\n+            }\n+            if (frameComponent == null)\n+                throw new ImageReadException(\"Invalid component\");\n+            Block fullBlock = new Block(\n+                    8*frameComponent.horizontalSamplingFactor,\n+                    8*frameComponent.verticalSamplingFactor);\n+            mcu[i] = fullBlock;\n+        }\n+        return mcu;\n+    }\n+\n+    private int[] zz = new int[64];\n+    private int[] blockInt = new int[64];\n+    private float[] block = new float[64];\n+    private void readMCU(JpegInputStream is, int[] preds, Block[] mcu)\n+            throws IOException, ImageReadException\n+    {\n+        for (int i = 0; i < sosSegment.numberOfComponents; i++)\n+        {\n+            SOSSegment.Component scanComponent = sosSegment.components[i];\n+            SOFNSegment.Component frameComponent = null;\n+            for (int j = 0; j < sofnSegment.numberOfComponents; j++)\n+            {\n+                if (sofnSegment.components[j].componentIdentifier ==\n+                    scanComponent.scanComponentSelector)\n+                {\n+                    frameComponent = sofnSegment.components[j];\n+                    break;\n+                }\n+            }\n+            if (frameComponent == null)\n+                throw new ImageReadException(\"Invalid component\");\n+            Block fullBlock = mcu[i];\n+            for (int y = 0; y < frameComponent.verticalSamplingFactor; y++)\n+            {\n+                for (int x = 0; x < frameComponent.horizontalSamplingFactor; x++)\n+                {\n+                    Arrays.fill(zz, 0);\n+                    // page 104 of T.81\n+                    int t = decode(is,\n+                            huffmanDCTables[scanComponent.dcCodingTableSelector]);\n+                    int diff = receive(t, is);\n+                    diff = extend(diff, t);\n+                    zz[0] = preds[i] + diff;\n+                    preds[i] = zz[0];\n+\n+                    // \"Decode_AC_coefficients\", figure F.13, page 106 of T.81\n+                    int k = 1;\n+                    while (true)\n+                    {\n+                        int rs = decode(is,\n+                                huffmanACTables[scanComponent.acCodingTableSelector]);\n+                        int ssss = rs & 0xf;\n+                        int rrrr = rs >> 4;\n+                        int r = rrrr;\n+\n+                        if (ssss == 0)\n+                        {\n+                            if (r == 15)\n+                                k += 16;\n+                            else\n+                                break;\n+                        }\n+                        else\n+                        {\n+                            k += r;\n+\n+                            // \"Decode_ZZ(k)\", figure F.14, page 107 of T.81\n+                            zz[k] = receive(ssss, is);\n+                            zz[k] = extend(zz[k], ssss);\n+\n+                            if (k == 63)\n+                                break;\n+                            else\n+                                k++;\n+                        }\n+                    }\n+\n+                    final int shift = (1 << (sofnSegment.precision - 1));\n+                    final int max = (1 << sofnSegment.precision) - 1;\n+\n+                    float[] scaledQuantizationTable =\n+                            scaledQuantizationTables[frameComponent.quantTabDestSelector];\n+                    ZigZag.zigZagToBlock(zz, blockInt);\n+                    for (int j = 0; j < 64; j++)\n+                        block[j] = blockInt[j] * scaledQuantizationTable[j];\n+                    DCT.inverseDCT8x8(block);\n+\n+                    int dstRowOffset = 8*y*8*frameComponent.horizontalSamplingFactor +\n+                            8*x;\n+                    int srcNext = 0;\n+                    for (int yy = 0; yy < 8; yy++)\n+                    {\n+                        for (int xx = 0; xx < 8; xx++)\n+                        {\n+                            float sample = block[srcNext++];\n+                            sample += shift;\n+                            int result;\n+                            if (sample < 0)\n+                                result = 0;\n+                            else if (sample > max)\n+                                result = max;\n+                            else\n+                                result = fastRound(sample);\n+                            fullBlock.samples[dstRowOffset + xx] = result;\n+                        }\n+                        dstRowOffset += 8*frameComponent.horizontalSamplingFactor;\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static int fastRound(float x)\n+    {\n+        return (int) (x + 0.5f);\n+    }\n+\n+    private int extend(int v, int t)\n+    {\n+        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n+        int vt = (1 << (t - 1));\n+        while (v < vt)\n+        {\n+            vt = (-1 << t) + 1;\n+            v += vt;\n+        }\n+        return v;\n+    }\n+\n+    private int receive(int ssss, JpegInputStream is)\n+            throws IOException, ImageReadException\n+    {\n+        // \"RECEIVE\", section F.2.2.4, figure F.17, page 110 of T.81\n+        int i = 0;\n+        int v = 0;\n+        while (i != ssss)\n+        {\n+            i++;\n+            v = (v << 1) + is.nextBit();\n+        }\n+        return v;\n+    }\n+\n+    private int decode(JpegInputStream is, DHTSegment.HuffmanTable huffmanTable)\n+            throws IOException, ImageReadException\n+    {\n+        // \"DECODE\", section F.2.2.3, figure F.16, page 109 of T.81\n+        int i = 1;\n+        int code = is.nextBit();\n+        while (code > huffmanTable.maxCode[i])\n+        {\n+            i++;\n+            code = (code << 1) | is.nextBit();\n+        }\n+        int j = huffmanTable.valPtr[i];\n+        j += code - huffmanTable.minCode[i];\n+        int value = huffmanTable.huffVal[j];\n+        return value;\n+    }\n+\n+    public BufferedImage decode(ByteSource byteSource)\n+            throws IOException, ImageReadException\n+    {\n+        JpegUtils jpegUtils = new JpegUtils();\n+        jpegUtils.traverseJFIF(byteSource, this);\n+        if (imageReadException != null)\n+            throw imageReadException;\n+        if (ioException != null)\n+            throw ioException;\n+        return image;\n+    }\n+}"
        },
        {
            "sha": "8b0f4c8a07e7bcdaa22cf0498a2ce4ff53b45013",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/decoder/JpegInputStream.java",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegInputStream.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegInputStream.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FJpegInputStream.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,64 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.decoder;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import org.apache.sanselan.ImageReadException;\n+import org.apache.sanselan.formats.jpeg.JpegConstants;\n+\n+public class JpegInputStream\n+{\n+    // Figure F.18, F.2.2.5, page 111 of ITU-T T.81\n+    private final InputStream is;\n+    private int cnt = 0;\n+    private int b;\n+\n+    public JpegInputStream(InputStream is)\n+    {\n+        this.is = is;\n+    }\n+\n+    public int nextBit()\n+            throws IOException, ImageReadException\n+    {\n+        if (cnt == 0)\n+        {\n+            b = is.read();\n+            if (b < 0)\n+                throw new ImageReadException(\"Premature End of File\");\n+            cnt = 8;\n+            if (b == 0xff)\n+            {\n+                int b2 = is.read();\n+                if (b2 < 0)\n+                    throw new ImageReadException(\"Premature End of File\");\n+                if (b2 != 0)\n+                {\n+                    if (b2 == (0xff & JpegConstants.DNLMarker))\n+                        throw new ImageReadException(\"DNL not yet supported\");\n+                    else\n+                        throw new ImageReadException(\"Invalid marker found \" +\n+                                \"in entropy data\");\n+                }\n+            }\n+        }\n+        int bit = (b >> 7) & 0x1;\n+        cnt--;\n+        b <<= 1;\n+        return bit;\n+    }\n+}"
        },
        {
            "sha": "3805ecdee5134ed861033333f210156655e2e3c4",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/decoder/YCbCrConverter.java",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FYCbCrConverter.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FYCbCrConverter.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fdecoder%2FYCbCrConverter.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,118 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.decoder;\n+\n+public class YCbCrConverter\n+{\n+    private static final int[] reds = new int[256*256];\n+    private static final int[] blues = new int[256*256];\n+    private static final int[] greens1 = new int[256*256];\n+    private static final int[] greens2 = new int[256*512];\n+    \n+    static\n+    {\n+        /*\n+         * Why use (Cr << 8) | Y\n+         * and not (Y << 8) | Cr as the index?\n+         * Y changes often, while Cb and Cr is usually subsampled\n+         * less often and repeats itself between adjacent pixels,\n+         * so using it as the high order byte gives\n+         * higher locality of reference.\n+         */\n+        for (int Y = 0; Y < 256; Y++)\n+        {\n+            for (int Cr = 0; Cr < 256; Cr++)\n+            {\n+                int r = Y + fastRound(1.402f*(Cr-128));\n+                if (r < 0) r = 0;\n+                if (r > 255) r = 255;\n+                reds[(Cr << 8) | Y] = r << 16;\n+            }\n+        }\n+        for (int Y = 0; Y < 256; Y++)\n+        {\n+            for (int Cb = 0; Cb < 256; Cb++)\n+            {\n+                int b = Y + fastRound(1.772f*(Cb-128));\n+                if (b < 0) b = 0;\n+                if (b > 255) b = 255;\n+                blues[(Cb << 8) | Y] = b;\n+            }\n+        }\n+        // green is the hardest\n+        // Math.round((float)(Y - 0.34414*(Cb-128) - 0.71414*(Cr-128)))\n+        // but Y is integral\n+        // = Y - Math.round((float)(0.34414*(Cb-128) + 0.71414*(Cr-128)))\n+        // = Y - Math.round(f(Cb, Cr))\n+        // where\n+        // f(Cb, Cr) = 0.34414*(Cb-128) + 0.71414*(Cr-128)\n+        // Cb and Cr terms each vary from 255-128 = 127 to 0-128 = -128\n+        // Linear function, so only examine endpoints:\n+        // Cb term   Cr term   Result\n+        // 127       127       134.4\n+        // -128      -128      -135.4\n+        // 127       -128      -47.7\n+        // -128      127       46.6\n+        // Thus with -135 being the minimum and 134 the maximum,\n+        // there is a range of 269 values,\n+        // and 135 needs to be added to make it zero-based.\n+\n+        // As for Y - f(Cb, Cr)\n+        // the range becomes:\n+        // Y     f(Cb, Cr)\n+        // 255   -135\n+        // 255   134\n+        // 0     -135\n+        // 0     134\n+        // thus the range is [-134,390] and has 524 values\n+        // but is clamped to [0, 255]\n+        for (int Cb = 0; Cb < 256; Cb++)\n+        {\n+            for (int Cr = 0; Cr < 256; Cr++)\n+            {\n+                int value = fastRound(0.34414f*(Cb-128) + 0.71414f*(Cr-128));\n+                greens1[(Cb << 8) | Cr] = value + 135;\n+            }\n+        }\n+        for (int Y = 0; Y < 256; Y++)\n+        {\n+            for (int value = 0; value < 270; value++)\n+            {\n+                int green = Y - (value - 135);\n+                if (green < 0)\n+                    green = 0;\n+                else if (green > 255)\n+                    green = 255;\n+                greens2[(value << 8) | Y] = green << 8;\n+            }\n+        }\n+    }\n+\n+    private static int fastRound(float x)\n+    {\n+        // Math.round() is very slow\n+        return (int) (x + 0.5f);\n+    }\n+\n+    public static int convertYCbCrToRGB(int Y, int Cb, int Cr)\n+    {\n+        int r = reds[(Cr << 8) | Y];\n+        int g1 = greens1[(Cb << 8) | Cr];\n+        int g = greens2[(g1 << 8) | Y];\n+        int b = blues[(Cb << 8) | Y];\n+        return r | g | b;\n+    }\n+}"
        },
        {
            "sha": "1f30c9dba332a34fbd6c51a3ad634e7213bb4e18",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/segments/DHTSegment.java",
            "status": "added",
            "additions": 167,
            "deletions": 0,
            "changes": 167,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDHTSegment.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDHTSegment.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDHTSegment.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,167 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.segments;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import org.apache.sanselan.ImageReadException;\n+\n+public class DHTSegment extends Segment\n+{\n+    public final ArrayList huffmanTables = new ArrayList();\n+\n+    public static class HuffmanTable\n+    {\n+        // some arrays are better off one-based\n+        // to avoid subtractions by one later when indexing them\n+        public final int tableClass;\n+        public final int destinationIdentifier;\n+        public final int[] bits; // 1-based\n+        public final int[] huffVal; // 0-based\n+\n+        // derived properties:\n+        public final int[] huffSize = new int[16 * 256]; // 0-based\n+        public final int[] huffCode; // 0-based\n+        public final int[] minCode = new int[1 + 16]; // 1-based\n+        public final int[] maxCode = new int[1 + 16]; // 1-based\n+        public final int[] valPtr = new int[1 + 16]; // 1-based\n+\n+        public HuffmanTable(int tableClass, int destinationIdentifier,\n+                int[] bits, int[] huffVal)\n+        {\n+            this.tableClass = tableClass;\n+            this.destinationIdentifier = destinationIdentifier;\n+            this.bits = bits;\n+            this.huffVal = huffVal;\n+\n+            // \"generate_size_table\", section C.2, figure C.1, page 51 of ITU-T T.81:\n+            int k = 0;\n+            int i = 1;\n+            int j = 1;\n+            int lastK = -1;\n+            while (true)\n+            {\n+                if (j > bits[i])\n+                {\n+                    i++;\n+                    j = 1;\n+                    if (i > 16)\n+                    {\n+                        huffSize[k] = 0;\n+                        lastK = k;\n+                        break;\n+                    }\n+                }\n+                else\n+                {\n+                    huffSize[k] = i;\n+                    k++;\n+                    j++;\n+                }\n+            }\n+\n+            // \"generate_code_table\", section C.2, figure C.2, page 52 of ITU-T T.81:\n+            k = 0;\n+            int code = 0;\n+            int si = huffSize[0];\n+            huffCode = new int[lastK];\n+            while (true)\n+            {\n+                huffCode[k] = code;\n+                code++;\n+                k++;\n+\n+                if (huffSize[k] == si)\n+                    continue;\n+                if (huffSize[k] == 0)\n+                    break;\n+                do\n+                {\n+                    code <<= 1;\n+                    si++;\n+                } while (huffSize[k] != si);\n+            }\n+\n+            // \"Decoder_tables\", section F.2.2.3, figure F.15, page 108 of T.81:\n+            i = 0;\n+            j = 0;\n+            while (true)\n+            {\n+                i++;\n+                if (i > 16)\n+                    break;\n+                if (bits[i] == 0)\n+                    maxCode[i] = -1;\n+                else\n+                {\n+                    valPtr[i] = j;\n+                    minCode[i] = huffCode[j];\n+                    j += bits[i] - 1;\n+                    maxCode[i] = huffCode[j];\n+                    j++;\n+                }\n+            }\n+\n+        }\n+    }\n+\n+\n+    public DHTSegment(int marker, byte[] segmentData)\n+            throws ImageReadException, IOException\n+    {\n+        this(marker, segmentData.length, new ByteArrayInputStream(segmentData));\n+    }\n+\n+    public DHTSegment(int marker, int length, InputStream is)\n+            throws ImageReadException, IOException\n+    {\n+        super(marker, length);\n+\n+        while (length > 0)\n+        {\n+            int tableClassAndDestinationId =\n+                    0xff & readByte(\"TableClassAndDestinationId\",\n+                    is, \"Not a Valid JPEG File\");\n+            length--;\n+            int tableClass = (tableClassAndDestinationId >> 4) & 0xf;\n+            int destinationIdentifier = tableClassAndDestinationId & 0xf;\n+            int[] bits = new int[1 + 16];\n+            int bitsSum = 0;\n+            for (int i = 1; i < bits.length; i++)\n+            {\n+                bits[i] = 0xff & readByte(\"Li\", is, \"Not a Valid JPEG File\");\n+                length--;\n+                bitsSum += bits[i];\n+            }\n+            int[] huffVal = new int[bitsSum];\n+            for (int i = 0; i < bitsSum; i++)\n+            {\n+                huffVal[i] = 0xff & readByte(\"Vij\", is, \"Not a Valid JPEG File\");\n+                length--;\n+            }\n+\n+            huffmanTables.add(new HuffmanTable(tableClass,\n+                    destinationIdentifier, bits, huffVal));\n+        }\n+    }\n+\n+    public String getDescription()\n+    {\n+        return \"DHT (\" + getSegmentType() + \")\";\n+    }\n+}"
        },
        {
            "sha": "e6e5b3f1da3c506b26537dbb1265510d5400181e",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/segments/DQTSegment.java",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDQTSegment.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDQTSegment.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FDQTSegment.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -0,0 +1,94 @@\n+/*\n+ *  Licensed under the Apache License, Version 2.0 (the \"License\");\n+ *  you may not use this file except in compliance with the License.\n+ *  You may obtain a copy of the License at\n+ * \n+ *       http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ *  Unless required by applicable law or agreed to in writing, software\n+ *  distributed under the License is distributed on an \"AS IS\" BASIS,\n+ *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ *  See the License for the specific language governing permissions and\n+ *  limitations under the License.\n+ *  under the License.\n+ */\n+\n+package org.apache.sanselan.formats.jpeg.segments;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.ArrayList;\n+import org.apache.sanselan.ImageReadException;\n+\n+public class DQTSegment extends Segment\n+{\n+    public final ArrayList quantizationTables = new ArrayList();\n+\n+    public static class QuantizationTable\n+    {\n+        public final int precision;\n+        public final int destinationIdentifier;\n+        public final int[] elements;\n+\n+        public QuantizationTable(int precision, int destinationIdentifier,\n+                int[] elements)\n+        {\n+            this.precision = precision;\n+            this.destinationIdentifier = destinationIdentifier;\n+            this.elements = elements;\n+        }\n+    }\n+\n+    public DQTSegment(int marker, byte[] segmentData)\n+            throws ImageReadException, IOException\n+    {\n+        this(marker, segmentData.length, new ByteArrayInputStream(segmentData));\n+    }\n+\n+    public DQTSegment(int marker, int length, InputStream is)\n+            throws ImageReadException, IOException\n+    {\n+        super(marker, length);\n+\n+        while (length > 0)\n+        {\n+            int precisionAndDestination = readByte(\n+                    \"QuantizationTablePrecisionAndDestination\", is,\n+                    \"Not a Valid JPEG File\");\n+            length--;\n+            int precision = (precisionAndDestination >> 4) & 0xf;\n+            int destinationIdentifier = precisionAndDestination & 0xf;\n+\n+            int[] elements = new int[64];\n+            for (int i = 0; i < 64; i++)\n+            {\n+                if (precision == 0)\n+                {\n+                    elements[i] = 0xff & readByte(\"QuantizationTableElement\",\n+                            is, \"Not a Valid JPEG File\");\n+                    length--;\n+                }\n+                else if (precision == 1)\n+                {\n+                    elements[i] = read2Bytes(\"QuantizationTableElement\",\n+                            is, \"Not a Valid JPEG File\");\n+                    length -= 2;\n+                }\n+                else\n+                {\n+                    throw new ImageReadException(\"Quantization table precision '\" +\n+                            precision + \"' is invalid\");\n+                }\n+            }\n+\n+            quantizationTables.add(new QuantizationTable(\n+                    precision, destinationIdentifier, elements));\n+        }\n+    }\n+\n+    public String getDescription()\n+    {\n+        return \"DQT (\" + getSegmentType() + \")\";\n+    }\n+}"
        },
        {
            "sha": "b5227fbf4be8aea8b070c5aa0a5a1ad750dc430d",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/segments/SOFNSegment.java",
            "status": "modified",
            "additions": 37,
            "deletions": 14,
            "changes": 51,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOFNSegment.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOFNSegment.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOFNSegment.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -28,7 +28,27 @@ public class SOFNSegment extends Segment\n     public final int width, height;\n     public final int numberOfComponents;\n     public final int precision;\n+    public final Component[] components;\n \n+    public static class Component\n+    {\n+        public final int componentIdentifier;\n+        public final int horizontalSamplingFactor;\n+        public final int verticalSamplingFactor;\n+        public final int quantTabDestSelector;\n+\n+        public Component(int componentIdentifier,\n+                int horizontalSamplingFactor,\n+                int veritcalSamplingFactor,\n+                int quantTabDestSelector)\n+        {\n+            this.componentIdentifier = componentIdentifier;\n+            this.horizontalSamplingFactor = horizontalSamplingFactor;\n+            this.verticalSamplingFactor = veritcalSamplingFactor;\n+            this.quantTabDestSelector = quantTabDestSelector;\n+        }\n+    }\n+    \n     public SOFNSegment(int marker, byte segmentData[])\n             throws ImageReadException, IOException\n     {\n@@ -43,23 +63,26 @@ public SOFNSegment(int marker, int marker_length, InputStream is)\n         if (getDebug())\n             System.out.println(\"SOF0Segment marker_length: \" + marker_length);\n \n+        precision = readByte(\"Data_precision\", is, \"Not a Valid JPEG File\");\n+        height = read2Bytes(\"Image_height\", is, \"Not a Valid JPEG File\");\n+        width = read2Bytes(\"Image_Width\", is, \"Not a Valid JPEG File\");\n+        numberOfComponents = readByte(\"Number_of_components\", is,\n+                \"Not a Valid JPEG File\");\n+        components = new Component[numberOfComponents];\n+        for (int i = 0; i < numberOfComponents; i++)\n         {\n-            precision = readByte(\"Data_precision\", is, \"Not a Valid JPEG File\");\n-            height = read2Bytes(\"Image_height\", is, \"Not a Valid JPEG File\");\n-            width = read2Bytes(\"Image_Width\", is, \"Not a Valid JPEG File\");\n-            numberOfComponents = readByte(\"Number_of_components\", is,\n+            int componentIdentifier = readByte(\"ComponentIdentifier\", is,\n                     \"Not a Valid JPEG File\");\n \n-            // ignore the rest of the segment for now...\n-            skipBytes(is, marker_length - 6,\n-                    \"Not a Valid JPEG File: SOF0 Segment\");\n-\n-            //                int Each_component1 = read_byte(\"Each_component1\", is,\n-            //                        \"Not a Valid JPEG File\");\n-            //                int Each_component2 = read_byte(\"Each_component2\", is,\n-            //                        \"Not a Valid JPEG File\");\n-            //                int Each_component3 = read_byte(\"Each_component3\", is,\n-            //                        \"Not a Valid JPEG File\");\n+            int hvSamplingFactors = readByte(\"SamplingFactors\", is,\n+                    \"Not a Valid JPEG File\");\n+            int horizontalSamplingFactor = (hvSamplingFactors >> 4) & 0xf;\n+            int verticalSamplingFactor = hvSamplingFactors & 0xf;\n+            int quantTabDestSelector = readByte(\"QuantTabDestSel\", is,\n+                    \"Not a Valid JPEG File\");\n+            components[i] = new Component(componentIdentifier,\n+                        horizontalSamplingFactor, verticalSamplingFactor,\n+                        quantTabDestSelector);\n         }\n \n         if (getDebug())"
        },
        {
            "sha": "f768e57c6300362caddc1e3bd84b8fa755867a53",
            "filename": "src/main/java/org/apache/sanselan/formats/jpeg/segments/SOSSegment.java",
            "status": "modified",
            "additions": 52,
            "deletions": 38,
            "changes": 90,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOSSegment.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOSSegment.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fsanselan%2Fformats%2Fjpeg%2Fsegments%2FSOSSegment.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -16,6 +16,7 @@\n  */\n package org.apache.sanselan.formats.jpeg.segments;\n \n+import java.io.ByteArrayInputStream;\n import java.io.IOException;\n import java.io.InputStream;\n \n@@ -24,12 +25,34 @@\n \n public class SOSSegment extends Segment\n {\n-    //    public final int width, height;\n-    //    public final int Number_of_components;\n-    //    public final int Precision;\n+    public final int numberOfComponents;\n+    public final Component[] components;\n+    public final int startOfSpectralSelection;\n+    public final int endOfSpectralSelection;\n+    public final int successiveApproximationBitHigh;\n+    public final int successiveApproximationBitLow;\n \n-    //        public final byte bytes[];\n-    //        public final int cur_marker, num_markers;\n+    public static class Component\n+    {\n+        public final int scanComponentSelector;\n+        public final int dcCodingTableSelector;\n+        public final int acCodingTableSelector;\n+\n+        public Component(int scanComponentSelector,\n+                int dcCodingTableSelector,\n+                int acCodingTableSelector)\n+        {\n+            this.scanComponentSelector = scanComponentSelector;\n+            this.dcCodingTableSelector = dcCodingTableSelector;\n+            this.acCodingTableSelector = acCodingTableSelector;\n+        }\n+    }\n+\n+    public SOSSegment(int marker, byte[] segmentData)\n+            throws ImageReadException, IOException\n+    {\n+        this(marker, segmentData.length, new ByteArrayInputStream(segmentData));\n+    }\n \n     public SOSSegment(int marker, int marker_length, InputStream is)\n             throws ImageReadException, IOException\n@@ -39,54 +62,45 @@ public SOSSegment(int marker, int marker_length, InputStream is)\n         if (getDebug())\n             System.out.println(\"SOSSegment marker_length: \" + marker_length);\n \n-        Debug.debug(\"SOS\", marker_length);\n-        //        {\n-        int number_of_components_in_scan = readByte(\n+//        Debug.debug(\"SOS\", marker_length);\n+\n+        numberOfComponents = readByte(\n                 \"number_of_components_in_scan\", is, \"Not a Valid JPEG File\");\n-        Debug.debug(\"number_of_components_in_scan\",\n-                number_of_components_in_scan);\n+//        Debug.debug(\"number_of_components_in_scan\",\n+//                numberOfComponents);\n \n-        for (int i = 0; i < number_of_components_in_scan; i++)\n+        components = new Component[numberOfComponents];\n+        for (int i = 0; i < numberOfComponents; i++)\n         {\n             int scan_component_selector = readByte(\"scan_component_selector\",\n                     is, \"Not a Valid JPEG File\");\n-            Debug.debug(\"scan_component_selector\", scan_component_selector);\n+//            Debug.debug(\"scan_component_selector\", scan_component_selector);\n \n-            int ac_dc_entrooy_coding_table_selector = readByte(\n+            int ac_dc_entropy_coding_table_selector = readByte(\n                     \"ac_dc_entrooy_coding_table_selector\", is,\n                     \"Not a Valid JPEG File\");\n-            Debug.debug(\"ac_dc_entrooy_coding_table_selector\",\n-                    ac_dc_entrooy_coding_table_selector);\n+//            Debug.debug(\"ac_dc_entrooy_coding_table_selector\",\n+//                    ac_dc_entropy_coding_table_selector);\n+\n+            int dcCodingTableSelector = (ac_dc_entropy_coding_table_selector >> 4) & 0xf;\n+            int acCodingTableSelector = ac_dc_entropy_coding_table_selector & 0xf;\n+            components[i] = new Component(scan_component_selector,\n+                    dcCodingTableSelector, acCodingTableSelector);\n         }\n \n-        int start_of_spectral_selection = readByte(\n+        startOfSpectralSelection = readByte(\n                 \"start_of_spectral_selection\", is, \"Not a Valid JPEG File\");\n-        Debug.debug(\"start_of_spectral_selection\", start_of_spectral_selection);\n-        int end_of_spectral_selection = readByte(\"end_of_spectral_selection\",\n+//        Debug.debug(\"start_of_spectral_selection\", startOfSpectralSelection);\n+        endOfSpectralSelection = readByte(\"end_of_spectral_selection\",\n                 is, \"Not a Valid JPEG File\");\n-        Debug.debug(\"end_of_spectral_selection\", end_of_spectral_selection);\n+//        Debug.debug(\"end_of_spectral_selection\", endOfSpectralSelection);\n         int successive_approximation_bit_position = readByte(\n                 \"successive_approximation_bit_position\", is,\n                 \"Not a Valid JPEG File\");\n-        Debug.debug(\"successive_approximation_bit_position\",\n-                successive_approximation_bit_position);\n-\n-        //            height = read2Bytes(\"Image_height\", is, \"Not a Valid JPEG File\");\n-        //            width = read2Bytes(\"Image_Width\", is, \"Not a Valid JPEG File\");\n-        //            Number_of_components = read_byte(\"Number_of_components\", is,\n-        //                    \"Not a Valid JPEG File\");\n-        //\n-        //            // ignore the rest of the segment for now...\n-        //            skipBytes(is, marker_length - 6,\n-        //                    \"Not a Valid JPEG File: SOF0 Segment\");\n-        //\n-        //            //                int Each_component1 = read_byte(\"Each_component1\", is,\n-        //            //                        \"Not a Valid JPEG File\");\n-        //            //                int Each_component2 = read_byte(\"Each_component2\", is,\n-        //            //                        \"Not a Valid JPEG File\");\n-        //            //                int Each_component3 = read_byte(\"Each_component3\", is,\n-        //            //                        \"Not a Valid JPEG File\");\n-        //        }\n+//        Debug.debug(\"successive_approximation_bit_position\",\n+//                successive_approximation_bit_position);\n+        successiveApproximationBitHigh = (successive_approximation_bit_position >> 4) & 0xf;\n+        successiveApproximationBitLow = successive_approximation_bit_position & 0xf;\n \n         if (getDebug())\n             System.out.println(\"\");"
        },
        {
            "sha": "70207437ffada4665fc0204978e4554366fc4c5c",
            "filename": "src/test/java/org/apache/sanselan/roundtrip/RoundtripTest.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/commons-imaging/blob/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Ftest%2Fjava%2Forg%2Fapache%2Fsanselan%2Froundtrip%2FRoundtripTest.java",
            "raw_url": "https://github.com/apache/commons-imaging/raw/c659a6007b258f3e2afc57cf2b4c4c5eb03fce74/src%2Ftest%2Fjava%2Forg%2Fapache%2Fsanselan%2Froundtrip%2FRoundtripTest.java",
            "contents_url": "https://api.github.com/repos/apache/commons-imaging/contents/src%2Ftest%2Fjava%2Forg%2Fapache%2Fsanselan%2Froundtrip%2FRoundtripTest.java?ref=c659a6007b258f3e2afc57cf2b4c4c5eb03fce74",
            "patch": "@@ -70,7 +70,7 @@ public FormatInfo(ImageFormat format, boolean canRead,\n                     COLOR_FULL_RGB, true), //\n             new FormatInfo(ImageFormat.IMAGE_FORMAT_TIFF, true, true,\n                     COLOR_FULL_RGB, true), //\n-            new FormatInfo(ImageFormat.IMAGE_FORMAT_JPEG, false, false,\n+            new FormatInfo(ImageFormat.IMAGE_FORMAT_JPEG, true, false,\n                     COLOR_FULL_RGB, true), //\n             new FormatInfo(ImageFormat.IMAGE_FORMAT_BMP, true, true,\n                     COLOR_FULL_RGB, true), //"
        }
    ]
}
{
    "sha": "74da47c604b38afe5c8754d30bf1fc39a58b1bdc",
    "node_id": "MDY6Q29tbWl0MTg1MTE2ODc6NzRkYTQ3YzYwNGIzOGFmZTVjODc1NGQzMGJmMWZjMzlhNThiMWJkYw==",
    "commit": {
        "author": {
            "name": "Gaston Dombiak",
            "email": "gaston@jivesoftware.com",
            "date": "2007-01-04T23:41:39Z"
        },
        "committer": {
            "name": "gato",
            "email": "gato@b35dd754-fafc-0310-a699-88a17e54d16e",
            "date": "2007-01-04T23:41:39Z"
        },
        "message": "Optimization - Use NIO for CM. JM-925\n\ngit-svn-id: http://svn.igniterealtime.org/svn/repos/wildfire/trunk@6557 b35dd754-fafc-0310-a699-88a17e54d16e",
        "tree": {
            "sha": "d25392076a093adf0c4f90c3a3b40d705cde9ce5",
            "url": "https://api.github.com/repos/igniterealtime/Openfire/git/trees/d25392076a093adf0c4f90c3a3b40d705cde9ce5"
        },
        "url": "https://api.github.com/repos/igniterealtime/Openfire/git/commits/74da47c604b38afe5c8754d30bf1fc39a58b1bdc",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/igniterealtime/Openfire/commits/74da47c604b38afe5c8754d30bf1fc39a58b1bdc",
    "html_url": "https://github.com/igniterealtime/Openfire/commit/74da47c604b38afe5c8754d30bf1fc39a58b1bdc",
    "comments_url": "https://api.github.com/repos/igniterealtime/Openfire/commits/74da47c604b38afe5c8754d30bf1fc39a58b1bdc/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "2b81fb4f9844c493249fc8c386c8ac5ffcd9e510",
            "url": "https://api.github.com/repos/igniterealtime/Openfire/commits/2b81fb4f9844c493249fc8c386c8ac5ffcd9e510",
            "html_url": "https://github.com/igniterealtime/Openfire/commit/2b81fb4f9844c493249fc8c386c8ac5ffcd9e510"
        }
    ],
    "stats": {
        "total": 112,
        "additions": 87,
        "deletions": 25
    },
    "files": [
        {
            "sha": "69bce91d1301ca9fe31ad90d57cdd35709d45830",
            "filename": "src/java/org/jivesoftware/wildfire/spi/ConnectionManagerImpl.java",
            "status": "modified",
            "additions": 87,
            "deletions": 25,
            "changes": 112,
            "blob_url": "https://github.com/igniterealtime/Openfire/blob/74da47c604b38afe5c8754d30bf1fc39a58b1bdc/src%2Fjava%2Forg%2Fjivesoftware%2Fwildfire%2Fspi%2FConnectionManagerImpl.java",
            "raw_url": "https://github.com/igniterealtime/Openfire/raw/74da47c604b38afe5c8754d30bf1fc39a58b1bdc/src%2Fjava%2Forg%2Fjivesoftware%2Fwildfire%2Fspi%2FConnectionManagerImpl.java",
            "contents_url": "https://api.github.com/repos/igniterealtime/Openfire/contents/src%2Fjava%2Forg%2Fjivesoftware%2Fwildfire%2Fspi%2FConnectionManagerImpl.java?ref=74da47c604b38afe5c8754d30bf1fc39a58b1bdc",
            "patch": "@@ -3,23 +3,30 @@\n  * $Revision: 3159 $\r\n  * $Date: 2005-12-04 22:56:40 -0300 (Sun, 04 Dec 2005) $\r\n  *\r\n- * Copyright (C) 2004 Jive Software. All rights reserved.\r\n+ * Copyright (C) 2007 Jive Software. All rights reserved.\r\n  *\r\n  * This software is published under the terms of the GNU Public License (GPL),\r\n  * a copy of which is included in this distribution.\r\n  */\r\n \r\n package org.jivesoftware.wildfire.spi;\r\n \r\n+import org.apache.mina.common.ExecutorThreadModel;\r\n+import org.apache.mina.filter.codec.ProtocolCodecFilter;\r\n+import org.apache.mina.transport.socket.nio.SocketAcceptor;\r\n+import org.apache.mina.transport.socket.nio.SocketAcceptorConfig;\r\n+import org.apache.mina.transport.socket.nio.SocketSessionConfig;\r\n import org.jivesoftware.util.*;\r\n import org.jivesoftware.wildfire.*;\r\n-import org.jivesoftware.wildfire.http.HttpBindManager;\r\n import org.jivesoftware.wildfire.container.BasicModule;\r\n-import org.jivesoftware.wildfire.multiplex.MultiplexerPacketDeliverer;\r\n+import org.jivesoftware.wildfire.http.HttpBindManager;\r\n import org.jivesoftware.wildfire.net.*;\r\n+import org.jivesoftware.wildfire.nio.MultiplexerConnectionHandler;\r\n+import org.jivesoftware.wildfire.nio.XMPPCodecFactory;\r\n \r\n import java.io.IOException;\r\n import java.net.InetAddress;\r\n+import java.net.InetSocketAddress;\r\n import java.net.Socket;\r\n import java.net.UnknownHostException;\r\n import java.security.KeyStore;\r\n@@ -28,14 +35,18 @@\n import java.util.ArrayList;\r\n import java.util.Iterator;\r\n import java.util.List;\r\n+import java.util.concurrent.Executor;\r\n+import java.util.concurrent.LinkedBlockingQueue;\r\n+import java.util.concurrent.ThreadPoolExecutor;\r\n+import java.util.concurrent.TimeUnit;\r\n \r\n public class ConnectionManagerImpl extends BasicModule implements ConnectionManager, CertificateEventListener {\r\n \r\n     private SocketAcceptThread socketThread;\r\n     private SSLSocketAcceptThread sslSocketThread;\r\n     private SocketAcceptThread componentSocketThread;\r\n     private SocketAcceptThread serverSocketThread;\r\n-    private SocketAcceptThread multiplexerSocketThread;\r\n+    private SocketAcceptor multiplexerSocketAcceptor;\r\n     private ArrayList<ServerPort> ports;\r\n \r\n     private SessionManager sessionManager;\r\n@@ -124,17 +135,36 @@ private void startConnectionManagerListener(String localIPAddress) {\n         // Start multiplexers socket unless it's been disabled.\r\n         if (isConnectionManagerListenerEnabled()) {\r\n             int port = getConnectionManagerListenerPort();\r\n+\r\n+            // Create SocketAcceptor with correct number of processors\r\n+            multiplexerSocketAcceptor = buildSocketAcceptor();\r\n+            // Customize Executor that will be used by processors to process incoming stanzas\r\n+            ExecutorThreadModel threadModel = ExecutorThreadModel.getInstance(\"connectionManager\");\r\n+            int eventThreads = JiveGlobals.getIntProperty(\"xmpp.multiplex.processing.max.threads\", 16);\r\n+            ThreadPoolExecutor eventExecutor = (ThreadPoolExecutor) threadModel.getExecutor();\r\n+            eventExecutor.setCorePoolSize(eventThreads + 1);\r\n+            eventExecutor.setMaximumPoolSize(eventThreads + 1);\r\n+            eventExecutor.setKeepAliveTime(60, TimeUnit.SECONDS);\r\n+            multiplexerSocketAcceptor.getDefaultConfig().setThreadModel(threadModel);\r\n+            // Add the XMPP codec filter\r\n+            multiplexerSocketAcceptor.getFilterChain().addFirst(\"xmpp\", new ProtocolCodecFilter(new XMPPCodecFactory()));\r\n+\r\n             try {\r\n-                multiplexerSocketThread = new SocketAcceptThread(this, new ServerPort(port,\r\n-                        serverName, localIPAddress, false, null,\r\n-                        ServerPort.Type.connectionManager));\r\n-                ports.add(multiplexerSocketThread.getServerPort());\r\n-                multiplexerSocketThread.setDaemon(true);\r\n-                multiplexerSocketThread.setPriority(Thread.MAX_PRIORITY);\r\n-                multiplexerSocketThread.start();\r\n+                // Listen on a specific network interface if it has been set.\r\n+                String interfaceName = JiveGlobals.getXMLProperty(\"xmpp.socket.network.interface\");\r\n+                InetAddress bindInterface = null;\r\n+                if (interfaceName != null) {\r\n+                    if (interfaceName.trim().length() > 0) {\r\n+                        bindInterface = InetAddress.getByName(interfaceName);\r\n+                    }\r\n+                }\r\n+                // Start accepting connections\r\n+                multiplexerSocketAcceptor.bind(new InetSocketAddress(bindInterface, port), new MultiplexerConnectionHandler(serverName));\r\n+\r\n+                ports.add(new ServerPort(port, serverName, localIPAddress, false, null, ServerPort.Type.connectionManager));\r\n \r\n                 List<String> params = new ArrayList<String>();\r\n-                params.add(Integer.toString(multiplexerSocketThread.getPort()));\r\n+                params.add(Integer.toString(port));\r\n                 Log.info(LocaleUtils.getLocalizedString(\"startup.multiplexer\", params));\r\n             }\r\n             catch (Exception e) {\r\n@@ -146,10 +176,15 @@ private void startConnectionManagerListener(String localIPAddress) {\n     }\r\n \r\n     private void stopConnectionManagerListener() {\r\n-        if (multiplexerSocketThread != null) {\r\n-            multiplexerSocketThread.shutdown();\r\n-            ports.remove(multiplexerSocketThread.getServerPort());\r\n-            multiplexerSocketThread = null;\r\n+        if (multiplexerSocketAcceptor != null) {\r\n+            multiplexerSocketAcceptor.unbindAll();\r\n+            for (ServerPort port : ports) {\r\n+                if (port.isConnectionManagerPort()) {\r\n+                    ports.remove(port);\r\n+                    break;\r\n+                }\r\n+            }\r\n+            multiplexerSocketAcceptor = null;\r\n         }\r\n     }\r\n \r\n@@ -292,15 +327,7 @@ else if (serverPort.isServerPort()) {\n             return new ServerSocketReader(router, routingTable, serverName, sock, conn,\r\n                     useBlockingMode);\r\n         }\r\n-        else {\r\n-            // Use the appropriate packeet deliverer for connection managers. The packet\r\n-            // deliverer will be configured with the domain of the connection manager once\r\n-            // the connection manager has finished the handshake.\r\n-            SocketConnection conn =\r\n-                    new SocketConnection(new MultiplexerPacketDeliverer(), sock, isSecure);\r\n-            return new ConnectionMultiplexerSocketReader(router, routingTable, serverName, sock,\r\n-                    conn, useBlockingMode);\r\n-        }\r\n+        return null;\r\n     }\r\n \r\n     private void startHTTPBindListeners() {\r\n@@ -538,6 +565,41 @@ public void certificateSigned(KeyStore keyStore, String alias, List<X509Certific\n         restartClientSSLListeners();\r\n     }\r\n \r\n+    private SocketAcceptor buildSocketAcceptor() {\r\n+        SocketAcceptor socketAcceptor;\r\n+        // Create SocketAcceptor with correct number of processors\r\n+        int ioThreads = JiveGlobals.getIntProperty(\"xmpp.processor.count\", Runtime.getRuntime().availableProcessors());\r\n+        // Set the executor that processors will use. Note that processors will use another executor\r\n+        // for processing events (i.e. incoming traffic)\r\n+        Executor ioExecutor = new ThreadPoolExecutor(\r\n+            ioThreads + 1, ioThreads + 1, 60, TimeUnit.SECONDS, new LinkedBlockingQueue<Runnable>() );\r\n+        socketAcceptor = new SocketAcceptor(ioThreads, ioExecutor);\r\n+        // Set that it will be possible to bind a socket if there is a connection in the timeout state\r\n+        SocketAcceptorConfig socketAcceptorConfig = (SocketAcceptorConfig) socketAcceptor.getDefaultConfig();\r\n+        socketAcceptorConfig.setReuseAddress(true);\r\n+        // Set the listen backlog (queue) length. Default is 50.\r\n+        socketAcceptorConfig.setBacklog(JiveGlobals.getIntProperty(\"xmpp.socket.backlog\", 50));\r\n+\r\n+        // Set default (low level) settings for new socket connections\r\n+        SocketSessionConfig socketSessionConfig = socketAcceptorConfig.getSessionConfig();\r\n+        //socketSessionConfig.setKeepAlive();\r\n+        int receiveBuffer = JiveGlobals.getIntProperty(\"xmpp.socket.buffer.receive\", -1);\r\n+        if (receiveBuffer > 0 ) {\r\n+            socketSessionConfig.setReceiveBufferSize(receiveBuffer);\r\n+        }\r\n+        int sendBuffer = JiveGlobals.getIntProperty(\"xmpp.socket.buffer.send\", -1);\r\n+        if (sendBuffer > 0 ) {\r\n+            socketSessionConfig.setSendBufferSize(sendBuffer);\r\n+        }\r\n+        int linger = JiveGlobals.getIntProperty(\"xmpp.socket.linger\", -1);\r\n+        if (linger > 0 ) {\r\n+            socketSessionConfig.setSoLinger(linger);\r\n+        }\r\n+        socketSessionConfig.setTcpNoDelay(\r\n+                JiveGlobals.getBooleanProperty(\"xmpp.socket.tcp-nodelay\", socketSessionConfig.isTcpNoDelay()));\r\n+        return socketAcceptor;\r\n+    }\r\n+\r\n     // #####################################################################\r\n     // Module management\r\n     // #####################################################################\r"
        }
    ]
}
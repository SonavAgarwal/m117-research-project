{
    "sha": "29f975ea99d9b9310c6fc33ac4f844fb10f4d98a",
    "node_id": "MDY6Q29tbWl0MjU4MDc2OToyOWY5NzVlYTk5ZDliOTMxMGM2ZmMzM2FjNGY4NDRmYjEwZjRkOThh",
    "commit": {
        "author": {
            "name": "Emmanuel Bourg",
            "email": "ebourg@apache.org",
            "date": "2013-12-18T23:14:26Z"
        },
        "committer": {
            "name": "Emmanuel Bourg",
            "email": "ebourg@apache.org",
            "date": "2013-12-18T23:14:26Z"
        },
        "message": "Replaced ZipArchiveInputStream.Buffer with a ByteBuffer\n\ngit-svn-id: https://svn.apache.org/repos/asf/commons/proper/compress/trunk@1552156 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "cd275f82ac608d4411261f6b4e60fb4805ce3c5d",
            "url": "https://api.github.com/repos/apache/commons-compress/git/trees/cd275f82ac608d4411261f6b4e60fb4805ce3c5d"
        },
        "url": "https://api.github.com/repos/apache/commons-compress/git/commits/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/commons-compress/commits/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a",
    "html_url": "https://github.com/apache/commons-compress/commit/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a",
    "comments_url": "https://api.github.com/repos/apache/commons-compress/commits/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a/comments",
    "author": {
        "login": "ebourg",
        "id": 54304,
        "node_id": "MDQ6VXNlcjU0MzA0",
        "avatar_url": "https://avatars.githubusercontent.com/u/54304?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ebourg",
        "html_url": "https://github.com/ebourg",
        "followers_url": "https://api.github.com/users/ebourg/followers",
        "following_url": "https://api.github.com/users/ebourg/following{/other_user}",
        "gists_url": "https://api.github.com/users/ebourg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/ebourg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ebourg/subscriptions",
        "organizations_url": "https://api.github.com/users/ebourg/orgs",
        "repos_url": "https://api.github.com/users/ebourg/repos",
        "events_url": "https://api.github.com/users/ebourg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/ebourg/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "ebourg",
        "id": 54304,
        "node_id": "MDQ6VXNlcjU0MzA0",
        "avatar_url": "https://avatars.githubusercontent.com/u/54304?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/ebourg",
        "html_url": "https://github.com/ebourg",
        "followers_url": "https://api.github.com/users/ebourg/followers",
        "following_url": "https://api.github.com/users/ebourg/following{/other_user}",
        "gists_url": "https://api.github.com/users/ebourg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/ebourg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/ebourg/subscriptions",
        "organizations_url": "https://api.github.com/users/ebourg/orgs",
        "repos_url": "https://api.github.com/users/ebourg/repos",
        "events_url": "https://api.github.com/users/ebourg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/ebourg/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "8301ee7fec23ffdee9ea2c8ce5a8b80f343744e5",
            "url": "https://api.github.com/repos/apache/commons-compress/commits/8301ee7fec23ffdee9ea2c8ce5a8b80f343744e5",
            "html_url": "https://github.com/apache/commons-compress/commit/8301ee7fec23ffdee9ea2c8ce5a8b80f343744e5"
        }
    ],
    "stats": {
        "total": 119,
        "additions": 37,
        "deletions": 82
    },
    "files": [
        {
            "sha": "185ed59d73b42e05bae7b7e32b43999d64a303a7",
            "filename": "src/main/java/org/apache/commons/compress/archivers/zip/ZipArchiveInputStream.java",
            "status": "modified",
            "additions": 37,
            "deletions": 82,
            "changes": 119,
            "blob_url": "https://github.com/apache/commons-compress/blob/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a/src%2Fmain%2Fjava%2Forg%2Fapache%2Fcommons%2Fcompress%2Farchivers%2Fzip%2FZipArchiveInputStream.java",
            "raw_url": "https://github.com/apache/commons-compress/raw/29f975ea99d9b9310c6fc33ac4f844fb10f4d98a/src%2Fmain%2Fjava%2Forg%2Fapache%2Fcommons%2Fcompress%2Farchivers%2Fzip%2FZipArchiveInputStream.java",
            "contents_url": "https://api.github.com/repos/apache/commons-compress/contents/src%2Fmain%2Fjava%2Forg%2Fapache%2Fcommons%2Fcompress%2Farchivers%2Fzip%2FZipArchiveInputStream.java?ref=29f975ea99d9b9310c6fc33ac4f844fb10f4d98a",
            "patch": "@@ -24,6 +24,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.PushbackInputStream;\n+import java.nio.ByteBuffer;\n import java.util.zip.CRC32;\n import java.util.zip.DataFormatException;\n import java.util.zip.Inflater;\n@@ -85,7 +86,7 @@ public class ZipArchiveInputStream extends ArchiveInputStream {\n     /**\n      * Buffer used to read from the wrapped stream.\n      */\n-    private final Buffer buf = new Buffer();\n+    private final ByteBuffer buf = ByteBuffer.allocate(ZipArchiveOutputStream.BUFFER_SIZE);\n     /**\n      * The entry that is currently being read.\n      */\n@@ -423,22 +424,24 @@ private int readStored(byte[] buffer, int start, int length)\n             return -1;\n         }\n \n-        if (buf.position >= buf.limit) {\n-            buf.position = 0;\n-            if ((buf.limit = in.read(buf.array)) == -1) {\n+        if (buf.position() >= buf.limit()) {\n+            buf.position(0);\n+            int l = in.read(buf.array());\n+            if (l == -1) {\n                 return -1;\n             }\n-            count(buf.limit);\n-            current.bytesReadFromStream += buf.limit;\n+            buf.limit(l);\n+\n+            count(buf.limit());\n+            current.bytesReadFromStream += buf.limit();\n         }\n \n         int toRead = Math.min(buf.remaining(), length);\n         if ((csize - current.bytesRead) < toRead) {\n             // if it is smaller than toRead then it fits into an int\n             toRead = (int) (csize - current.bytesRead);\n         }\n-        System.arraycopy(buf.array, buf.position, buffer, start, toRead);\n-        buf.position += toRead;\n+        buf.get(buffer, start, toRead);\n         current.bytesRead += toRead;\n         crc.update(buffer, start, toRead);\n         return toRead;\n@@ -450,14 +453,14 @@ private int readStored(byte[] buffer, int start, int length)\n     private int readDeflated(byte[] buffer, int start, int length)\n         throws IOException {\n         int read = readFromInflater(buffer, start, length);\n-        if (read == 0) {\n+        if (read <= 0) {\n             if (inf.finished()) {\n                 return -1;\n             } else if (inf.needsDictionary()) {\n                 throw new ZipException(\"This archive needs a preset dictionary\"\n                                        + \" which is not supported by Commons\"\n                                        + \" Compress.\");\n-            } else if (buf.limit == -1) {\n+            } else if (read == -1) {\n                 throw new IOException(\"Truncated ZIP file\");\n             }\n         }\n@@ -474,9 +477,11 @@ private int readFromInflater(byte[] buffer, int start, int length)\n         int read = 0;\n         do {\n             if (inf.needsInput()) {\n-                fill();\n-                if (buf.limit > 0) {\n-                    current.bytesReadFromStream += buf.limit;\n+                int l = fill();\n+                if (l > 0) {\n+                    current.bytesReadFromStream += buf.limit();\n+                } else if (l == -1) {\n+                    return -1;\n                 } else {\n                     break;\n                 }\n@@ -608,7 +613,7 @@ private void closeEntry() throws IOException {\n \n             // Pushback any required bytes\n             if (diff > 0) {\n-                pushback(buf.array, buf.limit - diff, diff);\n+                pushback(buf.array(), buf.limit() - diff, diff);\n             }\n         }\n \n@@ -617,7 +622,7 @@ private void closeEntry() throws IOException {\n         }\n \n         inf.reset();\n-        buf.reset();\n+        buf.clear().flip();\n         crc.reset();\n         current = null;\n         lastStoredEntry = null;\n@@ -631,7 +636,7 @@ private void drainCurrentEntryData() throws IOException {\n         long remaining = current.entry.getCompressedSize()\n             - current.bytesReadFromStream;\n         while (remaining > 0) {\n-            long n = in.read(buf.array, 0, (int) Math.min(buf.capacity(), remaining));\n+            long n = in.read(buf.array(), 0, (int) Math.min(buf.capacity(), remaining));\n             if (n < 0) {\n                 throw new EOFException(\n                                        \"Truncated ZIP entry: \" + current.entry.getName());\n@@ -667,14 +672,17 @@ private long getBytesInflated() {\n         return inB;\n     }\n \n-    private void fill() throws IOException {\n+    private int fill() throws IOException {\n         if (closed) {\n             throw new IOException(\"The stream is closed\");\n         }\n-        if ((buf.limit = in.read(buf.array)) > 0) {\n-            count(buf.limit);\n-            inf.setInput(buf.array, 0, buf.limit);\n+        int length = in.read(buf.array());\n+        if (length > 0) {\n+            buf.limit(length);\n+            count(buf.limit());\n+            inf.setInput(buf.array(), 0, buf.limit());\n         }\n+        return length;\n     }\n \n     private void readFully(byte[] b) throws IOException {\n@@ -761,8 +769,7 @@ private void readStoredEntry() throws IOException {\n         int ddLen = current.usesZip64 ? WORD + 2 * DWORD : 3 * WORD;\n \n         while (!done) {\n-            int r = in.read(buf.array, off,\n-                            ZipArchiveOutputStream.BUFFER_SIZE - off);\n+            int r = in.read(buf.array(), off, ZipArchiveOutputStream.BUFFER_SIZE - off);\n             if (r <= 0) {\n                 // read the whole archive without ever finding a\n                 // central directory\n@@ -803,14 +810,14 @@ private boolean bufferContainsSignature(ByteArrayOutputStream bos,\n         boolean done = false;\n         int readTooMuch = 0;\n         for (int i = 0; !done && i < lastRead - 4; i++) {\n-            if (buf.array[i] == LFH[0] && buf.array[i + 1] == LFH[1]) {\n-                if ((buf.array[i + 2] == LFH[2] && buf.array[i + 3] == LFH[3])\n-                    || (buf.array[i] == CFH[2] && buf.array[i + 3] == CFH[3])) {\n+            if (buf.array()[i] == LFH[0] && buf.array()[i + 1] == LFH[1]) {\n+                if ((buf.array()[i + 2] == LFH[2] && buf.array()[i + 3] == LFH[3])\n+                    || (buf.array()[i] == CFH[2] && buf.array()[i + 3] == CFH[3])) {\n                     // found a LFH or CFH:\n                     readTooMuch = offset + lastRead - i - expectedDDLen;\n                     done = true;\n                 }\n-                else if (buf.array[i + 2] == DD[2] && buf.array[i + 3] == DD[3]) {\n+                else if (buf.array()[i + 2] == DD[2] && buf.array()[i + 3] == DD[3]) {\n                     // found DD:\n                     readTooMuch = offset + lastRead - i;\n                     done = true;\n@@ -820,9 +827,8 @@ else if (buf.array[i + 2] == DD[2] && buf.array[i + 3] == DD[3]) {\n                     //   descriptor\n                     // * copy the remaining bytes to cache\n                     // * read data descriptor\n-                    pushback(buf.array, offset + lastRead - readTooMuch,\n-                             readTooMuch);\n-                    bos.write(buf.array, 0, i);\n+                    pushback(buf.array(), offset + lastRead - readTooMuch, readTooMuch);\n+                    bos.write(buf.array(), 0, i);\n                     readDataDescriptor();\n                 }\n             }\n@@ -843,9 +849,8 @@ private int cacheBytesRead(ByteArrayOutputStream bos, int offset,\n                                int lastRead, int expecteDDLen) {\n         final int cacheable = offset + lastRead - expecteDDLen - 3;\n         if (cacheable > 0) {\n-            bos.write(buf.array, 0, cacheable);\n-            System.arraycopy(buf.array, cacheable, buf.array, 0,\n-                             expecteDDLen + 3);\n+            bos.write(buf.array(), 0, cacheable);\n+            System.arraycopy(buf.array(), cacheable, buf.array(), 0, expecteDDLen + 3);\n             offset = expecteDDLen + 3;\n         } else {\n             offset += lastRead;\n@@ -1006,54 +1011,4 @@ private static final class CurrentEntry {\n          */\n         private long bytesReadFromStream;\n     }\n-\n-    /**\n-     * Contains a temporary buffer used to read from the wrapped\n-     * stream together with some information needed for internal\n-     * housekeeping.\n-     * \n-     * This class is similar to a java.nio.ByteBuffer but can't be replaced,\n-     * because the limit contains the length of the last read operation and\n-     * when the end of the stream is reached the limit is thus set to -1.\n-     * This is not allowed for a ByteBuffer.\n-     */\n-    private static final class Buffer {\n-        /**\n-         * Buffer used as temporary buffer when reading from the stream.\n-         */\n-        private final byte[] array = new byte[ZipArchiveOutputStream.BUFFER_SIZE];\n-\n-        /**\n-         * {@link #array array} may contain data the client hasnt read, yet,\n-         * this is the first byte that hasn't been read so far.\n-         */\n-        private int position = 0;\n-\n-        /**\n-         * Number of bytes read from the wrapped stream into {@link #array\n-         * array} with the last read operation.\n-         */\n-        private int limit = 0;\n-\n-        /**\n-         * Reset internal housekeeping.\n-         */\n-        private void reset() {\n-            position = limit = 0;\n-        }\n-\n-        /**\n-         * Returns the number of bytes left to read.\n-         */\n-        private int remaining() {\n-            return limit - position;\n-        }\n-\n-        /**\n-         * Returns the length of the buffer.\n-         */\n-        private int capacity() {\n-            return array.length;\n-        }\n-    }\n }"
        }
    ]
}
{
    "sha": "fc6f2ead8463d06ae73954508927e4f2224c8e77",
    "node_id": "MDY6Q29tbWl0MjQ5MzkwNDpmYzZmMmVhZDg0NjNkMDZhZTczOTU0NTA4OTI3ZTRmMjIyNGM4ZTc3",
    "commit": {
        "author": {
            "name": "Violeta Georgieva Georgieva",
            "email": "violetagg@apache.org",
            "date": "2016-09-26T11:42:26Z"
        },
        "committer": {
            "name": "Violeta Georgieva Georgieva",
            "email": "violetagg@apache.org",
            "date": "2016-09-26T11:42:26Z"
        },
        "message": "Websocket read implementation now uses SocketWrapperBase.read(boolean, ByteBuffer)\n\ngit-svn-id: https://svn.apache.org/repos/asf/tomcat/trunk@1762324 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "3a6f6cf9cf79dd7135543dd0eb528e22171a50d7",
            "url": "https://api.github.com/repos/apache/tomcat/git/trees/3a6f6cf9cf79dd7135543dd0eb528e22171a50d7"
        },
        "url": "https://api.github.com/repos/apache/tomcat/git/commits/fc6f2ead8463d06ae73954508927e4f2224c8e77",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/tomcat/commits/fc6f2ead8463d06ae73954508927e4f2224c8e77",
    "html_url": "https://github.com/apache/tomcat/commit/fc6f2ead8463d06ae73954508927e4f2224c8e77",
    "comments_url": "https://api.github.com/repos/apache/tomcat/commits/fc6f2ead8463d06ae73954508927e4f2224c8e77/comments",
    "author": {
        "login": "violetagg",
        "id": 696661,
        "node_id": "MDQ6VXNlcjY5NjY2MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/696661?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/violetagg",
        "html_url": "https://github.com/violetagg",
        "followers_url": "https://api.github.com/users/violetagg/followers",
        "following_url": "https://api.github.com/users/violetagg/following{/other_user}",
        "gists_url": "https://api.github.com/users/violetagg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/violetagg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/violetagg/subscriptions",
        "organizations_url": "https://api.github.com/users/violetagg/orgs",
        "repos_url": "https://api.github.com/users/violetagg/repos",
        "events_url": "https://api.github.com/users/violetagg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/violetagg/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "violetagg",
        "id": 696661,
        "node_id": "MDQ6VXNlcjY5NjY2MQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/696661?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/violetagg",
        "html_url": "https://github.com/violetagg",
        "followers_url": "https://api.github.com/users/violetagg/followers",
        "following_url": "https://api.github.com/users/violetagg/following{/other_user}",
        "gists_url": "https://api.github.com/users/violetagg/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/violetagg/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/violetagg/subscriptions",
        "organizations_url": "https://api.github.com/users/violetagg/orgs",
        "repos_url": "https://api.github.com/users/violetagg/repos",
        "events_url": "https://api.github.com/users/violetagg/events{/privacy}",
        "received_events_url": "https://api.github.com/users/violetagg/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "7f9801fa9b0174aee29f42661b551a05db83c02c",
            "url": "https://api.github.com/repos/apache/tomcat/commits/7f9801fa9b0174aee29f42661b551a05db83c02c",
            "html_url": "https://github.com/apache/tomcat/commit/7f9801fa9b0174aee29f42661b551a05db83c02c"
        }
    ],
    "stats": {
        "total": 85,
        "additions": 45,
        "deletions": 40
    },
    "files": [
        {
            "sha": "84e8132e7d23288f62f163df3fb2892a816c12cc",
            "filename": "java/org/apache/tomcat/websocket/WsFrameBase.java",
            "status": "modified",
            "additions": 31,
            "deletions": 33,
            "changes": 64,
            "blob_url": "https://github.com/apache/tomcat/blob/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameBase.java",
            "raw_url": "https://github.com/apache/tomcat/raw/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameBase.java",
            "contents_url": "https://api.github.com/repos/apache/tomcat/contents/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameBase.java?ref=fc6f2ead8463d06ae73954508927e4f2224c8e77",
            "patch": "@@ -47,7 +47,7 @@ public abstract class WsFrameBase {\n \n     // Connection level attributes\n     protected final WsSession wsSession;\n-    protected final byte[] inputBuffer;\n+    protected final ByteBuffer inputBuffer;\n     private final Transformation transformation;\n \n     // Attributes for control messages\n@@ -84,11 +84,10 @@ public abstract class WsFrameBase {\n     // Attributes tracking state\n     private volatile State state = State.NEW_FRAME;\n     private volatile boolean open = true;\n-    private volatile int readPos = 0;\n-    protected volatile int writePos = 0;\n \n     public WsFrameBase(WsSession wsSession, Transformation transformation) {\n-        inputBuffer = new byte[Constants.DEFAULT_BUFFER_SIZE];\n+        inputBuffer = ByteBuffer.allocate(Constants.DEFAULT_BUFFER_SIZE);\n+        inputBuffer.position(0).limit(0);\n         messageBufferBinary =\n                 ByteBuffer.allocate(wsSession.getMaxBinaryMessageBufferSize());\n         messageBufferText =\n@@ -142,10 +141,10 @@ protected void processInputBuffer() throws IOException {\n      */\n     private boolean processInitialHeader() throws IOException {\n         // Need at least two bytes of data to do this\n-        if (writePos - readPos < 2) {\n+        if (inputBuffer.remaining() < 2) {\n             return false;\n         }\n-        int b = inputBuffer[readPos++];\n+        int b = inputBuffer.get();\n         fin = (b & 0x80) > 0;\n         rsv = (b & 0x70) >>> 4;\n         opCode = (byte) (b & 0x0F);\n@@ -212,7 +211,7 @@ private boolean processInitialHeader() throws IOException {\n             }\n             continuationExpected = !fin;\n         }\n-        b = inputBuffer[readPos++];\n+        b = inputBuffer.get();\n         // Client data must be masked\n         if ((b & 0x80) == 0 && isMasked()) {\n             throw new WsIOException(new CloseReason(\n@@ -251,16 +250,18 @@ private boolean processRemainingHeader() throws IOException {\n         } else if (payloadLength == 127) {\n             headerLength += 8;\n         }\n-        if (writePos - readPos < headerLength) {\n+        if (inputBuffer.remaining() < headerLength) {\n             return false;\n         }\n         // Calculate new payload length if necessary\n         if (payloadLength == 126) {\n-            payloadLength = byteArrayToLong(inputBuffer, readPos, 2);\n-            readPos += 2;\n+            payloadLength = byteArrayToLong(inputBuffer.array(),\n+                    inputBuffer.arrayOffset() + inputBuffer.position(), 2);\n+            inputBuffer.position(inputBuffer.position() + 2);\n         } else if (payloadLength == 127) {\n-            payloadLength = byteArrayToLong(inputBuffer, readPos, 8);\n-            readPos += 8;\n+            payloadLength = byteArrayToLong(inputBuffer.array(),\n+                    inputBuffer.arrayOffset() + inputBuffer.position(), 8);\n+            inputBuffer.position(inputBuffer.position() + 8);\n         }\n         if (Util.isControl(opCode)) {\n             if (payloadLength > 125) {\n@@ -276,8 +277,7 @@ private boolean processRemainingHeader() throws IOException {\n             }\n         }\n         if (isMasked()) {\n-            System.arraycopy(inputBuffer, readPos, mask, 0, 4);\n-            readPos += 4;\n+            inputBuffer.get(mask, 0, 4);\n         }\n         state = State.DATA;\n         return true;\n@@ -607,9 +607,8 @@ private void newMessage() {\n \n \n     private void newFrame() {\n-        if (readPos == writePos) {\n-            readPos = 0;\n-            writePos = 0;\n+        if (inputBuffer.remaining() == 0) {\n+            inputBuffer.position(0).limit(0);\n         }\n \n         maskIndex = 0;\n@@ -626,25 +625,23 @@ private void newFrame() {\n     private void checkRoomHeaders() {\n         // Is the start of the current frame too near the end of the input\n         // buffer?\n-        if (inputBuffer.length - readPos < 131) {\n+        if (inputBuffer.capacity() - inputBuffer.position() < 131) {\n             // Limit based on a control frame with a full payload\n             makeRoom();\n         }\n     }\n \n \n     private void checkRoomPayload() {\n-        if (inputBuffer.length - readPos - payloadLength + payloadWritten < 0) {\n+        if (inputBuffer.capacity() - inputBuffer.position() - payloadLength + payloadWritten < 0) {\n             makeRoom();\n         }\n     }\n \n \n     private void makeRoom() {\n-        System.arraycopy(inputBuffer, readPos, inputBuffer, 0,\n-                writePos - readPos);\n-        writePos = writePos - readPos;\n-        readPos = 0;\n+        inputBuffer.compact();\n+        inputBuffer.flip();\n     }\n \n \n@@ -661,8 +658,8 @@ private boolean usePartial() {\n \n \n     private boolean swallowInput() {\n-        long toSkip = Math.min(payloadLength - payloadWritten, writePos - readPos);\n-        readPos += toSkip;\n+        long toSkip = Math.min(payloadLength - payloadWritten, inputBuffer.remaining());\n+        inputBuffer.position(inputBuffer.position() + (int) toSkip);\n         payloadWritten += toSkip;\n         if (payloadWritten == payloadLength) {\n             if (continuationExpected) {\n@@ -758,16 +755,18 @@ public TransformationResult getMoreData(byte opCode, boolean fin, int rsv,\n             // opCodes\n             // rsv is ignored as it known to be zero at this point\n             long toWrite = Math.min(\n-                    payloadLength - payloadWritten, writePos - readPos);\n+                    payloadLength - payloadWritten, inputBuffer.remaining());\n             toWrite = Math.min(toWrite, dest.remaining());\n \n-            dest.put(inputBuffer, readPos, (int) toWrite);\n-            readPos += toWrite;\n+            int orgLimit = inputBuffer.limit();\n+            inputBuffer.limit(inputBuffer.position() + (int) toWrite);\n+            dest.put(inputBuffer);\n+            inputBuffer.limit(orgLimit);\n             payloadWritten += toWrite;\n \n             if (payloadWritten == payloadLength) {\n                 return TransformationResult.END_OF_FRAME;\n-            } else if (readPos == writePos) {\n+            } else if (inputBuffer.remaining() == 0) {\n                 return TransformationResult.UNDERFLOW;\n             } else {\n                 // !dest.hasRemaining()\n@@ -797,20 +796,19 @@ public TransformationResult getMoreData(byte opCode, boolean fin, int rsv,\n             // opCode is ignored as the transformation is the same for all\n             // opCodes\n             // rsv is ignored as it known to be zero at this point\n-            while (payloadWritten < payloadLength && readPos < writePos &&\n+            while (payloadWritten < payloadLength && inputBuffer.remaining() > 0 &&\n                     dest.hasRemaining()) {\n-                byte b = (byte) ((inputBuffer[readPos] ^ mask[maskIndex]) & 0xFF);\n+                byte b = (byte) ((inputBuffer.get() ^ mask[maskIndex]) & 0xFF);\n                 maskIndex++;\n                 if (maskIndex == 4) {\n                     maskIndex = 0;\n                 }\n-                readPos++;\n                 payloadWritten++;\n                 dest.put(b);\n             }\n             if (payloadWritten == payloadLength) {\n                 return TransformationResult.END_OF_FRAME;\n-            } else if (readPos == writePos) {\n+            } else if (inputBuffer.remaining() == 0) {\n                 return TransformationResult.UNDERFLOW;\n             } else {\n                 // !dest.hasRemaining()"
        },
        {
            "sha": "109c32693aef6f30b730ebd140b8679d4b00bffd",
            "filename": "java/org/apache/tomcat/websocket/WsFrameClient.java",
            "status": "modified",
            "additions": 10,
            "deletions": 4,
            "changes": 14,
            "blob_url": "https://github.com/apache/tomcat/blob/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameClient.java",
            "raw_url": "https://github.com/apache/tomcat/raw/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameClient.java",
            "contents_url": "https://api.github.com/repos/apache/tomcat/contents/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2FWsFrameClient.java?ref=fc6f2ead8463d06ae73954508927e4f2224c8e77",
            "patch": "@@ -60,14 +60,20 @@ void startInputProcessing() {\n     private void processSocketRead() throws IOException {\n \n         while (response.hasRemaining()) {\n-            int remaining = response.remaining();\n+            inputBuffer.mark();\n+            inputBuffer.position(inputBuffer.limit()).limit(inputBuffer.capacity());\n \n-            int toCopy = Math.min(remaining, inputBuffer.length - writePos);\n+            int toCopy = Math.min(response.remaining(), inputBuffer.remaining());\n \n             // Copy remaining bytes read in HTTP phase to input buffer used by\n             // frame processing\n-            response.get(inputBuffer, writePos, toCopy);\n-            writePos += toCopy;\n+\n+            int orgLimit = response.limit();\n+            response.limit(response.position() + toCopy);\n+            inputBuffer.put(response);\n+            response.limit(orgLimit);\n+\n+            inputBuffer.limit(inputBuffer.position()).reset();\n \n             // Process the data we have\n             processInputBuffer();"
        },
        {
            "sha": "b8b90ad383d991e9de8a3913ab8e71b53b01efe8",
            "filename": "java/org/apache/tomcat/websocket/server/WsFrameServer.java",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/apache/tomcat/blob/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2Fserver%2FWsFrameServer.java",
            "raw_url": "https://github.com/apache/tomcat/raw/fc6f2ead8463d06ae73954508927e4f2224c8e77/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2Fserver%2FWsFrameServer.java",
            "contents_url": "https://api.github.com/repos/apache/tomcat/contents/java%2Forg%2Fapache%2Ftomcat%2Fwebsocket%2Fserver%2FWsFrameServer.java?ref=fc6f2ead8463d06ae73954508927e4f2224c8e77",
            "patch": "@@ -57,15 +57,16 @@ public void onDataAvailable() throws IOException {\n         }\n         while (isOpen() && socketWrapper.isReadyForRead()) {\n             // Fill up the input buffer with as much data as we can\n-            int read = socketWrapper.read(\n-                    false, inputBuffer, writePos, inputBuffer.length - writePos);\n+            inputBuffer.mark();\n+            inputBuffer.position(inputBuffer.limit()).limit(inputBuffer.capacity());\n+            int read = socketWrapper.read(false, inputBuffer);\n+            inputBuffer.limit(inputBuffer.position()).reset();\n             if (read <= 0) {\n                 return;\n             }\n             if (log.isDebugEnabled()) {\n                 log.debug(sm.getString(\"wsFrameServer.bytesRead\", Integer.toString(read)));\n             }\n-            writePos += read;\n             processInputBuffer();\n         }\n     }"
        }
    ]
}
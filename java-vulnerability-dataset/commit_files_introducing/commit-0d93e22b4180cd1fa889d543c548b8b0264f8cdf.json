{
    "sha": "0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
    "node_id": "MDY6Q29tbWl0NjIxMTE3ODc6MGQ5M2UyMmI0MTgwY2QxZmE4ODlkNTQzYzU0OGI4YjAyNjRmOGNkZg==",
    "commit": {
        "author": {
            "name": "Rhys Weatherley",
            "email": "rhys.weatherley@gmail.com",
            "date": "2016-06-29T01:20:58Z"
        },
        "committer": {
            "name": "Rhys Weatherley",
            "email": "rhys.weatherley@gmail.com",
            "date": "2016-06-29T01:20:58Z"
        },
        "message": "Fallback implementation of AESGCM with no JCE dependencies",
        "tree": {
            "sha": "d5116d26e723b2c767eebd96df9b801bfbc3df27",
            "url": "https://api.github.com/repos/rweather/noise-java/git/trees/d5116d26e723b2c767eebd96df9b801bfbc3df27"
        },
        "url": "https://api.github.com/repos/rweather/noise-java/git/commits/0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/rweather/noise-java/commits/0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
    "html_url": "https://github.com/rweather/noise-java/commit/0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
    "comments_url": "https://api.github.com/repos/rweather/noise-java/commits/0d93e22b4180cd1fa889d543c548b8b0264f8cdf/comments",
    "author": {
        "login": "rweather",
        "id": 719949,
        "node_id": "MDQ6VXNlcjcxOTk0OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/719949?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rweather",
        "html_url": "https://github.com/rweather",
        "followers_url": "https://api.github.com/users/rweather/followers",
        "following_url": "https://api.github.com/users/rweather/following{/other_user}",
        "gists_url": "https://api.github.com/users/rweather/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rweather/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rweather/subscriptions",
        "organizations_url": "https://api.github.com/users/rweather/orgs",
        "repos_url": "https://api.github.com/users/rweather/repos",
        "events_url": "https://api.github.com/users/rweather/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rweather/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "rweather",
        "id": 719949,
        "node_id": "MDQ6VXNlcjcxOTk0OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/719949?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rweather",
        "html_url": "https://github.com/rweather",
        "followers_url": "https://api.github.com/users/rweather/followers",
        "following_url": "https://api.github.com/users/rweather/following{/other_user}",
        "gists_url": "https://api.github.com/users/rweather/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rweather/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rweather/subscriptions",
        "organizations_url": "https://api.github.com/users/rweather/orgs",
        "repos_url": "https://api.github.com/users/rweather/repos",
        "events_url": "https://api.github.com/users/rweather/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rweather/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "db53b3321aab27bed662553128bc055cca1bea49",
            "url": "https://api.github.com/repos/rweather/noise-java/commits/db53b3321aab27bed662553128bc055cca1bea49",
            "html_url": "https://github.com/rweather/noise-java/commit/db53b3321aab27bed662553128bc055cca1bea49"
        }
    ],
    "stats": {
        "total": 281,
        "additions": 275,
        "deletions": 6
    },
    "files": [
        {
            "sha": "82e820dc50efdcc071ec83788b5a2fd87236caf5",
            "filename": "NoiseJava/src/com/southernstorm/noise/protocol/AESGCMFallbackCipherState.java",
            "status": "added",
            "additions": 267,
            "deletions": 0,
            "changes": 267,
            "blob_url": "https://github.com/rweather/noise-java/blob/0d93e22b4180cd1fa889d543c548b8b0264f8cdf/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FAESGCMFallbackCipherState.java",
            "raw_url": "https://github.com/rweather/noise-java/raw/0d93e22b4180cd1fa889d543c548b8b0264f8cdf/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FAESGCMFallbackCipherState.java",
            "contents_url": "https://api.github.com/repos/rweather/noise-java/contents/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FAESGCMFallbackCipherState.java?ref=0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
            "patch": "@@ -0,0 +1,267 @@\n+/*\n+ * Copyright (C) 2016 Southern Storm Software, Pty Ltd.\n+ *\n+ * Permission is hereby granted, free of charge, to any person obtaining a\n+ * copy of this software and associated documentation files (the \"Software\"),\n+ * to deal in the Software without restriction, including without limitation\n+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,\n+ * and/or sell copies of the Software, and to permit persons to whom the\n+ * Software is furnished to do so, subject to the following conditions:\n+ *\n+ * The above copyright notice and this permission notice shall be included\n+ * in all copies or substantial portions of the Software.\n+ *\n+ * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n+ * OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+ * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+ * DEALINGS IN THE SOFTWARE.\n+ */\n+\n+package com.southernstorm.noise.protocol;\n+\n+import java.util.Arrays;\n+\n+import javax.crypto.BadPaddingException;\n+import javax.crypto.ShortBufferException;\n+\n+import com.southernstorm.noise.crypto.GHASH;\n+import com.southernstorm.noise.crypto.RijndaelAES;\n+\n+/**\n+ * Fallback implementation of \"AESGCM\" on platforms where\n+ * the JCA/JCE does not have a suitable GCM or CTR provider.\n+ */\n+class AESGCMFallbackCipherState implements CipherState {\n+\n+\tprivate RijndaelAES aes;\n+\tprivate long n;\n+\tprivate byte[] iv;\n+\tprivate byte[] enciv;\n+\tprivate byte[] hashKey;\n+\tprivate GHASH ghash;\n+\tprivate boolean haskey;\n+\n+\t/**\n+\t * Constructs a new cipher state for the \"AESGCM\" algorithm.\n+\t */\n+\tpublic AESGCMFallbackCipherState()\n+\t{\n+\t\taes = new RijndaelAES();\n+\t\tn = 0;\n+\t\tiv = new byte [16];\n+\t\tenciv = new byte [16];\n+\t\thashKey = new byte [16];\n+\t\tghash = new GHASH();\n+\t\thaskey = false;\n+\t}\n+\n+\t@Override\n+\tpublic void destroy() {\n+\t\taes.destroy();\n+\t\tghash.destroy();\n+\t\tNoise.destroy(hashKey);\n+\t\tNoise.destroy(iv);\n+\t\tNoise.destroy(enciv);\n+\t}\n+\n+\t@Override\n+\tpublic String getCipherName() {\n+\t\treturn \"AESGCM\";\n+\t}\n+\n+\t@Override\n+\tpublic int getKeyLength() {\n+\t\treturn 32;\n+\t}\n+\n+\t@Override\n+\tpublic int getMACLength() {\n+\t\treturn haskey ? 16 : 0;\n+\t}\n+\n+\t@Override\n+\tpublic void initializeKey(byte[] key, int offset) {\n+\t\t// Set up the AES key.\n+\t\taes.setupEnc(key, offset, 256);\n+\t\thaskey = true;\n+\n+\t\t// Generate the hashing key by encrypting a block of zeroes.\n+\t\tArrays.fill(hashKey, (byte)0);\n+\t\taes.encrypt(hashKey, 0, hashKey, 0);\n+\t\tghash.reset(hashKey, 0);\n+\t\t\n+\t\t// Reset the nonce.\n+\t\tn = 0;\n+\t}\n+\n+\t@Override\n+\tpublic boolean hasKey() {\n+\t\treturn haskey;\n+\t}\n+\t\n+\t/**\n+\t * Set up to encrypt or decrypt the next packet.\n+\t * \n+\t * @param ad The associated data for the packet.\n+\t */\n+\tprivate void setup(byte[] ad)\n+\t{\n+\t\t// Check for nonce wrap-around.\n+\t\tif (n < 0)\n+\t\t\tthrow new IllegalStateException(\"Nonce has wrapped around\");\n+\t\t\n+\t\t// Format the counter/IV block.\n+\t\tiv[0] = 0;\n+\t\tiv[1] = 0;\n+\t\tiv[2] = 0;\n+\t\tiv[3] = 0;\n+\t\tiv[4] = (byte)(n >> 56);\n+\t\tiv[5] = (byte)(n >> 48);\n+\t\tiv[6] = (byte)(n >> 40);\n+\t\tiv[7] = (byte)(n >> 32);\n+\t\tiv[8] = (byte)(n >> 24);\n+\t\tiv[9] = (byte)(n >> 16);\n+\t\tiv[10] = (byte)(n >> 8);\n+\t\tiv[11] = (byte)n;\n+\t\tiv[12] = 0;\n+\t\tiv[13] = 0;\n+\t\tiv[14] = 0;\n+\t\tiv[15] = 1;\n+\t\t++n;\n+\t\t\n+\t\t// Encrypt a block of zeroes to generate the hash key to XOR\n+\t\t// the GHASH tag with at the end of the encrypt/decrypt operation.\n+\t\tArrays.fill(hashKey, (byte)0);\n+\t\taes.encrypt(iv, 0, hashKey, 0);\n+\t\t\n+\t\t// Initialize the GHASH with the associated data value.\n+\t\tghash.reset();\n+\t\tif (ad != null) {\n+\t\t\tghash.update(ad, 0, ad.length);\n+\t\t\tghash.pad();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Encrypts a block in CTR mode.\n+\t * \n+\t * @param plaintext The plaintext to encrypt.\n+\t * @param plaintextOffset Offset of the first plaintext byte.\n+\t * @param ciphertext The resulting ciphertext.\n+\t * @param ciphertextOffset Offset of the first ciphertext byte.\n+\t * @param length The number of bytes to encrypt.\n+\t * \n+\t * This function can also be used to decrypt.\n+\t */\n+\tprivate void encryptCTR(byte[] plaintext, int plaintextOffset, byte[] ciphertext, int ciphertextOffset, int length)\n+\t{\n+\t\twhile (length > 0) {\n+\t\t\t// Increment the IV and encrypt it to get the next keystream block.\n+\t\t\tif (++(iv[15]) == 0)\n+\t\t\t\tif (++(iv[14]) == 0)\n+\t\t\t\t\tif (++(iv[13]) == 0)\n+\t\t\t\t\t\t++(iv[12]);\n+\t\t\taes.encrypt(iv, 0, enciv, 0);\n+\t\t\t\n+\t\t\t// XOR the keystream block with the plaintext to create the ciphertext.\n+\t\t\tint temp = length;\n+\t\t\tif (temp > 16)\n+\t\t\t\ttemp = 16;\n+\t\t\tfor (int index = 0; index < temp; ++index)\n+\t\t\t\tciphertext[ciphertextOffset + index] = (byte)(plaintext[plaintextOffset + index] ^ enciv[index]);\n+\t\t\t\n+\t\t\t// Advance to the next block.\n+\t\t\tplaintextOffset += temp;\n+\t\t\tciphertextOffset += temp;\n+\t\t\tlength -= temp;\n+\t\t}\n+\t}\n+\n+\t@Override\n+\tpublic int encryptWithAd(byte[] ad, byte[] plaintext, int plaintextOffset,\n+\t\t\tbyte[] ciphertext, int ciphertextOffset, int length)\n+\t\t\tthrows ShortBufferException {\n+\t\tint space;\n+\t\tif (ciphertextOffset > ciphertext.length)\n+\t\t\tspace = 0;\n+\t\telse\n+\t\t\tspace = ciphertext.length - ciphertextOffset;\n+\t\tif (!haskey) {\n+\t\t\t// The key is not set yet - return the plaintext as-is.\n+\t\t\tif (length > space)\n+\t\t\t\tthrow new ShortBufferException();\n+\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n+\t\t\t\tSystem.arraycopy(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n+\t\t\treturn length;\n+\t\t}\n+\t\tif (space < 16 || length > (space - 16))\n+\t\t\tthrow new ShortBufferException();\n+\t\tsetup(ad);\n+\t\tencryptCTR(plaintext, plaintextOffset, ciphertext, ciphertextOffset, length);\n+\t\tghash.update(ciphertext, ciphertextOffset, length);\n+\t\tghash.pad(ad != null ? ad.length : 0, length);\n+\t\tghash.finish(ciphertext, ciphertextOffset + length, 16);\n+\t\tfor (int index = 0; index < 16; ++index)\n+\t\t\tciphertext[ciphertextOffset + length + index] ^= hashKey[index];\n+\t\treturn length + 16;\n+\t}\n+\n+\t@Override\n+\tpublic int decryptWithAd(byte[] ad, byte[] ciphertext,\n+\t\t\tint ciphertextOffset, byte[] plaintext, int plaintextOffset,\n+\t\t\tint length) throws ShortBufferException, BadPaddingException {\n+\t\tint space;\n+\t\tif (ciphertextOffset > ciphertext.length)\n+\t\t\tspace = 0;\n+\t\telse\n+\t\t\tspace = ciphertext.length - ciphertextOffset;\n+\t\tif (length > space)\n+\t\t\tthrow new ShortBufferException();\n+\t\tif (plaintextOffset > plaintext.length)\n+\t\t\tspace = 0;\n+\t\telse\n+\t\t\tspace = plaintext.length - plaintextOffset;\n+\t\tif (!haskey) {\n+\t\t\t// The key is not set yet - return the ciphertext as-is.\n+\t\t\tif (length > space)\n+\t\t\t\tthrow new ShortBufferException();\n+\t\t\tif (plaintext != ciphertext || plaintextOffset != ciphertextOffset)\n+\t\t\t\tSystem.arraycopy(ciphertext, ciphertextOffset, plaintext, plaintextOffset, length);\n+\t\t\treturn length;\n+\t\t}\n+\t\tif (length < 16)\n+\t\t\tNoise.throwBadTagException();\n+\t\tint dataLen = length - 16;\n+\t\tif (dataLen > space)\n+\t\t\tthrow new ShortBufferException();\n+\t\tsetup(ad);\n+\t\tghash.update(ciphertext, ciphertextOffset, dataLen);\n+\t\tghash.pad(ad != null ? ad.length : 0, dataLen);\n+\t\tghash.finish(enciv, 0, 16);\n+\t\tint temp = 0;\n+\t\tfor (int index = 0; index < 16; ++index)\n+\t\t\ttemp |= (hashKey[index] ^ enciv[index] ^ ciphertext[ciphertextOffset + dataLen + index]);\n+\t\tif ((temp & 0xFF) != 0)\n+\t\t\tNoise.throwBadTagException();\n+\t\tencryptCTR(ciphertext, ciphertextOffset, plaintext, plaintextOffset, dataLen);\n+\t\treturn dataLen;\n+\t}\n+\n+\t@Override\n+\tpublic CipherState fork(byte[] key, int offset) {\n+\t\tCipherState cipher;\n+\t\tcipher = new AESGCMFallbackCipherState();\n+\t\tcipher.initializeKey(key, offset);\n+\t\treturn cipher;\n+\t}\n+\n+\t@Override\n+\tpublic void setNonce(long nonce) {\n+\t\tif (nonce < n)\n+\t\t\tthrow new IllegalArgumentException(\"Nonce values cannot go backwards\");\n+\t\tn = nonce;\n+\t}\n+}"
        },
        {
            "sha": "663601e34529bc33977cd2b2ede5e1a114792106",
            "filename": "NoiseJava/src/com/southernstorm/noise/protocol/Noise.java",
            "status": "modified",
            "additions": 8,
            "deletions": 6,
            "changes": 14,
            "blob_url": "https://github.com/rweather/noise-java/blob/0d93e22b4180cd1fa889d543c548b8b0264f8cdf/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FNoise.java",
            "raw_url": "https://github.com/rweather/noise-java/raw/0d93e22b4180cd1fa889d543c548b8b0264f8cdf/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FNoise.java",
            "contents_url": "https://api.github.com/repos/rweather/noise-java/contents/NoiseJava%2Fsrc%2Fcom%2Fsouthernstorm%2Fnoise%2Fprotocol%2FNoise.java?ref=0d93e22b4180cd1fa889d543c548b8b0264f8cdf",
            "patch": "@@ -88,18 +88,20 @@ public static DHState createDH(String name) throws NoSuchAlgorithmException\n \tpublic static CipherState createCipher(String name) throws NoSuchAlgorithmException\n \t{\n \t\tif (name.equals(\"AESGCM\")) {\n-\t\t\ttry {\n-\t\t\t\treturn new AESGCMCipherState();\n-\t\t\t} catch (NoSuchAlgorithmException e) {\n+\t\t\t// AESGCMCipherState doesn't seem to work yet - FIXME.\n+\t\t\t//try {\n+\t\t\t//\treturn new AESGCMCipherState();\n+\t\t\t//} catch (NoSuchAlgorithmException e) {\n \t\t\t\t// The JCA/JCE does not have \"AES/GCM/NoPadding\" so try\n \t\t\t\t// emulating it on top of \"AES/CTR/NoPadding\" instead.\n \t\t\t\ttry {\n \t\t\t\t\treturn new AESGCMOnCtrCipherState();\n \t\t\t\t} catch (NoSuchAlgorithmException e1) {\n-\t\t\t\t\t// Re-throw the original \"GCM not found\" exception\".\n-\t\t\t\t\tthrow e;\n+\t\t\t\t\t// Could not find anything useful in the JCA/JCE so\n+\t\t\t\t\t// use the pure Java fallback implementation instead.\n+\t\t\t\t\treturn new AESGCMFallbackCipherState();\n \t\t\t\t}\n-\t\t\t}\n+\t\t\t//}\n \t\t} else if (name.equals(\"ChaChaPoly\")) {\n \t\t\treturn new ChaChaPolyCipherState();\n \t\t}"
        }
    ]
}
{
    "sha": "0957b8404e1ecfc5703d7c2827752773b7dc23be",
    "node_id": "MDY6Q29tbWl0MTYwOTk5OjA5NTdiODQwNGUxZWNmYzU3MDNkN2MyODI3NzUyNzczYjdkYzIzYmU=",
    "commit": {
        "author": {
            "name": "Mahadev Konar",
            "email": "mahadev@apache.org",
            "date": "2009-10-30T16:19:13Z"
        },
        "committer": {
            "name": "Mahadev Konar",
            "email": "mahadev@apache.org",
            "date": "2009-10-30T16:19:13Z"
        },
        "message": "ZOOKEEPER-549. Refactor Followers and related classes into a Peer->Follower hierarchy in preparation for Observers (henry robinson via mahadev)\n\ngit-svn-id: https://svn.apache.org/repos/asf/hadoop/zookeeper/trunk@831371 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "a715eee6ff7e9c45eae00a4094e40db63b32fac7",
            "url": "https://api.github.com/repos/apache/zookeeper/git/trees/a715eee6ff7e9c45eae00a4094e40db63b32fac7"
        },
        "url": "https://api.github.com/repos/apache/zookeeper/git/commits/0957b8404e1ecfc5703d7c2827752773b7dc23be",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/zookeeper/commits/0957b8404e1ecfc5703d7c2827752773b7dc23be",
    "html_url": "https://github.com/apache/zookeeper/commit/0957b8404e1ecfc5703d7c2827752773b7dc23be",
    "comments_url": "https://api.github.com/repos/apache/zookeeper/commits/0957b8404e1ecfc5703d7c2827752773b7dc23be/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "e9a7606bb0198f28ec9d9e5a3072d5f18b73b877",
            "url": "https://api.github.com/repos/apache/zookeeper/commits/e9a7606bb0198f28ec9d9e5a3072d5f18b73b877",
            "html_url": "https://github.com/apache/zookeeper/commit/e9a7606bb0198f28ec9d9e5a3072d5f18b73b877"
        }
    ],
    "stats": {
        "total": 1280,
        "additions": 748,
        "deletions": 532
    },
    "files": [
        {
            "sha": "c4adc550d68f2ba1b6bafa0625fa102567c26e6e",
            "filename": "CHANGES.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/CHANGES.txt",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/CHANGES.txt",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/CHANGES.txt?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -115,6 +115,9 @@ IMPROVEMENTS:\n   ZOOKEEPER-530. Memory corruption: Zookeeper c client IPv6 implementation\n   does not honor struct sockaddr_in6 size (isabel drost via mahadev)\n \n+  ZOOKEEPER-549. Refactor Followers and related classes into a Peer->Follower\n+  hierarchy in preparation for Observers (henry robinson via mahadev)\n+\n NEW FEATURES:\n   ZOOKEEPER-539. generate eclipse project via ant target. (phunt via mahadev)\n "
        },
        {
            "sha": "a659146a49c2e58742b8ac8c0d09413774962d03",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Follower.java",
            "status": "modified",
            "additions": 63,
            "deletions": 331,
            "changes": 394,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -18,52 +18,28 @@\n \n package org.apache.zookeeper.server.quorum;\n \n-import java.io.BufferedInputStream;\n-import java.io.BufferedOutputStream;\n import java.io.ByteArrayInputStream;\n-import java.io.ByteArrayOutputStream;\n-import java.io.DataInputStream;\n-import java.io.DataOutputStream;\n import java.io.IOException;\n-import java.net.ConnectException;\n import java.net.InetSocketAddress;\n-import java.net.Socket;\n-import java.util.HashMap;\n-import java.util.Map.Entry;\n-import java.util.concurrent.ConcurrentHashMap;\n \n import org.apache.jute.BinaryInputArchive;\n-import org.apache.jute.BinaryOutputArchive;\n-import org.apache.jute.InputArchive;\n-import org.apache.jute.OutputArchive;\n import org.apache.jute.Record;\n-import org.apache.log4j.Logger;\n-import org.apache.zookeeper.server.Request;\n-import org.apache.zookeeper.server.ServerCnxn;\n-import org.apache.zookeeper.server.ZooTrace;\n-import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.util.SerializeUtils;\n-import org.apache.zookeeper.txn.SetDataTxn;\n import org.apache.zookeeper.txn.TxnHeader;\n \n /**\n  * This class has the control logic for the Follower.\n  */\n-public class Follower {\n-    private static final Logger LOG = Logger.getLogger(Follower.class);\n-\n-    static final private boolean nodelay = System.getProperty(\"follower.nodelay\", \"true\").equals(\"true\");\n-    static {\n-        LOG.info(\"TCP NoDelay set to: \" + nodelay);\n-    }\n-\n-    QuorumPeer self;\n-\n-    FollowerZooKeeperServer zk;\n+public class Follower extends Learner{\n \n+    private long lastQueued;\n+    // This is the same object as this.zk, but we cache the downcast op\n+    FollowerZooKeeperServer fzk = null;\n+    \n     Follower(QuorumPeer self,FollowerZooKeeperServer zk) {\n         this.self = self;\n         this.zk=zk;\n+        this.fzk = zk;\n     }\n \n     @Override\n@@ -76,235 +52,24 @@ public String toString() {\n         return sb.toString();\n     }\n \n-    private InputArchive leaderIs;\n-\n-    private OutputArchive leaderOs;\n-\n-    private BufferedOutputStream bufferedOutput;\n-\n-    public Socket sock;\n-\n-    /**\n-     * write a packet to the leader\n-     *\n-     * @param pp\n-     *                the proposal packet to be sent to the leader\n-     * @throws IOException\n-     */\n-    void writePacket(QuorumPacket pp, boolean flush) throws IOException {\n-        synchronized (leaderOs) {\n-            if (pp != null) {\n-                leaderOs.writeRecord(pp, \"packet\");\n-            }\n-            if (flush) {\n-                bufferedOutput.flush();\n-            }\n-        }\n-    }\n-\n-    /**\n-     * read a packet from the leader\n-     *\n-     * @param pp\n-     *                the packet to be instantiated\n-     * @throws IOException\n-     */\n-    void readPacket(QuorumPacket pp) throws IOException {\n-        synchronized (leaderIs) {\n-            leaderIs.readRecord(pp, \"packet\");\n-        }\n-        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n-        if (pp.getType() == Leader.PING) {\n-            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n-        }\n-        if (LOG.isTraceEnabled()) {\n-            ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);\n-        }\n-    }\n-\n     /**\n      * the main method called by the follower to follow the leader\n      *\n      * @throws InterruptedException\n      */\n     void followLeader() throws InterruptedException {\n-        zk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n-\n-        try {\n-            InetSocketAddress addr = null;\n-            // Find the leader by id\n-            Vote current = self.getCurrentVote();\n-            for (QuorumServer s : self.quorumPeers.values()) {\n-                if (s.id == current.id) {\n-                    addr = s.addr;\n-                    break;\n-                }\n-            }\n-            if (addr == null) {\n-                LOG.warn(\"Couldn't find the leader with id = \"\n-                        + current.id);\n-            }\n-            LOG.info(\"Following \" + addr);\n-            sock = new Socket();\n+        fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n+        try {            \n+            InetSocketAddress addr = findLeader();            \n             try {\n-                QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);\n-                sock.setSoTimeout(self.tickTime * self.initLimit);\n-                for (int tries = 0; tries < 5; tries++) {\n-                    try {\n-                        //sock = new Socket();\n-                        //sock.setSoTimeout(self.tickTime * self.initLimit);\n-                        sock.connect(addr, self.tickTime * self.syncLimit);\n-                        sock.setTcpNoDelay(nodelay);\n-                        break;\n-                    } catch (IOException e) {\n-                        if (tries == 4) {\n-                            LOG.error(\"Unexpected exception\",e);\n-                            throw e;\n-                        } else {\n-                            LOG.warn(\"Unexpected exception, tries=\"+tries,e);\n-                            sock = new Socket();\n-                            sock.setSoTimeout(self.tickTime * self.initLimit);\n-                        }\n-                    }\n-                    Thread.sleep(1000);\n-                }\n-                leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n-                        sock.getInputStream()));\n-                bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n-                leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n-                \n-                /*\n-                 * Send follower info, including last zxid and sid\n-                 */\n+                connectToLeader(addr);\n+                long newLeaderZxid = registerWithLeader(Leader.FOLLOWERINFO);\n+                syncWithLeader(newLeaderZxid);                \n                 QuorumPacket qp = new QuorumPacket();\n-                qp.setType(Leader.FOLLOWERINFO);\n-                long sentLastZxid = self.getLastLoggedZxid();\n-                qp.setZxid(sentLastZxid);\n-                \n-                /*\n-                 * Add sid to payload\n-                 */\n-                ByteArrayOutputStream bsid = new ByteArrayOutputStream();\n-                DataOutputStream dsid = new DataOutputStream(bsid);\n-                dsid.writeLong(self.getId());\n-                qp.setData(bsid.toByteArray());\n-                \n-                writePacket(qp, true);\n-                readPacket(qp);\n-                long newLeaderZxid = qp.getZxid();\n-    \n-                if (qp.getType() != Leader.NEWLEADER) {\n-                    LOG.error(\"First packet should have been NEWLEADER\");\n-                    throw new IOException(\"First packet should have been NEWLEADER\");\n-                }\n-                readPacket(qp);\n-                synchronized (zk) {\n-                    if (qp.getType() == Leader.DIFF) {\n-                        LOG.info(\"Getting a diff from the leader 0x\" + Long.toHexString(qp.getZxid()));\n-                        zk.loadData();\n-                    }\n-                    else if (qp.getType() == Leader.SNAP) {\n-                        LOG.info(\"Getting a snapshot from leader\");\n-                        // The leader is going to dump the database\n-                        zk.deserializeSnapshot(leaderIs);\n-                        String signature = leaderIs.readString(\"signature\");\n-                        if (!signature.equals(\"BenWasHere\")) {\n-                            LOG.error(\"Missing signature. Got \" + signature);\n-                            throw new IOException(\"Missing signature\");\n-                        }\n-                    } else if (qp.getType() == Leader.TRUNC) {\n-                        //we need to truncate the log to the lastzxid of the leader\n-                        LOG.warn(\"Truncating log to get in sync with the leader 0x\"\n-                                + Long.toHexString(qp.getZxid()));\n-                        boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n-                        if (!truncated) {\n-                            // not able to truncate the log\n-                            LOG.fatal(\"Not able to truncate the log \"\n-                                    + Long.toHexString(qp.getZxid()));\n-                            System.exit(13);\n-                        }\n-    \n-                        zk.loadData();\n-                    }\n-                    else {\n-                        LOG.fatal(\"Got unexpected packet from leader \"\n-                                + qp.getType() + \" exiting ... \" );\n-                        System.exit(13);\n-\n-                    }\n-                    zk.dataTree.lastProcessedZxid = newLeaderZxid;\n-                }\n-                ack.setZxid(newLeaderZxid & ~0xffffffffL);\n-                writePacket(ack, true);\n-                sock.setSoTimeout(self.tickTime * self.syncLimit);\n-                zk.startup();\n-                \n                 while (self.running) {\n                     readPacket(qp);\n-                    switch (qp.getType()) {\n-                    case Leader.PING:\n-                        // Send back the ping with our session data\n-                        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n-                        DataOutputStream dos = new DataOutputStream(bos);\n-                        HashMap<Long, Integer> touchTable = zk\n-                                .getTouchSnapshot();\n-                        for (Entry<Long, Integer> entry : touchTable.entrySet()) {\n-                            dos.writeLong(entry.getKey());\n-                            dos.writeInt(entry.getValue());\n-                        }\n-                        qp.setData(bos.toByteArray());\n-                        writePacket(qp, true);\n-                        break;\n-                    case Leader.PROPOSAL:\n-                        TxnHeader hdr = new TxnHeader();\n-                        BinaryInputArchive ia = BinaryInputArchive\n-                                .getArchive(new ByteArrayInputStream(qp.getData()));\n-                        Record txn = SerializeUtils.deserializeTxn(ia, hdr);\n-                        if (hdr.getZxid() != lastQueued + 1) {\n-                            LOG.warn(\"Got zxid 0x\"\n-                                    + Long.toHexString(hdr.getZxid())\n-                                    + \" expected 0x\"\n-                                    + Long.toHexString(lastQueued + 1));\n-                        }\n-                        lastQueued = hdr.getZxid();\n-                        zk.logRequest(hdr, txn);\n-                        break;\n-                    case Leader.COMMIT:\n-                        zk.commit(qp.getZxid());\n-                        break;\n-                    case Leader.UPTODATE:\n-                        zk.takeSnapshot();\n-                        self.cnxnFactory.setZooKeeperServer(zk);\n-                        break;\n-                    case Leader.REVALIDATE:\n-                        ByteArrayInputStream bis = new ByteArrayInputStream(qp\n-                                .getData());\n-                        DataInputStream dis = new DataInputStream(bis);\n-                        long sessionId = dis.readLong();\n-                        boolean valid = dis.readBoolean();\n-                        synchronized (pendingRevalidations) {\n-                            ServerCnxn cnxn = pendingRevalidations\n-                                    .remove(sessionId);\n-                            if (cnxn == null) {\n-                                LOG.warn(\"Missing session 0x\"\n-                                        + Long.toHexString(sessionId)\n-                                        + \" for validation\");\n-                            } else {\n-                                cnxn.finishSessionInit(valid);\n-                            }\n-                        }\n-                        if (LOG.isTraceEnabled()) {\n-                            ZooTrace.logTraceMessage(LOG,\n-                                    ZooTrace.SESSION_TRACE_MASK,\n-                                    \"Session 0x\" + Long.toHexString(sessionId)\n-                                    + \" is valid: \" + valid);\n-                        }\n-                        break;\n-                    case Leader.SYNC:\n-                        zk.sync();\n-                        break;\n-                    }\n-                }\n+                    processPacket(qp);                   \n+                }                              \n             } catch (IOException e) {\n                 LOG.warn(\"Exception when following the leader\", e);\n                 try {\n@@ -314,116 +79,83 @@ else if (qp.getType() == Leader.SNAP) {\n                 }\n     \n                 synchronized (pendingRevalidations) {\n-                    // clear pending revalitions\n+                    // clear pending revalidations\n                     pendingRevalidations.clear();\n                     pendingRevalidations.notifyAll();\n                 }\n             }\n         } finally {\n-            zk.unregisterJMX(this);\n+            zk.unregisterJMX((Learner)this);\n         }\n     }\n \n-    private long lastQueued;\n-\n-    final ConcurrentHashMap<Long, ServerCnxn> pendingRevalidations =\n-        new ConcurrentHashMap<Long, ServerCnxn>();\n-    \n-    public int getPendingRevalidationsCount() {\n-        return pendingRevalidations.size();\n-    }\n-\n     /**\n-     * validate a seesion for a client\n-     *\n-     * @param clientId\n-     *                the client to be revailidated\n-     * @param timeout\n-     *                the timeout for which the session is valid\n-     * @return\n+     * Examine the packet received in qp and dispatch based on its contents.\n+     * @param qp\n      * @throws IOException\n-     * @throws InterruptedException\n      */\n-    void validateSession(ServerCnxn cnxn, long clientId, int timeout)\n-            throws IOException, InterruptedException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        DataOutputStream dos = new DataOutputStream(baos);\n-        dos.writeLong(clientId);\n-        dos.writeInt(timeout);\n-        dos.close();\n-        QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos\n-                .toByteArray(), null);\n-        pendingRevalidations.put(clientId, cnxn);\n-        if (LOG.isTraceEnabled()) {\n-            ZooTrace.logTraceMessage(LOG,\n-                                     ZooTrace.SESSION_TRACE_MASK,\n-                                     \"To validate session 0x\"\n-                                     + Long.toHexString(clientId));\n+    protected void processPacket(QuorumPacket qp) throws IOException{\n+        switch (qp.getType()) {\n+        case Leader.PING:            \n+            ping(qp);            \n+            break;\n+        case Leader.PROPOSAL:            \n+            TxnHeader hdr = new TxnHeader();\n+            BinaryInputArchive ia = BinaryInputArchive\n+            .getArchive(new ByteArrayInputStream(qp.getData()));\n+            Record txn = SerializeUtils.deserializeTxn(ia, hdr);\n+            if (hdr.getZxid() != lastQueued + 1) {\n+                LOG.warn(\"Got zxid 0x\"\n+                        + Long.toHexString(hdr.getZxid())\n+                        + \" expected 0x\"\n+                        + Long.toHexString(lastQueued + 1));\n+            }\n+            lastQueued = hdr.getZxid();\n+            fzk.logRequest(hdr, txn);\n+            break;\n+        case Leader.COMMIT:\n+            fzk.commit(qp.getZxid());\n+            break;\n+        case Leader.UPTODATE:\n+            fzk.takeSnapshot();\n+            self.cnxnFactory.setZooKeeperServer(fzk);\n+            break;\n+        case Leader.REVALIDATE:\n+            revalidate(qp);\n+            break;\n+        case Leader.SYNC:\n+            fzk.sync();\n+            break;\n         }\n-        writePacket(qp, true);\n     }\n \n+\n     /**\n-     * send a request packet to the leader\n-     *\n-     * @param request\n-     *                the request from the client\n-     * @throws IOException\n+     * The zxid of the last operation seen\n+     * @return zxid\n      */\n-    void request(Request request) throws IOException {\n-        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n-        DataOutputStream oa = new DataOutputStream(baos);\n-        oa.writeLong(request.sessionId);\n-        oa.writeInt(request.cxid);\n-        oa.writeInt(request.type);\n-        if (request.request != null) {\n-            request.request.rewind();\n-            int len = request.request.remaining();\n-            byte b[] = new byte[len];\n-            request.request.get(b);\n-            request.request.rewind();\n-            oa.write(b);\n-        }\n-        oa.close();\n-        QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos\n-                .toByteArray(), request.authInfo);\n-//        QuorumPacket qp;\n-//        if(request.type == OpCode.sync){\n-//            qp = new QuorumPacket(Leader.SYNC, -1, baos\n-//                    .toByteArray(), request.authInfo);\n-//        }\n-//        else{\n-//        qp = new QuorumPacket(Leader.REQUEST, -1, baos\n-//                .toByteArray(), request.authInfo);\n-//        }\n-        writePacket(qp, true);\n-    }\n-\n     public long getZxid() {\n         try {\n-            synchronized (zk) {\n-                return zk.getZxid();\n+            synchronized (fzk) {\n+                return fzk.getZxid();\n             }\n         } catch (NullPointerException e) {\n             LOG.warn(\"error getting zxid\", e);\n         }\n         return -1;\n     }\n     \n-    public long getLastQueued() {\n+    /**\n+     * The zxid of the last operation queued\n+     * @return zxid\n+     */\n+    protected long getLastQueued() {\n         return lastQueued;\n     }\n \n-    public void shutdown() {\n-        // set the zookeeper server to null\n-        self.cnxnFactory.setZooKeeperServer(null);\n-        // clear all the connections\n-        self.cnxnFactory.clear();\n-        // shutdown previous zookeeper\n-        if (zk != null) {\n-            zk.shutdown();\n-\n-        }\n+    @Override\n+    public void shutdown() {    \n         LOG.info(\"shutdown called\", new Exception(\"shutdown Follower\"));\n+        super.shutdown();\n     }\n }"
        },
        {
            "sha": "675e1353185ab3673633f3be9af645c81dfe334a",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/FollowerZooKeeperServer.java",
            "status": "modified",
            "additions": 17,
            "deletions": 105,
            "changes": 122,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollowerZooKeeperServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollowerZooKeeperServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollowerZooKeeperServer.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -19,20 +19,15 @@\n package org.apache.zookeeper.server.quorum;\n \n import java.io.IOException;\n-import java.util.HashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.LinkedBlockingQueue;\n \n import org.apache.jute.Record;\n import org.apache.log4j.Logger;\n-import org.apache.zookeeper.jmx.MBeanRegistry;\n-import org.apache.zookeeper.server.DataTreeBean;\n import org.apache.zookeeper.server.FinalRequestProcessor;\n import org.apache.zookeeper.server.Request;\n import org.apache.zookeeper.server.RequestProcessor;\n-import org.apache.zookeeper.server.ServerCnxn;\n import org.apache.zookeeper.server.SyncRequestProcessor;\n-import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.persistence.FileTxnSnapLog;\n import org.apache.zookeeper.txn.TxnHeader;\n \n@@ -41,13 +36,11 @@\n  * processors: FollowerRequestProcessor -> CommitProcessor ->\n  * FinalRequestProcessor\n  * \n- * A SyncRequestProcessor is also spawn off to log proposals from the leader.\n+ * A SyncRequestProcessor is also spawned off to log proposals from the leader.\n  */\n-public class FollowerZooKeeperServer extends ZooKeeperServer {\n+public class FollowerZooKeeperServer extends LearnerZooKeeperServer {\n     private static final Logger LOG = Logger.getLogger(FollowerZooKeeperServer.class);\n \n-    private QuorumPeer self;\n-\n     CommitProcessor commitProcessor;\n \n     SyncRequestProcessor syncProcessor;\n@@ -65,19 +58,13 @@ public class FollowerZooKeeperServer extends ZooKeeperServer {\n     FollowerZooKeeperServer(FileTxnSnapLog logFactory,QuorumPeer self,\n             DataTreeBuilder treeBuilder) throws IOException {\n         super(logFactory, self.tickTime,treeBuilder);\n-        this.self = self;\n+        this.self = self;        \n         this.pendingSyncs = new ConcurrentLinkedQueue<Request>();\n     }\n \n     public Follower getFollower(){\n         return self.follower;\n-    }\n-    \n-    @Override\n-    protected void createSessionTracker() {\n-        sessionTracker = new FollowerSessionTracker(this, sessionsWithTimeouts,\n-                self.getId());\n-    }\n+    }      \n \n     @Override\n     protected void setupRequestProcessors() {\n@@ -88,28 +75,10 @@ protected void setupRequestProcessors() {\n         firstProcessor = new FollowerRequestProcessor(this, commitProcessor);\n         ((FollowerRequestProcessor) firstProcessor).start();\n         syncProcessor = new SyncRequestProcessor(this,\n-                new SendAckRequestProcessor(getFollower()));\n+                new SendAckRequestProcessor((Learner)getFollower()));\n         syncProcessor.start();\n     }\n-\n-    @Override\n-    protected void revalidateSession(ServerCnxn cnxn, long sessionId,\n-            int sessionTimeout) throws IOException, InterruptedException {\n-        getFollower().validateSession(cnxn, sessionId, sessionTimeout);\n-    }\n-\n-    public HashMap<Long, Integer> getTouchSnapshot() {\n-        if (sessionTracker != null) {\n-            return ((FollowerSessionTracker) sessionTracker).snapshot();\n-        }\n-        return new HashMap<Long, Integer>();\n-    }\n-\n-    @Override\n-    public long getServerId() {\n-        return self.getId();\n-    }\n-\n+    \n     LinkedBlockingQueue<Request> pendingTxns = new LinkedBlockingQueue<Request>();\n \n     public void logRequest(TxnHeader hdr, Record txn) {\n@@ -124,6 +93,12 @@ public void logRequest(TxnHeader hdr, Record txn) {\n         syncProcessor.processRequest(request);\n     }\n \n+    /**\n+     * When a COMMIT message is received, eventually this method is called, \n+     * which matches up the zxid from the COMMIT with (hopefully) the head of\n+     * the pendingTxns queue and hands it to the commitProcessor to commit.\n+     * @param zxid - must correspond to the head of pendingTxns if it exists\n+     */\n     public void commit(long zxid) {\n         if (pendingTxns.size() == 0) {\n             LOG.warn(\"Committing \" + Long.toHexString(zxid)\n@@ -155,14 +130,6 @@ synchronized public void sync(){\n     public int getGlobalOutstandingLimit() {\n         return super.getGlobalOutstandingLimit() / (self.getQuorumSize() - 1);\n     }\n-\n-    /**\n-     * Do not do anything in the follower.\n-     */\n-    @Override\n-    public void addCommittedProposal(Request r) {\n-        //do nothing\n-    }\n     \n     @Override\n     public void shutdown() {\n@@ -180,69 +147,14 @@ public void shutdown() {\n                     e);\n         }\n     }\n-\n-\n-    @Override\n-    protected void registerJMX() {\n-        // register with JMX\n-        try {\n-            jmxDataTreeBean = new DataTreeBean(dataTree);\n-            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to register with JMX\", e);\n-            jmxDataTreeBean = null;\n-        }\n-    }\n-\n-    public void registerJMX(FollowerBean followerBean,\n-            LocalPeerBean localPeerBean)\n-    {\n-        // register with JMX\n-        if (self.jmxLeaderElectionBean != null) {\n-            try {\n-                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n-            } catch (Exception e) {\n-                LOG.warn(\"Failed to register with JMX\", e);\n-            }\n-            self.jmxLeaderElectionBean = null;\n-        }\n-\n-        try {\n-            jmxServerBean = followerBean;\n-            MBeanRegistry.getInstance().register(followerBean, localPeerBean);\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to register with JMX\", e);\n-            jmxServerBean = null;\n-        }\n-    }\n-\n-    @Override\n-    protected void unregisterJMX() {\n-        // unregister from JMX\n-        try {\n-            if (jmxDataTreeBean != null) {\n-                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to unregister with JMX\", e);\n-        }\n-        jmxDataTreeBean = null;\n-    }\n-\n-    protected void unregisterJMX(Follower follower) {\n-        // unregister from JMX\n-        try {\n-            if (jmxServerBean != null) {\n-                MBeanRegistry.getInstance().unregister(jmxServerBean);\n-            }\n-        } catch (Exception e) {\n-            LOG.warn(\"Failed to unregister with JMX\", e);\n-        }\n-        jmxServerBean = null;\n-    }\n     \n     @Override\n     public String getState() {\n         return \"follower\";\n     }\n+\n+    @Override\n+    public Learner getLearner() {\n+        return getFollower();\n+    }\n }"
        },
        {
            "sha": "e23322ac97997aeb0db870e9ae82c328e4933b1d",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Leader.java",
            "status": "modified",
            "additions": 42,
            "deletions": 41,
            "changes": 83,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -72,48 +72,48 @@ public String toString() {\n     QuorumPeer self;\n \n     // the follower acceptor thread\n-    FollowerCnxAcceptor cnxAcceptor;\n+    LearnerCnxAcceptor cnxAcceptor;\n     \n     // list of all the followers\n-    public HashSet<FollowerHandler> followers = new HashSet<FollowerHandler>();\n+    public HashSet<LearnerHandler> learners = new HashSet<LearnerHandler>();\n \n-    // list of followers that are ready to follow (i.e synced with the leader)\n-    public HashSet<FollowerHandler> forwardingFollowers = new HashSet<FollowerHandler>();\n-    \n+    // list of followers that are ready to follow (i.e synced with the leader)    \n+    public HashSet<LearnerHandler> forwardingFollowers = new HashSet<LearnerHandler>();\n+        \n     //Pending sync requests\n-    public HashMap<Long,List<FollowerSyncRequest>> pendingSyncs = new HashMap<Long,List<FollowerSyncRequest>>();\n+    public HashMap<Long,List<LearnerSyncRequest>> pendingSyncs = new HashMap<Long,List<LearnerSyncRequest>>();\n     \n     //Follower counter\n     AtomicLong followerCounter = new AtomicLong(-1);\n     /**\n-     * Adds follower to the leader.\n+     * Adds peer to the leader.\n      * \n-     * @param follower\n-     *                instance of follower handle\n+     * @param learner\n+     *                instance of learner handle\n      */\n-    void addFollowerHandler(FollowerHandler follower) {\n-        synchronized (followers) {\n-            followers.add(follower);\n+    void addLearnerHandler(LearnerHandler learner) {\n+        synchronized (learners) {\n+            learners.add(learner);\n         }\n     }\n \n     /**\n-     * Remove the follower from the followers list\n+     * Remove the learner from the learner list\n      * \n-     * @param follower\n+     * @param peer\n      */\n-    void removeFollowerHandler(FollowerHandler follower) {\n+    void removeLearnerHandler(LearnerHandler peer) {\n         synchronized (forwardingFollowers) {\n-            forwardingFollowers.remove(follower);\n-        }\n-        synchronized (followers) {\n-            followers.remove(follower);\n+            forwardingFollowers.remove(peer);            \n+        }        \n+        synchronized (learners) {\n+            learners.remove(peer);\n         }\n     }\n \n-    boolean isFollowerSynced(FollowerHandler follower){\n+    boolean isLearnerSynced(LearnerHandler peer){\n         synchronized (forwardingFollowers) {\n-            return forwardingFollowers.contains(follower);\n+            return forwardingFollowers.contains(peer);\n         }        \n     }\n     \n@@ -209,18 +209,18 @@ boolean isFollowerSynced(FollowerHandler follower){\n \n     Proposal newLeaderProposal = new Proposal();\n     \n-    class FollowerCnxAcceptor extends Thread{\n+    class LearnerCnxAcceptor extends Thread{\n         private volatile boolean stop = false;\n         \n         @Override\n         public void run() {\n             try {\n                 while (!stop) {\n                     try{\n-                        Socket s = ss.accept();\n+                        Socket s = ss.accept();                        \n                         s.setSoTimeout(self.tickTime * self.syncLimit);\n                         s.setTcpNoDelay(nodelay);\n-                        FollowerHandler fh = new FollowerHandler(s, Leader.this);\n+                        LearnerHandler fh = new LearnerHandler(s, Leader.this);\n                         fh.start();\n                     } catch (SocketException e) {\n                         if (stop) {\n@@ -267,9 +267,10 @@ void lead() throws IOException, InterruptedException {\n             synchronized(this){\n                 lastProposed = zk.getZxid();\n             }\n-            \n+                      \n             newLeaderProposal.packet = new QuorumPacket(NEWLEADER, zk.getZxid(),\n-                    null, null);\n+                    null, null);            \n+\n             if ((newLeaderProposal.packet.getZxid() & 0xffffffffL) != 0) {\n                 LOG.info(\"NEWLEADER proposal has Zxid of \"\n                         + Long.toHexString(newLeaderProposal.packet.getZxid()));\n@@ -278,7 +279,7 @@ void lead() throws IOException, InterruptedException {\n             \n             // Start thread that waits for connection requests from \n             // new followers.\n-            cnxAcceptor = new FollowerCnxAcceptor();\n+            cnxAcceptor = new LearnerCnxAcceptor();\n             cnxAcceptor.start();\n             \n             // We have to get at least a majority of servers in sync with\n@@ -296,7 +297,7 @@ void lead() throws IOException, InterruptedException {\n                     \n                     shutdown(\"Waiting for a quorum of followers, only synced with: \" + ackToString);\n                     HashSet<Long> followerSet = new HashSet<Long>();\n-                    for(FollowerHandler f : followers)\n+                    for(LearnerHandler f : learners)\n                         followerSet.add(f.getSid());\n                     \n                     if (self.getQuorumVerifier().containsQuorum(followerSet)) {\n@@ -333,8 +334,8 @@ void lead() throws IOException, InterruptedException {\n                 \n                 // lock on the followers when we use it.\n                 syncedSet.add(self.getId());\n-                synchronized (followers) {\n-                    for (FollowerHandler f : followers) {\n+                synchronized (learners) {\n+                    for (LearnerHandler f : learners) {\n                         if (f.synced()) {\n                             syncedCount++;\n                             syncedSet.add(f.getSid());\n@@ -388,10 +389,10 @@ void shutdown(String reason) {\n         } catch (IOException e) {\n             LOG.warn(\"Ignoring unexpected exception during close\",e);\n         }\n-        synchronized (followers) {\n-            for (Iterator<FollowerHandler> it = followers.iterator(); it\n+        synchronized (learners) {\n+            for (Iterator<LearnerHandler> it = learners.iterator(); it\n                     .hasNext();) {\n-                FollowerHandler f = it.next();\n+                LearnerHandler f = it.next();\n                 it.remove();\n                 f.shutdown();\n             }\n@@ -466,7 +467,7 @@ synchronized public void processAck(long sid, long zxid, SocketAddress followerA\n                 commit(zxid);\n                 zk.commitProcessor.commit(p.request);\n                 if(pendingSyncs.containsKey(zxid)){\n-                    for(FollowerSyncRequest r: pendingSyncs.remove(zxid)) {\n+                    for(LearnerSyncRequest r: pendingSyncs.remove(zxid)) {\n                         sendSync(r);\n                     }\n                 }\n@@ -538,12 +539,12 @@ public void shutdown() {\n      */\n     void sendPacket(QuorumPacket qp) {\n         synchronized (forwardingFollowers) {\n-            for (FollowerHandler f : forwardingFollowers) {\n+            for (LearnerHandler f : forwardingFollowers) {                \n                 f.queuePacket(qp);\n             }\n         }\n     }\n-\n+    \n     long lastCommitted = -1;\n \n     /**\n@@ -604,13 +605,13 @@ public Proposal propose(Request request) {\n      * @param r the request\n      */\n     \n-    synchronized public void processSync(FollowerSyncRequest r){\n+    synchronized public void processSync(LearnerSyncRequest r){\n         if(outstandingProposals.isEmpty()){\n             sendSync(r);\n         } else {\n-            List<FollowerSyncRequest> l = pendingSyncs.get(lastProposed);\n+            List<LearnerSyncRequest> l = pendingSyncs.get(lastProposed);\n             if (l == null) {\n-                l = new ArrayList<FollowerSyncRequest>();\n+                l = new ArrayList<LearnerSyncRequest>();\n             }\n             l.add(r);\n             pendingSyncs.put(lastProposed, l);\n@@ -624,7 +625,7 @@ synchronized public void processSync(FollowerSyncRequest r){\n      * @param r\n      */\n             \n-    public void sendSync(FollowerSyncRequest r){\n+    public void sendSync(LearnerSyncRequest r){\n         QuorumPacket qp = new QuorumPacket(Leader.SYNC, 0, null, null);\n         r.fh.queuePacket(qp);\n     }\n@@ -636,7 +637,7 @@ public void sendSync(FollowerSyncRequest r){\n      * @param handler handler of the follower\n      * @return last proposed zxid\n      */\n-    synchronized public long startForwarding(FollowerHandler handler,\n+    synchronized public long startForwarding(LearnerHandler handler,\n             long lastSeenZxid) {\n         // Queue up any outstanding requests enabling the receipt of\n         // new requests"
        },
        {
            "sha": "1c8c303e6f3a2305c34b5f2a72ea456ebc848422",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LeaderBean.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderBean.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderBean.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeaderBean.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -20,7 +20,7 @@\n \n import org.apache.zookeeper.server.ZooKeeperServerBean;\n import org.apache.zookeeper.server.ZooKeeperServer;\n-import org.apache.zookeeper.server.quorum.FollowerHandler;\n+import org.apache.zookeeper.server.quorum.LearnerHandler;\n import org.apache.zookeeper.server.quorum.Leader;\n \n /**\n@@ -44,7 +44,7 @@ public String getCurrentZxid() {\n     \n     public String followerInfo() {\n         StringBuffer sb = new StringBuffer();\n-        for (FollowerHandler handler : leader.followers) {\n+        for (LearnerHandler handler : leader.learners) {\n             sb.append(handler.toString()).append(\"\\n\");\n         }\n         return sb.toString();"
        },
        {
            "sha": "b079b9d2b301e41eaa2501259eae4f2df1ff4a23",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Learner.java",
            "status": "added",
            "additions": 375,
            "deletions": 0,
            "changes": 375,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -0,0 +1,375 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.ConnectException;\n+import java.net.InetSocketAddress;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.Map.Entry;\n+import java.util.concurrent.ConcurrentHashMap;\n+\n+import org.apache.jute.BinaryInputArchive;\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.jute.InputArchive;\n+import org.apache.jute.OutputArchive;\n+import org.apache.log4j.Logger;\n+import org.apache.zookeeper.server.Request;\n+import org.apache.zookeeper.server.ServerCnxn;\n+import org.apache.zookeeper.server.ZooTrace;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n+\n+/**\n+ * This class is the superclass of two of the three main actors in a ZK\n+ * ensemble: Followers and Observers. Both Followers and Observers share \n+ * a good deal of code which is moved into Peer to avoid duplication. \n+ */\n+public class Learner {       \n+    QuorumPeer self;\n+    LearnerZooKeeperServer zk;\n+    \n+    protected BufferedOutputStream bufferedOutput;\n+    \n+    protected Socket sock;\n+    \n+    /**\n+     * Socket getter\n+     * @return \n+     */\n+    public Socket getSocket() {\n+        return sock;\n+    }\n+    \n+    protected InputArchive leaderIs;\n+    protected OutputArchive leaderOs;    \n+    \n+    protected static final Logger LOG = Logger.getLogger(Learner.class);\n+\n+    static final private boolean nodelay = System.getProperty(\"follower.nodelay\", \"true\").equals(\"true\");\n+    static {\n+        LOG.info(\"TCP NoDelay set to: \" + nodelay);\n+    }   \n+    \n+    final ConcurrentHashMap<Long, ServerCnxn> pendingRevalidations =\n+        new ConcurrentHashMap<Long, ServerCnxn>();\n+    \n+    public int getPendingRevalidationsCount() {\n+        return pendingRevalidations.size();\n+    }\n+    \n+    /**\n+     * validate a session for a client\n+     *\n+     * @param clientId\n+     *                the client to be revalidated\n+     * @param timeout\n+     *                the timeout for which the session is valid\n+     * @return\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    void validateSession(ServerCnxn cnxn, long clientId, int timeout)\n+            throws IOException, InterruptedException {\n+        LOG.info(\"Revalidating client: \" + clientId);\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(baos);\n+        dos.writeLong(clientId);\n+        dos.writeInt(timeout);\n+        dos.close();\n+        QuorumPacket qp = new QuorumPacket(Leader.REVALIDATE, -1, baos\n+                .toByteArray(), null);\n+        pendingRevalidations.put(clientId, cnxn);\n+        if (LOG.isTraceEnabled()) {\n+            ZooTrace.logTraceMessage(LOG,\n+                                     ZooTrace.SESSION_TRACE_MASK,\n+                                     \"To validate session 0x\"\n+                                     + Long.toHexString(clientId));\n+        }\n+        writePacket(qp, true);\n+    }     \n+    \n+    /**\n+     * write a packet to the leader\n+     *\n+     * @param pp\n+     *                the proposal packet to be sent to the leader\n+     * @throws IOException\n+     */\n+    void writePacket(QuorumPacket pp, boolean flush) throws IOException {\n+        synchronized (leaderOs) {\n+            if (pp != null) {\n+                leaderOs.writeRecord(pp, \"packet\");\n+            }\n+            if (flush) {\n+                bufferedOutput.flush();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * read a packet from the leader\n+     *\n+     * @param pp\n+     *                the packet to be instantiated\n+     * @throws IOException\n+     */\n+    void readPacket(QuorumPacket pp) throws IOException {\n+        synchronized (leaderIs) {\n+            leaderIs.readRecord(pp, \"packet\");\n+        }\n+        long traceMask = ZooTrace.SERVER_PACKET_TRACE_MASK;\n+        if (pp.getType() == Leader.PING) {\n+            traceMask = ZooTrace.SERVER_PING_TRACE_MASK;\n+        }\n+        if (LOG.isTraceEnabled()) {\n+            ZooTrace.logQuorumPacket(LOG, traceMask, 'i', pp);\n+        }\n+    }\n+    \n+    /**\n+     * send a request packet to the leader\n+     *\n+     * @param request\n+     *                the request from the client\n+     * @throws IOException\n+     */\n+    void request(Request request) throws IOException {\n+        ByteArrayOutputStream baos = new ByteArrayOutputStream();\n+        DataOutputStream oa = new DataOutputStream(baos);\n+        oa.writeLong(request.sessionId);\n+        oa.writeInt(request.cxid);\n+        oa.writeInt(request.type);\n+        if (request.request != null) {\n+            request.request.rewind();\n+            int len = request.request.remaining();\n+            byte b[] = new byte[len];\n+            request.request.get(b);\n+            request.request.rewind();\n+            oa.write(b);\n+        }\n+        oa.close();\n+        QuorumPacket qp = new QuorumPacket(Leader.REQUEST, -1, baos\n+                .toByteArray(), request.authInfo);\n+        writePacket(qp, true);\n+    }\n+    \n+    /**\n+     * Returns the address of the node we think is the leader.\n+     */\n+    protected InetSocketAddress findLeader() {\n+        InetSocketAddress addr = null;\n+        // Find the leader by id\n+        Vote current = self.getCurrentVote();\n+        for (QuorumServer s : self.getView().values()) {\n+            if (s.id == current.id) {\n+                addr = s.addr;\n+                break;\n+            }\n+        }\n+        if (addr == null) {\n+            LOG.warn(\"Couldn't find the leader with id = \"\n+                    + current.id);\n+        }\n+        return addr;\n+    }\n+    \n+    /**\n+     * Establish a connection with the Leader found by findLeader. Retries\n+     * 5 times before giving up. \n+     * @param addr - the address of the Leader to connect to.\n+     * @throws IOException - if the socket connection fails on the 5th attempt\n+     * @throws ConnectException\n+     * @throws InterruptedException\n+     */\n+    protected void connectToLeader(InetSocketAddress addr) \n+    throws IOException, ConnectException, InterruptedException {\n+        sock = new Socket();        \n+        sock.setSoTimeout(self.tickTime * self.initLimit);\n+        for (int tries = 0; tries < 5; tries++) {\n+            try {\n+                sock.connect(addr, self.tickTime * self.syncLimit);\n+                sock.setTcpNoDelay(nodelay);\n+                break;\n+            } catch (IOException e) {\n+                if (tries == 4) {\n+                    LOG.error(\"Unexpected exception\",e);\n+                    throw e;\n+                } else {\n+                    LOG.warn(\"Unexpected exception, tries=\"+tries+\n+                            \", connecting to \" + addr,e);\n+                    sock = new Socket();\n+                    sock.setSoTimeout(self.tickTime * self.initLimit);\n+                }\n+            }\n+            Thread.sleep(1000);\n+        }\n+        leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n+                sock.getInputStream()));\n+        bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n+        leaderOs = BinaryOutputArchive.getArchive(bufferedOutput);\n+    }   \n+    \n+    /**\n+     * Once connected to the leader, perform the handshake protocol to\n+     * establish a following / observing connection. \n+     * @param pktType\n+     * @return the zxid the Leader sends for synchronization purposes.\n+     * @throws IOException\n+     */\n+    protected long registerWithLeader(int pktType) throws IOException{\n+        /*\n+         * Send follower info, including last zxid and sid\n+         */\n+        QuorumPacket qp = new QuorumPacket();                \n+        qp.setType(pktType);\n+        long sentLastZxid = self.getLastLoggedZxid();\n+        qp.setZxid(sentLastZxid);\n+        \n+        /*\n+         * Add sid to payload\n+         */\n+        ByteArrayOutputStream bsid = new ByteArrayOutputStream();\n+        DataOutputStream dsid = new DataOutputStream(bsid);\n+        dsid.writeLong(self.getId());\n+        qp.setData(bsid.toByteArray());\n+        \n+        writePacket(qp, true);\n+        readPacket(qp);        \n+\n+        if (qp.getType() != Leader.NEWLEADER) {\n+            LOG.error(\"First packet should have been NEWLEADER\");\n+            throw new IOException(\"First packet should have been NEWLEADER\");\n+        }\n+        \n+        return qp.getZxid();\n+    } \n+    \n+    /**\n+     * Finally, synchronize our history with the Leader. \n+     * @param newLeaderZxid\n+     * @throws IOException\n+     * @throws InterruptedException\n+     */\n+    protected void syncWithLeader(long newLeaderZxid) throws IOException, InterruptedException{\n+        QuorumPacket ack = new QuorumPacket(Leader.ACK, 0, null, null);\n+        QuorumPacket qp = new QuorumPacket();\n+        \n+        readPacket(qp);        \n+        synchronized (zk) {\n+            if (qp.getType() == Leader.DIFF) {\n+                LOG.info(\"Getting a diff from the leader 0x\" + Long.toHexString(qp.getZxid()));                \n+                zk.loadData();\n+            }\n+            else if (qp.getType() == Leader.SNAP) {\n+                LOG.info(\"Getting a snapshot from leader\");\n+                // The leader is going to dump the database\n+                zk.deserializeSnapshot(leaderIs);\n+                String signature = leaderIs.readString(\"signature\");\n+                if (!signature.equals(\"BenWasHere\")) {\n+                    LOG.error(\"Missing signature. Got \" + signature);\n+                    throw new IOException(\"Missing signature\");\n+                }\n+            } else if (qp.getType() == Leader.TRUNC) {\n+                //we need to truncate the log to the lastzxid of the leader\n+                LOG.warn(\"Truncating log to get in sync with the leader 0x\"\n+                        + Long.toHexString(qp.getZxid()));\n+                boolean truncated=zk.getLogWriter().truncateLog(qp.getZxid());\n+                if (!truncated) {\n+                    // not able to truncate the log\n+                    LOG.fatal(\"Not able to truncate the log \"\n+                            + Long.toHexString(qp.getZxid()));\n+                    System.exit(13);\n+                }\n+\n+                zk.loadData();\n+            }\n+            else {\n+                LOG.fatal(\"Got unexpected packet from leader \"\n+                        + qp.getType() + \" exiting ... \" );\n+                System.exit(13);\n+\n+            }\n+            zk.dataTree.lastProcessedZxid = newLeaderZxid;\n+        }\n+        ack.setZxid(newLeaderZxid & ~0xffffffffL);\n+        writePacket(ack, true);\n+        sock.setSoTimeout(self.tickTime * self.syncLimit);\n+        zk.startup();\n+    }\n+    \n+    protected void revalidate(QuorumPacket qp) throws IOException {\n+        ByteArrayInputStream bis = new ByteArrayInputStream(qp\n+                .getData());\n+        DataInputStream dis = new DataInputStream(bis);\n+        long sessionId = dis.readLong();\n+        boolean valid = dis.readBoolean();\n+        synchronized (pendingRevalidations) {\n+            ServerCnxn cnxn = pendingRevalidations\n+                    .remove(sessionId);\n+            if (cnxn == null) {\n+                LOG.warn(\"Missing session 0x\"\n+                        + Long.toHexString(sessionId)\n+                        + \" for validation\");\n+            } else {\n+                cnxn.finishSessionInit(valid);\n+            }\n+        }\n+        if (LOG.isTraceEnabled()) {\n+            ZooTrace.logTraceMessage(LOG,\n+                    ZooTrace.SESSION_TRACE_MASK,\n+                    \"Session 0x\" + Long.toHexString(sessionId)\n+                    + \" is valid: \" + valid);\n+        }\n+    }\n+        \n+    protected void ping(QuorumPacket qp) throws IOException {\n+        // Send back the ping with our session data\n+        ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+        DataOutputStream dos = new DataOutputStream(bos);\n+        HashMap<Long, Integer> touchTable = zk\n+                .getTouchSnapshot();\n+        for (Entry<Long, Integer> entry : touchTable.entrySet()) {\n+            dos.writeLong(entry.getKey());\n+            dos.writeInt(entry.getValue());\n+        }\n+        qp.setData(bos.toByteArray());\n+        writePacket(qp, true);\n+    }\n+    \n+    \n+    /**\n+     * Shutdown the Peer\n+     */\n+    public void shutdown() {\n+        // set the zookeeper server to null\n+        self.cnxnFactory.setZooKeeperServer(null);\n+        // clear all the connections\n+        self.cnxnFactory.clear();\n+        // shutdown previous zookeeper\n+        if (zk != null) {\n+            zk.shutdown();\n+        }\n+    }\n+}"
        },
        {
            "sha": "e08bc606c6580f91a215bc7a561bc06d31324c08",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java",
            "status": "renamed",
            "additions": 30,
            "deletions": 24,
            "changes": 54,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -43,20 +43,24 @@\n \n /**\n  * There will be an instance of this class created by the Leader for each\n- * follower.All communication for a given Follower will be handled by this\n+ * learner. All communication with a learner is handled by this\n  * class.\n  */\n-public class FollowerHandler extends Thread {\n-    private static final Logger LOG = Logger.getLogger(FollowerHandler.class);\n+public class LearnerHandler extends Thread {\n+    private static final Logger LOG = Logger.getLogger(LearnerHandler.class);\n \n-    public final Socket sock;\n+    protected final Socket sock;    \n+\n+    public Socket getSocket() {\n+        return sock;\n+    }\n \n     final Leader leader;\n \n     long tickOfLastAck;\n     \n     /**\n-     * ZooKeeper server identifier of this follower\n+     * ZooKeeper server identifier of this learner\n      */\n     protected long sid = 0;\n     \n@@ -65,7 +69,7 @@ long getSid(){\n     }                    \n \n     /**\n-     * The packets to be sent to the follower\n+     * The packets to be sent to the learner\n      */\n     final LinkedBlockingQueue<QuorumPacket> queuedPackets =\n         new LinkedBlockingQueue<QuorumPacket>();\n@@ -76,17 +80,17 @@ long getSid(){\n \n     private BufferedOutputStream bufferedOutput;\n \n-    FollowerHandler(Socket sock, Leader leader) throws IOException {\n-        super(\"FollowerHandler-\" + sock.getRemoteSocketAddress());\n+    LearnerHandler(Socket sock, Leader leader) throws IOException {\n+        super(\"LeanerHandler-\" + sock.getRemoteSocketAddress());\n         this.sock = sock;\n         this.leader = leader;\n-        leader.addFollowerHandler(this);\n+        leader.addLearnerHandler(this);\n     }\n     \n     @Override\n     public String toString() {\n         StringBuffer sb = new StringBuffer();\n-        sb.append(\"FollowerHandler \").append(sock);\n+        sb.append(\"LearnerHandler \").append(sock);\n         sb.append(\" tickOfLastAck:\").append(tickOfLastAck());\n         sb.append(\" synced?:\").append(synced());\n         sb.append(\" queuedPacketLength:\").append(queuedPackets.size());\n@@ -97,7 +101,7 @@ public String toString() {\n      * If this packet is queued, the sender thread will exit\n      */\n     final QuorumPacket proposalOfDeath = new QuorumPacket();\n-\n+   \n     /**\n      * This method will use the thread to send packets added to the\n      * queuedPackets list\n@@ -151,7 +155,7 @@ static public String packetToString(QuorumPacket p) {\n             break;\n         case Leader.FOLLOWERINFO:\n             type = \"FOLLOWERINFO\";\n-            break;\n+            break;    \n         case Leader.NEWLEADER:\n             type = \"NEWLEADER\";\n             break;\n@@ -199,21 +203,21 @@ static public String packetToString(QuorumPacket p) {\n     }\n \n     /**\n-     * This thread will receive packets from the follower and process them and\n-     * also listen to new connections from new followers.\n+     * This thread will receive packets from the peer and process them and\n+     * also listen to new connections from new peers.\n      */\n     @Override\n     public void run() {\n         try {\n-\n+            \n             ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock\n                     .getInputStream()));\n             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n             oa = BinaryOutputArchive.getArchive(bufferedOutput);\n \n             QuorumPacket qp = new QuorumPacket();\n             ia.readRecord(qp, \"packet\");\n-            if(qp.getType() != leader.FOLLOWERINFO){\n+            if(qp.getType() != Leader.FOLLOWERINFO) {\n             \tLOG.error(\"First packet \" + qp.toString()\n                         + \" is not FOLLOWERINFO!\");\n                 return;\n@@ -224,6 +228,7 @@ public void run() {\n             } else {\n             \tthis.sid = leader.followerCounter.getAndDecrement();\n             }\n+\n             LOG.info(\"Follower sid: \" + this.sid + \" : info : \"\n                     + leader.self.quorumPeers.get(this.sid));\n             \n@@ -261,7 +266,8 @@ public void run() {\n                 else {\n                     logTxns = false;\n                 }            \n-            }\n+\t\t\t\t\t\t}\n+            \n             //check if we decided to send a diff or we need to send a truncate\n             // we avoid using epochs for truncating because epochs make things\n             // complicated. Two epochs might have the last 32 bits as same.\n@@ -270,7 +276,7 @@ public void run() {\n             // things simple we just send sanpshot.\n             if (logTxns && (peerLastZxid > leader.zk.maxCommittedLog)) {\n                 // this is the only case that we are sure that\n-                // we can ask the follower to truncate the log\n+                // we can ask the peer to truncate the log\n                 packetToSend = Leader.TRUNC;\n                 zxidToSend = leader.zk.maxCommittedLog;\n                 updates = zxidToSend;\n@@ -303,14 +309,14 @@ public void run() {\n                         + Long.toHexString(peerLastZxid) + \" \" \n                         + \" zxid of leader is 0x\"\n                         + Long.toHexString(leaderLastZxid));\n-                // Dump data to follower\n+                // Dump data to peer\n                 leader.zk.serializeSnapshot(oa);\n                 oa.writeString(\"BenWasHere\", \"signature\");\n             }\n             bufferedOutput.flush();\n             \n             // Mutation packets will be queued during the serialize,\n-            // so we need to mark when the follower can actually start\n+            // so we need to mark when the peer can actually start\n             // using the data\n             //\n             queuedPackets\n@@ -392,14 +398,14 @@ public void run() {\n                     qp.setData(bos.toByteArray());\n                     queuedPackets.add(qp);\n                     break;\n-                case Leader.REQUEST:\n+                case Leader.REQUEST:                    \n                     bb = ByteBuffer.wrap(qp.getData());\n                     sessionId = bb.getLong();\n                     cxid = bb.getInt();\n                     type = bb.getInt();\n                     bb = bb.slice();\n                     if(type == OpCode.sync){\n-                     \tleader.zk.submitRequest(new FollowerSyncRequest(this, sessionId, cxid, type, bb,\n+                     \tleader.zk.submitRequest(new LearnerSyncRequest(this, sessionId, cxid, type, bb,\n                                 qp.getAuthinfo()));\n                     } else {\n                         Request si = new Request(null, sessionId, cxid, type, bb, qp.getAuthinfo());\n@@ -439,15 +445,15 @@ public void shutdown() {\n         } catch (IOException e) {\n             LOG.warn(\"Ignoring unexpected exception during socket close\", e);\n         }\n-        leader.removeFollowerHandler(this);\n+        leader.removeLearnerHandler(this);\n     }\n \n     public long tickOfLastAck() {\n         return tickOfLastAck;\n     }\n \n     /**\n-     * ping calls from the leader to the followers\n+     * ping calls from the leader to the peers\n      */\n     public void ping() {\n         long id;",
            "previous_filename": "src/java/main/org/apache/zookeeper/server/quorum/FollowerHandler.java"
        },
        {
            "sha": "e9cf7ad4e40c93644852ddedc6308e3b7a94bc51",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerSessionTracker.java",
            "status": "renamed",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSessionTracker.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSessionTracker.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSessionTracker.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -28,7 +28,7 @@\n  * This is really just a shell of a SessionTracker that tracks session activity\n  * to be forwarded to the Leader using a PING.\n  */\n-public class FollowerSessionTracker implements SessionTracker {\n+public class LearnerSessionTracker implements SessionTracker {\n     SessionExpirer expirer;\n \n     HashMap<Long, Integer> touchTable = new HashMap<Long, Integer>();\n@@ -41,7 +41,7 @@ public class FollowerSessionTracker implements SessionTracker {\n     /**\n      * \n      */\n-    public FollowerSessionTracker(SessionExpirer expirer,\n+    public LearnerSessionTracker(SessionExpirer expirer,\n             ConcurrentHashMap<Long, Integer> sessionsWithTimeouts, long id) {\n         this.expirer = expirer;\n         this.sessionsWithTimeouts = sessionsWithTimeouts;",
            "previous_filename": "src/java/main/org/apache/zookeeper/server/quorum/FollowerSessionTracker.java"
        },
        {
            "sha": "bfbc9a8fdb2d4d83521975684087f2c09a548c12",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerSyncRequest.java",
            "status": "renamed",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncRequest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncRequest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerSyncRequest.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -24,9 +24,9 @@\n import org.apache.zookeeper.data.Id;\n import org.apache.zookeeper.server.Request;\n \n-public class FollowerSyncRequest extends Request {\n-\tFollowerHandler fh;\n-\tpublic FollowerSyncRequest(FollowerHandler fh, long sessionId, int xid, int type,\n+public class LearnerSyncRequest extends Request {\n+\tLearnerHandler fh;\n+\tpublic LearnerSyncRequest(LearnerHandler fh, long sessionId, int xid, int type,\n \t\t\tByteBuffer bb, List<Id> authInfo) {\n \t\tsuper(null, sessionId, xid, type, bb, authInfo);\n \t\tthis.fh = fh;",
            "previous_filename": "src/java/main/org/apache/zookeeper/server/quorum/FollowerSyncRequest.java"
        },
        {
            "sha": "fe6a422c5670d7992b5132c177e614176fe20e78",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerZooKeeperServer.java",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerZooKeeperServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerZooKeeperServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerZooKeeperServer.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -0,0 +1,149 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+\n+import org.apache.zookeeper.jmx.MBeanRegistry;\n+import org.apache.zookeeper.server.DataTreeBean;\n+import org.apache.zookeeper.server.Request;\n+import org.apache.zookeeper.server.ServerCnxn;\n+import org.apache.zookeeper.server.ZooKeeperServer;\n+import org.apache.zookeeper.server.ZooKeeperServerBean;\n+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;\n+\n+/**\n+ * Parent class for all ZooKeeperServers for Learners \n+ */\n+public abstract class LearnerZooKeeperServer extends ZooKeeperServer {    \n+    \n+    protected QuorumPeer self;\n+    \n+    public LearnerZooKeeperServer(FileTxnSnapLog logFactory, int tickTime,\n+            DataTreeBuilder treeBuilder) throws IOException {\n+        super(logFactory,tickTime,treeBuilder);\n+    }\n+\n+    /**\n+     * Abstract method to return the learner associated with this server.\n+     * Since the Learner may change under our feet (when QuorumPeer reassigns\n+     * it) we can't simply take a reference here. Instead, we need the \n+     * subclasses to implement this.     \n+     */\n+    abstract public Learner getLearner();        \n+    \n+    /**\n+     * Returns the current state of the session tracker. This is only currently\n+     * used by a Learner to build a ping response packet.\n+     * \n+     */\n+    protected HashMap<Long, Integer> getTouchSnapshot() {\n+        if (sessionTracker != null) {\n+            return ((LearnerSessionTracker) sessionTracker).snapshot();\n+        }\n+        return new HashMap<Long, Integer>();\n+    }\n+    \n+    /**\n+     * Returns the id of the associated QuorumPeer, which will do for a unique\n+     * id of this server. \n+     */\n+    public long getServerId() {\n+        return self.getId();\n+    }    \n+    \n+    /**\n+     * Learners don't make use of this method, only Leaders.\n+     */\n+    @Override\n+    public void addCommittedProposal(Request request) {\n+        // Don't do anything!\n+    }\n+    \n+    @Override\n+    protected void createSessionTracker() {\n+        sessionTracker = new LearnerSessionTracker(this, sessionsWithTimeouts,\n+                self.getId());\n+    }\n+    \n+    @Override\n+    protected void revalidateSession(ServerCnxn cnxn, long sessionId,\n+            int sessionTimeout) throws IOException, InterruptedException {\n+        getLearner().validateSession(cnxn, sessionId, sessionTimeout);\n+    }\n+    \n+    @Override\n+    protected void registerJMX() {\n+        // register with JMX\n+        try {\n+            jmxDataTreeBean = new DataTreeBean(dataTree);\n+            MBeanRegistry.getInstance().register(jmxDataTreeBean, jmxServerBean);\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to register with JMX\", e);\n+            jmxDataTreeBean = null;\n+        }\n+    }\n+\n+    public void registerJMX(ZooKeeperServerBean serverBean,\n+            LocalPeerBean localPeerBean)\n+    {\n+        // register with JMX\n+        if (self.jmxLeaderElectionBean != null) {\n+            try {\n+                MBeanRegistry.getInstance().unregister(self.jmxLeaderElectionBean);\n+            } catch (Exception e) {\n+                LOG.warn(\"Failed to register with JMX\", e);\n+            }\n+            self.jmxLeaderElectionBean = null;\n+        }\n+\n+        try {\n+            jmxServerBean = serverBean;\n+            MBeanRegistry.getInstance().register(serverBean, localPeerBean);\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to register with JMX\", e);\n+            jmxServerBean = null;\n+        }\n+    }\n+\n+    @Override\n+    protected void unregisterJMX() {\n+        // unregister from JMX\n+        try {\n+            if (jmxDataTreeBean != null) {\n+                MBeanRegistry.getInstance().unregister(jmxDataTreeBean);\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        jmxDataTreeBean = null;\n+    }\n+\n+    protected void unregisterJMX(Learner peer) {\n+        // unregister from JMX\n+        try {\n+            if (jmxServerBean != null) {\n+                MBeanRegistry.getInstance().unregister(jmxServerBean);\n+            }\n+        } catch (Exception e) {\n+            LOG.warn(\"Failed to unregister with JMX\", e);\n+        }\n+        jmxServerBean = null;\n+    }\n+}"
        },
        {
            "sha": "386430aa313eec1935e93e9952fab147b7a20df5",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/ProposalRequestProcessor.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FProposalRequestProcessor.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FProposalRequestProcessor.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FProposalRequestProcessor.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -62,8 +62,8 @@ public void processRequest(Request request) {\n          * call processRequest on the next processor.\n          */\n         \n-        if(request instanceof FollowerSyncRequest){\n-            zks.getLeader().processSync((FollowerSyncRequest)request);\n+        if(request instanceof LearnerSyncRequest){\n+            zks.getLeader().processSync((LearnerSyncRequest)request);\n         } else {\n                 nextProcessor.processRequest(request);\n             if (request.hdr != null) {"
        },
        {
            "sha": "5dfb69f1d2966d864e71445889d05bfede746cd1",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java",
            "status": "modified",
            "additions": 23,
            "deletions": 6,
            "changes": 29,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -452,7 +452,7 @@ public void run() {\n         try {\n             jmxQuorumBean = new QuorumBean(this);\n             MBeanRegistry.getInstance().register(jmxQuorumBean, null);\n-            for(QuorumServer s: quorumPeers.values()){\n+            for(QuorumServer s: getView().values()){\n                 ZKMBeanInfo p;\n                 if (getId() == s.id) {\n                     p = jmxLocalPeerBean = new LocalPeerBean(this);\n@@ -548,16 +548,33 @@ public void shutdown() {\n         }\n     }\n \n+    /**\n+     * A 'view' is a node's current opinion of the membership of the\n+     * ensemble. \n+     */\n+    public Map<Long,QuorumPeer.QuorumServer> getView() {\n+        return this.quorumPeers;\n+    }\n+    \n+    /**\n+     * Check if a node is in the current view. With static membership, the\n+     * result of this check will never change; only when dynamic membership\n+     * is introduced will this be more useful.\n+     */\n+    public boolean viewContains(Long sid) {\n+        return this.quorumPeers.containsKey(sid);\n+    }\n+    \n     public String[] getQuorumPeers() {\n         List<String> l = new ArrayList<String>();\n         synchronized (this) {\n             if (leader != null) {\n-                synchronized (leader.followers) {\n-                    for (FollowerHandler fh : leader.followers) {\n-                        if (fh.sock == null)\n+                synchronized (leader.learners) {\n+                    for (LearnerHandler fh : leader.learners) {\n+                        if (fh.getSocket() == null)\n                             continue;\n-                        String s = fh.sock.getRemoteSocketAddress().toString();\n-                        if (leader.isFollowerSynced(fh))\n+                        String s = fh.getSocket().getRemoteSocketAddress().toString();\n+                        if (leader.isLearnerSynced(fh))\n                             s += \"*\";\n                         l.add(s);\n                     }"
        },
        {
            "sha": "f033e12423a86781706647f43e0d544c744f8e39",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/SendAckRequestProcessor.java",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FSendAckRequestProcessor.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FSendAckRequestProcessor.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FSendAckRequestProcessor.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -30,23 +30,23 @@\n public class SendAckRequestProcessor implements RequestProcessor, Flushable {\n     private static final Logger LOG = Logger.getLogger(SendAckRequestProcessor.class);\n     \n-    Follower follower;\n+    Learner learner;\n \n-    SendAckRequestProcessor(Follower follower) {\n-        this.follower = follower;\n+    SendAckRequestProcessor(Learner peer) {\n+        this.learner = peer;\n     }\n \n     public void processRequest(Request si) {\n         if(si.type != OpCode.sync){\n             QuorumPacket qp = new QuorumPacket(Leader.ACK, si.hdr.getZxid(), null,\n                 null);\n             try {\n-                follower.writePacket(qp, false);\n+                learner.writePacket(qp, false);\n             } catch (IOException e) {\n                 LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n                 try {\n-                    if (!follower.sock.isClosed()) {\n-                        follower.sock.close();\n+                    if (!learner.sock.isClosed()) {\n+                        learner.sock.close();\n                     }\n                 } catch (IOException e1) {\n                     // Nothing to do, we are shutting things down, so an exception here is irrelevant\n@@ -58,12 +58,12 @@ public void processRequest(Request si) {\n     \n     public void flush() throws IOException {\n         try {\n-            follower.writePacket(null, true);\n+            learner.writePacket(null, true);\n         } catch(IOException e) {\n             LOG.warn(\"Closing connection to leader, exception during packet send\", e);\n             try {\n-                if (!follower.sock.isClosed()) {\n-                    follower.sock.close();\n+                if (!learner.sock.isClosed()) {\n+                    learner.sock.close();\n                 }\n             } catch (IOException e1) {\n                     // Nothing to do, we are shutting things down, so an exception here is irrelevant"
        },
        {
            "sha": "c09eb16b62e5e0a1e2722d3ba452cf4c87a9b1f0",
            "filename": "src/java/test/config/findbugsExcludeFile.xml",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -51,8 +51,8 @@\n \n    <!-- Two unrecoverable errors while following the leader  -->\n    <Match>\n-     <Class name=\"org.apache.zookeeper.server.quorum.Follower\" />\n-       <Method name=\"followLeader\" />\n+     <Class name=\"org.apache.zookeeper.server.quorum.Learner\" />\n+       <Method name=\"syncWithLeader\" />\n        <Bug pattern=\"DM_EXIT\" />\n    </Match>\n \n@@ -91,7 +91,7 @@\n      <Bug code=\"IS\"/>\n   </Match>\n   <Match>\n-     <Class name=\"org.apache.zookeeper.server.quorum.FollowerSessionTracker\"/>\n+     <Class name=\"org.apache.zookeeper.server.quorum.LearnerSessionTracker\"/>\n        <Bug code=\"UrF\"/>\n   </Match>\n   <Match>"
        },
        {
            "sha": "2d8edcd5e6d85850b5891db26df0ad434807936b",
            "filename": "src/java/test/org/apache/zookeeper/test/QuorumTest.java",
            "status": "modified",
            "additions": 25,
            "deletions": 4,
            "changes": 29,
            "blob_url": "https://github.com/apache/zookeeper/blob/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FQuorumTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/0957b8404e1ecfc5703d7c2827752773b7dc23be/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FQuorumTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FQuorumTest.java?ref=0957b8404e1ecfc5703d7c2827752773b7dc23be",
            "patch": "@@ -30,7 +30,7 @@\n import org.apache.zookeeper.ZooKeeper;\n import org.apache.zookeeper.ZooDefs.Ids;\n import org.apache.zookeeper.data.Stat;\n-import org.apache.zookeeper.server.quorum.FollowerHandler;\n+import org.apache.zookeeper.server.quorum.LearnerHandler;\n import org.apache.zookeeper.server.quorum.Leader;\n import org.junit.Before;\n import org.junit.Test;\n@@ -91,6 +91,27 @@ public void testClientWithWatcherObj() throws IOException,\n         ct.testClientWithWatcherObj();\n     }\n     \n+    @Test\n+    public void testGetView() {                \n+        ct.assertEquals(5,qb.s1.getView().size());        \n+        ct.assertEquals(5,qb.s2.getView().size());        \n+        ct.assertEquals(5,qb.s3.getView().size());        \n+        ct.assertEquals(5,qb.s4.getView().size());\n+        ct.assertEquals(5,qb.s5.getView().size());\n+    }\n+    \n+    @Test\n+    public void testViewContains() {\n+        // Test view contains self\n+        ct.assertTrue(qb.s1.viewContains(qb.s1.getId()));\n+        \n+        // Test view contains other servers\n+        ct.assertTrue(qb.s1.viewContains(qb.s2.getId()));\n+        \n+        // Test view does not contain non-existant servers\n+        ct.assertFalse(qb.s1.viewContains(-1L));\n+    }\n+    \n     volatile int counter = 0;\n     volatile int errors = 0;\n     @Test\n@@ -117,9 +138,9 @@ public void processResult(int rc, String path, Object ctx,\n                 }\n             }, null);\n         }\n-        ArrayList<FollowerHandler> fhs = new ArrayList<FollowerHandler>(leader.forwardingFollowers);\n-        for(FollowerHandler f: fhs) {\n-            f.sock.shutdownInput();\n+        ArrayList<LearnerHandler> fhs = new ArrayList<LearnerHandler>(leader.forwardingFollowers);\n+        for(LearnerHandler f: fhs) {\n+            f.getSocket().shutdownInput();\n         }\n         for(int i = 0; i < 5000; i++) {\n             zk.setData(\"/blah/blah\", new byte[0], -1, new AsyncCallback.StatCallback() {"
        }
    ]
}
{
    "sha": "fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
    "node_id": "MDY6Q29tbWl0NTA3Nzc1OmZlMzY4NjFhZGEzZTc1MjU5ZmY2MDFhOWY2YjBlMWNkNWZiYjhhZmU=",
    "commit": {
        "author": {
            "name": "Yogesh Gaikwad",
            "email": "902768+bizybot@users.noreply.github.com",
            "date": "2019-02-05T03:21:57Z"
        },
        "committer": {
            "name": "GitHub",
            "email": "noreply@github.com",
            "date": "2019-02-05T03:21:57Z"
        },
        "message": "Add support for API keys to access Elasticsearch (#38291)\n\nX-Pack security supports built-in authentication service\r\n`token-service` that allows access tokens to be used to \r\naccess Elasticsearch without using Basic authentication.\r\nThe tokens are generated by `token-service` based on\r\nOAuth2 spec. The access token is a short-lived token\r\n(defaults to 20m) and refresh token with a lifetime of 24 hours,\r\nmaking them unsuitable for long-lived or recurring tasks where\r\nthe system might go offline thereby failing refresh of tokens.\r\n\r\nThis commit introduces a built-in authentication service\r\n`api-key-service` that adds support for long-lived tokens aka API\r\nkeys to access Elasticsearch. The `api-key-service` is consulted\r\nafter `token-service` in the authentication chain. By default,\r\nif TLS is enabled then `api-key-service` is also enabled.\r\nThe service can be disabled using the configuration setting.\r\n\r\nThe API keys:-\r\n- by default do not have an expiration but expiration can be\r\n  configured where the API keys need to be expired after a\r\n  certain amount of time.\r\n- when generated will keep authentication information of the user that\r\n   generated them.\r\n- can be defined with a role describing the privileges for accessing\r\n   Elasticsearch and will be limited by the role of the user that\r\n   generated them\r\n- can be invalidated via invalidation API\r\n- information can be retrieved via a get API\r\n- that have been expired or invalidated will be retained for 1 week\r\n  before being deleted. The expired API keys remover task handles this.\r\n\r\nFollowing are the API key management APIs:-\r\n1. Create API Key - `PUT/POST /_security/api_key`\r\n2. Get API key(s) - `GET /_security/api_key`\r\n3. Invalidate API Key(s) `DELETE /_security/api_key`\r\n\r\nThe API keys can be used to access Elasticsearch using `Authorization`\r\nheader, where the auth scheme is `ApiKey` and the credentials, is the \r\nbase64 encoding of API key Id and API key separated by a colon.\r\nExample:-\r\n```\r\ncurl -H \"Authorization: ApiKey YXBpLWtleS1pZDphcGkta2V5\" http://localhost:9200/_cluster/health\r\n```\r\n\r\nCloses #34383",
        "tree": {
            "sha": "4962a129b3bd41009359c921c30207820a93e496",
            "url": "https://api.github.com/repos/elastic/elasticsearch/git/trees/4962a129b3bd41009359c921c30207820a93e496"
        },
        "url": "https://api.github.com/repos/elastic/elasticsearch/git/commits/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
        "comment_count": 0,
        "verification": {
            "verified": true,
            "reason": "valid",
            "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJcWQFVCRBK7hj4Ov3rIwAAdHIIAERnIARtJi/oZ8udgwnSIFVD\nQ65YRM66tonBnbtggPOp3+7FJzHgtNsIdLDelFbabbIXdpaYs8x3RYBqfqOMvlty\n+og8q8TY16vRVP4lFwgLw0qbKJPmFppvO5fmrmio6LZ5UkUHoxKFEr39eO9yzVUg\ncb66gPYAZRT2H/i5pM8goROfFsMMPjLuXdIxGJlDM9FWs5N9f3ZnCZ0NAe4eqrDx\nDOuYfrNMWDRcYcbxtqHs4ETvir0+MiEQ//krCUNQHCmB99pj3jR/9Z4go2L6fgKi\nJyjb1rYAm2ymKfJOfFenvfs+CftDslXT8kdGn9X8ZOfjwyJjSglwPIxU3B3SPgI=\n=etRH\n-----END PGP SIGNATURE-----\n",
            "payload": "tree 4962a129b3bd41009359c921c30207820a93e496\nparent d25530358452b4abbf223017003692ea92e76f8e\nauthor Yogesh Gaikwad <902768+bizybot@users.noreply.github.com> 1549336917 +1100\ncommitter GitHub <noreply@github.com> 1549336917 +1100\n\nAdd support for API keys to access Elasticsearch (#38291)\n\nX-Pack security supports built-in authentication service\r\n`token-service` that allows access tokens to be used to \r\naccess Elasticsearch without using Basic authentication.\r\nThe tokens are generated by `token-service` based on\r\nOAuth2 spec. The access token is a short-lived token\r\n(defaults to 20m) and refresh token with a lifetime of 24 hours,\r\nmaking them unsuitable for long-lived or recurring tasks where\r\nthe system might go offline thereby failing refresh of tokens.\r\n\r\nThis commit introduces a built-in authentication service\r\n`api-key-service` that adds support for long-lived tokens aka API\r\nkeys to access Elasticsearch. The `api-key-service` is consulted\r\nafter `token-service` in the authentication chain. By default,\r\nif TLS is enabled then `api-key-service` is also enabled.\r\nThe service can be disabled using the configuration setting.\r\n\r\nThe API keys:-\r\n- by default do not have an expiration but expiration can be\r\n  configured where the API keys need to be expired after a\r\n  certain amount of time.\r\n- when generated will keep authentication information of the user that\r\n   generated them.\r\n- can be defined with a role describing the privileges for accessing\r\n   Elasticsearch and will be limited by the role of the user that\r\n   generated them\r\n- can be invalidated via invalidation API\r\n- information can be retrieved via a get API\r\n- that have been expired or invalidated will be retained for 1 week\r\n  before being deleted. The expired API keys remover task handles this.\r\n\r\nFollowing are the API key management APIs:-\r\n1. Create API Key - `PUT/POST /_security/api_key`\r\n2. Get API key(s) - `GET /_security/api_key`\r\n3. Invalidate API Key(s) `DELETE /_security/api_key`\r\n\r\nThe API keys can be used to access Elasticsearch using `Authorization`\r\nheader, where the auth scheme is `ApiKey` and the credentials, is the \r\nbase64 encoding of API key Id and API key separated by a colon.\r\nExample:-\r\n```\r\ncurl -H \"Authorization: ApiKey YXBpLWtleS1pZDphcGkta2V5\" http://localhost:9200/_cluster/health\r\n```\r\n\r\nCloses #34383",
            "verified_at": "2024-11-07T22:41:54Z"
        }
    },
    "url": "https://api.github.com/repos/elastic/elasticsearch/commits/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
    "html_url": "https://github.com/elastic/elasticsearch/commit/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
    "comments_url": "https://api.github.com/repos/elastic/elasticsearch/commits/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/comments",
    "author": {
        "login": "bizybot",
        "id": 902768,
        "node_id": "MDQ6VXNlcjkwMjc2OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/902768?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/bizybot",
        "html_url": "https://github.com/bizybot",
        "followers_url": "https://api.github.com/users/bizybot/followers",
        "following_url": "https://api.github.com/users/bizybot/following{/other_user}",
        "gists_url": "https://api.github.com/users/bizybot/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/bizybot/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/bizybot/subscriptions",
        "organizations_url": "https://api.github.com/users/bizybot/orgs",
        "repos_url": "https://api.github.com/users/bizybot/repos",
        "events_url": "https://api.github.com/users/bizybot/events{/privacy}",
        "received_events_url": "https://api.github.com/users/bizybot/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "web-flow",
        "id": 19864447,
        "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/web-flow",
        "html_url": "https://github.com/web-flow",
        "followers_url": "https://api.github.com/users/web-flow/followers",
        "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
        "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
        "organizations_url": "https://api.github.com/users/web-flow/orgs",
        "repos_url": "https://api.github.com/users/web-flow/repos",
        "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
        "received_events_url": "https://api.github.com/users/web-flow/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "d25530358452b4abbf223017003692ea92e76f8e",
            "url": "https://api.github.com/repos/elastic/elasticsearch/commits/d25530358452b4abbf223017003692ea92e76f8e",
            "html_url": "https://github.com/elastic/elasticsearch/commit/d25530358452b4abbf223017003692ea92e76f8e"
        }
    ],
    "stats": {
        "total": 11643,
        "additions": 10697,
        "deletions": 946
    },
    "files": [
        {
            "sha": "44262f09346de5d60fb6adc5369c12f0685a7ef0",
            "filename": "client/rest-high-level/build.gradle",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fbuild.gradle",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fbuild.gradle",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fbuild.gradle?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -104,6 +104,7 @@ integTestCluster {\n   setting 'xpack.license.self_generated.type', 'trial'\n   setting 'xpack.security.enabled', 'true'\n   setting 'xpack.security.authc.token.enabled', 'true'\n+  setting 'xpack.security.authc.api_key.enabled', 'true'\n   // Truststore settings are not used since TLS is not enabled. Included for testing the get certificates API\n   setting 'xpack.security.http.ssl.certificate_authorities', 'testnode.crt'\n   setting 'xpack.security.transport.ssl.truststore.path', 'testnode.jks'"
        },
        {
            "sha": "fefb5771dc801a2fb54278697d20db183ea0aa56",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/SecurityClient.java",
            "status": "modified",
            "additions": 97,
            "deletions": 0,
            "changes": 97,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityClient.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityClient.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityClient.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -27,6 +27,8 @@\n import org.elasticsearch.client.security.ClearRealmCacheResponse;\n import org.elasticsearch.client.security.ClearRolesCacheRequest;\n import org.elasticsearch.client.security.ClearRolesCacheResponse;\n+import org.elasticsearch.client.security.CreateApiKeyRequest;\n+import org.elasticsearch.client.security.CreateApiKeyResponse;\n import org.elasticsearch.client.security.CreateTokenRequest;\n import org.elasticsearch.client.security.CreateTokenResponse;\n import org.elasticsearch.client.security.DeletePrivilegesRequest;\n@@ -39,6 +41,8 @@\n import org.elasticsearch.client.security.DeleteUserResponse;\n import org.elasticsearch.client.security.DisableUserRequest;\n import org.elasticsearch.client.security.EnableUserRequest;\n+import org.elasticsearch.client.security.GetApiKeyRequest;\n+import org.elasticsearch.client.security.GetApiKeyResponse;\n import org.elasticsearch.client.security.GetPrivilegesRequest;\n import org.elasticsearch.client.security.GetPrivilegesResponse;\n import org.elasticsearch.client.security.GetRoleMappingsRequest;\n@@ -53,6 +57,8 @@\n import org.elasticsearch.client.security.GetUsersResponse;\n import org.elasticsearch.client.security.HasPrivilegesRequest;\n import org.elasticsearch.client.security.HasPrivilegesResponse;\n+import org.elasticsearch.client.security.InvalidateApiKeyRequest;\n+import org.elasticsearch.client.security.InvalidateApiKeyResponse;\n import org.elasticsearch.client.security.InvalidateTokenRequest;\n import org.elasticsearch.client.security.InvalidateTokenResponse;\n import org.elasticsearch.client.security.PutPrivilegesRequest;\n@@ -842,4 +848,95 @@ public void deletePrivilegesAsync(DeletePrivilegesRequest request, RequestOption\n         restHighLevelClient.performRequestAsyncAndParseEntity(request, SecurityRequestConverters::deletePrivileges, options,\n             DeletePrivilegesResponse::fromXContent, listener, singleton(404));\n     }\n+\n+    /**\n+     * Create an API Key.<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to create a API key\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response from the create API key call\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public CreateApiKeyResponse createApiKey(final CreateApiKeyRequest request, final RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, SecurityRequestConverters::createApiKey, options,\n+                CreateApiKeyResponse::fromXContent, emptySet());\n+    }\n+\n+    /**\n+     * Asynchronously creates an API key.<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to create a API key\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     */\n+    public void createApiKeyAsync(final CreateApiKeyRequest request, final RequestOptions options,\n+            final ActionListener<CreateApiKeyResponse> listener) {\n+        restHighLevelClient.performRequestAsyncAndParseEntity(request, SecurityRequestConverters::createApiKey, options,\n+                CreateApiKeyResponse::fromXContent, listener, emptySet());\n+    }\n+\n+    /**\n+     * Retrieve API Key(s) information.<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to retrieve API key(s)\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response from the create API key call\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public GetApiKeyResponse getApiKey(final GetApiKeyRequest request, final RequestOptions options) throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, SecurityRequestConverters::getApiKey, options,\n+                GetApiKeyResponse::fromXContent, emptySet());\n+    }\n+\n+    /**\n+     * Asynchronously retrieve API Key(s) information.<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to retrieve API key(s)\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     */\n+    public void getApiKeyAsync(final GetApiKeyRequest request, final RequestOptions options,\n+            final ActionListener<GetApiKeyResponse> listener) {\n+        restHighLevelClient.performRequestAsyncAndParseEntity(request, SecurityRequestConverters::getApiKey, options,\n+                GetApiKeyResponse::fromXContent, listener, emptySet());\n+    }\n+\n+    /**\n+     * Invalidate API Key(s).<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to invalidate API key(s)\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @return the response from the invalidate API key call\n+     * @throws IOException in case there is a problem sending the request or parsing back the response\n+     */\n+    public InvalidateApiKeyResponse invalidateApiKey(final InvalidateApiKeyRequest request, final RequestOptions options)\n+            throws IOException {\n+        return restHighLevelClient.performRequestAndParseEntity(request, SecurityRequestConverters::invalidateApiKey, options,\n+                InvalidateApiKeyResponse::fromXContent, emptySet());\n+    }\n+\n+    /**\n+     * Asynchronously invalidates API key(s).<br>\n+     * See <a href=\"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html\">\n+     * the docs</a> for more.\n+     *\n+     * @param request the request to invalidate API key(s)\n+     * @param options the request options (e.g. headers), use {@link RequestOptions#DEFAULT} if nothing needs to be customized\n+     * @param listener the listener to be notified upon request completion\n+     */\n+    public void invalidateApiKeyAsync(final InvalidateApiKeyRequest request, final RequestOptions options,\n+                                      final ActionListener<InvalidateApiKeyResponse> listener) {\n+        restHighLevelClient.performRequestAsyncAndParseEntity(request, SecurityRequestConverters::invalidateApiKey, options,\n+                InvalidateApiKeyResponse::fromXContent, listener, emptySet());\n+    }\n }"
        },
        {
            "sha": "f686167e211bb16b443be32a7d333fb9eb9db602",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/SecurityRequestConverters.java",
            "status": "modified",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConverters.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConverters.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConverters.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -26,18 +26,21 @@\n import org.elasticsearch.client.security.ChangePasswordRequest;\n import org.elasticsearch.client.security.ClearRealmCacheRequest;\n import org.elasticsearch.client.security.ClearRolesCacheRequest;\n+import org.elasticsearch.client.security.CreateApiKeyRequest;\n import org.elasticsearch.client.security.CreateTokenRequest;\n import org.elasticsearch.client.security.DeletePrivilegesRequest;\n import org.elasticsearch.client.security.DeleteRoleMappingRequest;\n import org.elasticsearch.client.security.DeleteRoleRequest;\n import org.elasticsearch.client.security.DeleteUserRequest;\n import org.elasticsearch.client.security.DisableUserRequest;\n import org.elasticsearch.client.security.EnableUserRequest;\n+import org.elasticsearch.client.security.GetApiKeyRequest;\n import org.elasticsearch.client.security.GetPrivilegesRequest;\n import org.elasticsearch.client.security.GetRoleMappingsRequest;\n import org.elasticsearch.client.security.GetRolesRequest;\n import org.elasticsearch.client.security.GetUsersRequest;\n import org.elasticsearch.client.security.HasPrivilegesRequest;\n+import org.elasticsearch.client.security.InvalidateApiKeyRequest;\n import org.elasticsearch.client.security.InvalidateTokenRequest;\n import org.elasticsearch.client.security.PutPrivilegesRequest;\n import org.elasticsearch.client.security.PutRoleMappingRequest;\n@@ -256,4 +259,36 @@ static Request putRole(final PutRoleRequest putRoleRequest) throws IOException {\n         params.withRefreshPolicy(putRoleRequest.getRefreshPolicy());\n         return request;\n     }\n+\n+    static Request createApiKey(final CreateApiKeyRequest createApiKeyRequest) throws IOException {\n+        final Request request = new Request(HttpPost.METHOD_NAME, \"/_security/api_key\");\n+        request.setEntity(createEntity(createApiKeyRequest, REQUEST_BODY_CONTENT_TYPE));\n+        final RequestConverters.Params params = new RequestConverters.Params(request);\n+        params.withRefreshPolicy(createApiKeyRequest.getRefreshPolicy());\n+        return request;\n+    }\n+\n+    static Request getApiKey(final GetApiKeyRequest getApiKeyRequest) throws IOException {\n+        final Request request = new Request(HttpGet.METHOD_NAME, \"/_security/api_key\");\n+        if (Strings.hasText(getApiKeyRequest.getId())) {\n+            request.addParameter(\"id\", getApiKeyRequest.getId());\n+        }\n+        if (Strings.hasText(getApiKeyRequest.getName())) {\n+            request.addParameter(\"name\", getApiKeyRequest.getName());\n+        }\n+        if (Strings.hasText(getApiKeyRequest.getUserName())) {\n+            request.addParameter(\"username\", getApiKeyRequest.getUserName());\n+        }\n+        if (Strings.hasText(getApiKeyRequest.getRealmName())) {\n+            request.addParameter(\"realm_name\", getApiKeyRequest.getRealmName());\n+        }\n+        return request;\n+    }\n+\n+    static Request invalidateApiKey(final InvalidateApiKeyRequest invalidateApiKeyRequest) throws IOException {\n+        final Request request = new Request(HttpDelete.METHOD_NAME, \"/_security/api_key\");\n+        request.setEntity(createEntity(invalidateApiKeyRequest, REQUEST_BODY_CONTENT_TYPE));\n+        final RequestConverters.Params params = new RequestConverters.Params(request);\n+        return request;\n+    }\n }"
        },
        {
            "sha": "ad5f0a9ba2cf6ca8885a1d1245415cb290f82ae2",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/CreateApiKeyRequest.java",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,128 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.client.security.user.privileges.Role;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+import java.util.List;\n+import java.util.Objects;\n+\n+/**\n+ * Request to create API key\n+ */\n+public final class CreateApiKeyRequest implements Validatable, ToXContentObject {\n+\n+    private final String name;\n+    private final TimeValue expiration;\n+    private final List<Role> roles;\n+    private final RefreshPolicy refreshPolicy;\n+\n+    /**\n+     * Create API Key request constructor\n+     * @param name name for the API key\n+     * @param roles list of {@link Role}s\n+     * @param expiration to specify expiration for the API key\n+     */\n+    public CreateApiKeyRequest(String name, List<Role> roles, @Nullable TimeValue expiration, @Nullable final RefreshPolicy refreshPolicy) {\n+        if (Strings.hasText(name)) {\n+            this.name = name;\n+        } else {\n+            throw new IllegalArgumentException(\"name must not be null or empty\");\n+        }\n+        this.roles = Objects.requireNonNull(roles, \"roles may not be null\");\n+        this.expiration = expiration;\n+        this.refreshPolicy = (refreshPolicy == null) ? RefreshPolicy.getDefault() : refreshPolicy;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public TimeValue getExpiration() {\n+        return expiration;\n+    }\n+\n+    public List<Role> getRoles() {\n+        return roles;\n+    }\n+\n+    public RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, refreshPolicy, roles, expiration);\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+        final CreateApiKeyRequest that = (CreateApiKeyRequest) o;\n+        return Objects.equals(name, that.name) && Objects.equals(refreshPolicy, that.refreshPolicy) && Objects.equals(roles, that.roles)\n+                && Objects.equals(expiration, that.expiration);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject().field(\"name\", name);\n+        if (expiration != null) {\n+            builder.field(\"expiration\", expiration.getStringRep());\n+        }\n+        builder.startObject(\"role_descriptors\");\n+        for (Role role : roles) {\n+            builder.startObject(role.getName());\n+            if (role.getApplicationPrivileges() != null) {\n+                builder.field(Role.APPLICATIONS.getPreferredName(), role.getApplicationPrivileges());\n+            }\n+            if (role.getClusterPrivileges() != null) {\n+                builder.field(Role.CLUSTER.getPreferredName(), role.getClusterPrivileges());\n+            }\n+            if (role.getGlobalPrivileges() != null) {\n+                builder.field(Role.GLOBAL.getPreferredName(), role.getGlobalPrivileges());\n+            }\n+            if (role.getIndicesPrivileges() != null) {\n+                builder.field(Role.INDICES.getPreferredName(), role.getIndicesPrivileges());\n+            }\n+            if (role.getMetadata() != null) {\n+                builder.field(Role.METADATA.getPreferredName(), role.getMetadata());\n+            }\n+            if (role.getRunAsPrivilege() != null) {\n+                builder.field(Role.RUN_AS.getPreferredName(), role.getRunAsPrivilege());\n+            }\n+            builder.endObject();\n+        }\n+        builder.endObject();\n+        return builder.endObject();\n+    }\n+\n+}"
        },
        {
            "sha": "9c5037237407b04e8471c79b5f158afd341b4ecd",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/CreateApiKeyResponse.java",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Response for create API key\n+ */\n+public final class CreateApiKeyResponse {\n+\n+    private final String name;\n+    private final String id;\n+    private final SecureString key;\n+    private final Instant expiration;\n+\n+    public CreateApiKeyResponse(String name, String id, SecureString key, Instant expiration) {\n+        this.name = name;\n+        this.id = id;\n+        this.key = key;\n+        // As we do not yet support the nanosecond precision when we serialize to JSON,\n+        // here creating the 'Instant' of milliseconds precision.\n+        // This Instant can then be used for date comparison.\n+        this.expiration = (expiration != null) ? Instant.ofEpochMilli(expiration.toEpochMilli()): null;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public SecureString getKey() {\n+        return key;\n+    }\n+\n+    @Nullable\n+    public Instant getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(id, name, key, expiration);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final CreateApiKeyResponse other = (CreateApiKeyResponse) obj;\n+        return Objects.equals(id, other.id)\n+                && Objects.equals(key, other.key)\n+                && Objects.equals(name, other.name)\n+                && Objects.equals(expiration, other.expiration);\n+    }\n+\n+    static ConstructingObjectParser<CreateApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"create_api_key_response\",\n+            args -> new CreateApiKeyResponse((String) args[0], (String) args[1], new SecureString((String) args[2]),\n+                    (args[3] == null) ? null : Instant.ofEpochMilli((Long) args[3])));\n+    static {\n+        PARSER.declareString(constructorArg(), new ParseField(\"name\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"id\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"api_key\"));\n+        PARSER.declareLong(optionalConstructorArg(), new ParseField(\"expiration\"));\n+    }\n+\n+    public static CreateApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+}"
        },
        {
            "sha": "6fa98ec549b0769bea2601bb2a7430c1d486f730",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/GetApiKeyRequest.java",
            "status": "added",
            "additions": 133,
            "deletions": 0,
            "changes": 133,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,133 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Request for get API key\n+ */\n+public final class GetApiKeyRequest implements Validatable, ToXContentObject {\n+\n+    private final String realmName;\n+    private final String userName;\n+    private final String id;\n+    private final String name;\n+\n+    // pkg scope for testing\n+    GetApiKeyRequest(@Nullable String realmName, @Nullable String userName, @Nullable String apiKeyId,\n+            @Nullable String apiKeyName) {\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false && Strings.hasText(apiKeyId) == false\n+                && Strings.hasText(apiKeyName) == false) {\n+            throwValidationError(\"One of [api key id, api key name, username, realm name] must be specified\");\n+        }\n+        if (Strings.hasText(apiKeyId) || Strings.hasText(apiKeyName)) {\n+            if (Strings.hasText(realmName) || Strings.hasText(userName)) {\n+                throwValidationError(\n+                        \"username or realm name must not be specified when the api key id or api key name is specified\");\n+            }\n+        }\n+        if (Strings.hasText(apiKeyId) && Strings.hasText(apiKeyName)) {\n+            throwValidationError(\"only one of [api key id, api key name] can be specified\");\n+        }\n+        this.realmName = realmName;\n+        this.userName = userName;\n+        this.id = apiKeyId;\n+        this.name = apiKeyName;\n+    }\n+\n+    private void throwValidationError(String message) {\n+        throw new IllegalArgumentException(message);\n+    }\n+\n+    public String getRealmName() {\n+        return realmName;\n+    }\n+\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Creates get API key request for given realm name\n+     * @param realmName realm name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingRealmName(String realmName) {\n+        return new GetApiKeyRequest(realmName, null, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given user name\n+     * @param userName user name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingUserName(String userName) {\n+        return new GetApiKeyRequest(null, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given realm and user name\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingRealmAndUserName(String realmName, String userName) {\n+        return new GetApiKeyRequest(realmName, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given api key id\n+     * @param apiKeyId api key id\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingApiKeyId(String apiKeyId) {\n+        return new GetApiKeyRequest(null, null, apiKeyId, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given api key name\n+     * @param apiKeyName api key name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingApiKeyName(String apiKeyName) {\n+        return new GetApiKeyRequest(null, null, null, apiKeyName);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        return builder;\n+    }\n+\n+}"
        },
        {
            "sha": "58e3e8effbb09c7ca396606f5a0fa6d9172cdca6",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/GetApiKeyResponse.java",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Response for get API keys.<br>\n+ * The result contains information about the API keys that were found.\n+ */\n+public final class GetApiKeyResponse {\n+\n+    private final List<ApiKey> foundApiKeysInfo;\n+\n+    public GetApiKeyResponse(List<ApiKey> foundApiKeysInfo) {\n+        Objects.requireNonNull(foundApiKeysInfo, \"found_api_keys_info must be provided\");\n+        this.foundApiKeysInfo = Collections.unmodifiableList(foundApiKeysInfo);\n+    }\n+\n+    public static GetApiKeyResponse emptyResponse() {\n+        return new GetApiKeyResponse(Collections.emptyList());\n+    }\n+\n+    public List<ApiKey> getApiKeyInfos() {\n+        return foundApiKeysInfo;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(foundApiKeysInfo);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final GetApiKeyResponse other = (GetApiKeyResponse) obj;\n+        return Objects.equals(foundApiKeysInfo, other.foundApiKeysInfo);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static ConstructingObjectParser<GetApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"get_api_key_response\", args -> {\n+        return (args[0] == null) ? GetApiKeyResponse.emptyResponse() : new GetApiKeyResponse((List<ApiKey>) args[0]);\n+    });\n+    static {\n+        PARSER.declareObjectArray(optionalConstructorArg(), (p, c) -> ApiKey.fromXContent(p), new ParseField(\"api_keys\"));\n+    }\n+\n+    public static GetApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"GetApiKeyResponse [foundApiKeysInfo=\" + foundApiKeysInfo + \"]\";\n+    }\n+}"
        },
        {
            "sha": "d3203354b7ab1333550f7b0ed72a0fc0fea09634",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/InvalidateApiKeyRequest.java",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,145 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.Validatable;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Request for invalidating API key(s) so that it can no longer be used\n+ */\n+public final class InvalidateApiKeyRequest implements Validatable, ToXContentObject {\n+\n+    private final String realmName;\n+    private final String userName;\n+    private final String id;\n+    private final String name;\n+\n+    // pkg scope for testing\n+    InvalidateApiKeyRequest(@Nullable String realmName, @Nullable String userName, @Nullable String apiKeyId,\n+            @Nullable String apiKeyName) {\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false && Strings.hasText(apiKeyId) == false\n+                && Strings.hasText(apiKeyName) == false) {\n+            throwValidationError(\"One of [api key id, api key name, username, realm name] must be specified\");\n+        }\n+        if (Strings.hasText(apiKeyId) || Strings.hasText(apiKeyName)) {\n+            if (Strings.hasText(realmName) || Strings.hasText(userName)) {\n+                throwValidationError(\n+                        \"username or realm name must not be specified when the api key id or api key name is specified\");\n+            }\n+        }\n+        if (Strings.hasText(apiKeyId) && Strings.hasText(apiKeyName)) {\n+            throwValidationError(\"only one of [api key id, api key name] can be specified\");\n+        }\n+        this.realmName = realmName;\n+        this.userName = userName;\n+        this.id = apiKeyId;\n+        this.name = apiKeyName;\n+    }\n+\n+    private void throwValidationError(String message) {\n+        throw new IllegalArgumentException(message);\n+    }\n+\n+    public String getRealmName() {\n+        return realmName;\n+    }\n+\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given realm name\n+     * @param realmName realm name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingRealmName(String realmName) {\n+        return new InvalidateApiKeyRequest(realmName, null, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given user name\n+     * @param userName user name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingUserName(String userName) {\n+        return new InvalidateApiKeyRequest(null, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given realm and user name\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingRealmAndUserName(String realmName, String userName) {\n+        return new InvalidateApiKeyRequest(realmName, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given api key id\n+     * @param apiKeyId api key id\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingApiKeyId(String apiKeyId) {\n+        return new InvalidateApiKeyRequest(null, null, apiKeyId, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given api key name\n+     * @param apiKeyName api key name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingApiKeyName(String apiKeyName) {\n+        return new InvalidateApiKeyRequest(null, null, null, apiKeyName);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject();\n+        if (realmName != null) {\n+            builder.field(\"realm_name\", realmName);\n+        }\n+        if (userName != null) {\n+            builder.field(\"username\", userName);\n+        }\n+        if (id != null) {\n+            builder.field(\"id\", id);\n+        }\n+        if (name != null) {\n+            builder.field(\"name\", name);\n+        }\n+        return builder.endObject();\n+    }\n+}"
        },
        {
            "sha": "48df9d0f7f12b571421b28370d93b07731e6b2c9",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/InvalidateApiKeyResponse.java",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,121 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+public final class InvalidateApiKeyResponse {\n+\n+    private final List<String> invalidatedApiKeys;\n+    private final List<String> previouslyInvalidatedApiKeys;\n+    private final List<ElasticsearchException> errors;\n+\n+    /**\n+     * Constructor for API keys invalidation response\n+     * @param invalidatedApiKeys list of invalidated API key ids\n+     * @param previouslyInvalidatedApiKeys list of previously invalidated API key ids\n+     * @param errors list of encountered errors while invalidating API keys\n+     */\n+    public InvalidateApiKeyResponse(List<String> invalidatedApiKeys, List<String> previouslyInvalidatedApiKeys,\n+                                    @Nullable List<ElasticsearchException> errors) {\n+        this.invalidatedApiKeys = Objects.requireNonNull(invalidatedApiKeys, \"invalidated_api_keys must be provided\");\n+        this.previouslyInvalidatedApiKeys = Objects.requireNonNull(previouslyInvalidatedApiKeys,\n+                \"previously_invalidated_api_keys must be provided\");\n+        if (null != errors) {\n+            this.errors = errors;\n+        } else {\n+            this.errors = Collections.emptyList();\n+        }\n+    }\n+\n+    public static InvalidateApiKeyResponse emptyResponse() {\n+        return new InvalidateApiKeyResponse(Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    public List<String> getInvalidatedApiKeys() {\n+        return invalidatedApiKeys;\n+    }\n+\n+    public List<String> getPreviouslyInvalidatedApiKeys() {\n+        return previouslyInvalidatedApiKeys;\n+    }\n+\n+    public List<ElasticsearchException> getErrors() {\n+        return errors;\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static ConstructingObjectParser<InvalidateApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"invalidate_api_key_response\",\n+            args -> {\n+                return new InvalidateApiKeyResponse((List<String>) args[0], (List<String>) args[1], (List<ElasticsearchException>) args[3]);\n+            });\n+    static {\n+        PARSER.declareStringArray(constructorArg(), new ParseField(\"invalidated_api_keys\"));\n+        PARSER.declareStringArray(constructorArg(), new ParseField(\"previously_invalidated_api_keys\"));\n+        // error count is parsed but ignored as we have list of errors\n+        PARSER.declareInt(constructorArg(), new ParseField(\"error_count\"));\n+        PARSER.declareObjectArray(optionalConstructorArg(), (p, c) -> ElasticsearchException.fromXContent(p),\n+                new ParseField(\"error_details\"));\n+    }\n+\n+    public static InvalidateApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(invalidatedApiKeys, previouslyInvalidatedApiKeys, errors);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        InvalidateApiKeyResponse other = (InvalidateApiKeyResponse) obj;\n+        return Objects.equals(invalidatedApiKeys, other.invalidatedApiKeys)\n+                && Objects.equals(previouslyInvalidatedApiKeys, other.previouslyInvalidatedApiKeys)\n+                && Objects.equals(errors, other.errors);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApiKeysInvalidationResult [invalidatedApiKeys=\" + invalidatedApiKeys + \", previouslyInvalidatedApiKeys=\"\n+                + previouslyInvalidatedApiKeys + \", errors=\" + errors + \"]\";\n+    }\n+}"
        },
        {
            "sha": "d021628f750cbd3c4df9093fbca161123414dc08",
            "filename": "client/rest-high-level/src/main/java/org/elasticsearch/client/security/support/ApiKey.java",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2Fsupport%2FApiKey.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2Fsupport%2FApiKey.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2Fsupport%2FApiKey.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security.support;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * API key information\n+ */\n+public final class ApiKey {\n+\n+    private final String name;\n+    private final String id;\n+    private final Instant creation;\n+    private final Instant expiration;\n+    private final boolean invalidated;\n+    private final String username;\n+    private final String realm;\n+\n+    public ApiKey(String name, String id, Instant creation, Instant expiration, boolean invalidated, String username, String realm) {\n+        this.name = name;\n+        this.id = id;\n+        // As we do not yet support the nanosecond precision when we serialize to JSON,\n+        // here creating the 'Instant' of milliseconds precision.\n+        // This Instant can then be used for date comparison.\n+        this.creation = Instant.ofEpochMilli(creation.toEpochMilli());\n+        this.expiration = (expiration != null) ? Instant.ofEpochMilli(expiration.toEpochMilli()): null;\n+        this.invalidated = invalidated;\n+        this.username = username;\n+        this.realm = realm;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * @return a instance of {@link Instant} when this API key was created.\n+     */\n+    public Instant getCreation() {\n+        return creation;\n+    }\n+\n+    /**\n+     * @return a instance of {@link Instant} when this API key will expire. In case the API key does not expire then will return\n+     * {@code null}\n+     */\n+    public Instant getExpiration() {\n+        return expiration;\n+    }\n+\n+    /**\n+     * @return {@code true} if this API key has been invalidated else returns {@code false}\n+     */\n+    public boolean isInvalidated() {\n+        return invalidated;\n+    }\n+\n+    /**\n+     * @return the username for which this API key was created.\n+     */\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    /**\n+     * @return the realm name of the user for which this API key was created.\n+     */\n+    public String getRealm() {\n+        return realm;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, id, creation, expiration, invalidated, username, realm);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        ApiKey other = (ApiKey) obj;\n+        return Objects.equals(name, other.name)\n+                && Objects.equals(id, other.id)\n+                && Objects.equals(creation, other.creation)\n+                && Objects.equals(expiration, other.expiration)\n+                && Objects.equals(invalidated, other.invalidated)\n+                && Objects.equals(username, other.username)\n+                && Objects.equals(realm, other.realm);\n+    }\n+\n+    static ConstructingObjectParser<ApiKey, Void> PARSER = new ConstructingObjectParser<>(\"api_key\", args -> {\n+        return new ApiKey((String) args[0], (String) args[1], Instant.ofEpochMilli((Long) args[2]),\n+                (args[3] == null) ? null : Instant.ofEpochMilli((Long) args[3]), (Boolean) args[4], (String) args[5], (String) args[6]);\n+    });\n+    static {\n+        PARSER.declareString(constructorArg(), new ParseField(\"name\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"id\"));\n+        PARSER.declareLong(constructorArg(), new ParseField(\"creation\"));\n+        PARSER.declareLong(optionalConstructorArg(), new ParseField(\"expiration\"));\n+        PARSER.declareBoolean(constructorArg(), new ParseField(\"invalidated\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"username\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"realm\"));\n+    }\n+\n+    public static ApiKey fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApiKey [name=\" + name + \", id=\" + id + \", creation=\" + creation + \", expiration=\" + expiration + \", invalidated=\"\n+                + invalidated + \", username=\" + username + \", realm=\" + realm + \"]\";\n+    }\n+}"
        },
        {
            "sha": "b2c2028d0fbbd6caba177e929b4e4ea1b35dc1c7",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/SecurityRequestConvertersTests.java",
            "status": "modified",
            "additions": 52,
            "deletions": 2,
            "changes": 54,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConvertersTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConvertersTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2FSecurityRequestConvertersTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -24,17 +24,20 @@\n import org.apache.http.client.methods.HttpPost;\n import org.apache.http.client.methods.HttpPut;\n import org.elasticsearch.client.security.ChangePasswordRequest;\n+import org.elasticsearch.client.security.CreateApiKeyRequest;\n import org.elasticsearch.client.security.CreateTokenRequest;\n import org.elasticsearch.client.security.DeletePrivilegesRequest;\n import org.elasticsearch.client.security.DeleteRoleMappingRequest;\n import org.elasticsearch.client.security.DeleteRoleRequest;\n import org.elasticsearch.client.security.DeleteUserRequest;\n import org.elasticsearch.client.security.DisableUserRequest;\n import org.elasticsearch.client.security.EnableUserRequest;\n+import org.elasticsearch.client.security.GetApiKeyRequest;\n import org.elasticsearch.client.security.GetPrivilegesRequest;\n import org.elasticsearch.client.security.GetRoleMappingsRequest;\n import org.elasticsearch.client.security.GetRolesRequest;\n import org.elasticsearch.client.security.GetUsersRequest;\n+import org.elasticsearch.client.security.InvalidateApiKeyRequest;\n import org.elasticsearch.client.security.PutPrivilegesRequest;\n import org.elasticsearch.client.security.PutRoleMappingRequest;\n import org.elasticsearch.client.security.PutRoleRequest;\n@@ -44,11 +47,14 @@\n import org.elasticsearch.client.security.support.expressiondsl.expressions.AnyRoleMapperExpression;\n import org.elasticsearch.client.security.support.expressiondsl.fields.FieldRoleMapperExpression;\n import org.elasticsearch.client.security.user.User;\n-import org.elasticsearch.client.security.user.privileges.ApplicationResourcePrivileges;\n import org.elasticsearch.client.security.user.privileges.ApplicationPrivilege;\n+import org.elasticsearch.client.security.user.privileges.ApplicationResourcePrivileges;\n import org.elasticsearch.client.security.user.privileges.IndicesPrivileges;\n import org.elasticsearch.client.security.user.privileges.Role;\n+import org.elasticsearch.client.security.user.privileges.Role.ClusterPrivilegeName;\n+import org.elasticsearch.client.security.user.privileges.Role.IndexPrivilegeName;\n import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.util.set.Sets;\n import org.elasticsearch.test.ESTestCase;\n \n@@ -61,6 +67,7 @@\n import java.util.Map;\n \n import static org.elasticsearch.client.RequestConvertersTests.assertToXContentBody;\n+import static org.hamcrest.Matchers.equalTo;\n \n public class SecurityRequestConvertersTests extends ESTestCase {\n \n@@ -411,4 +418,47 @@ public void testPutRole() throws IOException {\n         assertEquals(expectedParams, request.getParameters());\n         assertToXContentBody(putRoleRequest, request.getEntity());\n     }\n-}\n+\n+    public void testCreateApiKey() throws IOException {\n+        final String name = randomAlphaOfLengthBetween(4, 7);\n+        final List<Role> roles = Collections.singletonList(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        final TimeValue expiration = randomBoolean() ? null : TimeValue.timeValueHours(24);\n+        final RefreshPolicy refreshPolicy = randomFrom(RefreshPolicy.values());\n+        final Map<String, String> expectedParams;\n+        if (refreshPolicy != RefreshPolicy.NONE) {\n+            expectedParams = Collections.singletonMap(\"refresh\", refreshPolicy.getValue());\n+        } else {\n+            expectedParams = Collections.emptyMap();\n+        }\n+        final CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(name, roles, expiration, refreshPolicy);\n+        final Request request = SecurityRequestConverters.createApiKey(createApiKeyRequest);\n+        assertEquals(HttpPost.METHOD_NAME, request.getMethod());\n+        assertEquals(\"/_security/api_key\", request.getEndpoint());\n+        assertEquals(expectedParams, request.getParameters());\n+        assertToXContentBody(createApiKeyRequest, request.getEntity());\n+    }\n+\n+    public void testGetApiKey() throws IOException {\n+        String realmName = randomAlphaOfLength(5);\n+        String userName = randomAlphaOfLength(7);\n+        final GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingRealmAndUserName(realmName, userName);\n+        final Request request = SecurityRequestConverters.getApiKey(getApiKeyRequest);\n+        assertEquals(HttpGet.METHOD_NAME, request.getMethod());\n+        assertEquals(\"/_security/api_key\", request.getEndpoint());\n+        Map<String, String> mapOfParameters = new HashMap<>();\n+        mapOfParameters.put(\"realm_name\", realmName);\n+        mapOfParameters.put(\"username\", userName);\n+        assertThat(request.getParameters(), equalTo(mapOfParameters));\n+    }\n+\n+    public void testInvalidateApiKey() throws IOException {\n+        String realmName = randomAlphaOfLength(5);\n+        String userName = randomAlphaOfLength(7);\n+        final InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmAndUserName(realmName, userName);\n+        final Request request = SecurityRequestConverters.invalidateApiKey(invalidateApiKeyRequest);\n+        assertEquals(HttpDelete.METHOD_NAME, request.getMethod());\n+        assertEquals(\"/_security/api_key\", request.getEndpoint());\n+        assertToXContentBody(invalidateApiKeyRequest, request.getEntity());\n+    }\n+ }"
        },
        {
            "sha": "ea070868c6821e27a109a47278c924bf268fe11c",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/documentation/SecurityDocumentationIT.java",
            "status": "modified",
            "additions": 388,
            "deletions": 12,
            "changes": 400,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fdocumentation%2FSecurityDocumentationIT.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fdocumentation%2FSecurityDocumentationIT.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fdocumentation%2FSecurityDocumentationIT.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -33,6 +33,8 @@\n import org.elasticsearch.client.security.ClearRealmCacheResponse;\n import org.elasticsearch.client.security.ClearRolesCacheRequest;\n import org.elasticsearch.client.security.ClearRolesCacheResponse;\n+import org.elasticsearch.client.security.CreateApiKeyRequest;\n+import org.elasticsearch.client.security.CreateApiKeyResponse;\n import org.elasticsearch.client.security.CreateTokenRequest;\n import org.elasticsearch.client.security.CreateTokenResponse;\n import org.elasticsearch.client.security.DeletePrivilegesRequest;\n@@ -46,6 +48,8 @@\n import org.elasticsearch.client.security.DisableUserRequest;\n import org.elasticsearch.client.security.EnableUserRequest;\n import org.elasticsearch.client.security.ExpressionRoleMapping;\n+import org.elasticsearch.client.security.GetApiKeyRequest;\n+import org.elasticsearch.client.security.GetApiKeyResponse;\n import org.elasticsearch.client.security.GetPrivilegesRequest;\n import org.elasticsearch.client.security.GetPrivilegesResponse;\n import org.elasticsearch.client.security.GetRoleMappingsRequest;\n@@ -58,6 +62,8 @@\n import org.elasticsearch.client.security.GetUsersResponse;\n import org.elasticsearch.client.security.HasPrivilegesRequest;\n import org.elasticsearch.client.security.HasPrivilegesResponse;\n+import org.elasticsearch.client.security.InvalidateApiKeyRequest;\n+import org.elasticsearch.client.security.InvalidateApiKeyResponse;\n import org.elasticsearch.client.security.InvalidateTokenRequest;\n import org.elasticsearch.client.security.InvalidateTokenResponse;\n import org.elasticsearch.client.security.PutPrivilegesRequest;\n@@ -69,6 +75,7 @@\n import org.elasticsearch.client.security.PutUserRequest;\n import org.elasticsearch.client.security.PutUserResponse;\n import org.elasticsearch.client.security.RefreshPolicy;\n+import org.elasticsearch.client.security.support.ApiKey;\n import org.elasticsearch.client.security.support.CertificateInfo;\n import org.elasticsearch.client.security.support.expressiondsl.RoleMapperExpression;\n import org.elasticsearch.client.security.support.expressiondsl.expressions.AnyRoleMapperExpression;\n@@ -78,13 +85,17 @@\n import org.elasticsearch.client.security.user.privileges.ApplicationResourcePrivileges;\n import org.elasticsearch.client.security.user.privileges.IndicesPrivileges;\n import org.elasticsearch.client.security.user.privileges.Role;\n+import org.elasticsearch.client.security.user.privileges.Role.ClusterPrivilegeName;\n+import org.elasticsearch.client.security.user.privileges.Role.IndexPrivilegeName;\n import org.elasticsearch.client.security.user.privileges.UserIndicesPrivileges;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.unit.TimeValue;\n import org.elasticsearch.common.util.set.Sets;\n import org.hamcrest.Matchers;\n \n-import javax.crypto.SecretKeyFactory;\n-import javax.crypto.spec.PBEKeySpec;\n import java.io.IOException;\n+import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Base64;\n@@ -97,15 +108,20 @@\n import java.util.concurrent.CountDownLatch;\n import java.util.concurrent.TimeUnit;\n \n+import javax.crypto.SecretKeyFactory;\n+import javax.crypto.spec.PBEKeySpec;\n+\n import static org.hamcrest.Matchers.contains;\n import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.empty;\n import static org.hamcrest.Matchers.emptyIterable;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.greaterThan;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.isIn;\n import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n \n public class SecurityDocumentationIT extends ESRestHighLevelClientTestCase {\n@@ -336,7 +352,7 @@ public void onFailure(Exception e) {\n \n     private void addUser(RestHighLevelClient client, String userName, String password) throws IOException {\n         User user = new User(userName, Collections.singletonList(userName));\n-        PutUserRequest request = new PutUserRequest(user, password.toCharArray(), true, RefreshPolicy.NONE);\n+        PutUserRequest request = PutUserRequest.withPassword(user, password.toCharArray(), true, RefreshPolicy.NONE);\n         PutUserResponse response = client.security().putUser(request, RequestOptions.DEFAULT);\n         assertTrue(response.isCreated());\n     }\n@@ -510,7 +526,7 @@ public void testEnableUser() throws Exception {\n         RestHighLevelClient client = highLevelClient();\n         char[] password = new char[]{'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};\n         User enable_user = new User(\"enable_user\", Collections.singletonList(\"superuser\"));\n-        PutUserRequest putUserRequest = new PutUserRequest(enable_user, password, true, RefreshPolicy.IMMEDIATE);\n+        PutUserRequest putUserRequest = PutUserRequest.withPassword(enable_user, password, true, RefreshPolicy.IMMEDIATE);\n         PutUserResponse putUserResponse = client.security().putUser(putUserRequest, RequestOptions.DEFAULT);\n         assertTrue(putUserResponse.isCreated());\n \n@@ -555,7 +571,7 @@ public void testDisableUser() throws Exception {\n         RestHighLevelClient client = highLevelClient();\n         char[] password = new char[]{'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};\n         User disable_user = new User(\"disable_user\", Collections.singletonList(\"superuser\"));\n-        PutUserRequest putUserRequest = new PutUserRequest(disable_user, password, true, RefreshPolicy.IMMEDIATE);\n+        PutUserRequest putUserRequest = PutUserRequest.withPassword(disable_user, password, true, RefreshPolicy.IMMEDIATE);\n         PutUserResponse putUserResponse = client.security().putUser(putUserRequest, RequestOptions.DEFAULT);\n         assertTrue(putUserResponse.isCreated());\n         {\n@@ -1032,7 +1048,7 @@ public void testChangePassword() throws Exception {\n         char[] password = new char[]{'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};\n         char[] newPassword = new char[]{'n', 'e', 'w', 'p', 'a', 's', 's', 'w', 'o', 'r', 'd'};\n         User user = new User(\"change_password_user\", Collections.singletonList(\"superuser\"), Collections.emptyMap(), null, null);\n-        PutUserRequest putUserRequest = new PutUserRequest(user, password, true, RefreshPolicy.NONE);\n+        PutUserRequest putUserRequest = PutUserRequest.withPassword(user, password, true, RefreshPolicy.NONE);\n         PutUserResponse putUserResponse = client.security().putUser(putUserRequest, RequestOptions.DEFAULT);\n         assertTrue(putUserResponse.isCreated());\n         {\n@@ -1249,7 +1265,8 @@ public void testCreateToken() throws Exception {\n         {\n             // Setup user\n             User token_user = new User(\"token_user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putUserRequest = new PutUserRequest(token_user, \"password\".toCharArray(), true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putUserRequest = PutUserRequest.withPassword(token_user, \"password\".toCharArray(), true,\n+                    RefreshPolicy.IMMEDIATE);\n             PutUserResponse putUserResponse = client.security().putUser(putUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putUserResponse.isCreated());\n         }\n@@ -1327,27 +1344,27 @@ public void testInvalidateToken() throws Exception {\n             // Setup users\n             final char[] password = \"password\".toCharArray();\n             User user = new User(\"user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putUserRequest = new PutUserRequest(user, password, true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putUserRequest = PutUserRequest.withPassword(user, password, true, RefreshPolicy.IMMEDIATE);\n             PutUserResponse putUserResponse = client.security().putUser(putUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putUserResponse.isCreated());\n \n             User this_user = new User(\"this_user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putThisUserRequest = new PutUserRequest(this_user, password, true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putThisUserRequest = PutUserRequest.withPassword(this_user, password, true, RefreshPolicy.IMMEDIATE);\n             PutUserResponse putThisUserResponse = client.security().putUser(putThisUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putThisUserResponse.isCreated());\n \n             User that_user = new User(\"that_user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putThatUserRequest = new PutUserRequest(that_user, password, true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putThatUserRequest = PutUserRequest.withPassword(that_user, password, true, RefreshPolicy.IMMEDIATE);\n             PutUserResponse putThatUserResponse = client.security().putUser(putThatUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putThatUserResponse.isCreated());\n \n             User other_user = new User(\"other_user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putOtherUserRequest = new PutUserRequest(other_user, password, true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putOtherUserRequest = PutUserRequest.withPassword(other_user, password, true, RefreshPolicy.IMMEDIATE);\n             PutUserResponse putOtherUserResponse = client.security().putUser(putOtherUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putOtherUserResponse.isCreated());\n \n             User extra_user = new User(\"extra_user\", Collections.singletonList(\"kibana_user\"));\n-            PutUserRequest putExtraUserRequest = new PutUserRequest(extra_user, password, true, RefreshPolicy.IMMEDIATE);\n+            PutUserRequest putExtraUserRequest = PutUserRequest.withPassword(extra_user, password, true, RefreshPolicy.IMMEDIATE);\n             PutUserResponse putExtraUserResponse = client.security().putUser(putExtraUserRequest, RequestOptions.DEFAULT);\n             assertTrue(putExtraUserResponse.isCreated());\n \n@@ -1747,4 +1764,363 @@ public void onFailure(Exception e) {\n         }\n     }\n \n+    public void testCreateApiKey() throws Exception {\n+        RestHighLevelClient client = highLevelClient();\n+\n+        List<Role> roles = Collections.singletonList(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        final TimeValue expiration = TimeValue.timeValueHours(24);\n+        final RefreshPolicy refreshPolicy = randomFrom(RefreshPolicy.values());\n+        {\n+            final String name = randomAlphaOfLength(5);\n+            // tag::create-api-key-request\n+            CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(name, roles, expiration, refreshPolicy);\n+            // end::create-api-key-request\n+\n+            // tag::create-api-key-execute\n+            CreateApiKeyResponse createApiKeyResponse = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            // end::create-api-key-execute\n+\n+            // tag::create-api-key-response\n+            SecureString apiKey = createApiKeyResponse.getKey(); // <1>\n+            Instant apiKeyExpiration = createApiKeyResponse.getExpiration(); // <2>\n+            // end::create-api-key-response\n+            assertThat(createApiKeyResponse.getName(), equalTo(name));\n+            assertNotNull(apiKey);\n+            assertNotNull(apiKeyExpiration);\n+        }\n+\n+        {\n+            final String name = randomAlphaOfLength(5);\n+            CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(name, roles, expiration, refreshPolicy);\n+\n+            ActionListener<CreateApiKeyResponse> listener;\n+            // tag::create-api-key-execute-listener\n+            listener = new ActionListener<CreateApiKeyResponse>() {\n+                @Override\n+                public void onResponse(CreateApiKeyResponse createApiKeyResponse) {\n+                    // <1>\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    // <2>\n+                }\n+            };\n+            // end::create-api-key-execute-listener\n+\n+            // Avoid unused variable warning\n+            assertNotNull(listener);\n+\n+            // Replace the empty listener by a blocking listener in test\n+            final PlainActionFuture<CreateApiKeyResponse> future = new PlainActionFuture<>();\n+            listener = future;\n+\n+            // tag::create-api-key-execute-async\n+            client.security().createApiKeyAsync(createApiKeyRequest, RequestOptions.DEFAULT, listener); // <1>\n+            // end::create-api-key-execute-async\n+\n+            assertNotNull(future.get(30, TimeUnit.SECONDS));\n+            assertThat(future.get().getName(), equalTo(name));\n+            assertNotNull(future.get().getKey());\n+            assertNotNull(future.get().getExpiration());\n+        }\n+    }\n+\n+    public void testGetApiKey() throws Exception {\n+        RestHighLevelClient client = highLevelClient();\n+\n+        List<Role> roles = Collections.singletonList(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        final TimeValue expiration = TimeValue.timeValueHours(24);\n+        final RefreshPolicy refreshPolicy = randomFrom(RefreshPolicy.values());\n+        // Create API Keys\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(\"k1\", roles, expiration, refreshPolicy);\n+        CreateApiKeyResponse createApiKeyResponse1 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+        assertThat(createApiKeyResponse1.getName(), equalTo(\"k1\"));\n+        assertNotNull(createApiKeyResponse1.getKey());\n+\n+        final ApiKey expectedApiKeyInfo = new ApiKey(createApiKeyResponse1.getName(), createApiKeyResponse1.getId(), Instant.now(),\n+                Instant.now().plusMillis(expiration.getMillis()), false, \"test_user\", \"default_file\");\n+        {\n+            // tag::get-api-key-id-request\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingApiKeyId(createApiKeyResponse1.getId());\n+            // end::get-api-key-id-request\n+\n+            // tag::get-api-key-execute\n+            GetApiKeyResponse getApiKeyResponse = client.security().getApiKey(getApiKeyRequest, RequestOptions.DEFAULT);\n+            // end::get-api-key-execute\n+\n+            assertThat(getApiKeyResponse.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(getApiKeyResponse.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(getApiKeyResponse.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+\n+        {\n+            // tag::get-api-key-name-request\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingApiKeyName(createApiKeyResponse1.getName());\n+            // end::get-api-key-name-request\n+\n+            GetApiKeyResponse getApiKeyResponse = client.security().getApiKey(getApiKeyRequest, RequestOptions.DEFAULT);\n+\n+            assertThat(getApiKeyResponse.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(getApiKeyResponse.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(getApiKeyResponse.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+\n+        {\n+            // tag::get-realm-api-keys-request\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingRealmName(\"default_file\");\n+            // end::get-realm-api-keys-request\n+\n+            GetApiKeyResponse getApiKeyResponse = client.security().getApiKey(getApiKeyRequest, RequestOptions.DEFAULT);\n+\n+            assertThat(getApiKeyResponse.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(getApiKeyResponse.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(getApiKeyResponse.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+\n+        {\n+            // tag::get-user-api-keys-request\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingUserName(\"test_user\");\n+            // end::get-user-api-keys-request\n+\n+            GetApiKeyResponse getApiKeyResponse = client.security().getApiKey(getApiKeyRequest, RequestOptions.DEFAULT);\n+\n+            assertThat(getApiKeyResponse.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(getApiKeyResponse.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(getApiKeyResponse.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+\n+        {\n+            // tag::get-user-realm-api-keys-request\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingRealmAndUserName(\"default_file\", \"test_user\");\n+            // end::get-user-realm-api-keys-request\n+\n+            // tag::get-api-key-response\n+            GetApiKeyResponse getApiKeyResponse = client.security().getApiKey(getApiKeyRequest, RequestOptions.DEFAULT);\n+            // end::get-api-key-response\n+\n+            assertThat(getApiKeyResponse.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(getApiKeyResponse.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(getApiKeyResponse.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+\n+        {\n+            GetApiKeyRequest getApiKeyRequest = GetApiKeyRequest.usingApiKeyId(createApiKeyResponse1.getId());\n+\n+            ActionListener<GetApiKeyResponse> listener;\n+            // tag::get-api-key-execute-listener\n+            listener = new ActionListener<GetApiKeyResponse>() {\n+                @Override\n+                public void onResponse(GetApiKeyResponse getApiKeyResponse) {\n+                    // <1>\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    // <2>\n+                }\n+            };\n+            // end::get-api-key-execute-listener\n+\n+            // Avoid unused variable warning\n+            assertNotNull(listener);\n+\n+            // Replace the empty listener by a blocking listener in test\n+            final PlainActionFuture<GetApiKeyResponse> future = new PlainActionFuture<>();\n+            listener = future;\n+\n+            // tag::get-api-key-execute-async\n+            client.security().getApiKeyAsync(getApiKeyRequest, RequestOptions.DEFAULT, listener); // <1>\n+            // end::get-api-key-execute-async\n+\n+            final GetApiKeyResponse response = future.get(30, TimeUnit.SECONDS);\n+            assertNotNull(response);\n+\n+            assertThat(response.getApiKeyInfos(), is(notNullValue()));\n+            assertThat(response.getApiKeyInfos().size(), is(1));\n+            verifyApiKey(response.getApiKeyInfos().get(0), expectedApiKeyInfo);\n+        }\n+    }\n+\n+    private void verifyApiKey(final ApiKey actual, final ApiKey expected) {\n+        assertThat(actual.getId(), is(expected.getId()));\n+        assertThat(actual.getName(), is(expected.getName()));\n+        assertThat(actual.getUsername(), is(expected.getUsername()));\n+        assertThat(actual.getRealm(), is(expected.getRealm()));\n+        assertThat(actual.isInvalidated(), is(expected.isInvalidated()));\n+        assertThat(actual.getExpiration(), is(greaterThan(Instant.now())));\n+    }\n+\n+    public void testInvalidateApiKey() throws Exception {\n+        RestHighLevelClient client = highLevelClient();\n+\n+        List<Role> roles = Collections.singletonList(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        final TimeValue expiration = TimeValue.timeValueHours(24);\n+        final RefreshPolicy refreshPolicy = randomFrom(RefreshPolicy.values());\n+        // Create API Keys\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(\"k1\", roles, expiration, refreshPolicy);\n+        CreateApiKeyResponse createApiKeyResponse1 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+        assertThat(createApiKeyResponse1.getName(), equalTo(\"k1\"));\n+        assertNotNull(createApiKeyResponse1.getKey());\n+\n+        {\n+            // tag::invalidate-api-key-id-request\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingApiKeyId(createApiKeyResponse1.getId());\n+            // end::invalidate-api-key-id-request\n+\n+            // tag::invalidate-api-key-execute\n+            InvalidateApiKeyResponse invalidateApiKeyResponse = client.security().invalidateApiKey(invalidateApiKeyRequest,\n+                    RequestOptions.DEFAULT);\n+            // end::invalidate-api-key-execute\n+\n+            final List<ElasticsearchException> errors = invalidateApiKeyResponse.getErrors();\n+            final List<String> invalidatedApiKeyIds = invalidateApiKeyResponse.getInvalidatedApiKeys();\n+            final List<String> previouslyInvalidatedApiKeyIds = invalidateApiKeyResponse.getPreviouslyInvalidatedApiKeys();\n+\n+            assertTrue(errors.isEmpty());\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse1.getId());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(previouslyInvalidatedApiKeyIds.size(), equalTo(0));\n+        }\n+\n+        {\n+            createApiKeyRequest = new CreateApiKeyRequest(\"k2\", roles, expiration, refreshPolicy);\n+            CreateApiKeyResponse createApiKeyResponse2 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            assertThat(createApiKeyResponse2.getName(), equalTo(\"k2\"));\n+            assertNotNull(createApiKeyResponse2.getKey());\n+\n+            // tag::invalidate-api-key-name-request\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingApiKeyName(createApiKeyResponse2.getName());\n+            // end::invalidate-api-key-name-request\n+\n+            InvalidateApiKeyResponse invalidateApiKeyResponse = client.security().invalidateApiKey(invalidateApiKeyRequest,\n+                    RequestOptions.DEFAULT);\n+\n+            final List<ElasticsearchException> errors = invalidateApiKeyResponse.getErrors();\n+            final List<String> invalidatedApiKeyIds = invalidateApiKeyResponse.getInvalidatedApiKeys();\n+            final List<String> previouslyInvalidatedApiKeyIds = invalidateApiKeyResponse.getPreviouslyInvalidatedApiKeys();\n+\n+            assertTrue(errors.isEmpty());\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse2.getId());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(previouslyInvalidatedApiKeyIds.size(), equalTo(0));\n+        }\n+\n+        {\n+            createApiKeyRequest = new CreateApiKeyRequest(\"k3\", roles, expiration, refreshPolicy);\n+            CreateApiKeyResponse createApiKeyResponse3 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            assertThat(createApiKeyResponse3.getName(), equalTo(\"k3\"));\n+            assertNotNull(createApiKeyResponse3.getKey());\n+\n+            // tag::invalidate-realm-api-keys-request\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmName(\"default_file\");\n+            // end::invalidate-realm-api-keys-request\n+\n+            InvalidateApiKeyResponse invalidateApiKeyResponse = client.security().invalidateApiKey(invalidateApiKeyRequest,\n+                    RequestOptions.DEFAULT);\n+\n+            final List<ElasticsearchException> errors = invalidateApiKeyResponse.getErrors();\n+            final List<String> invalidatedApiKeyIds = invalidateApiKeyResponse.getInvalidatedApiKeys();\n+            final List<String> previouslyInvalidatedApiKeyIds = invalidateApiKeyResponse.getPreviouslyInvalidatedApiKeys();\n+\n+            assertTrue(errors.isEmpty());\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse3.getId());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(previouslyInvalidatedApiKeyIds.size(), equalTo(0));\n+        }\n+\n+        {\n+            createApiKeyRequest = new CreateApiKeyRequest(\"k4\", roles, expiration, refreshPolicy);\n+            CreateApiKeyResponse createApiKeyResponse4 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            assertThat(createApiKeyResponse4.getName(), equalTo(\"k4\"));\n+            assertNotNull(createApiKeyResponse4.getKey());\n+\n+            // tag::invalidate-user-api-keys-request\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingUserName(\"test_user\");\n+            // end::invalidate-user-api-keys-request\n+\n+            InvalidateApiKeyResponse invalidateApiKeyResponse = client.security().invalidateApiKey(invalidateApiKeyRequest,\n+                    RequestOptions.DEFAULT);\n+\n+            final List<ElasticsearchException> errors = invalidateApiKeyResponse.getErrors();\n+            final List<String> invalidatedApiKeyIds = invalidateApiKeyResponse.getInvalidatedApiKeys();\n+            final List<String> previouslyInvalidatedApiKeyIds = invalidateApiKeyResponse.getPreviouslyInvalidatedApiKeys();\n+\n+            assertTrue(errors.isEmpty());\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse4.getId());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(previouslyInvalidatedApiKeyIds.size(), equalTo(0));\n+        }\n+\n+        {\n+            createApiKeyRequest = new CreateApiKeyRequest(\"k5\", roles, expiration, refreshPolicy);\n+            CreateApiKeyResponse createApiKeyResponse5 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            assertThat(createApiKeyResponse5.getName(), equalTo(\"k5\"));\n+            assertNotNull(createApiKeyResponse5.getKey());\n+\n+            // tag::invalidate-user-realm-api-keys-request\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingRealmAndUserName(\"default_file\", \"test_user\");\n+            // end::invalidate-user-realm-api-keys-request\n+\n+            // tag::invalidate-api-key-response\n+            InvalidateApiKeyResponse invalidateApiKeyResponse = client.security().invalidateApiKey(invalidateApiKeyRequest,\n+                    RequestOptions.DEFAULT);\n+            // end::invalidate-api-key-response\n+\n+            final List<ElasticsearchException> errors = invalidateApiKeyResponse.getErrors();\n+            final List<String> invalidatedApiKeyIds = invalidateApiKeyResponse.getInvalidatedApiKeys();\n+            final List<String> previouslyInvalidatedApiKeyIds = invalidateApiKeyResponse.getPreviouslyInvalidatedApiKeys();\n+\n+            assertTrue(errors.isEmpty());\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse5.getId());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(previouslyInvalidatedApiKeyIds.size(), equalTo(0));\n+        }\n+\n+        {\n+            createApiKeyRequest = new CreateApiKeyRequest(\"k6\", roles, expiration, refreshPolicy);\n+            CreateApiKeyResponse createApiKeyResponse6 = client.security().createApiKey(createApiKeyRequest, RequestOptions.DEFAULT);\n+            assertThat(createApiKeyResponse6.getName(), equalTo(\"k6\"));\n+            assertNotNull(createApiKeyResponse6.getKey());\n+\n+            InvalidateApiKeyRequest invalidateApiKeyRequest = InvalidateApiKeyRequest.usingApiKeyId(createApiKeyResponse6.getId());\n+\n+            ActionListener<InvalidateApiKeyResponse> listener;\n+            // tag::invalidate-api-key-execute-listener\n+            listener = new ActionListener<InvalidateApiKeyResponse>() {\n+                @Override\n+                public void onResponse(InvalidateApiKeyResponse invalidateApiKeyResponse) {\n+                    // <1>\n+                }\n+\n+                @Override\n+                public void onFailure(Exception e) {\n+                    // <2>\n+                }\n+            };\n+            // end::invalidate-api-key-execute-listener\n+\n+            // Avoid unused variable warning\n+            assertNotNull(listener);\n+\n+            // Replace the empty listener by a blocking listener in test\n+            final PlainActionFuture<InvalidateApiKeyResponse> future = new PlainActionFuture<>();\n+            listener = future;\n+\n+            // tag::invalidate-api-key-execute-async\n+            client.security().invalidateApiKeyAsync(invalidateApiKeyRequest, RequestOptions.DEFAULT, listener); // <1>\n+            // end::invalidate-api-key-execute-async\n+\n+            final InvalidateApiKeyResponse response = future.get(30, TimeUnit.SECONDS);\n+            assertNotNull(response);\n+            final List<String> invalidatedApiKeyIds = response.getInvalidatedApiKeys();\n+            List<String> expectedInvalidatedApiKeyIds = Arrays.asList(createApiKeyResponse6.getId());\n+            assertTrue(response.getErrors().isEmpty());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(expectedInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+            assertThat(response.getPreviouslyInvalidatedApiKeys().size(), equalTo(0));\n+        }\n+    }\n }"
        },
        {
            "sha": "188493deeb78ac073ae431006bf68115a5802076",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/CreateApiKeyRequestTests.java",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,105 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.security.user.privileges.IndicesPrivileges;\n+import org.elasticsearch.client.security.user.privileges.Role;\n+import org.elasticsearch.client.security.user.privileges.Role.ClusterPrivilegeName;\n+import org.elasticsearch.client.security.user.privileges.Role.IndexPrivilegeName;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class CreateApiKeyRequestTests extends ESTestCase {\n+\n+    public void test() throws IOException {\n+        List<Role> roles = new ArrayList<>();\n+        roles.add(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        roles.add(Role.builder().name(\"r2\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-y\").privileges(IndexPrivilegeName.ALL).build()).build());\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(\"api-key\", roles, null, null);\n+        final XContentBuilder builder = XContentFactory.jsonBuilder();\n+        createApiKeyRequest.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+        final String output = Strings.toString(builder);\n+        assertThat(output, equalTo(\n+                \"{\\\"name\\\":\\\"api-key\\\",\\\"role_descriptors\\\":{\\\"r1\\\":{\\\"applications\\\":[],\\\"cluster\\\":[\\\"all\\\"],\\\"indices\\\":[{\\\"names\\\":\"\n+                        + \"[\\\"ind-x\\\"],\\\"privileges\\\":[\\\"all\\\"],\\\"allow_restricted_indices\\\":false}],\\\"metadata\\\":{},\\\"run_as\\\":[]},\"\n+                        + \"\\\"r2\\\":{\\\"applications\\\":[],\\\"cluster\\\":\"\n+                        + \"[\\\"all\\\"],\\\"indices\\\":[{\\\"names\\\":[\\\"ind-y\\\"],\\\"privileges\\\":[\\\"all\\\"],\\\"allow_restricted_indices\\\":false}],\"\n+                        + \"\\\"metadata\\\":{},\\\"run_as\\\":[]}}}\"));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        final String name = randomAlphaOfLength(5);\n+        List<Role> roles = Collections.singletonList(Role.builder().name(\"r1\").clusterPrivileges(ClusterPrivilegeName.ALL)\n+                .indicesPrivileges(IndicesPrivileges.builder().indices(\"ind-x\").privileges(IndexPrivilegeName.ALL).build()).build());\n+        final TimeValue expiration = null;\n+        final RefreshPolicy refreshPolicy = randomFrom(RefreshPolicy.values());\n+\n+        CreateApiKeyRequest createApiKeyRequest = new CreateApiKeyRequest(name, roles, expiration, refreshPolicy);\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyRequest, (original) -> {\n+            return new CreateApiKeyRequest(original.getName(), original.getRoles(), original.getExpiration(), original.getRefreshPolicy());\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyRequest, (original) -> {\n+            return new CreateApiKeyRequest(original.getName(), original.getRoles(), original.getExpiration(), original.getRefreshPolicy());\n+        }, CreateApiKeyRequestTests::mutateTestItem);\n+    }\n+\n+    private static CreateApiKeyRequest mutateTestItem(CreateApiKeyRequest original) {\n+        switch (randomIntBetween(0, 3)) {\n+        case 0:\n+            return new CreateApiKeyRequest(randomAlphaOfLength(5), original.getRoles(), original.getExpiration(),\n+                    original.getRefreshPolicy());\n+        case 1:\n+            return new CreateApiKeyRequest(original.getName(),\n+                    Collections.singletonList(Role.builder().name(randomAlphaOfLength(6)).clusterPrivileges(ClusterPrivilegeName.ALL)\n+                            .indicesPrivileges(\n+                                    IndicesPrivileges.builder().indices(randomAlphaOfLength(4)).privileges(IndexPrivilegeName.ALL).build())\n+                            .build()),\n+                    original.getExpiration(), original.getRefreshPolicy());\n+        case 2:\n+            return new CreateApiKeyRequest(original.getName(), original.getRoles(), TimeValue.timeValueSeconds(10000),\n+                    original.getRefreshPolicy());\n+        case 3:\n+            List<RefreshPolicy> values = Arrays.stream(RefreshPolicy.values()).filter(rp -> rp != original.getRefreshPolicy())\n+                    .collect(Collectors.toList());\n+            return new CreateApiKeyRequest(original.getName(), original.getRoles(), original.getExpiration(), randomFrom(values));\n+        default:\n+            return new CreateApiKeyRequest(randomAlphaOfLength(5), original.getRoles(), original.getExpiration(),\n+                    original.getRefreshPolicy());\n+        }\n+    }\n+}"
        },
        {
            "sha": "4481d70c80b371a54aa931c1abd80e8d8688dd9f",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/CreateApiKeyResponseTests.java",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FCreateApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.common.CharArrays;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class CreateApiKeyResponseTests extends ESTestCase {\n+\n+    public void testFromXContent() throws IOException {\n+        final String id = randomAlphaOfLengthBetween(4, 8);\n+        final String name = randomAlphaOfLength(5);\n+        final SecureString apiKey = UUIDs.randomBase64UUIDSecureString();\n+        final Instant expiration = randomBoolean() ? null : Instant.ofEpochMilli(10000);\n+\n+        final XContentType xContentType = randomFrom(XContentType.values());\n+        final XContentBuilder builder = XContentFactory.contentBuilder(xContentType);\n+        builder.startObject().field(\"id\", id).field(\"name\", name);\n+        if (expiration != null) {\n+            builder.field(\"expiration\", expiration.toEpochMilli());\n+        }\n+        byte[] charBytes = CharArrays.toUtf8Bytes(apiKey.getChars());\n+        try {\n+            builder.field(\"api_key\").utf8Value(charBytes, 0, charBytes.length);\n+        } finally {\n+            Arrays.fill(charBytes, (byte) 0);\n+        }\n+        builder.endObject();\n+        BytesReference xContent = BytesReference.bytes(builder);\n+\n+        final CreateApiKeyResponse response = CreateApiKeyResponse.fromXContent(createParser(xContentType.xContent(), xContent));\n+        assertThat(response.getId(), equalTo(id));\n+        assertThat(response.getName(), equalTo(name));\n+        assertThat(response.getKey(), equalTo(apiKey));\n+        if (expiration != null) {\n+            assertThat(response.getExpiration(), equalTo(expiration));\n+        }\n+    }\n+\n+    public void testEqualsHashCode() {\n+        final String id = randomAlphaOfLengthBetween(4, 8);\n+        final String name = randomAlphaOfLength(5);\n+        final SecureString apiKey = UUIDs.randomBase64UUIDSecureString();\n+        final Instant expiration = Instant.ofEpochMilli(10000);\n+        CreateApiKeyResponse createApiKeyResponse = new CreateApiKeyResponse(name, id, apiKey, expiration);\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyResponse, (original) -> {\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), original.getExpiration());\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyResponse, (original) -> {\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), original.getExpiration());\n+        }, CreateApiKeyResponseTests::mutateTestItem);\n+    }\n+\n+    private static CreateApiKeyResponse mutateTestItem(CreateApiKeyResponse original) {\n+        switch (randomIntBetween(0, 3)) {\n+        case 0:\n+            return new CreateApiKeyResponse(randomAlphaOfLength(7), original.getId(), original.getKey(), original.getExpiration());\n+        case 1:\n+            return new CreateApiKeyResponse(original.getName(), randomAlphaOfLengthBetween(4, 8), original.getKey(),\n+                    original.getExpiration());\n+        case 2:\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), UUIDs.randomBase64UUIDSecureString(),\n+                    original.getExpiration());\n+        case 3:\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), Instant.ofEpochMilli(150000));\n+        default:\n+            return new CreateApiKeyResponse(randomAlphaOfLength(7), original.getId(), original.getKey(), original.getExpiration());\n+        }\n+    }\n+}"
        },
        {
            "sha": "79551e1e73e9286735b002683806ecbec9c22531",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/GetApiKeyRequestTests.java",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,72 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class GetApiKeyRequestTests extends ESTestCase {\n+\n+    public void testRequestValidation() {\n+        GetApiKeyRequest request = GetApiKeyRequest.usingApiKeyId(randomAlphaOfLength(5));\n+        Optional<ValidationException> ve = request.validate();\n+        assertFalse(ve.isPresent());\n+        request = GetApiKeyRequest.usingApiKeyName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertFalse(ve.isPresent());\n+        request = GetApiKeyRequest.usingRealmName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertFalse(ve.isPresent());\n+        request = GetApiKeyRequest.usingUserName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertFalse(ve.isPresent());\n+        request = GetApiKeyRequest.usingRealmAndUserName(randomAlphaOfLength(5), randomAlphaOfLength(7));\n+        ve = request.validate();\n+        assertFalse(ve.isPresent());\n+    }\n+\n+    public void testRequestValidationFailureScenarios() throws IOException {\n+        String[][] inputs = new String[][] {\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }),\n+                        randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), \"user\", \"api-kid\", \"api-kname\" },\n+                { \"realm\", randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" },\n+                { \"realm\", \"user\", \"api-kid\", randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" } };\n+        String[] expectedErrorMessages = new String[] { \"One of [api key id, api key name, username, realm name] must be specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"only one of [api key id, api key name] can be specified\" };\n+\n+        for (int i = 0; i < inputs.length; i++) {\n+            final int caseNo = i;\n+            IllegalArgumentException ve = expectThrows(IllegalArgumentException.class,\n+                    () -> new GetApiKeyRequest(inputs[caseNo][0], inputs[caseNo][1], inputs[caseNo][2], inputs[caseNo][3]));\n+            assertNotNull(ve);\n+            assertThat(ve.getMessage(), equalTo(expectedErrorMessages[caseNo]));\n+        }\n+    }\n+}"
        },
        {
            "sha": "7aa92e4f212a43e1cd7475df28923bd05b50ceeb",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/GetApiKeyResponseTests.java",
            "status": "added",
            "additions": 100,
            "deletions": 0,
            "changes": 100,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FGetApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,100 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.security.support.ApiKey;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class GetApiKeyResponseTests extends ESTestCase {\n+\n+    public void testFromXContent() throws IOException {\n+        ApiKey apiKeyInfo1 = createApiKeyInfo(\"name1\", \"id-1\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), false,\n+                \"user-a\", \"realm-x\");\n+        ApiKey apiKeyInfo2 = createApiKeyInfo(\"name2\", \"id-2\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), true,\n+                \"user-b\", \"realm-y\");\n+        GetApiKeyResponse response = new GetApiKeyResponse(Arrays.asList(apiKeyInfo1, apiKeyInfo2));\n+        final XContentType xContentType = randomFrom(XContentType.values());\n+        final XContentBuilder builder = XContentFactory.contentBuilder(xContentType);\n+        toXContent(response, builder);\n+        BytesReference xContent = BytesReference.bytes(builder);\n+        GetApiKeyResponse responseParsed = GetApiKeyResponse.fromXContent(createParser(xContentType.xContent(), xContent));\n+        assertThat(responseParsed, equalTo(response));\n+    }\n+\n+    private void toXContent(GetApiKeyResponse response, final XContentBuilder builder) throws IOException {\n+        builder.startObject();\n+        builder.startArray(\"api_keys\");\n+        for (ApiKey apiKey : response.getApiKeyInfos()) {\n+        builder.startObject()\n+        .field(\"id\", apiKey.getId())\n+        .field(\"name\", apiKey.getName())\n+        .field(\"creation\", apiKey.getCreation().toEpochMilli());\n+        if (apiKey.getExpiration() != null) {\n+            builder.field(\"expiration\", apiKey.getExpiration().toEpochMilli());\n+        }\n+        builder.field(\"invalidated\", apiKey.isInvalidated())\n+        .field(\"username\", apiKey.getUsername())\n+        .field(\"realm\", apiKey.getRealm());\n+        builder.endObject();\n+        }\n+        builder.endArray();\n+        builder.endObject();\n+    }\n+\n+    public void testEqualsHashCode() {\n+        ApiKey apiKeyInfo1 = createApiKeyInfo(\"name1\", \"id-1\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), false,\n+                \"user-a\", \"realm-x\");\n+        GetApiKeyResponse response = new GetApiKeyResponse(Arrays.asList(apiKeyInfo1));\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(response, (original) -> {\n+            return new GetApiKeyResponse(original.getApiKeyInfos());\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(response, (original) -> {\n+            return new GetApiKeyResponse(original.getApiKeyInfos());\n+        }, GetApiKeyResponseTests::mutateTestItem);\n+    }\n+\n+    private static GetApiKeyResponse mutateTestItem(GetApiKeyResponse original) {\n+        ApiKey apiKeyInfo = createApiKeyInfo(\"name2\", \"id-2\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), true,\n+                \"user-b\", \"realm-y\");\n+        switch (randomIntBetween(0, 2)) {\n+        case 0:\n+            return new GetApiKeyResponse(Arrays.asList(apiKeyInfo));\n+        default:\n+            return new GetApiKeyResponse(Arrays.asList(apiKeyInfo));\n+        }\n+    }\n+\n+    private static ApiKey createApiKeyInfo(String name, String id, Instant creation, Instant expiration, boolean invalidated,\n+                                           String username, String realm) {\n+        return new ApiKey(name, id, creation, expiration, invalidated, username, realm);\n+    }\n+}"
        },
        {
            "sha": "25ee4bb05bcc473eb98e3b8b6f24788a07543f87",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/InvalidateApiKeyRequestTests.java",
            "status": "added",
            "additions": 73,
            "deletions": 0,
            "changes": 73,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,73 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.client.ValidationException;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.Optional;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class InvalidateApiKeyRequestTests extends ESTestCase {\n+\n+    public void testRequestValidation() {\n+        InvalidateApiKeyRequest request = InvalidateApiKeyRequest.usingApiKeyId(randomAlphaOfLength(5));\n+        Optional<ValidationException> ve = request.validate();\n+        assertThat(ve.isPresent(), is(false));\n+        request = InvalidateApiKeyRequest.usingApiKeyName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertThat(ve.isPresent(), is(false));\n+        request = InvalidateApiKeyRequest.usingRealmName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertThat(ve.isPresent(), is(false));\n+        request = InvalidateApiKeyRequest.usingUserName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertThat(ve.isPresent(), is(false));\n+        request = InvalidateApiKeyRequest.usingRealmAndUserName(randomAlphaOfLength(5), randomAlphaOfLength(7));\n+        ve = request.validate();\n+        assertThat(ve.isPresent(), is(false));\n+    }\n+\n+    public void testRequestValidationFailureScenarios() throws IOException {\n+        String[][] inputs = new String[][] {\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }),\n+                        randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), \"user\", \"api-kid\", \"api-kname\" },\n+                { \"realm\", randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" },\n+                { \"realm\", \"user\", \"api-kid\", randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" } };\n+        String[] expectedErrorMessages = new String[] { \"One of [api key id, api key name, username, realm name] must be specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                \"only one of [api key id, api key name] can be specified\" };\n+\n+        for (int i = 0; i < inputs.length; i++) {\n+            final int caseNo = i;\n+            IllegalArgumentException ve = expectThrows(IllegalArgumentException.class,\n+                    () -> new InvalidateApiKeyRequest(inputs[caseNo][0], inputs[caseNo][1], inputs[caseNo][2], inputs[caseNo][3]));\n+            assertNotNull(ve);\n+            assertThat(ve.getMessage(), equalTo(expectedErrorMessages[caseNo]));\n+        }\n+    }\n+}"
        },
        {
            "sha": "f5cd403536fc249ff99603c3289cef3c79857d3d",
            "filename": "client/rest-high-level/src/test/java/org/elasticsearch/client/security/InvalidateApiKeyResponseTests.java",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/client%2Frest-high-level%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fclient%2Fsecurity%2FInvalidateApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,111 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.client.security;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+\n+public class InvalidateApiKeyResponseTests extends ESTestCase {\n+\n+    public void testFromXContent() throws IOException {\n+        List<String> invalidatedApiKeys = Arrays.asList(randomArray(2, 5, String[]::new, () -> randomAlphaOfLength(5)));\n+        List<String> previouslyInvalidatedApiKeys = Arrays.asList(randomArray(2, 3, String[]::new, () -> randomAlphaOfLength(5)));\n+        List<ElasticsearchException> errors = Arrays.asList(randomArray(2, 5, ElasticsearchException[]::new,\n+                () -> new ElasticsearchException(randomAlphaOfLength(5), new IllegalArgumentException(randomAlphaOfLength(4)))));\n+\n+        final XContentType xContentType = randomFrom(XContentType.values());\n+        final XContentBuilder builder = XContentFactory.contentBuilder(xContentType);\n+        builder.startObject().array(\"invalidated_api_keys\", invalidatedApiKeys.toArray(Strings.EMPTY_ARRAY))\n+                .array(\"previously_invalidated_api_keys\", previouslyInvalidatedApiKeys.toArray(Strings.EMPTY_ARRAY))\n+                .field(\"error_count\", errors.size());\n+        if (errors.isEmpty() == false) {\n+            builder.field(\"error_details\");\n+            builder.startArray();\n+            for (ElasticsearchException e : errors) {\n+                builder.startObject();\n+                ElasticsearchException.generateThrowableXContent(builder, ToXContent.EMPTY_PARAMS, e);\n+                builder.endObject();\n+            }\n+            builder.endArray();\n+        }\n+        builder.endObject();\n+        BytesReference xContent = BytesReference.bytes(builder);\n+\n+        final InvalidateApiKeyResponse response = InvalidateApiKeyResponse.fromXContent(createParser(xContentType.xContent(), xContent));\n+        assertThat(response.getInvalidatedApiKeys(), containsInAnyOrder(invalidatedApiKeys.toArray(Strings.EMPTY_ARRAY)));\n+        assertThat(response.getPreviouslyInvalidatedApiKeys(),\n+                containsInAnyOrder(previouslyInvalidatedApiKeys.toArray(Strings.EMPTY_ARRAY)));\n+        assertThat(response.getErrors(), is(notNullValue()));\n+        assertThat(response.getErrors().size(), is(errors.size()));\n+        assertThat(response.getErrors().get(0).toString(), containsString(\"type=illegal_argument_exception\"));\n+        assertThat(response.getErrors().get(1).toString(), containsString(\"type=illegal_argument_exception\"));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        List<String> invalidatedApiKeys = Arrays.asList(randomArray(2, 5, String[]::new, () -> randomAlphaOfLength(5)));\n+        List<String> previouslyInvalidatedApiKeys = Arrays.asList(randomArray(2, 3, String[]::new, () -> randomAlphaOfLength(5)));\n+        List<ElasticsearchException> errors = Arrays.asList(randomArray(2, 5, ElasticsearchException[]::new,\n+                () -> new ElasticsearchException(randomAlphaOfLength(5), new IllegalArgumentException(randomAlphaOfLength(4)))));\n+        InvalidateApiKeyResponse invalidateApiKeyResponse = new InvalidateApiKeyResponse(invalidatedApiKeys, previouslyInvalidatedApiKeys,\n+                errors);\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(invalidateApiKeyResponse, (original) -> {\n+            return new InvalidateApiKeyResponse(original.getInvalidatedApiKeys(), original.getPreviouslyInvalidatedApiKeys(),\n+                    original.getErrors());\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(invalidateApiKeyResponse, (original) -> {\n+            return new InvalidateApiKeyResponse(original.getInvalidatedApiKeys(), original.getPreviouslyInvalidatedApiKeys(),\n+                    original.getErrors());\n+        }, InvalidateApiKeyResponseTests::mutateTestItem);\n+    }\n+\n+    private static InvalidateApiKeyResponse mutateTestItem(InvalidateApiKeyResponse original) {\n+        switch (randomIntBetween(0, 2)) {\n+        case 0:\n+            return new InvalidateApiKeyResponse(Arrays.asList(randomArray(2, 5, String[]::new, () -> randomAlphaOfLength(5))),\n+                    original.getPreviouslyInvalidatedApiKeys(), original.getErrors());\n+        case 1:\n+            return new InvalidateApiKeyResponse(original.getInvalidatedApiKeys(), Collections.emptyList(), original.getErrors());\n+        case 2:\n+            return new InvalidateApiKeyResponse(original.getInvalidatedApiKeys(), original.getPreviouslyInvalidatedApiKeys(),\n+                    Collections.emptyList());\n+        default:\n+            return new InvalidateApiKeyResponse(Arrays.asList(randomArray(2, 5, String[]::new, () -> randomAlphaOfLength(5))),\n+                    original.getPreviouslyInvalidatedApiKeys(), original.getErrors());\n+        }\n+    }\n+}"
        },
        {
            "sha": "93c3fa16de1da4d789cf139e0062435b4b1af71c",
            "filename": "docs/java-rest/high-level/security/create-api-key.asciidoc",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fcreate-api-key.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fcreate-api-key.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fcreate-api-key.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,40 @@\n+--\n+:api: create-api-key\n+:request: CreateApiKeyRequest\n+:response: CreateApiKeyResponse\n+--\n+\n+[id=\"{upid}-{api}\"]\n+=== Create API Key API\n+\n+API Key can be created using this API.\n+\n+[id=\"{upid}-{api}-request\"]\n+==== Create API Key Request\n+\n+A +{request}+ contains name for the API key,\n+list of role descriptors to define permissions and\n+optional expiration for the generated API key.\n+If expiration is not provided then by default the API\n+keys do not expire.\n+\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[{api}-request]\n+--------------------------------------------------\n+\n+include::../execution.asciidoc[]\n+\n+[id=\"{upid}-{api}-response\"]\n+==== Create API Key Response\n+\n+The returned +{response}+ contains an id,\n+API key, name for the API key and optional\n+expiration.\n+\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[{api}-response]\n+--------------------------------------------------\n+<1> the API key that can be used to authenticate to Elasticsearch.\n+<2> expiration if the API keys expire\n\\ No newline at end of file"
        },
        {
            "sha": "bb98b527d22ba546bf713e891fca87edaed9aed3",
            "filename": "docs/java-rest/high-level/security/get-api-key.asciidoc",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fget-api-key.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fget-api-key.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Fget-api-key.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,67 @@\n+--\n+:api: get-api-key\n+:request: GetApiKeyRequest\n+:response: GetApiKeyResponse\n+--\n+\n+[id=\"{upid}-{api}\"]\n+=== Get API Key information API\n+\n+API Key(s) information can be retrieved using this API.\n+\n+[id=\"{upid}-{api}-request\"]\n+==== Get API Key Request\n+The +{request}+ supports retrieving API key information for\n+\n+. A specific API key\n+\n+. All API keys for a specific realm\n+\n+. All API keys for a specific user\n+\n+. All API keys for a specific user in a specific realm\n+\n+===== Retrieve a specific API key by its id\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[get-api-key-id-request]\n+--------------------------------------------------\n+\n+===== Retrieve a specific API key by its name\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[get-api-key-name-request]\n+--------------------------------------------------\n+\n+===== Retrieve all API keys for given realm\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[get-realm-api-keys-request]\n+--------------------------------------------------\n+\n+===== Retrieve all API keys for a given user\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[get-user-api-keys-request]\n+--------------------------------------------------\n+\n+===== Retrieve all API keys for given user in a realm\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[get-user-realm-api-keys-request]\n+--------------------------------------------------\n+\n+include::../execution.asciidoc[]\n+\n+[id=\"{upid}-{api}-response\"]\n+==== Get API Key information API Response\n+\n+The returned +{response}+ contains the information regarding the API keys that were\n+requested.\n+\n+`api_keys`:: Available using `getApiKeyInfos`, contains list of API keys that were retrieved for this request.\n+\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[{api}-response]\n+--------------------------------------------------"
        },
        {
            "sha": "7f9c43b3165a8dee21d217cc07aa7364ddc08530",
            "filename": "docs/java-rest/high-level/security/invalidate-api-key.asciidoc",
            "status": "added",
            "additions": 75,
            "deletions": 0,
            "changes": 75,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Finvalidate-api-key.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Finvalidate-api-key.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs%2Fjava-rest%2Fhigh-level%2Fsecurity%2Finvalidate-api-key.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,75 @@\n+--\n+:api: invalidate-api-key\n+:request: InvalidateApiKeyRequest\n+:response: InvalidateApiKeyResponse\n+--\n+\n+[id=\"{upid}-{api}\"]\n+=== Invalidate API Key API\n+\n+API Key(s) can be invalidated using this API.\n+\n+[id=\"{upid}-{api}-request\"]\n+==== Invalidate API Key Request\n+The +{request}+ supports invalidating\n+\n+. A specific API key\n+\n+. All API keys for a specific realm\n+\n+. All API keys for a specific user\n+\n+. All API keys for a specific user in a specific realm\n+\n+===== Specific API key by API key id\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[invalidate-api-key-id-request]\n+--------------------------------------------------\n+\n+===== Specific API key by API key name\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[invalidate-api-key-name-request]\n+--------------------------------------------------\n+\n+===== All API keys for realm\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[invalidate-realm-api-keys-request]\n+--------------------------------------------------\n+\n+===== All API keys for user\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[invalidate-user-api-keys-request]\n+--------------------------------------------------\n+\n+===== All API key for user in realm\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[invalidate-user-realm-api-keys-request]\n+--------------------------------------------------\n+\n+include::../execution.asciidoc[]\n+\n+[id=\"{upid}-{api}-response\"]\n+==== Invalidate API Key Response\n+\n+The returned +{response}+ contains the information regarding the API keys that the request\n+invalidated.\n+\n+`invalidatedApiKeys`:: Available using `getInvalidatedApiKeys` lists the API keys\n+                      that this request invalidated.\n+\n+`previouslyInvalidatedApiKeys`:: Available using `getPreviouslyInvalidatedApiKeys` lists the API keys\n+                                that this request attempted to invalidate\n+                                but were already invalid.\n+\n+`errors`:: Available using `getErrors` contains possible errors that were encountered while\n+           attempting to invalidate API keys.\n+\n+[\"source\",\"java\",subs=\"attributes,callouts,macros\"]\n+--------------------------------------------------\n+include-tagged::{doc-tests-file}[{api}-response]\n+--------------------------------------------------\n\\ No newline at end of file"
        },
        {
            "sha": "1df10985e7e3b9b3240da295a56fbac3b3841976",
            "filename": "docs/java-rest/high-level/supported-apis.asciidoc",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsupported-apis.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/docs%2Fjava-rest%2Fhigh-level%2Fsupported-apis.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/docs%2Fjava-rest%2Fhigh-level%2Fsupported-apis.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -411,6 +411,9 @@ The Java High Level REST Client supports the following Security APIs:\n * <<{upid}-get-privileges>>\n * <<{upid}-put-privileges>>\n * <<{upid}-delete-privileges>>\n+* <<{upid}-create-api-key>>\n+* <<{upid}-get-api-key>>\n+* <<{upid}-invalidate-api-key>>\n \n include::security/put-user.asciidoc[]\n include::security/get-users.asciidoc[]\n@@ -435,6 +438,9 @@ include::security/delete-role-mapping.asciidoc[]\n include::security/create-token.asciidoc[]\n include::security/invalidate-token.asciidoc[]\n include::security/put-privileges.asciidoc[]\n+include::security/create-api-key.asciidoc[]\n+include::security/get-api-key.asciidoc[]\n+include::security/invalidate-api-key.asciidoc[]\n \n == Watcher APIs\n "
        },
        {
            "sha": "c83edb69b3e629068896dcbddccf5f82a4bdc683",
            "filename": "rest-api-spec/src/main/resources/rest-api-spec/test/README.asciidoc",
            "status": "modified",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/rest-api-spec%2Fsrc%2Fmain%2Fresources%2Frest-api-spec%2Ftest%2FREADME.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/rest-api-spec%2Fsrc%2Fmain%2Fresources%2Frest-api-spec%2Ftest%2FREADME.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/rest-api-spec%2Fsrc%2Fmain%2Fresources%2Frest-api-spec%2Ftest%2FREADME.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -280,6 +280,31 @@ example above), but the same goes for actual values:\n \n The stash should be reset at the beginning of each test file.\n \n+=== `transform_and_set`\n+\n+For some tests, it is necessary to extract a value and transform it from the previous `response`, in\n+order to reuse it in a subsequent `do` and other tests.\n+Currently, it only has support for `base64EncodeCredentials`, for unknown transformations it will not\n+do anything and stash the value as is.\n+For instance, when testing you may want to base64 encode username and password for\n+`Basic` authorization header:\n+\n+....\n+    - do:\n+        index:\n+            index: test\n+            type:  test\n+    - transform_and_set:  { login_creds: \"#base64EncodeCredentials(user,password)\" }   # stash the base64 encoded credentials of `response.user` and `response.password` as `login_creds`\n+    - do:\n+        headers:\n+            Authorization: Basic ${login_creds} # replace `$login_creds` with the stashed value\n+        get:\n+            index: test\n+            type:  test\n+....\n+\n+Stashed values can be used as described in the `set` section\n+\n === `is_true`\n \n The specified key exists and has a true value (ie not `0`, `false`, `undefined`, `null`"
        },
        {
            "sha": "b5b35b477efbd1dedc0b6e1a5184aabe663d3ad7",
            "filename": "server/src/main/java/org/elasticsearch/common/RandomBasedUUIDGenerator.java",
            "status": "modified",
            "additions": 31,
            "deletions": 3,
            "changes": 34,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FRandomBasedUUIDGenerator.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FRandomBasedUUIDGenerator.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FRandomBasedUUIDGenerator.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -20,6 +20,9 @@\n package org.elasticsearch.common;\n \n \n+import org.elasticsearch.common.settings.SecureString;\n+\n+import java.util.Arrays;\n import java.util.Base64;\n import java.util.Random;\n \n@@ -34,12 +37,37 @@ public String getBase64UUID() {\n         return getBase64UUID(SecureRandomHolder.INSTANCE);\n     }\n \n+    /**\n+     * Returns a Base64 encoded {@link SecureString} of a Version 4.0 compatible UUID\n+     * as defined here: http://www.ietf.org/rfc/rfc4122.txt\n+     */\n+    public SecureString getBase64UUIDSecureString() {\n+        byte[] uuidBytes = null;\n+        byte[] encodedBytes = null;\n+        try {\n+            uuidBytes = getUUIDBytes(SecureRandomHolder.INSTANCE);\n+            encodedBytes = Base64.getUrlEncoder().withoutPadding().encode(uuidBytes);\n+            return new SecureString(CharArrays.utf8BytesToChars(encodedBytes));\n+        } finally {\n+            if (uuidBytes != null) {\n+                Arrays.fill(uuidBytes, (byte) 0);\n+            }\n+            if (encodedBytes != null) {\n+                Arrays.fill(encodedBytes, (byte) 0);\n+            }\n+        }\n+    }\n+\n     /**\n      * Returns a Base64 encoded version of a Version 4.0 compatible UUID\n      * randomly initialized by the given {@link java.util.Random} instance\n      * as defined here: http://www.ietf.org/rfc/rfc4122.txt\n      */\n     public String getBase64UUID(Random random) {\n+        return Base64.getUrlEncoder().withoutPadding().encodeToString(getUUIDBytes(random));\n+    }\n+\n+    private byte[] getUUIDBytes(Random random) {\n         final byte[] randomBytes = new byte[16];\n         random.nextBytes(randomBytes);\n         /* Set the version to version 4 (see http://www.ietf.org/rfc/rfc4122.txt)\n@@ -48,12 +76,12 @@ public String getBase64UUID(Random random) {\n          * stamp (bits 4 through 7 of the time_hi_and_version field).*/\n         randomBytes[6] &= 0x0f;  /* clear the 4 most significant bits for the version  */\n         randomBytes[6] |= 0x40;  /* set the version to 0100 / 0x40 */\n-        \n-        /* Set the variant: \n+\n+        /* Set the variant:\n          * The high field of th clock sequence multiplexed with the variant.\n          * We set only the MSB of the variant*/\n         randomBytes[8] &= 0x3f;  /* clear the 2 most significant bits */\n         randomBytes[8] |= 0x80;  /* set the variant (MSB is set)*/\n-        return Base64.getUrlEncoder().withoutPadding().encodeToString(randomBytes);\n+        return randomBytes;\n     }\n }"
        },
        {
            "sha": "a6a314c2cccb0e8259c185230b9468f15f92f4b5",
            "filename": "server/src/main/java/org/elasticsearch/common/UUIDs.java",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FUUIDs.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FUUIDs.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2FUUIDs.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -19,6 +19,8 @@\n \n package org.elasticsearch.common;\n \n+import org.elasticsearch.common.settings.SecureString;\n+\n import java.util.Random;\n \n public class UUIDs {\n@@ -50,4 +52,9 @@ public static String randomBase64UUID() {\n         return RANDOM_UUID_GENERATOR.getBase64UUID();\n     }\n \n+    /** Returns a Base64 encoded {@link SecureString} of a Version 4.0 compatible UUID as defined here: http://www.ietf.org/rfc/rfc4122.txt,\n+     *  using a private {@code SecureRandom} instance */\n+    public static SecureString randomBase64UUIDSecureString() {\n+        return RANDOM_UUID_GENERATOR.getBase64UUIDSecureString();\n+    }\n }"
        },
        {
            "sha": "f361225b48f2da3497899f0b6abf32a5f7f1a806",
            "filename": "server/src/main/java/org/elasticsearch/common/io/stream/StreamInput.java",
            "status": "modified",
            "additions": 17,
            "deletions": 0,
            "changes": 17,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamInput.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamInput.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamInput.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -588,6 +588,23 @@ public Object readGenericValue() throws IOException {\n         }\n     }\n \n+    /**\n+     * Read an {@link Instant} from the stream with nanosecond resolution\n+     */\n+    public final Instant readInstant() throws IOException {\n+        return Instant.ofEpochSecond(readLong(), readInt());\n+    }\n+\n+    /**\n+     * Read an optional {@link Instant} from the stream. Returns <code>null</code> when\n+     * no instant is present.\n+     */\n+    @Nullable\n+    public final Instant readOptionalInstant() throws IOException {\n+        final boolean present = readBoolean();\n+        return present ? readInstant() : null;\n+    }\n+\n     @SuppressWarnings(\"unchecked\")\n     private List readArrayList() throws IOException {\n         int size = readArraySize();"
        },
        {
            "sha": "1c9dfd7ea44339367474cf084b1160efbf6bea52",
            "filename": "server/src/main/java/org/elasticsearch/common/io/stream/StreamOutput.java",
            "status": "modified",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamOutput.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamOutput.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamOutput.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -56,6 +56,7 @@\n import java.nio.file.NoSuchFileException;\n import java.nio.file.NotDirectoryException;\n import java.time.ZoneId;\n+import java.time.Instant;\n import java.time.ZonedDateTime;\n import java.util.Collection;\n import java.util.Collections;\n@@ -573,6 +574,26 @@ public final <K, V> void writeMap(final Map<K, V> map, final Writer<K> keyWriter\n         }\n     }\n \n+    /**\n+     * Writes an {@link Instant} to the stream with nanosecond resolution\n+     */\n+    public final void writeInstant(Instant instant) throws IOException {\n+        writeLong(instant.getEpochSecond());\n+        writeInt(instant.getNano());\n+    }\n+\n+    /**\n+     * Writes an {@link Instant} to the stream, which could possibly be null\n+     */\n+    public final void writeOptionalInstant(@Nullable Instant instant) throws IOException {\n+        if (instant == null) {\n+            writeBoolean(false);\n+        } else {\n+            writeBoolean(true);\n+            writeInstant(instant);\n+        }\n+    }\n+\n     private static final Map<Class<?>, Writer> WRITERS;\n \n     static {"
        },
        {
            "sha": "02d534552100c430b8b71b768c5790a83963655c",
            "filename": "server/src/main/java/org/elasticsearch/common/util/set/Sets.java",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSets.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSets.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSets.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -144,4 +144,19 @@ public static <T> Set<T> union(Set<T> left, Set<T> right) {\n         union.addAll(right);\n         return union;\n     }\n+\n+    public static <T> Set<T> intersection(Set<T> set1, Set<T> set2) {\n+        Objects.requireNonNull(set1);\n+        Objects.requireNonNull(set2);\n+        final Set<T> left;\n+        final Set<T> right;\n+        if (set1.size() < set2.size()) {\n+            left = set1;\n+            right = set2;\n+        } else {\n+            left = set2;\n+            right = set1;\n+        }\n+        return left.stream().filter(o -> right.contains(o)).collect(Collectors.toSet());\n+    }\n }"
        },
        {
            "sha": "837c0202faf92cc48bbdb3b7133e52d1a2c50df1",
            "filename": "server/src/test/java/org/elasticsearch/common/io/stream/StreamTests.java",
            "status": "modified",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Fio%2Fstream%2FStreamTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -30,6 +30,7 @@\n import java.io.ByteArrayInputStream;\n import java.io.EOFException;\n import java.io.IOException;\n+import java.time.Instant;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -336,6 +337,37 @@ public void testSetOfLongs() throws IOException {\n         assertThat(targetSet, equalTo(sourceSet));\n     }\n \n+    public void testInstantSerialization() throws IOException {\n+        final Instant instant = Instant.now();\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeInstant(instant);\n+            try (StreamInput in = out.bytes().streamInput()) {\n+                final Instant serialized = in.readInstant();\n+                assertEquals(instant, serialized);\n+            }\n+        }\n+    }\n+\n+    public void testOptionalInstantSerialization() throws IOException {\n+        final Instant instant = Instant.now();\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeOptionalInstant(instant);\n+            try (StreamInput in = out.bytes().streamInput()) {\n+                final Instant serialized = in.readOptionalInstant();\n+                assertEquals(instant, serialized);\n+            }\n+        }\n+\n+        final Instant missing = null;\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            out.writeOptionalInstant(missing);\n+            try (StreamInput in = out.bytes().streamInput()) {\n+                final Instant serialized = in.readOptionalInstant();\n+                assertEquals(missing, serialized);\n+            }\n+        }\n+    }\n+\n     static final class WriteableString implements Writeable {\n         final String string;\n "
        },
        {
            "sha": "f4337daf4346cbccad1a7a5b64f50ac18fa09c25",
            "filename": "server/src/test/java/org/elasticsearch/common/util/set/SetsTests.java",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSetsTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSetsTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/server%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fcommon%2Futil%2Fset%2FSetsTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -28,6 +28,7 @@\n import java.util.stream.Collectors;\n import java.util.stream.IntStream;\n \n+import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.greaterThan;\n \n@@ -56,6 +57,17 @@ public void testSortedDifference() {\n         }\n     }\n \n+    public void testIntersection() {\n+        final int endExclusive = randomIntBetween(0, 256);\n+        final Tuple<Set<Integer>, Set<Integer>> sets = randomSets(endExclusive);\n+        final Set<Integer> intersection = Sets.intersection(sets.v1(), sets.v2());\n+        final Set<Integer> expectedIntersection = IntStream.range(0, endExclusive)\n+                .boxed()\n+                .filter(i -> (sets.v1().contains(i) && sets.v2().contains(i)))\n+                .collect(Collectors.toSet());\n+        assertThat(intersection, containsInAnyOrder(expectedIntersection.toArray(new Integer[0])));\n+    }\n+\n     /**\n      * Assert the difference between two sets is as expected.\n      *"
        },
        {
            "sha": "fea1c3997530ccd4555cd16129c165079ea07aed",
            "filename": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/Features.java",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2FFeatures.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2FFeatures.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2FFeatures.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -46,7 +46,8 @@ public final class Features {\n             \"stash_path_replace\",\n             \"warnings\",\n             \"yaml\",\n-            \"contains\"\n+            \"contains\",\n+            \"transform_and_set\"\n     ));\n \n     private Features() {"
        },
        {
            "sha": "135a60cca3431c7aaddac14cc7ea0772ab85b55c",
            "filename": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/section/ExecutableSection.java",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FExecutableSection.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FExecutableSection.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FExecutableSection.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -40,6 +40,7 @@ public interface ExecutableSection {\n     List<NamedXContentRegistry.Entry> DEFAULT_EXECUTABLE_CONTEXTS = unmodifiableList(Arrays.asList(\n             new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"do\"), DoSection::parse),\n             new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"set\"), SetSection::parse),\n+            new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"transform_and_set\"), TransformAndSetSection::parse),\n             new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"match\"), MatchAssertion::parse),\n             new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"is_true\"), IsTrueAssertion::parse),\n             new NamedXContentRegistry.Entry(ExecutableSection.class, new ParseField(\"is_false\"), IsFalseAssertion::parse),"
        },
        {
            "sha": "7b0b915dd97dff4b46fe4e90a55abc43122f4fa5",
            "filename": "test/framework/src/main/java/org/elasticsearch/test/rest/yaml/section/TransformAndSetSection.java",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSection.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSection.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/test%2Fframework%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSection.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,106 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.test.rest.yaml.section;\n+\n+import org.elasticsearch.common.ParsingException;\n+import org.elasticsearch.common.xcontent.XContentLocation;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestExecutionContext;\n+\n+import java.io.IOException;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Represents a transform_and_set section:\n+ * <p>\n+ *\n+ * In the following example,<br>\n+ * - transform_and_set: { login_creds: \"#base64EncodeCredentials(user,password)\" }<br>\n+ * user and password are from the response which are joined by ':' and Base64 encoded and then stashed as 'login_creds'\n+ *\n+ */\n+public class TransformAndSetSection implements ExecutableSection {\n+    public static TransformAndSetSection parse(XContentParser parser) throws IOException {\n+        String currentFieldName = null;\n+        XContentParser.Token token;\n+\n+        TransformAndSetSection transformAndStashSection = new TransformAndSetSection(parser.getTokenLocation());\n+\n+        while ((token = parser.nextToken()) != XContentParser.Token.END_OBJECT) {\n+            if (token == XContentParser.Token.FIELD_NAME) {\n+                currentFieldName = parser.currentName();\n+            } else if (token.isValue()) {\n+                transformAndStashSection.addSet(currentFieldName, parser.text());\n+            }\n+        }\n+\n+        parser.nextToken();\n+\n+        if (transformAndStashSection.getStash().isEmpty()) {\n+            throw new ParsingException(transformAndStashSection.location, \"transform_and_set section must set at least a value\");\n+        }\n+\n+        return transformAndStashSection;\n+    }\n+\n+    private final Map<String, String> transformStash = new HashMap<>();\n+    private final XContentLocation location;\n+\n+    public TransformAndSetSection(XContentLocation location) {\n+        this.location = location;\n+    }\n+\n+    public void addSet(String stashedField, String transformThis) {\n+        transformStash.put(stashedField, transformThis);\n+    }\n+\n+    public Map<String, String> getStash() {\n+        return transformStash;\n+    }\n+\n+    @Override\n+    public XContentLocation getLocation() {\n+        return location;\n+    }\n+\n+    @Override\n+    public void execute(ClientYamlTestExecutionContext executionContext) throws IOException {\n+        for (Map.Entry<String, String> entry : transformStash.entrySet()) {\n+            String key = entry.getKey();\n+            String value = entry.getValue();\n+            if (value.startsWith(\"#base64EncodeCredentials(\") && value.endsWith(\")\")) {\n+                value = entry.getValue().substring(\"#base64EncodeCredentials(\".length(), entry.getValue().lastIndexOf(\")\"));\n+                String[] idAndPassword = value.split(\",\");\n+                if (idAndPassword.length == 2) {\n+                    String credentials = executionContext.response(idAndPassword[0].trim()) + \":\"\n+                            + executionContext.response(idAndPassword[1].trim());\n+                    value = Base64.getEncoder().encodeToString(credentials.getBytes(StandardCharsets.UTF_8));\n+                } else {\n+                    throw new IllegalArgumentException(\"base64EncodeCredentials requires a username/id and a password parameters\");\n+                }\n+            }\n+            executionContext.stash().stashValue(key, value);\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "a61f91de287e7456ae58db71cc51db5d518345f5",
            "filename": "test/framework/src/test/java/org/elasticsearch/test/rest/yaml/section/TransformAndSetSectionTests.java",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSectionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/test%2Fframework%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSectionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/test%2Fframework%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Ftest%2Frest%2Fyaml%2Fsection%2FTransformAndSetSectionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Licensed to Elasticsearch under one or more contributor\n+ * license agreements. See the NOTICE file distributed with\n+ * this work for additional information regarding copyright\n+ * ownership. Elasticsearch licenses this file to you under\n+ * the Apache License, Version 2.0 (the \"License\"); you may\n+ * not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *    http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+\n+package org.elasticsearch.test.rest.yaml.section;\n+\n+import org.elasticsearch.common.ParsingException;\n+import org.elasticsearch.common.xcontent.yaml.YamlXContent;\n+import org.elasticsearch.test.rest.yaml.ClientYamlTestExecutionContext;\n+import org.elasticsearch.test.rest.yaml.Stash;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.util.Base64;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyNoMoreInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class TransformAndSetSectionTests extends AbstractClientYamlTestFragmentParserTestCase {\n+\n+    public void testParseSingleValue() throws Exception {\n+        parser = createParser(YamlXContent.yamlXContent,\n+                        \"{ key: value }\"\n+        );\n+\n+        TransformAndSetSection transformAndSet = TransformAndSetSection.parse(parser);\n+        assertThat(transformAndSet, notNullValue());\n+        assertThat(transformAndSet.getStash(), notNullValue());\n+        assertThat(transformAndSet.getStash().size(), equalTo(1));\n+        assertThat(transformAndSet.getStash().get(\"key\"), equalTo(\"value\"));\n+    }\n+\n+    public void testParseMultipleValues() throws Exception {\n+        parser = createParser(YamlXContent.yamlXContent,\n+                        \"{ key1: value1, key2: value2 }\"\n+        );\n+\n+        TransformAndSetSection transformAndSet = TransformAndSetSection.parse(parser);\n+        assertThat(transformAndSet, notNullValue());\n+        assertThat(transformAndSet.getStash(), notNullValue());\n+        assertThat(transformAndSet.getStash().size(), equalTo(2));\n+        assertThat(transformAndSet.getStash().get(\"key1\"), equalTo(\"value1\"));\n+        assertThat(transformAndSet.getStash().get(\"key2\"), equalTo(\"value2\"));\n+    }\n+\n+    public void testTransformation() throws Exception {\n+        parser = createParser(YamlXContent.yamlXContent, \"{ login_creds: \\\"#base64EncodeCredentials(id,api_key)\\\" }\");\n+\n+        TransformAndSetSection transformAndSet = TransformAndSetSection.parse(parser);\n+        assertThat(transformAndSet, notNullValue());\n+        assertThat(transformAndSet.getStash(), notNullValue());\n+        assertThat(transformAndSet.getStash().size(), equalTo(1));\n+        assertThat(transformAndSet.getStash().get(\"login_creds\"), equalTo(\"#base64EncodeCredentials(id,api_key)\"));\n+\n+        ClientYamlTestExecutionContext executionContext = mock(ClientYamlTestExecutionContext.class);\n+        when(executionContext.response(\"id\")).thenReturn(\"user\");\n+        when(executionContext.response(\"api_key\")).thenReturn(\"password\");\n+        Stash stash = new Stash();\n+        when(executionContext.stash()).thenReturn(stash);\n+        transformAndSet.execute(executionContext);\n+        verify(executionContext).response(\"id\");\n+        verify(executionContext).response(\"api_key\");\n+        verify(executionContext).stash();\n+        assertThat(stash.getValue(\"$login_creds\"),\n+                equalTo(Base64.getEncoder().encodeToString(\"user:password\".getBytes(StandardCharsets.UTF_8))));\n+        verifyNoMoreInteractions(executionContext);\n+    }\n+\n+    public void testParseSetSectionNoValues() throws Exception {\n+        parser = createParser(YamlXContent.yamlXContent,\n+                \"{ }\"\n+        );\n+\n+        Exception e = expectThrows(ParsingException.class, () -> TransformAndSetSection.parse(parser));\n+        assertThat(e.getMessage(), is(\"transform_and_set section must set at least a value\"));\n+    }\n+}"
        },
        {
            "sha": "ecfd30bb7469b6f1c3699a6fad2009e55d98e19b",
            "filename": "x-pack/docs/build.gradle",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fbuild.gradle",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fbuild.gradle",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fdocs%2Fbuild.gradle?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -73,6 +73,7 @@ project.copyRestSpec.from(xpackResources) {\n }\n integTestCluster {\n     setting 'xpack.security.enabled', 'true'\n+    setting 'xpack.security.authc.api_key.enabled', 'true'\n     setting 'xpack.security.authc.token.enabled', 'true'\n     // Disable monitoring exporters for the docs tests\n     setting 'xpack.monitoring.exporters._local.type', 'local'"
        },
        {
            "sha": "c59c44312ae603a38a1d51aa14cfbe364deb7dfa",
            "filename": "x-pack/docs/en/rest-api/security.asciidoc",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -51,6 +51,17 @@ without requiring basic authentication:\n * <<security-api-get-token,Get token>>\n * <<security-api-invalidate-token,Invalidate token>>\n \n+[float]\n+[[security-api-keys]]\n+=== API Keys\n+\n+You can use the following APIs to create, retrieve and invalidate API keys for access\n+without requiring basic authentication:\n+\n+* <<security-api-create-api-key,Create API Key>>\n+* <<security-api-get-api-key,Get API Key>>\n+* <<security-api-invalidate-api-key,Invalidate API Key>>\n+\n [float]\n [[security-user-apis]]\n === Users\n@@ -88,3 +99,6 @@ include::security/get-users.asciidoc[]\n include::security/has-privileges.asciidoc[]\n include::security/invalidate-tokens.asciidoc[]\n include::security/ssl.asciidoc[]\n+include::security/create-api-keys.asciidoc[]\n+include::security/invalidate-api-keys.asciidoc[]\n+include::security/get-api-keys.asciidoc[]"
        },
        {
            "sha": "e4fa1be71d40e2efbd6fc34a5d3b11569a303497",
            "filename": "x-pack/docs/en/rest-api/security/create-api-keys.asciidoc",
            "status": "added",
            "additions": 99,
            "deletions": 0,
            "changes": 99,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fcreate-api-keys.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fcreate-api-keys.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fcreate-api-keys.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,99 @@\n+[role=\"xpack\"]\n+[[security-api-create-api-key]]\n+=== Create API Key API\n+\n+Creates an API key for access without requiring basic authentication.\n+\n+==== Request\n+\n+`POST /_security/api_key`\n+`PUT /_security/api_key`\n+\n+==== Description\n+\n+The API keys are created by the {es} API key service, which is automatically enabled\n+when you configure TLS on the HTTP interface. See <<tls-http>>. Alternatively,\n+you can explicitly enable the `xpack.security.authc.api_key.enabled` setting. When \n+you are running in production mode, a bootstrap check prevents you from enabling \n+the API key service unless you also enable TLS on the HTTP interface. \n+\n+A successful create API key API call returns a JSON structure that contains \n+the unique id, the name to identify API key, the API key and the expiration if \n+applicable for the API key in milliseconds. \n+\n+NOTE: By default API keys never expire. You can specify expiration at the time of \n+creation for the API keys. \n+\n+==== Request Body\n+\n+The following parameters can be specified in the body of a POST or PUT request:\n+\n+`name`::\n+(string) Specifies the name for this API key.\n+\n+`role_descriptors`::\n+(array-of-role-descriptor) Optional array of role descriptor for this API key. The role descriptor \n+must be a subset of permissions of the authenticated user. The structure of role \n+descriptor is same as the request for create role API. For more details on role \n+see <<security-api-roles, Role Management APIs>>.\n+If the role descriptors are not provided then permissions of the authenticated user are applied.\n+\n+`expiration`::\n+(string) Optional expiration time for the API key. By default API keys never expire.\n+\n+==== Examples\n+\n+The following example creates an API key:\n+\n+[source, js]\n+------------------------------------------------------------\n+POST /_security/api_key\n+{\n+  \"name\": \"my-api-key\",\n+  \"expiration\": \"1d\", <1>\n+  \"role_descriptors\": { <2>\n+    \"role-a\": {\n+      \"cluster\": [\"all\"],\n+      \"index\": [\n+        {\n+          \"names\": [\"index-a*\"],\n+          \"privileges\": [\"read\"]\n+        }\n+      ]\n+    },\n+    \"role-b\": {\n+      \"cluster\": [\"all\"],\n+      \"index\": [\n+        {\n+          \"names\": [\"index-b*\"],\n+          \"privileges\": [\"all\"]\n+        }\n+      ]\n+    }\n+  }\n+}\n+------------------------------------------------------------\n+// CONSOLE\n+<1> optional expiration for the API key being generated. If expiration is not\n+ provided then the API keys do not expire.\n+<2> optional role descriptors for this API key, if not provided then permissions\n+ of authenticated user are applied.\n+\n+A successful call returns a JSON structure that provides\n+API key information.\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"id\":\"VuaCfGcBCdbkQm-e5aOx\", <1>\n+  \"name\":\"my-api-key\",\n+  \"expiration\":1544068612110, <2>\n+  \"api_key\":\"ui2lp2axTNmsyakw9tvNnw\" <3>\n+}\n+--------------------------------------------------\n+// TESTRESPONSE[s/VuaCfGcBCdbkQm-e5aOx/$body.id/]\n+// TESTRESPONSE[s/1544068612110/$body.expiration/]\n+// TESTRESPONSE[s/ui2lp2axTNmsyakw9tvNnw/$body.api_key/]\n+<1> unique id for this API key\n+<2> optional expiration in milliseconds for this API key\n+<3> generated API key"
        },
        {
            "sha": "ab2ef770cb12483c85e8f1a4ec22e9fd1487a06d",
            "filename": "x-pack/docs/en/rest-api/security/get-api-keys.asciidoc",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fget-api-keys.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fget-api-keys.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Fget-api-keys.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,118 @@\n+[role=\"xpack\"]\n+[[security-api-get-api-key]]\n+=== Get API Key information API\n+++++\n+<titleabbrev>Get API key information</titleabbrev>\n+++++\n+\n+Retrieves information for one or more API keys.\n+\n+==== Request\n+\n+`GET /_security/api_key`\n+\n+==== Description\n+\n+The information for the API keys created by <<security-api-create-api-key,create API Key>> can be retrieved\n+using this API.\n+\n+==== Request Body\n+\n+The following parameters can be specified in the query parameters of a GET request and\n+pertain to retrieving api keys:\n+\n+`id` (optional)::\n+(string) An API key id. This parameter cannot be used with any of `name`, `realm_name` or\n+         `username` are used.\n+\n+`name` (optional)::\n+(string) An API key name. This parameter cannot be used with any of `id`, `realm_name` or\n+                          `username` are used.\n+\n+`realm_name` (optional)::\n+(string) The name of an authentication realm. This parameter cannot be used with either `id` or `name`.\n+\n+`username` (optional)::\n+(string) The username of a user. This parameter cannot be used with either `id` or `name`.\n+\n+NOTE: While all parameters are optional, at least one of them is required.\n+\n+==== Examples\n+\n+The following example to retrieve the API key identified by specified `id`:\n+\n+[source,js]\n+--------------------------------------------------\n+GET /_security/api_key?id=dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+whereas the following example to retrieve the API key identified by specified `name`:\n+\n+[source,js]\n+--------------------------------------------------\n+GET /_security/api_key?name=hadoop_myuser_key\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+The following example retrieves all API keys for the `native1` realm:\n+\n+[source,js]\n+--------------------------------------------------\n+GET /_xpack/api_key?realm_name=native1\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+The following example retrieves all API keys for the user `myuser` in all realms:\n+\n+[source,js]\n+--------------------------------------------------\n+GET /_xpack/api_key?username=myuser\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+Finally, the following example retrieves all API keys for the user `myuser` in\n+ the `native1` realm immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+GET /_xpack/api_key?username=myuser&realm_name=native1\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+A successful call returns a JSON structure that contains the information of one or more API keys that were retrieved.\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"api_keys\": [ <1>\n+    {\n+      \"id\": \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\", <2>\n+      \"name\": \"hadoop_myuser_key\", <3>\n+      \"creation\": 1548550550158, <4>\n+      \"expiration\": 1548551550158, <5>\n+      \"invalidated\": false, <6>\n+      \"username\": \"myuser\", <7>\n+      \"realm\": \"native1\" <8>\n+    },\n+    {\n+      \"id\": \"api-key-id-2\",\n+      \"name\": \"api-key-name-2\",\n+      \"creation\": 1548550550158,\n+      \"invalidated\": false,\n+      \"username\": \"user-y\",\n+      \"realm\": \"realm-2\"\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The list of API keys that were retrieved for this request.\n+<2> Id for the API key\n+<3> Name of the API key\n+<4> Creation time for the API key in milliseconds\n+<5> optional expiration time for the API key in milliseconds\n+<6> invalidation status for the API key, `true` if the key has been invalidated else `false`\n+<7> principal for which this API key was created\n+<8> realm name of the principal for which this API key was created"
        },
        {
            "sha": "4809e267ebd80fff8cac518e4aa112658bd683bf",
            "filename": "x-pack/docs/en/rest-api/security/invalidate-api-keys.asciidoc",
            "status": "added",
            "additions": 140,
            "deletions": 0,
            "changes": 140,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Finvalidate-api-keys.asciidoc",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Finvalidate-api-keys.asciidoc",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fdocs%2Fen%2Frest-api%2Fsecurity%2Finvalidate-api-keys.asciidoc?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,140 @@\n+[role=\"xpack\"]\n+[[security-api-invalidate-api-key]]\n+=== Invalidate API Key API\n+++++\n+<titleabbrev>Invalidate API key</titleabbrev>\n+++++\n+\n+Invalidates one or more API keys.\n+\n+==== Request\n+\n+`DELETE /_security/api_key`\n+\n+==== Description\n+\n+The API keys created by <<security-api-create-api-key,create API Key>> can be invalidated\n+using this API.\n+\n+==== Request Body\n+\n+The following parameters can be specified in the body of a DELETE request and\n+pertain to invalidating api keys:\n+\n+`id` (optional)::\n+(string) An API key id. This parameter cannot be used with any of `name`, `realm_name` or\n+         `username` are used.\n+\n+`name` (optional)::\n+(string) An API key name. This parameter cannot be used with any of `id`, `realm_name` or\n+                          `username` are used.\n+\n+`realm_name` (optional)::\n+(string) The name of an authentication realm. This parameter cannot be used with either `api_key_id` or `api_key_name`.\n+\n+`username` (optional)::\n+(string) The username of a user. This parameter cannot be used with either `api_key_id` or `api_key_name`.\n+\n+NOTE: While all parameters are optional, at least one of them is required.\n+\n+==== Examples\n+\n+The following example invalidates the API key identified by specified `id` immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+DELETE /_security/api_key\n+{\n+  \"id\" : \"dGhpcyBpcyBub3QgYSByZWFsIHRva2VuIGJ1dCBpdCBpcyBvbmx5IHRlc3QgZGF0YS4gZG8gbm90IHRyeSB0byByZWFkIHRva2VuIQ==\"\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+whereas the following example invalidates the API key identified by specified `name` immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+DELETE /_security/api_key\n+{\n+  \"name\" : \"hadoop_myuser_key\"\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+The following example invalidates all API keys for the `native1` realm immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+DELETE /_xpack/api_key\n+{\n+  \"realm_name\" : \"native1\"\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+The following example invalidates all API keys for the user `myuser` in all realms immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+DELETE /_xpack/api_key\n+{\n+  \"username\" : \"myuser\"\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+Finally, the following example invalidates all API keys for the user `myuser` in\n+ the `native1` realm immediately:\n+\n+[source,js]\n+--------------------------------------------------\n+DELETE /_xpack/api_key\n+{\n+  \"username\" : \"myuser\",\n+  \"realm_name\" : \"native1\"\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+A successful call returns a JSON structure that contains the ids of the API keys that were invalidated, the ids\n+of the API keys that had already been invalidated, and potentially a list of errors encountered while invalidating\n+specific api keys.\n+\n+[source,js]\n+--------------------------------------------------\n+{\n+  \"invalidated_api_keys\": [ <1>\n+    \"api-key-id-1\"\n+  ],\n+  \"previously_invalidated_api_keys\": [ <2>\n+    \"api-key-id-2\",\n+    \"api-key-id-3\"\n+  ],\n+  \"error_count\": 2, <3>\n+  \"error_details\": [ <4>\n+    {\n+      \"type\": \"exception\",\n+      \"reason\": \"error occurred while invalidating api keys\",\n+      \"caused_by\": {\n+        \"type\": \"illegal_argument_exception\",\n+        \"reason\": \"invalid api key id\"\n+      }\n+    },\n+    {\n+      \"type\": \"exception\",\n+      \"reason\": \"error occurred while invalidating api keys\",\n+      \"caused_by\": {\n+        \"type\": \"illegal_argument_exception\",\n+        \"reason\": \"invalid api key id\"\n+      }\n+    }\n+  ]\n+}\n+--------------------------------------------------\n+// NOTCONSOLE\n+\n+<1> The ids of the API keys that were invalidated as part of this request.\n+<2> The ids of the API keys that were already invalidated.\n+<3> The number of errors that were encountered when invalidating the API keys.\n+<4> Details about these errors. This field is not present in the response when\n+    `error_count` is 0."
        },
        {
            "sha": "6ce71982f5b1ddab2d4dd3aeeb9fabea354354b7",
            "filename": "x-pack/plugin/build.gradle",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fbuild.gradle",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fbuild.gradle",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fbuild.gradle?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -133,6 +133,7 @@ integTestCluster {\n   setting 'xpack.monitoring.exporters._local.type', 'local'\n   setting 'xpack.monitoring.exporters._local.enabled', 'false'\n   setting 'xpack.security.authc.token.enabled', 'true'\n+  setting 'xpack.security.authc.api_key.enabled', 'true'\n   setting 'xpack.security.transport.ssl.enabled', 'true'\n   setting 'xpack.security.transport.ssl.key', nodeKey.name\n   setting 'xpack.security.transport.ssl.certificate', nodeCert.name"
        },
        {
            "sha": "a0a81b1a51677a85a94677a3470c9a3e815a3bb5",
            "filename": "x-pack/plugin/ccr/src/main/java/org/elasticsearch/xpack/ccr/CcrLicenseChecker.java",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fccr%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fccr%2FCcrLicenseChecker.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fccr%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fccr%2FCcrLicenseChecker.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fccr%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fccr%2FCcrLicenseChecker.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -13,36 +13,37 @@\n import org.elasticsearch.action.ActionResponse;\n import org.elasticsearch.action.admin.cluster.state.ClusterStateRequest;\n import org.elasticsearch.action.admin.cluster.state.ClusterStateResponse;\n-import org.elasticsearch.action.support.ContextPreservingActionListener;\n import org.elasticsearch.action.admin.indices.stats.IndexShardStats;\n import org.elasticsearch.action.admin.indices.stats.IndexStats;\n import org.elasticsearch.action.admin.indices.stats.IndicesStatsAction;\n import org.elasticsearch.action.admin.indices.stats.IndicesStatsRequest;\n import org.elasticsearch.action.admin.indices.stats.IndicesStatsResponse;\n import org.elasticsearch.action.admin.indices.stats.ShardStats;\n+import org.elasticsearch.action.support.ContextPreservingActionListener;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.client.FilterClient;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n-import org.elasticsearch.common.util.concurrent.ThreadContext;\n import org.elasticsearch.common.CheckedConsumer;\n import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n import org.elasticsearch.index.IndexNotFoundException;\n import org.elasticsearch.index.engine.CommitStats;\n import org.elasticsearch.index.engine.Engine;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.license.RemoteClusterLicenseChecker;\n import org.elasticsearch.license.XPackLicenseState;\n import org.elasticsearch.rest.RestStatus;\n-import org.elasticsearch.xpack.ccr.action.ShardFollowTask;\n import org.elasticsearch.xpack.ccr.action.ShardChangesAction;\n+import org.elasticsearch.xpack.ccr.action.ShardFollowTask;\n import org.elasticsearch.xpack.core.XPackPlugin;\n import org.elasticsearch.xpack.core.security.SecurityContext;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n import org.elasticsearch.xpack.core.security.support.Exceptions;\n \n import java.util.Arrays;\n@@ -328,7 +329,7 @@ public void hasPrivilegesToFollowIndices(final Client remoteClient, final String\n                 message.append(indices.length == 1 ? \" index \" : \" indices \");\n                 message.append(Arrays.toString(indices));\n \n-                HasPrivilegesResponse.ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().iterator().next();\n+                ResourcePrivileges resourcePrivileges = response.getIndexPrivileges().iterator().next();\n                 for (Map.Entry<String, Boolean> entry : resourcePrivileges.getPrivileges().entrySet()) {\n                     if (entry.getValue() == false) {\n                         message.append(\", privilege for action [\");"
        },
        {
            "sha": "6b1fcb67950e9c285458e3ece52d757e921e1562",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/XPackClientPlugin.java",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackClientPlugin.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackClientPlugin.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackClientPlugin.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -137,6 +137,9 @@\n import org.elasticsearch.xpack.core.security.SecurityFeatureSetUsage;\n import org.elasticsearch.xpack.core.security.SecurityField;\n import org.elasticsearch.xpack.core.security.SecuritySettings;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyAction;\n import org.elasticsearch.xpack.core.security.action.realm.ClearRealmCacheAction;\n import org.elasticsearch.xpack.core.security.action.role.ClearRolesCacheAction;\n import org.elasticsearch.xpack.core.security.action.role.DeleteRoleAction;\n@@ -314,6 +317,9 @@ public List<Action<? extends ActionResponse>> getClientActions() {\n                 InvalidateTokenAction.INSTANCE,\n                 GetCertificateInfoAction.INSTANCE,\n                 RefreshTokenAction.INSTANCE,\n+                CreateApiKeyAction.INSTANCE,\n+                InvalidateApiKeyAction.INSTANCE,\n+                GetApiKeyAction.INSTANCE,\n                 // upgrade\n                 IndexUpgradeInfoAction.INSTANCE,\n                 IndexUpgradeAction.INSTANCE,"
        },
        {
            "sha": "dd8b1d5bb468108e1dcfae841af09d6616c0fd0b",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/XPackSettings.java",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackSettings.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackSettings.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2FXPackSettings.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -99,10 +99,14 @@ private XPackSettings() {\n     public static final Setting<Boolean> RESERVED_REALM_ENABLED_SETTING = Setting.boolSetting(\"xpack.security.authc.reserved_realm.enabled\",\n             true, Setting.Property.NodeScope);\n \n-    /** Setting for enabling or disabling the token service. Defaults to true */\n+    /** Setting for enabling or disabling the token service. Defaults to the value of https being enabled */\n     public static final Setting<Boolean> TOKEN_SERVICE_ENABLED_SETTING = Setting.boolSetting(\"xpack.security.authc.token.enabled\",\n         XPackSettings.HTTP_SSL_ENABLED::getRaw, Setting.Property.NodeScope);\n \n+    /** Setting for enabling or disabling the api key service. Defaults to the value of https being enabled */\n+    public static final Setting<Boolean> API_KEY_SERVICE_ENABLED_SETTING = Setting.boolSetting(\"xpack.security.authc.api_key.enabled\",\n+        XPackSettings.HTTP_SSL_ENABLED::getRaw, Setting.Property.NodeScope);\n+\n     /** Setting for enabling or disabling FIPS mode. Defaults to false */\n     public static final Setting<Boolean> FIPS_MODE_ENABLED =\n         Setting.boolSetting(\"xpack.security.fips_mode.enabled\", false, Property.NodeScope);\n@@ -199,6 +203,7 @@ public static List<Setting<?>> getAllSettings() {\n         settings.add(HTTP_SSL_ENABLED);\n         settings.add(RESERVED_REALM_ENABLED_SETTING);\n         settings.add(TOKEN_SERVICE_ENABLED_SETTING);\n+        settings.add(API_KEY_SERVICE_ENABLED_SETTING);\n         settings.add(SQL_ENABLED);\n         settings.add(USER_SETTING);\n         settings.add(ROLLUP_ENABLED);"
        },
        {
            "sha": "0da07a52996ade34f912fad653cd8b939517e7d9",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/SecurityContext.java",
            "status": "modified",
            "additions": 7,
            "deletions": 4,
            "changes": 11,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2FSecurityContext.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2FSecurityContext.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2FSecurityContext.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -13,9 +13,11 @@\n import org.elasticsearch.common.util.concurrent.ThreadContext.StoredContext;\n import org.elasticsearch.node.Node;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.user.User;\n \n import java.io.IOException;\n+import java.util.Collections;\n import java.util.Objects;\n import java.util.function.Consumer;\n \n@@ -71,7 +73,8 @@ public void setUser(User user, Version version) {\n         } else {\n             lookedUpBy = null;\n         }\n-        setAuthentication(new Authentication(user, authenticatedBy, lookedUpBy, version));\n+        setAuthentication(\n+            new Authentication(user, authenticatedBy, lookedUpBy, version, AuthenticationType.INTERNAL, Collections.emptyMap()));\n     }\n \n     /** Writes the authentication to the thread context */\n@@ -89,7 +92,7 @@ private void setAuthentication(Authentication authentication) {\n      */\n     public void executeAsUser(User user, Consumer<StoredContext> consumer, Version version) {\n         final StoredContext original = threadContext.newStoredContext(true);\n-        try (ThreadContext.StoredContext ctx = threadContext.stashContext()) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setUser(user, version);\n             consumer.accept(original);\n         }\n@@ -102,9 +105,9 @@ public void executeAsUser(User user, Consumer<StoredContext> consumer, Version v\n     public void executeAfterRewritingAuthentication(Consumer<StoredContext> consumer, Version version) {\n         final StoredContext original = threadContext.newStoredContext(true);\n         final Authentication authentication = Objects.requireNonNull(userSettings.getAuthentication());\n-        try (ThreadContext.StoredContext ctx = threadContext.stashContext()) {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             setAuthentication(new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n-                                                 authentication.getLookedUpBy(), version));\n+                authentication.getLookedUpBy(), version, authentication.getAuthenticationType(), authentication.getMetadata()));\n             consumer.accept(original);\n         }\n     }"
        },
        {
            "sha": "bfe9f523062a0da717bbc58baf4e4322710c5adf",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/ApiKey.java",
            "status": "added",
            "additions": 165,
            "deletions": 0,
            "changes": 165,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FApiKey.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FApiKey.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FApiKey.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,165 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * API key information\n+ */\n+public final class ApiKey implements ToXContentObject, Writeable {\n+\n+    private final String name;\n+    private final String id;\n+    private final Instant creation;\n+    private final Instant expiration;\n+    private final boolean invalidated;\n+    private final String username;\n+    private final String realm;\n+\n+    public ApiKey(String name, String id, Instant creation, Instant expiration, boolean invalidated, String username, String realm) {\n+        this.name = name;\n+        this.id = id;\n+        // As we do not yet support the nanosecond precision when we serialize to JSON,\n+        // here creating the 'Instant' of milliseconds precision.\n+        // This Instant can then be used for date comparison.\n+        this.creation = Instant.ofEpochMilli(creation.toEpochMilli());\n+        this.expiration = (expiration != null) ? Instant.ofEpochMilli(expiration.toEpochMilli()): null;\n+        this.invalidated = invalidated;\n+        this.username = username;\n+        this.realm = realm;\n+    }\n+\n+    public ApiKey(StreamInput in) throws IOException {\n+        this.name = in.readString();\n+        this.id = in.readString();\n+        this.creation = in.readInstant();\n+        this.expiration = in.readOptionalInstant();\n+        this.invalidated = in.readBoolean();\n+        this.username = in.readString();\n+        this.realm = in.readString();\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Instant getCreation() {\n+        return creation;\n+    }\n+\n+    public Instant getExpiration() {\n+        return expiration;\n+    }\n+\n+    public boolean isInvalidated() {\n+        return invalidated;\n+    }\n+\n+    public String getUsername() {\n+        return username;\n+    }\n+\n+    public String getRealm() {\n+        return realm;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+        .field(\"id\", id)\n+        .field(\"name\", name)\n+        .field(\"creation\", creation.toEpochMilli());\n+        if (expiration != null) {\n+            builder.field(\"expiration\", expiration.toEpochMilli());\n+        }\n+        builder.field(\"invalidated\", invalidated)\n+        .field(\"username\", username)\n+        .field(\"realm\", realm);\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(name);\n+        out.writeString(id);\n+        out.writeInstant(creation);\n+        out.writeOptionalInstant(expiration);\n+        out.writeBoolean(invalidated);\n+        out.writeString(username);\n+        out.writeString(realm);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(name, id, creation, expiration, invalidated, username, realm);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        ApiKey other = (ApiKey) obj;\n+        return Objects.equals(name, other.name)\n+                && Objects.equals(id, other.id)\n+                && Objects.equals(creation, other.creation)\n+                && Objects.equals(expiration, other.expiration)\n+                && Objects.equals(invalidated, other.invalidated)\n+                && Objects.equals(username, other.username)\n+                && Objects.equals(realm, other.realm);\n+    }\n+\n+    static ConstructingObjectParser<ApiKey, Void> PARSER = new ConstructingObjectParser<>(\"api_key\", args -> {\n+        return new ApiKey((String) args[0], (String) args[1], Instant.ofEpochMilli((Long) args[2]),\n+                (args[3] == null) ? null : Instant.ofEpochMilli((Long) args[3]), (Boolean) args[4], (String) args[5], (String) args[6]);\n+    });\n+    static {\n+        PARSER.declareString(constructorArg(), new ParseField(\"name\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"id\"));\n+        PARSER.declareLong(constructorArg(), new ParseField(\"creation\"));\n+        PARSER.declareLong(optionalConstructorArg(), new ParseField(\"expiration\"));\n+        PARSER.declareBoolean(constructorArg(), new ParseField(\"invalidated\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"username\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"realm\"));\n+    }\n+\n+    public static ApiKey fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ApiKey [name=\" + name + \", id=\" + id + \", creation=\" + creation + \", expiration=\" + expiration + \", invalidated=\"\n+                + invalidated + \", username=\" + username + \", realm=\" + realm + \"]\";\n+    }\n+\n+}"
        },
        {
            "sha": "5d211ea70b5224b4bd1d0d69d095b804272864d7",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyAction.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.common.io.stream.Writeable;\n+\n+/**\n+ * Action for the creation of an API key\n+ */\n+public final class CreateApiKeyAction extends Action<CreateApiKeyResponse> {\n+\n+    public static final String NAME = \"cluster:admin/xpack/security/api_key/create\";\n+    public static final CreateApiKeyAction INSTANCE = new CreateApiKeyAction();\n+\n+    private CreateApiKeyAction() {\n+        super(NAME);\n+    }\n+\n+    @Override\n+    public CreateApiKeyResponse newResponse() {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    @Override\n+    public Writeable.Reader<CreateApiKeyResponse> getResponseReader() {\n+        return CreateApiKeyResponse::new;\n+    }\n+}"
        },
        {
            "sha": "28a872c2222dd80c691f9f8a372d8f75293db62e",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyRequest.java",
            "status": "added",
            "additions": 132,
            "deletions": 0,
            "changes": 132,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request class used for the creation of an API key. The request requires a name to be provided\n+ * and optionally an expiration time and permission limitation can be provided.\n+ */\n+public final class CreateApiKeyRequest extends ActionRequest {\n+    public static final WriteRequest.RefreshPolicy DEFAULT_REFRESH_POLICY = WriteRequest.RefreshPolicy.WAIT_UNTIL;\n+\n+    private String name;\n+    private TimeValue expiration;\n+    private List<RoleDescriptor> roleDescriptors = Collections.emptyList();\n+    private WriteRequest.RefreshPolicy refreshPolicy = DEFAULT_REFRESH_POLICY;\n+\n+    public CreateApiKeyRequest() {}\n+\n+    /**\n+     * Create API Key request constructor\n+     * @param name name for the API key\n+     * @param roleDescriptors list of {@link RoleDescriptor}s\n+     * @param expiration to specify expiration for the API key\n+     */\n+    public CreateApiKeyRequest(String name, List<RoleDescriptor> roleDescriptors, @Nullable TimeValue expiration) {\n+        if (Strings.hasText(name)) {\n+            this.name = name;\n+        } else {\n+            throw new IllegalArgumentException(\"name must not be null or empty\");\n+        }\n+        this.roleDescriptors = Objects.requireNonNull(roleDescriptors, \"role descriptors may not be null\");\n+        this.expiration = expiration;\n+    }\n+\n+    public CreateApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        this.name = in.readString();\n+        this.expiration = in.readOptionalTimeValue();\n+        this.roleDescriptors = Collections.unmodifiableList(in.readList(RoleDescriptor::new));\n+        this.refreshPolicy = WriteRequest.RefreshPolicy.readFrom(in);\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        if (Strings.hasText(name)) {\n+            this.name = name;\n+        } else {\n+            throw new IllegalArgumentException(\"name must not be null or empty\");\n+        }\n+    }\n+\n+    public TimeValue getExpiration() {\n+        return expiration;\n+    }\n+\n+    public void setExpiration(TimeValue expiration) {\n+        this.expiration = expiration;\n+    }\n+\n+    public List<RoleDescriptor> getRoleDescriptors() {\n+        return roleDescriptors;\n+    }\n+\n+    public void setRoleDescriptors(List<RoleDescriptor> roleDescriptors) {\n+        this.roleDescriptors = Collections.unmodifiableList(Objects.requireNonNull(roleDescriptors, \"role descriptors may not be null\"));\n+    }\n+\n+    public WriteRequest.RefreshPolicy getRefreshPolicy() {\n+        return refreshPolicy;\n+    }\n+\n+    public void setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        this.refreshPolicy = Objects.requireNonNull(refreshPolicy, \"refresh policy may not be null\");\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (Strings.isNullOrEmpty(name)) {\n+            validationException = addValidationError(\"name is required\", validationException);\n+        } else {\n+            if (name.length() > 256) {\n+                validationException = addValidationError(\"name may not be more than 256 characters long\", validationException);\n+            }\n+            if (name.equals(name.trim()) == false) {\n+                validationException = addValidationError(\"name may not begin or end with whitespace\", validationException);\n+            }\n+            if (name.startsWith(\"_\")) {\n+                validationException = addValidationError(\"name may not begin with an underscore\", validationException);\n+            }\n+        }\n+        return validationException;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(name);\n+        out.writeOptionalTimeValue(expiration);\n+        out.writeList(roleDescriptors);\n+        refreshPolicy.writeTo(out);\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+}"
        },
        {
            "sha": "1a711aa7d9a26aaf63d1a59d5212f04e172ecc46",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyRequestBuilder.java",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilder.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilder.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilder.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequestBuilder;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.ElasticsearchClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.List;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Request builder for populating a {@link CreateApiKeyRequest}\n+ */\n+public final class CreateApiKeyRequestBuilder extends ActionRequestBuilder<CreateApiKeyRequest, CreateApiKeyResponse> {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static final ConstructingObjectParser<CreateApiKeyRequest, Void> PARSER = new ConstructingObjectParser<>(\n+            \"api_key_request\", false, (args, v) -> {\n+                return new CreateApiKeyRequest((String) args[0], (List<RoleDescriptor>) args[1],\n+                        TimeValue.parseTimeValue((String) args[2], null, \"expiration\"));\n+            });\n+\n+    static {\n+        PARSER.declareString(constructorArg(), new ParseField(\"name\"));\n+        PARSER.declareNamedObjects(constructorArg(), (p, c, n) -> {\n+            p.nextToken();\n+            return RoleDescriptor.parse(n, p, false);\n+        }, new ParseField(\"role_descriptors\"));\n+        PARSER.declareString(optionalConstructorArg(), new ParseField(\"expiration\"));\n+    }\n+\n+    public CreateApiKeyRequestBuilder(ElasticsearchClient client) {\n+        super(client, CreateApiKeyAction.INSTANCE, new CreateApiKeyRequest());\n+    }\n+\n+    public CreateApiKeyRequestBuilder setName(String name) {\n+        request.setName(name);\n+        return this;\n+    }\n+\n+    public CreateApiKeyRequestBuilder setExpiration(TimeValue expiration) {\n+        request.setExpiration(expiration);\n+        return this;\n+    }\n+\n+    public CreateApiKeyRequestBuilder setRoleDescriptors(List<RoleDescriptor> roleDescriptors) {\n+        request.setRoleDescriptors(roleDescriptors);\n+        return this;\n+    }\n+\n+    public CreateApiKeyRequestBuilder setRefreshPolicy(WriteRequest.RefreshPolicy refreshPolicy) {\n+        request.setRefreshPolicy(refreshPolicy);\n+        return this;\n+    }\n+\n+    public CreateApiKeyRequestBuilder source(BytesReference source, XContentType xContentType) throws IOException {\n+        final NamedXContentRegistry registry = NamedXContentRegistry.EMPTY;\n+        try (InputStream stream = source.streamInput();\n+                XContentParser parser = xContentType.xContent().createParser(registry, LoggingDeprecationHandler.INSTANCE, stream)) {\n+            CreateApiKeyRequest createApiKeyRequest = PARSER.parse(parser, null);\n+            setName(createApiKeyRequest.getName());\n+            setRoleDescriptors(createApiKeyRequest.getRoleDescriptors());\n+            setExpiration(createApiKeyRequest.getExpiration());\n+        }\n+        return this;\n+    }\n+}"
        },
        {
            "sha": "a774413c3c4a228fcc59f291aa369ab67e9048aa",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyResponse.java",
            "status": "added",
            "additions": 168,
            "deletions": 0,
            "changes": 168,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,168 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.CharArrays;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Response for the successful creation of an api key\n+ */\n+public final class CreateApiKeyResponse extends ActionResponse implements ToXContentObject {\n+\n+    static ConstructingObjectParser<CreateApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"create_api_key_response\",\n+            args -> new CreateApiKeyResponse((String) args[0], (String) args[1], new SecureString((String) args[2]),\n+                    (args[3] == null) ? null : Instant.ofEpochMilli((Long) args[3])));\n+    static {\n+        PARSER.declareString(constructorArg(), new ParseField(\"name\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"id\"));\n+        PARSER.declareString(constructorArg(), new ParseField(\"api_key\"));\n+        PARSER.declareLong(optionalConstructorArg(), new ParseField(\"expiration\"));\n+    }\n+\n+    private final String name;\n+    private final String id;\n+    private final SecureString key;\n+    private final Instant expiration;\n+\n+    public CreateApiKeyResponse(String name, String id, SecureString key, Instant expiration) {\n+        this.name = name;\n+        this.id = id;\n+        this.key = key;\n+        // As we do not yet support the nanosecond precision when we serialize to JSON,\n+        // here creating the 'Instant' of milliseconds precision.\n+        // This Instant can then be used for date comparison.\n+        this.expiration = (expiration != null) ? Instant.ofEpochMilli(expiration.toEpochMilli()): null;\n+    }\n+\n+    public CreateApiKeyResponse(StreamInput in) throws IOException {\n+        super(in);\n+        this.name = in.readString();\n+        this.id = in.readString();\n+        byte[] bytes = null;\n+        try {\n+            bytes = in.readByteArray();\n+            this.key = new SecureString(CharArrays.utf8BytesToChars(bytes));\n+        } finally {\n+            if (bytes != null) {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        }\n+        this.expiration = in.readOptionalInstant();\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public SecureString getKey() {\n+        return key;\n+    }\n+\n+    @Nullable\n+    public Instant getExpiration() {\n+        return expiration;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        final int prime = 31;\n+        int result = 1;\n+        result = prime * result + ((expiration == null) ? 0 : expiration.hashCode());\n+        result = prime * result + Objects.hash(id, name, key);\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null || getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final CreateApiKeyResponse other = (CreateApiKeyResponse) obj;\n+        if (expiration == null) {\n+            if (other.expiration != null)\n+                return false;\n+        } else if (!Objects.equals(expiration, other.expiration))\n+            return false;\n+        return Objects.equals(id, other.id)\n+                && Objects.equals(key, other.key)\n+                && Objects.equals(name, other.name);\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeString(name);\n+        out.writeString(id);\n+        byte[] bytes = null;\n+        try {\n+            bytes = CharArrays.toUtf8Bytes(key.getChars());\n+            out.writeByteArray(bytes);\n+        } finally {\n+            if (bytes != null) {\n+                Arrays.fill(bytes, (byte) 0);\n+            }\n+        }\n+        out.writeOptionalInstant(expiration);\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    public static CreateApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+            .field(\"id\", id)\n+            .field(\"name\", name);\n+        if (expiration != null) {\n+            builder.field(\"expiration\", expiration.toEpochMilli());\n+        }\n+        byte[] charBytes = CharArrays.toUtf8Bytes(key.getChars());\n+        try {\n+            builder.field(\"api_key\").utf8Value(charBytes, 0, charBytes.length);\n+        } finally {\n+            Arrays.fill(charBytes, (byte) 0);\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"CreateApiKeyResponse [name=\" + name + \", id=\" + id + \", expiration=\" + expiration + \"]\";\n+    }\n+\n+}"
        },
        {
            "sha": "2af331909a3afde7e63e16a91b8849bbc8dbef5e",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GetApiKeyAction.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.common.io.stream.Writeable;\n+\n+/**\n+ * Action for retrieving API key(s)\n+ */\n+public final class GetApiKeyAction extends Action<GetApiKeyResponse> {\n+\n+    public static final String NAME = \"cluster:admin/xpack/security/api_key/get\";\n+    public static final GetApiKeyAction INSTANCE = new GetApiKeyAction();\n+\n+    private GetApiKeyAction() {\n+        super(NAME);\n+    }\n+\n+    @Override\n+    public GetApiKeyResponse newResponse() {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    @Override\n+    public Writeable.Reader<GetApiKeyResponse> getResponseReader() {\n+        return GetApiKeyResponse::new;\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "287ebcee4b6f2e1a9d8f397b7c065876f3dbe830",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GetApiKeyRequest.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request for get API key\n+ */\n+public final class GetApiKeyRequest extends ActionRequest {\n+\n+    private final String realmName;\n+    private final String userName;\n+    private final String apiKeyId;\n+    private final String apiKeyName;\n+\n+    public GetApiKeyRequest() {\n+        this(null, null, null, null);\n+    }\n+\n+    public GetApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        realmName = in.readOptionalString();\n+        userName = in.readOptionalString();\n+        apiKeyId = in.readOptionalString();\n+        apiKeyName = in.readOptionalString();\n+    }\n+\n+    public GetApiKeyRequest(@Nullable String realmName, @Nullable String userName, @Nullable String apiKeyId,\n+            @Nullable String apiKeyName) {\n+        this.realmName = realmName;\n+        this.userName = userName;\n+        this.apiKeyId = apiKeyId;\n+        this.apiKeyName = apiKeyName;\n+    }\n+\n+    public String getRealmName() {\n+        return realmName;\n+    }\n+\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    public String getApiKeyId() {\n+        return apiKeyId;\n+    }\n+\n+    public String getApiKeyName() {\n+        return apiKeyName;\n+    }\n+\n+    /**\n+     * Creates get API key request for given realm name\n+     * @param realmName realm name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingRealmName(String realmName) {\n+        return new GetApiKeyRequest(realmName, null, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given user name\n+     * @param userName user name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingUserName(String userName) {\n+        return new GetApiKeyRequest(null, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given realm and user name\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingRealmAndUserName(String realmName, String userName) {\n+        return new GetApiKeyRequest(realmName, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates get API key request for given api key id\n+     * @param apiKeyId api key id\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingApiKeyId(String apiKeyId) {\n+        return new GetApiKeyRequest(null, null, apiKeyId, null);\n+    }\n+\n+    /**\n+     * Creates get api key request for given api key name\n+     * @param apiKeyName api key name\n+     * @return {@link GetApiKeyRequest}\n+     */\n+    public static GetApiKeyRequest usingApiKeyName(String apiKeyName) {\n+        return new GetApiKeyRequest(null, null, null, apiKeyName);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false && Strings.hasText(apiKeyId) == false\n+                && Strings.hasText(apiKeyName) == false) {\n+            validationException = addValidationError(\"One of [api key id, api key name, username, realm name] must be specified\",\n+                    validationException);\n+        }\n+        if (Strings.hasText(apiKeyId) || Strings.hasText(apiKeyName)) {\n+            if (Strings.hasText(realmName) || Strings.hasText(userName)) {\n+                validationException = addValidationError(\n+                        \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        validationException);\n+            }\n+        }\n+        if (Strings.hasText(apiKeyId) && Strings.hasText(apiKeyName)) {\n+            validationException = addValidationError(\"only one of [api key id, api key name] can be specified\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeOptionalString(realmName);\n+        out.writeOptionalString(userName);\n+        out.writeOptionalString(apiKeyId);\n+        out.writeOptionalString(apiKeyName);\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) throws IOException {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+}"
        },
        {
            "sha": "97b8f380f69400b513d8b666811ea595ca448313",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/GetApiKeyResponse.java",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Response for get API keys.<br>\n+ * The result contains information about the API keys that were found.\n+ */\n+public final class GetApiKeyResponse extends ActionResponse implements ToXContentObject, Writeable {\n+\n+    private final ApiKey[] foundApiKeysInfo;\n+\n+    public GetApiKeyResponse(StreamInput in) throws IOException {\n+        super(in);\n+        this.foundApiKeysInfo = in.readArray(ApiKey::new, ApiKey[]::new);\n+    }\n+\n+    public GetApiKeyResponse(Collection<ApiKey> foundApiKeysInfo) {\n+        Objects.requireNonNull(foundApiKeysInfo, \"found_api_keys_info must be provided\");\n+        this.foundApiKeysInfo = foundApiKeysInfo.toArray(new ApiKey[0]);\n+    }\n+\n+    public static GetApiKeyResponse emptyResponse() {\n+        return new GetApiKeyResponse(Collections.emptyList());\n+    }\n+\n+    public ApiKey[] getApiKeyInfos() {\n+        return foundApiKeysInfo;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+            .array(\"api_keys\", (Object[]) foundApiKeysInfo);\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) throws IOException {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeArray(foundApiKeysInfo);\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    static ConstructingObjectParser<GetApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"get_api_key_response\", args -> {\n+        return (args[0] == null) ? GetApiKeyResponse.emptyResponse() : new GetApiKeyResponse((List<ApiKey>) args[0]);\n+    });\n+    static {\n+        PARSER.declareObjectArray(optionalConstructorArg(), (p, c) -> ApiKey.fromXContent(p), new ParseField(\"api_keys\"));\n+    }\n+\n+    public static GetApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"GetApiKeyResponse [foundApiKeysInfo=\" + foundApiKeysInfo + \"]\";\n+    }\n+\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "0f5c7e66e724c4a26173b9fb9cdf2ba48ea3e344",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/InvalidateApiKeyAction.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.common.io.stream.Writeable;\n+\n+/**\n+ * Action for invalidating API key\n+ */\n+public final class InvalidateApiKeyAction extends Action<InvalidateApiKeyResponse> {\n+\n+    public static final String NAME = \"cluster:admin/xpack/security/api_key/invalidate\";\n+    public static final InvalidateApiKeyAction INSTANCE = new InvalidateApiKeyAction();\n+\n+    private InvalidateApiKeyAction() {\n+        super(NAME);\n+    }\n+\n+    @Override\n+    public InvalidateApiKeyResponse newResponse() {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    @Override\n+    public Writeable.Reader<InvalidateApiKeyResponse> getResponseReader() {\n+        return InvalidateApiKeyResponse::new;\n+    }\n+}"
        },
        {
            "sha": "f8815785d53d85dd45fdf8db1b54a79796553013",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/InvalidateApiKeyRequest.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequest.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequest.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequest.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+\n+import java.io.IOException;\n+\n+import static org.elasticsearch.action.ValidateActions.addValidationError;\n+\n+/**\n+ * Request for invalidating API key(s) so that it can no longer be used\n+ */\n+public final class InvalidateApiKeyRequest extends ActionRequest {\n+\n+    private final String realmName;\n+    private final String userName;\n+    private final String id;\n+    private final String name;\n+\n+    public InvalidateApiKeyRequest() {\n+        this(null, null, null, null);\n+    }\n+\n+    public InvalidateApiKeyRequest(StreamInput in) throws IOException {\n+        super(in);\n+        realmName = in.readOptionalString();\n+        userName = in.readOptionalString();\n+        id = in.readOptionalString();\n+        name = in.readOptionalString();\n+    }\n+\n+    public InvalidateApiKeyRequest(@Nullable String realmName, @Nullable String userName, @Nullable String id,\n+            @Nullable String name) {\n+        this.realmName = realmName;\n+        this.userName = userName;\n+        this.id = id;\n+        this.name = name;\n+    }\n+\n+    public String getRealmName() {\n+        return realmName;\n+    }\n+\n+    public String getUserName() {\n+        return userName;\n+    }\n+\n+    public String getId() {\n+        return id;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * Creates invalidate api key request for given realm name\n+     * @param realmName realm name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingRealmName(String realmName) {\n+        return new InvalidateApiKeyRequest(realmName, null, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given user name\n+     * @param userName user name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingUserName(String userName) {\n+        return new InvalidateApiKeyRequest(null, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given realm and user name\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingRealmAndUserName(String realmName, String userName) {\n+        return new InvalidateApiKeyRequest(realmName, userName, null, null);\n+    }\n+\n+    /**\n+     * Creates invalidate API key request for given api key id\n+     * @param id api key id\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingApiKeyId(String id) {\n+        return new InvalidateApiKeyRequest(null, null, id, null);\n+    }\n+\n+    /**\n+     * Creates invalidate api key request for given api key name\n+     * @param name api key name\n+     * @return {@link InvalidateApiKeyRequest}\n+     */\n+    public static InvalidateApiKeyRequest usingApiKeyName(String name) {\n+        return new InvalidateApiKeyRequest(null, null, null, name);\n+    }\n+\n+    @Override\n+    public ActionRequestValidationException validate() {\n+        ActionRequestValidationException validationException = null;\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false && Strings.hasText(id) == false\n+                && Strings.hasText(name) == false) {\n+            validationException = addValidationError(\"One of [api key id, api key name, username, realm name] must be specified\",\n+                    validationException);\n+        }\n+        if (Strings.hasText(id) || Strings.hasText(name)) {\n+            if (Strings.hasText(realmName) || Strings.hasText(userName)) {\n+                validationException = addValidationError(\n+                        \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        validationException);\n+            }\n+        }\n+        if (Strings.hasText(id) && Strings.hasText(name)) {\n+            validationException = addValidationError(\"only one of [api key id, api key name] can be specified\", validationException);\n+        }\n+        return validationException;\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeOptionalString(realmName);\n+        out.writeOptionalString(userName);\n+        out.writeOptionalString(id);\n+        out.writeOptionalString(name);\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) throws IOException {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+}"
        },
        {
            "sha": "e9580c93d90865020c05d38bec6dfd35ddad9673",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/InvalidateApiKeyResponse.java",
            "status": "added",
            "additions": 141,
            "deletions": 0,
            "changes": 141,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,141 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.ToXContentObject;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Objects;\n+\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.constructorArg;\n+import static org.elasticsearch.common.xcontent.ConstructingObjectParser.optionalConstructorArg;\n+\n+/**\n+ * Response for invalidation of one or more API keys result.<br>\n+ * The result contains information about:\n+ * <ul>\n+ * <li>API key ids that were actually invalidated</li>\n+ * <li>API key ids that were not invalidated in this request because they were already invalidated</li>\n+ * <li>how many errors were encountered while invalidating API keys and the error details</li>\n+ * </ul>\n+ */\n+public final class InvalidateApiKeyResponse extends ActionResponse implements ToXContentObject, Writeable {\n+\n+    private final List<String> invalidatedApiKeys;\n+    private final List<String> previouslyInvalidatedApiKeys;\n+    private final List<ElasticsearchException> errors;\n+\n+    public InvalidateApiKeyResponse(StreamInput in) throws IOException {\n+        super(in);\n+        this.invalidatedApiKeys = in.readList(StreamInput::readString);\n+        this.previouslyInvalidatedApiKeys = in.readList(StreamInput::readString);\n+        this.errors = in.readList(StreamInput::readException);\n+    }\n+\n+    /**\n+     * Constructor for API keys invalidation response\n+     * @param invalidatedApiKeys list of invalidated API key ids\n+     * @param previouslyInvalidatedApiKeys list of previously invalidated API key ids\n+     * @param errors list of encountered errors while invalidating API keys\n+     */\n+    public InvalidateApiKeyResponse(List<String> invalidatedApiKeys, List<String> previouslyInvalidatedApiKeys,\n+                                    @Nullable List<ElasticsearchException> errors) {\n+        this.invalidatedApiKeys = Objects.requireNonNull(invalidatedApiKeys, \"invalidated_api_keys must be provided\");\n+        this.previouslyInvalidatedApiKeys = Objects.requireNonNull(previouslyInvalidatedApiKeys,\n+                \"previously_invalidated_api_keys must be provided\");\n+        if (null != errors) {\n+            this.errors = errors;\n+        } else {\n+            this.errors = Collections.emptyList();\n+        }\n+    }\n+\n+    public static InvalidateApiKeyResponse emptyResponse() {\n+        return new InvalidateApiKeyResponse(Collections.emptyList(), Collections.emptyList(), Collections.emptyList());\n+    }\n+\n+    public List<String> getInvalidatedApiKeys() {\n+        return invalidatedApiKeys;\n+    }\n+\n+    public List<String> getPreviouslyInvalidatedApiKeys() {\n+        return previouslyInvalidatedApiKeys;\n+    }\n+\n+    public List<ElasticsearchException> getErrors() {\n+        return errors;\n+    }\n+\n+    @Override\n+    public XContentBuilder toXContent(XContentBuilder builder, Params params) throws IOException {\n+        builder.startObject()\n+            .array(\"invalidated_api_keys\", invalidatedApiKeys.toArray(Strings.EMPTY_ARRAY))\n+            .array(\"previously_invalidated_api_keys\", previouslyInvalidatedApiKeys.toArray(Strings.EMPTY_ARRAY))\n+            .field(\"error_count\", errors.size());\n+        if (errors.isEmpty() == false) {\n+            builder.field(\"error_details\");\n+            builder.startArray();\n+            for (ElasticsearchException e : errors) {\n+                builder.startObject();\n+                ElasticsearchException.generateThrowableXContent(builder, params, e);\n+                builder.endObject();\n+            }\n+            builder.endArray();\n+        }\n+        return builder.endObject();\n+    }\n+\n+    @Override\n+    public void readFrom(StreamInput in) throws IOException {\n+        throw new UnsupportedOperationException(\"usage of Streamable is to be replaced by Writeable\");\n+    }\n+\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        super.writeTo(out);\n+        out.writeStringCollection(invalidatedApiKeys);\n+        out.writeStringCollection(previouslyInvalidatedApiKeys);\n+        out.writeCollection(errors, StreamOutput::writeException);\n+    }\n+\n+    static ConstructingObjectParser<InvalidateApiKeyResponse, Void> PARSER = new ConstructingObjectParser<>(\"invalidate_api_key_response\",\n+            args -> {\n+                return new InvalidateApiKeyResponse((List<String>) args[0], (List<String>) args[1], (List<ElasticsearchException>) args[3]);\n+            });\n+    static {\n+        PARSER.declareStringArray(constructorArg(), new ParseField(\"invalidated_api_keys\"));\n+        PARSER.declareStringArray(constructorArg(), new ParseField(\"previously_invalidated_api_keys\"));\n+        // we parse error_count but ignore it while constructing response\n+        PARSER.declareInt(constructorArg(), new ParseField(\"error_count\"));\n+        PARSER.declareObjectArray(optionalConstructorArg(), (p, c) -> ElasticsearchException.fromXContent(p),\n+                new ParseField(\"error_details\"));\n+    }\n+\n+    public static InvalidateApiKeyResponse fromXContent(XContentParser parser) throws IOException {\n+        return PARSER.parse(parser, null);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"InvalidateApiKeyResponse [invalidatedApiKeys=\" + invalidatedApiKeys + \", previouslyInvalidatedApiKeys=\"\n+                + previouslyInvalidatedApiKeys + \", errors=\" + errors + \"]\";\n+    }\n+\n+}"
        },
        {
            "sha": "27079eebcc36bdf34fcd98d5ddfc7f35451499e1",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/role/GetRolesResponse.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Frole%2FGetRolesResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Frole%2FGetRolesResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Frole%2FGetRolesResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -37,7 +37,7 @@ public void readFrom(StreamInput in) throws IOException {\n         int size = in.readVInt();\n         roles = new RoleDescriptor[size];\n         for (int i = 0; i < size; i++) {\n-            roles[i] = RoleDescriptor.readFrom(in);\n+            roles[i] = new RoleDescriptor(in);\n         }\n     }\n \n@@ -46,7 +46,7 @@ public void writeTo(StreamOutput out) throws IOException {\n         super.writeTo(out);\n         out.writeVInt(roles.length);\n         for (RoleDescriptor role : roles) {\n-            RoleDescriptor.writeTo(role, out);\n+            role.writeTo(out);\n         }\n     }\n }"
        },
        {
            "sha": "74984556dc1a0744bfdacf799c38335ab8847e93",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/action/user/HasPrivilegesResponse.java",
            "status": "modified",
            "additions": 8,
            "deletions": 53,
            "changes": 61,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponse.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponse.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponse.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -11,6 +11,7 @@\n import org.elasticsearch.common.io.stream.StreamOutput;\n import org.elasticsearch.common.xcontent.ToXContentObject;\n import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n \n import java.io.IOException;\n import java.util.Collection;\n@@ -49,7 +50,7 @@ public HasPrivilegesResponse(String username, boolean completeMatch, Map<String,\n     }\n \n     private static Set<ResourcePrivileges> sorted(Collection<ResourcePrivileges> resources) {\n-        final Set<ResourcePrivileges> set = new TreeSet<>(Comparator.comparing(o -> o.resource));\n+        final Set<ResourcePrivileges> set = new TreeSet<>(Comparator.comparing(o -> o.getResource()));\n         set.addAll(resources);\n         return set;\n     }\n@@ -116,11 +117,11 @@ public void readFrom(StreamInput in) throws IOException {\n \n     private static Set<ResourcePrivileges> readResourcePrivileges(StreamInput in) throws IOException {\n         final int count = in.readVInt();\n-        final Set<ResourcePrivileges> set = new TreeSet<>(Comparator.comparing(o -> o.resource));\n+        final Set<ResourcePrivileges> set = new TreeSet<>(Comparator.comparing(o -> o.getResource()));\n         for (int i = 0; i < count; i++) {\n             final String index = in.readString();\n             final Map<String, Boolean> privileges = in.readMap(StreamInput::readString, StreamInput::readBoolean);\n-            set.add(new ResourcePrivileges(index, privileges));\n+            set.add(ResourcePrivileges.builder(index).addPrivileges(privileges).build());\n         }\n         return set;\n     }\n@@ -144,8 +145,8 @@ public void writeTo(StreamOutput out) throws IOException {\n     private static void writeResourcePrivileges(StreamOutput out, Set<ResourcePrivileges> privileges) throws IOException {\n         out.writeVInt(privileges.size());\n         for (ResourcePrivileges priv : privileges) {\n-            out.writeString(priv.resource);\n-            out.writeMap(priv.privileges, StreamOutput::writeString, StreamOutput::writeBoolean);\n+            out.writeString(priv.getResource());\n+            out.writeMap(priv.getPrivileges(), StreamOutput::writeString, StreamOutput::writeBoolean);\n         }\n     }\n \n@@ -181,60 +182,14 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params) throws\n         return builder;\n     }\n \n-    private void appendResources(XContentBuilder builder, String field, Set<HasPrivilegesResponse.ResourcePrivileges> privileges)\n+    private void appendResources(XContentBuilder builder, String field, Set<ResourcePrivileges> privileges)\n         throws IOException {\n         builder.startObject(field);\n-        for (HasPrivilegesResponse.ResourcePrivileges privilege : privileges) {\n+        for (ResourcePrivileges privilege : privileges) {\n             builder.field(privilege.getResource());\n             builder.map(privilege.getPrivileges());\n         }\n         builder.endObject();\n     }\n \n-\n-    public static class ResourcePrivileges {\n-        private final String resource;\n-        private final Map<String, Boolean> privileges;\n-\n-        public ResourcePrivileges(String resource, Map<String, Boolean> privileges) {\n-            this.resource = Objects.requireNonNull(resource);\n-            this.privileges = Collections.unmodifiableMap(privileges);\n-        }\n-\n-        public String getResource() {\n-            return resource;\n-        }\n-\n-        public Map<String, Boolean> getPrivileges() {\n-            return privileges;\n-        }\n-\n-        @Override\n-        public String toString() {\n-            return getClass().getSimpleName() + \"{\" +\n-                    \"resource='\" + resource + '\\'' +\n-                    \", privileges=\" + privileges +\n-                    '}';\n-        }\n-\n-        @Override\n-        public int hashCode() {\n-            int result = resource.hashCode();\n-            result = 31 * result + privileges.hashCode();\n-            return result;\n-        }\n-\n-        @Override\n-        public boolean equals(Object o) {\n-            if (this == o) {\n-                return true;\n-            }\n-            if (o == null || getClass() != o.getClass()) {\n-                return false;\n-            }\n-\n-            final ResourcePrivileges other = (ResourcePrivileges) o;\n-            return this.resource.equals(other.resource) && this.privileges.equals(other.privileges);\n-        }\n-    }\n }"
        },
        {
            "sha": "a93cc44aadb23a9b487b0b38f7be722b680496ab",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/Authentication.java",
            "status": "modified",
            "additions": 47,
            "deletions": 15,
            "changes": 62,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FAuthentication.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FAuthentication.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FAuthentication.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -18,6 +18,8 @@\n \n import java.io.IOException;\n import java.util.Base64;\n+import java.util.Collections;\n+import java.util.Map;\n import java.util.Objects;\n \n // TODO(hub-cap) Clean this up after moving User over - This class can re-inherit its field AUTHENTICATION_KEY in AuthenticationField.\n@@ -28,16 +30,25 @@ public class Authentication implements ToXContentObject {\n     private final RealmRef authenticatedBy;\n     private final RealmRef lookedUpBy;\n     private final Version version;\n+    private final AuthenticationType type;\n+    private final Map<String, Object> metadata;\n \n     public Authentication(User user, RealmRef authenticatedBy, RealmRef lookedUpBy) {\n         this(user, authenticatedBy, lookedUpBy, Version.CURRENT);\n     }\n \n     public Authentication(User user, RealmRef authenticatedBy, RealmRef lookedUpBy, Version version) {\n+        this(user, authenticatedBy, lookedUpBy, version, AuthenticationType.REALM, Collections.emptyMap());\n+    }\n+\n+    public Authentication(User user, RealmRef authenticatedBy, RealmRef lookedUpBy, Version version,\n+                          AuthenticationType type, Map<String, Object> metadata) {\n         this.user = Objects.requireNonNull(user);\n         this.authenticatedBy = Objects.requireNonNull(authenticatedBy);\n         this.lookedUpBy = lookedUpBy;\n         this.version = version;\n+        this.type = type;\n+        this.metadata = metadata;\n     }\n \n     public Authentication(StreamInput in) throws IOException {\n@@ -49,6 +60,13 @@ public Authentication(StreamInput in) throws IOException {\n             this.lookedUpBy = null;\n         }\n         this.version = in.getVersion();\n+        if (in.getVersion().onOrAfter(Version.V_7_0_0)) { // TODO change to V6_6 after backport\n+            type = AuthenticationType.values()[in.readVInt()];\n+            metadata = in.readMap();\n+        } else {\n+            type = AuthenticationType.REALM;\n+            metadata = Collections.emptyMap();\n+        }\n     }\n \n     public User getUser() {\n@@ -67,8 +85,15 @@ public Version getVersion() {\n         return version;\n     }\n \n-    public static Authentication readFromContext(ThreadContext ctx)\n-            throws IOException, IllegalArgumentException {\n+    public AuthenticationType getAuthenticationType() {\n+        return type;\n+    }\n+\n+    public Map<String, Object> getMetadata() {\n+        return metadata;\n+    }\n+\n+    public static Authentication readFromContext(ThreadContext ctx) throws IOException, IllegalArgumentException {\n         Authentication authentication = ctx.getTransient(AuthenticationField.AUTHENTICATION_KEY);\n         if (authentication != null) {\n             assert ctx.getHeader(AuthenticationField.AUTHENTICATION_KEY) != null;\n@@ -107,8 +132,7 @@ public static Authentication decode(String header) throws IOException {\n      * Writes the authentication to the context. There must not be an existing authentication in the context and if there is an\n      * {@link IllegalStateException} will be thrown\n      */\n-    public void writeToContext(ThreadContext ctx)\n-            throws IOException, IllegalArgumentException {\n+    public void writeToContext(ThreadContext ctx) throws IOException, IllegalArgumentException {\n         ensureContextDoesNotContainAuthentication(ctx);\n         String header = encode();\n         ctx.putTransient(AuthenticationField.AUTHENTICATION_KEY, this);\n@@ -141,28 +165,28 @@ public void writeTo(StreamOutput out) throws IOException {\n         } else {\n             out.writeBoolean(false);\n         }\n+        if (out.getVersion().onOrAfter(Version.V_7_0_0)) { // TODO change to V6_6 after backport\n+            out.writeVInt(type.ordinal());\n+            out.writeMap(metadata);\n+        }\n     }\n \n     @Override\n     public boolean equals(Object o) {\n         if (this == o) return true;\n         if (o == null || getClass() != o.getClass()) return false;\n-\n         Authentication that = (Authentication) o;\n-\n-        if (!user.equals(that.user)) return false;\n-        if (!authenticatedBy.equals(that.authenticatedBy)) return false;\n-        if (lookedUpBy != null ? !lookedUpBy.equals(that.lookedUpBy) : that.lookedUpBy != null) return false;\n-        return version.equals(that.version);\n+        return user.equals(that.user) &&\n+            authenticatedBy.equals(that.authenticatedBy) &&\n+            Objects.equals(lookedUpBy, that.lookedUpBy) &&\n+            version.equals(that.version) &&\n+            type == that.type &&\n+            metadata.equals(that.metadata);\n     }\n \n     @Override\n     public int hashCode() {\n-        int result = user.hashCode();\n-        result = 31 * result + authenticatedBy.hashCode();\n-        result = 31 * result + (lookedUpBy != null ? lookedUpBy.hashCode() : 0);\n-        result = 31 * result + version.hashCode();\n-        return result;\n+        return Objects.hash(user, authenticatedBy, lookedUpBy, version, type, metadata);\n     }\n \n     @Override\n@@ -246,5 +270,13 @@ public int hashCode() {\n             return result;\n         }\n     }\n+\n+    public enum AuthenticationType {\n+        REALM,\n+        API_KEY,\n+        TOKEN,\n+        ANONYMOUS,\n+        INTERNAL\n+    }\n }\n "
        },
        {
            "sha": "d8954501b8b83e99c87d216a38f5c3ae24f675d7",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authc/DefaultAuthenticationFailureHandler.java",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandler.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandler.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandler.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -68,10 +68,12 @@ private static Integer authSchemePriority(final String headerValue) {\n             return 0;\n         } else if (headerValue.regionMatches(true, 0, \"bearer\", 0, \"bearer\".length())) {\n             return 1;\n-        } else if (headerValue.regionMatches(true, 0, \"basic\", 0, \"basic\".length())) {\n+        } else if (headerValue.regionMatches(true, 0, \"apikey\", 0, \"apikey\".length())) {\n             return 2;\n-        } else {\n+        } else if (headerValue.regionMatches(true, 0, \"basic\", 0, \"basic\".length())) {\n             return 3;\n+        } else {\n+            return 4;\n         }\n     }\n "
        },
        {
            "sha": "5705d7bf357233f253336b8453520481abde857c",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/RoleDescriptor.java",
            "status": "modified",
            "additions": 33,
            "deletions": 38,
            "changes": 71,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2FRoleDescriptor.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2FRoleDescriptor.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2FRoleDescriptor.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -43,7 +43,7 @@\n  * A holder for a Role that contains user-readable information about the Role\n  * without containing the actual Role object.\n  */\n-public class RoleDescriptor implements ToXContentObject {\n+public class RoleDescriptor implements ToXContentObject, Writeable {\n \n     public static final String ROLE_TYPE = \"role\";\n \n@@ -110,6 +110,27 @@ public RoleDescriptor(String name,\n                 Collections.singletonMap(\"enabled\", true);\n     }\n \n+    public RoleDescriptor(StreamInput in) throws IOException {\n+        this.name = in.readString();\n+        this.clusterPrivileges = in.readStringArray();\n+        int size = in.readVInt();\n+        this.indicesPrivileges = new IndicesPrivileges[size];\n+        for (int i = 0; i < size; i++) {\n+            indicesPrivileges[i] = new IndicesPrivileges(in);\n+        }\n+        this.runAs = in.readStringArray();\n+        this.metadata = in.readMap();\n+        this.transientMetadata = in.readMap();\n+\n+        if (in.getVersion().onOrAfter(Version.V_6_4_0)) {\n+            this.applicationPrivileges = in.readArray(ApplicationResourcePrivileges::new, ApplicationResourcePrivileges[]::new);\n+            this.conditionalClusterPrivileges = ConditionalClusterPrivileges.readArray(in);\n+        } else {\n+            this.applicationPrivileges = ApplicationResourcePrivileges.NONE;\n+            this.conditionalClusterPrivileges = ConditionalClusterPrivileges.EMPTY_ARRAY;\n+        }\n+    }\n+\n     public String getName() {\n         return this.name;\n     }\n@@ -232,46 +253,20 @@ public XContentBuilder toXContent(XContentBuilder builder, Params params, boolea\n         return builder.endObject();\n     }\n \n-    public static RoleDescriptor readFrom(StreamInput in) throws IOException {\n-        String name = in.readString();\n-        String[] clusterPrivileges = in.readStringArray();\n-        int size = in.readVInt();\n-        IndicesPrivileges[] indicesPrivileges = new IndicesPrivileges[size];\n-        for (int i = 0; i < size; i++) {\n-            indicesPrivileges[i] = new IndicesPrivileges(in);\n-        }\n-        String[] runAs = in.readStringArray();\n-        Map<String, Object> metadata = in.readMap();\n-\n-        final Map<String, Object> transientMetadata = in.readMap();\n-\n-        final ApplicationResourcePrivileges[] applicationPrivileges;\n-        final ConditionalClusterPrivilege[] conditionalClusterPrivileges;\n-        if (in.getVersion().onOrAfter(Version.V_6_4_0)) {\n-            applicationPrivileges = in.readArray(ApplicationResourcePrivileges::new, ApplicationResourcePrivileges[]::new);\n-            conditionalClusterPrivileges = ConditionalClusterPrivileges.readArray(in);\n-        } else {\n-            applicationPrivileges = ApplicationResourcePrivileges.NONE;\n-            conditionalClusterPrivileges = ConditionalClusterPrivileges.EMPTY_ARRAY;\n-        }\n-\n-        return new RoleDescriptor(name, clusterPrivileges, indicesPrivileges, applicationPrivileges, conditionalClusterPrivileges,\n-            runAs, metadata, transientMetadata);\n-    }\n-\n-    public static void writeTo(RoleDescriptor descriptor, StreamOutput out) throws IOException {\n-        out.writeString(descriptor.name);\n-        out.writeStringArray(descriptor.clusterPrivileges);\n-        out.writeVInt(descriptor.indicesPrivileges.length);\n-        for (IndicesPrivileges group : descriptor.indicesPrivileges) {\n+    @Override\n+    public void writeTo(StreamOutput out) throws IOException {\n+        out.writeString(name);\n+        out.writeStringArray(clusterPrivileges);\n+        out.writeVInt(indicesPrivileges.length);\n+        for (IndicesPrivileges group : indicesPrivileges) {\n             group.writeTo(out);\n         }\n-        out.writeStringArray(descriptor.runAs);\n-        out.writeMap(descriptor.metadata);\n-        out.writeMap(descriptor.transientMetadata);\n+        out.writeStringArray(runAs);\n+        out.writeMap(metadata);\n+        out.writeMap(transientMetadata);\n         if (out.getVersion().onOrAfter(Version.V_6_4_0)) {\n-            out.writeArray(ApplicationResourcePrivileges::write, descriptor.applicationPrivileges);\n-            ConditionalClusterPrivileges.writeArray(out, descriptor.getConditionalClusterPrivileges());\n+            out.writeArray(ApplicationResourcePrivileges::write, applicationPrivileges);\n+            ConditionalClusterPrivileges.writeArray(out, getConditionalClusterPrivileges());\n         }\n     }\n "
        },
        {
            "sha": "8cdf099e676d81c4db4eb4fa9972cc259d289292",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/IndicesAccessControl.java",
            "status": "modified",
            "additions": 63,
            "deletions": 9,
            "changes": 72,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControl.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControl.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControl.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -6,11 +6,13 @@\n package org.elasticsearch.xpack.core.security.authz.accesscontrol;\n \n import org.elasticsearch.common.Nullable;\n-import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.util.set.Sets;\n import org.elasticsearch.xpack.core.security.authz.IndicesAndAliasesResolverField;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n \n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.Map;\n import java.util.Set;\n \n@@ -22,7 +24,7 @@ public class IndicesAccessControl {\n     public static final IndicesAccessControl ALLOW_ALL = new IndicesAccessControl(true, Collections.emptyMap());\n     public static final IndicesAccessControl ALLOW_NO_INDICES = new IndicesAccessControl(true,\n             Collections.singletonMap(IndicesAndAliasesResolverField.NO_INDEX_PLACEHOLDER,\n-                    new IndicesAccessControl.IndexAccessControl(true, new FieldPermissions(), null)));\n+                    new IndicesAccessControl.IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.allowAll())));\n \n     private final boolean granted;\n     private final Map<String, IndexAccessControl> indexPermissions;\n@@ -55,12 +57,12 @@ public static class IndexAccessControl {\n \n         private final boolean granted;\n         private final FieldPermissions fieldPermissions;\n-        private final Set<BytesReference> queries;\n+        private final DocumentPermissions documentPermissions;\n \n-        public IndexAccessControl(boolean granted, FieldPermissions fieldPermissions, Set<BytesReference> queries) {\n+        public IndexAccessControl(boolean granted, FieldPermissions fieldPermissions, DocumentPermissions documentPermissions) {\n             this.granted = granted;\n-            this.fieldPermissions = fieldPermissions;\n-            this.queries = queries;\n+            this.fieldPermissions = (fieldPermissions == null) ? FieldPermissions.DEFAULT : fieldPermissions;\n+            this.documentPermissions = (documentPermissions == null) ? DocumentPermissions.allowAll() : documentPermissions;\n         }\n \n         /**\n@@ -82,20 +84,72 @@ public FieldPermissions getFieldPermissions() {\n          *         then this means that there are no document level restrictions\n          */\n         @Nullable\n-        public Set<BytesReference> getQueries() {\n-            return queries;\n+        public DocumentPermissions getDocumentPermissions() {\n+            return documentPermissions;\n+        }\n+\n+        /**\n+         * Returns a instance of {@link IndexAccessControl}, where the privileges for {@code this} object are constrained by the privileges\n+         * contained in the provided parameter.<br>\n+         * Allowed fields for this index permission would be an intersection of allowed fields.<br>\n+         * Allowed documents for this index permission would be an intersection of allowed documents.<br>\n+         *\n+         * @param limitedByIndexAccessControl {@link IndexAccessControl}\n+         * @return {@link IndexAccessControl}\n+         * @see FieldPermissions#limitFieldPermissions(FieldPermissions)\n+         * @see DocumentPermissions#limitDocumentPermissions(DocumentPermissions)\n+         */\n+        public IndexAccessControl limitIndexAccessControl(IndexAccessControl limitedByIndexAccessControl) {\n+            final boolean granted;\n+            if (this.granted == limitedByIndexAccessControl.granted) {\n+                granted = this.granted;\n+            } else {\n+                granted = false;\n+            }\n+            FieldPermissions fieldPermissions = getFieldPermissions().limitFieldPermissions(\n+                    limitedByIndexAccessControl.fieldPermissions);\n+            DocumentPermissions documentPermissions = getDocumentPermissions()\n+                    .limitDocumentPermissions(limitedByIndexAccessControl.getDocumentPermissions());\n+            return new IndexAccessControl(granted, fieldPermissions, documentPermissions);\n         }\n \n         @Override\n         public String toString() {\n             return \"IndexAccessControl{\" +\n                     \"granted=\" + granted +\n                     \", fieldPermissions=\" + fieldPermissions +\n-                    \", queries=\" + queries +\n+                    \", documentPermissions=\" + documentPermissions +\n                     '}';\n         }\n     }\n \n+    /**\n+     * Returns a instance of {@link IndicesAccessControl}, where the privileges for {@code this}\n+     * object are constrained by the privileges contained in the provided parameter.<br>\n+     *\n+     * @param limitedByIndicesAccessControl {@link IndicesAccessControl}\n+     * @return {@link IndicesAccessControl}\n+     */\n+    public IndicesAccessControl limitIndicesAccessControl(IndicesAccessControl limitedByIndicesAccessControl) {\n+        final boolean granted;\n+        if (this.granted == limitedByIndicesAccessControl.granted) {\n+            granted = this.granted;\n+        } else {\n+            granted = false;\n+        }\n+        Set<String> indexes = indexPermissions.keySet();\n+        Set<String> otherIndexes = limitedByIndicesAccessControl.indexPermissions.keySet();\n+        Set<String> commonIndexes = Sets.intersection(indexes, otherIndexes);\n+\n+        Map<String, IndexAccessControl> indexPermissions = new HashMap<>(commonIndexes.size());\n+        for (String index : commonIndexes) {\n+            IndexAccessControl indexAccessControl = getIndexPermissions(index);\n+            IndexAccessControl limitedByIndexAccessControl = limitedByIndicesAccessControl.getIndexPermissions(index);\n+            indexPermissions.put(index, indexAccessControl.limitIndexAccessControl(limitedByIndexAccessControl));\n+        }\n+        return new IndicesAccessControl(granted, indexPermissions);\n+    }\n+\n     @Override\n     public String toString() {\n         return \"IndicesAccessControl{\" +"
        },
        {
            "sha": "56383909d846eb331220e7ec5586e1419a17d772",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/SecurityIndexSearcherWrapper.java",
            "status": "modified",
            "additions": 11,
            "deletions": 168,
            "changes": 179,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapper.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapper.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapper.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -5,8 +5,8 @@\n  */\n package org.elasticsearch.xpack.core.security.authz.accesscontrol;\n \n-import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n import org.apache.lucene.index.DirectoryReader;\n import org.apache.lucene.index.LeafReaderContext;\n import org.apache.lucene.search.BooleanQuery;\n@@ -18,64 +18,35 @@\n import org.apache.lucene.search.DocIdSetIterator;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.LeafCollector;\n-import org.apache.lucene.search.Query;\n import org.apache.lucene.search.Scorer;\n import org.apache.lucene.search.Weight;\n-import org.apache.lucene.search.join.BitSetProducer;\n-import org.apache.lucene.search.join.ToChildBlockJoinQuery;\n import org.apache.lucene.util.BitSet;\n import org.apache.lucene.util.BitSetIterator;\n import org.apache.lucene.util.Bits;\n import org.apache.lucene.util.SparseFixedBitSet;\n-import org.elasticsearch.ElasticsearchParseException;\n import org.elasticsearch.ExceptionsHelper;\n-import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.logging.LoggerMessageFormat;\n-import org.elasticsearch.common.lucene.search.Queries;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n-import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n-import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n-import org.elasticsearch.common.xcontent.XContentFactory;\n-import org.elasticsearch.common.xcontent.XContentParser;\n import org.elasticsearch.index.cache.bitset.BitsetFilterCache;\n import org.elasticsearch.index.engine.EngineException;\n-import org.elasticsearch.index.query.BoolQueryBuilder;\n-import org.elasticsearch.index.query.BoostingQueryBuilder;\n-import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n-import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n-import org.elasticsearch.index.query.QueryBuilder;\n-import org.elasticsearch.index.query.QueryRewriteContext;\n import org.elasticsearch.index.query.QueryShardContext;\n-import org.elasticsearch.index.query.Rewriteable;\n-import org.elasticsearch.index.query.TermsQueryBuilder;\n-import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n-import org.elasticsearch.index.search.NestedHelper;\n import org.elasticsearch.index.shard.IndexSearcherWrapper;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.index.shard.ShardUtils;\n import org.elasticsearch.license.XPackLicenseState;\n-import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptService;\n-import org.elasticsearch.script.ScriptType;\n-import org.elasticsearch.script.TemplateScript;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.DocumentSubsetReader.DocumentSubsetDirectoryReader;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.support.Exceptions;\n import org.elasticsearch.xpack.core.security.user.User;\n \n import java.io.IOException;\n-import java.util.ArrayList;\n import java.util.Arrays;\n-import java.util.Collections;\n-import java.util.HashMap;\n import java.util.List;\n-import java.util.Map;\n import java.util.function.Function;\n \n-import static org.apache.lucene.search.BooleanClause.Occur.FILTER;\n-import static org.apache.lucene.search.BooleanClause.Occur.SHOULD;\n-\n /**\n  * An {@link IndexSearcherWrapper} implementation that is used for field and document level security.\n  * <p>\n@@ -107,7 +78,7 @@ public SecurityIndexSearcherWrapper(Function<ShardId, QueryShardContext> querySh\n     }\n \n     @Override\n-    protected DirectoryReader wrap(DirectoryReader reader) {\n+    protected DirectoryReader wrap(final DirectoryReader reader) {\n         if (licenseState.isDocumentAndFieldLevelSecurityAllowed() == false) {\n             return reader;\n         }\n@@ -120,47 +91,22 @@ protected DirectoryReader wrap(DirectoryReader reader) {\n                 throw new IllegalStateException(LoggerMessageFormat.format(\"couldn't extract shardId from reader [{}]\", reader));\n             }\n \n-            IndicesAccessControl.IndexAccessControl permissions = indicesAccessControl.getIndexPermissions(shardId.getIndexName());\n+            final IndicesAccessControl.IndexAccessControl permissions = indicesAccessControl.getIndexPermissions(shardId.getIndexName());\n             // No permissions have been defined for an index, so don't intercept the index reader for access control\n             if (permissions == null) {\n                 return reader;\n             }\n \n-            if (permissions.getQueries() != null) {\n-                BooleanQuery.Builder filter = new BooleanQuery.Builder();\n-                for (BytesReference bytesReference : permissions.getQueries()) {\n-                    QueryShardContext queryShardContext = queryShardContextProvider.apply(shardId);\n-                    String templateResult = evaluateTemplate(bytesReference.utf8ToString());\n-                    try (XContentParser parser = XContentFactory.xContent(templateResult)\n-                            .createParser(queryShardContext.getXContentRegistry(), LoggingDeprecationHandler.INSTANCE, templateResult)) {\n-                        QueryBuilder queryBuilder = queryShardContext.parseInnerQueryBuilder(parser);\n-                        verifyRoleQuery(queryBuilder);\n-                        failIfQueryUsesClient(queryBuilder, queryShardContext);\n-                        Query roleQuery = queryShardContext.toQuery(queryBuilder).query();\n-                        filter.add(roleQuery, SHOULD);\n-                        if (queryShardContext.getMapperService().hasNested()) {\n-                            NestedHelper nestedHelper = new NestedHelper(queryShardContext.getMapperService());\n-                            if (nestedHelper.mightMatchNestedDocs(roleQuery)) {\n-                                roleQuery = new BooleanQuery.Builder()\n-                                    .add(roleQuery, FILTER)\n-                                    .add(Queries.newNonNestedFilter(queryShardContext.indexVersionCreated()), FILTER)\n-                                    .build();\n-                            }\n-                            // If access is allowed on root doc then also access is allowed on all nested docs of that root document:\n-                            BitSetProducer rootDocs = queryShardContext.bitsetFilter(\n-                                    Queries.newNonNestedFilter(queryShardContext.indexVersionCreated()));\n-                            ToChildBlockJoinQuery includeNestedDocs = new ToChildBlockJoinQuery(roleQuery, rootDocs);\n-                            filter.add(includeNestedDocs, SHOULD);\n-                        }\n-                    }\n+            DirectoryReader wrappedReader = reader;\n+            DocumentPermissions documentPermissions = permissions.getDocumentPermissions();\n+            if (documentPermissions != null && documentPermissions.hasDocumentLevelPermissions()) {\n+                BooleanQuery filterQuery = documentPermissions.filter(getUser(), scriptService, shardId, queryShardContextProvider);\n+                if (filterQuery != null) {\n+                    wrappedReader = DocumentSubsetReader.wrap(wrappedReader, bitsetFilterCache, new ConstantScoreQuery(filterQuery));\n                 }\n-\n-                // at least one of the queries should match\n-                filter.setMinimumNumberShouldMatch(1);\n-                reader = DocumentSubsetReader.wrap(reader, bitsetFilterCache, new ConstantScoreQuery(filter.build()));\n             }\n \n-            return permissions.getFieldPermissions().filter(reader);\n+            return permissions.getFieldPermissions().filter(wrappedReader);\n         } catch (IOException e) {\n             logger.error(\"Unable to apply field level security\");\n             throw ExceptionsHelper.convertToElastic(e);\n@@ -255,48 +201,6 @@ static void intersectScorerAndRoleBits(Scorer scorer, SparseFixedBitSet roleBits\n         }\n     }\n \n-    String evaluateTemplate(String querySource) throws IOException {\n-        // EMPTY is safe here because we never use namedObject\n-        try (XContentParser parser = XContentFactory.xContent(querySource).createParser(NamedXContentRegistry.EMPTY,\n-                LoggingDeprecationHandler.INSTANCE, querySource)) {\n-            XContentParser.Token token = parser.nextToken();\n-            if (token != XContentParser.Token.START_OBJECT) {\n-                throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n-            }\n-            token = parser.nextToken();\n-            if (token != XContentParser.Token.FIELD_NAME) {\n-                throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n-            }\n-            if (\"template\".equals(parser.currentName())) {\n-                token = parser.nextToken();\n-                if (token != XContentParser.Token.START_OBJECT) {\n-                    throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n-                }\n-                Script script = Script.parse(parser);\n-                // Add the user details to the params\n-                Map<String, Object> params = new HashMap<>();\n-                if (script.getParams() != null) {\n-                    params.putAll(script.getParams());\n-                }\n-                User user = getUser();\n-                Map<String, Object> userModel = new HashMap<>();\n-                userModel.put(\"username\", user.principal());\n-                userModel.put(\"full_name\", user.fullName());\n-                userModel.put(\"email\", user.email());\n-                userModel.put(\"roles\", Arrays.asList(user.roles()));\n-                userModel.put(\"metadata\", Collections.unmodifiableMap(user.metadata()));\n-                params.put(\"_user\", userModel);\n-                // Always enforce mustache script lang:\n-                script = new Script(script.getType(),\n-                        script.getType() == ScriptType.STORED ? null : \"mustache\", script.getIdOrCode(), script.getOptions(), params);\n-                TemplateScript compiledTemplate = scriptService.compile(script, TemplateScript.CONTEXT).newInstance(script.getParams());\n-                return compiledTemplate.execute();\n-            } else {\n-                return querySource;\n-            }\n-        }\n-    }\n-\n     protected IndicesAccessControl getIndicesAccessControl() {\n         IndicesAccessControl indicesAccessControl = threadContext.getTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY);\n         if (indicesAccessControl == null) {\n@@ -310,65 +214,4 @@ protected User getUser(){\n         return authentication.getUser();\n     }\n \n-    /**\n-     * Checks whether the role query contains queries we know can't be used as DLS role query.\n-     */\n-    static void verifyRoleQuery(QueryBuilder queryBuilder) throws IOException {\n-        if (queryBuilder instanceof TermsQueryBuilder) {\n-            TermsQueryBuilder termsQueryBuilder = (TermsQueryBuilder) queryBuilder;\n-            if (termsQueryBuilder.termsLookup() != null) {\n-                throw new IllegalArgumentException(\"terms query with terms lookup isn't supported as part of a role query\");\n-            }\n-        } else if (queryBuilder instanceof GeoShapeQueryBuilder) {\n-            GeoShapeQueryBuilder geoShapeQueryBuilder = (GeoShapeQueryBuilder) queryBuilder;\n-            if (geoShapeQueryBuilder.shape() == null) {\n-                throw new IllegalArgumentException(\"geoshape query referring to indexed shapes isn't support as part of a role query\");\n-            }\n-        } else if (queryBuilder.getName().equals(\"percolate\")) {\n-            // actually only if percolate query is referring to an existing document then this is problematic,\n-            // a normal percolate query does work. However we can't check that here as this query builder is inside\n-            // another module. So we don't allow the entire percolate query. I don't think users would ever use\n-            // a percolate query as role query, so this restriction shouldn't prohibit anyone from using dls.\n-            throw new IllegalArgumentException(\"percolate query isn't support as part of a role query\");\n-        } else if (queryBuilder.getName().equals(\"has_child\")) {\n-            throw new IllegalArgumentException(\"has_child query isn't support as part of a role query\");\n-        } else if (queryBuilder.getName().equals(\"has_parent\")) {\n-            throw new IllegalArgumentException(\"has_parent query isn't support as part of a role query\");\n-        } else if (queryBuilder instanceof BoolQueryBuilder) {\n-            BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) queryBuilder;\n-            List<QueryBuilder> clauses = new ArrayList<>();\n-            clauses.addAll(boolQueryBuilder.filter());\n-            clauses.addAll(boolQueryBuilder.must());\n-            clauses.addAll(boolQueryBuilder.mustNot());\n-            clauses.addAll(boolQueryBuilder.should());\n-            for (QueryBuilder clause : clauses) {\n-                verifyRoleQuery(clause);\n-            }\n-        } else if (queryBuilder instanceof ConstantScoreQueryBuilder) {\n-            verifyRoleQuery(((ConstantScoreQueryBuilder) queryBuilder).innerQuery());\n-        } else if (queryBuilder instanceof FunctionScoreQueryBuilder) {\n-            verifyRoleQuery(((FunctionScoreQueryBuilder) queryBuilder).query());\n-        } else if (queryBuilder instanceof BoostingQueryBuilder) {\n-            verifyRoleQuery(((BoostingQueryBuilder) queryBuilder).negativeQuery());\n-            verifyRoleQuery(((BoostingQueryBuilder) queryBuilder).positiveQuery());\n-        }\n-    }\n-\n-    /**\n-     * Fall back validation that verifies that queries during rewrite don't use\n-     * the client to make remote calls. In the case of DLS this can cause a dead\n-     * lock if DLS is also applied on these remote calls. For example in the\n-     * case of terms query with lookup, this can cause recursive execution of\n-     * the DLS query until the get thread pool has been exhausted:\n-     * https://github.com/elastic/x-plugins/issues/3145\n-     */\n-    static void failIfQueryUsesClient(QueryBuilder queryBuilder, QueryRewriteContext original)\n-            throws IOException {\n-        QueryRewriteContext copy = new QueryRewriteContext(\n-                original.getXContentRegistry(), original.getWriteableRegistry(), null, original::nowInMillis);\n-        Rewriteable.rewrite(queryBuilder, copy);\n-        if (copy.hasAsyncActions()) {\n-            throw new IllegalStateException(\"role queries are not allowed to execute additional requests\");\n-        }\n-    }\n }"
        },
        {
            "sha": "0cd4e8a8b0ddce9385691e0af5c2e1a85a3b0af1",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/ApplicationPermission.java",
            "status": "modified",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FApplicationPermission.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FApplicationPermission.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FApplicationPermission.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -12,10 +12,12 @@\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.util.set.Sets;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n import org.elasticsearch.xpack.core.security.support.Automatons;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n import java.util.List;\n@@ -83,6 +85,40 @@ public boolean grants(ApplicationPrivilege other, String resource) {\n         return matched;\n     }\n \n+    /**\n+     * For a given application, checks for the privileges for resources and returns an instance of {@link ResourcePrivilegesMap} holding a\n+     * map of resource to {@link ResourcePrivileges} where the resource is application resource and the map of application privilege to\n+     * whether it is allowed or not.\n+     *\n+     * @param applicationName checks privileges for the provided application name\n+     * @param checkForResources check permission grants for the set of resources\n+     * @param checkForPrivilegeNames check permission grants for the set of privilege names\n+     * @param storedPrivileges stored {@link ApplicationPrivilegeDescriptor} for an application against which the access checks are\n+     *        performed\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    public ResourcePrivilegesMap checkResourcePrivileges(final String applicationName, Set<String> checkForResources,\n+                                                         Set<String> checkForPrivilegeNames,\n+                                                         Collection<ApplicationPrivilegeDescriptor> storedPrivileges) {\n+        final ResourcePrivilegesMap.Builder resourcePrivilegesMapBuilder = ResourcePrivilegesMap.builder();\n+        for (String checkResource : checkForResources) {\n+            for (String checkPrivilegeName : checkForPrivilegeNames) {\n+                final Set<String> nameSet = Collections.singleton(checkPrivilegeName);\n+                final ApplicationPrivilege checkPrivilege = ApplicationPrivilege.get(applicationName, nameSet, storedPrivileges);\n+                assert checkPrivilege.getApplication().equals(applicationName) : \"Privilege \" + checkPrivilege + \" should have application \"\n+                        + applicationName;\n+                assert checkPrivilege.name().equals(nameSet) : \"Privilege \" + checkPrivilege + \" should have name \" + nameSet;\n+\n+                if (grants(checkPrivilege, checkResource)) {\n+                    resourcePrivilegesMapBuilder.addResourcePrivilege(checkResource, checkPrivilegeName, Boolean.TRUE);\n+                } else {\n+                    resourcePrivilegesMapBuilder.addResourcePrivilege(checkResource, checkPrivilegeName, Boolean.FALSE);\n+                }\n+            }\n+        }\n+        return resourcePrivilegesMapBuilder.build();\n+    }\n+\n     @Override\n     public String toString() {\n         return getClass().getSimpleName() + \"{privileges=\" + permissions + \"}\";"
        },
        {
            "sha": "687798971399fb0bed816db6e372dd0a2d5aff49",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/ClusterPermission.java",
            "status": "modified",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FClusterPermission.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FClusterPermission.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FClusterPermission.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -5,6 +5,7 @@\n  */\n package org.elasticsearch.xpack.core.security.authz.permission;\n \n+import org.apache.lucene.util.automaton.Operations;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.transport.TransportRequest;\n import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n@@ -33,6 +34,10 @@ public ClusterPrivilege privilege() {\n \n     public abstract boolean check(String action, TransportRequest request);\n \n+    public boolean grants(ClusterPrivilege clusterPrivilege) {\n+        return Operations.subsetOf(clusterPrivilege.getAutomaton(), this.privilege().getAutomaton());\n+    }\n+\n     public abstract List<Tuple<ClusterPrivilege, ConditionalClusterPrivilege>> privileges();\n \n     /**\n@@ -111,5 +116,10 @@ public List<Tuple<ClusterPrivilege, ConditionalClusterPrivilege>> privileges() {\n         public boolean check(String action, TransportRequest request) {\n             return children.stream().anyMatch(p -> p.check(action, request));\n         }\n+\n+        @Override\n+        public boolean grants(ClusterPrivilege clusterPrivilege) {\n+            return children.stream().anyMatch(p -> p.grants(clusterPrivilege));\n+        }\n     }\n }"
        },
        {
            "sha": "08d754b4e535707ae0a27a58ca2e71461322a5be",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/DocumentPermissions.java",
            "status": "added",
            "additions": 262,
            "deletions": 0,
            "changes": 262,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissions.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissions.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissions.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.apache.lucene.search.BooleanQuery;\n+import org.apache.lucene.search.Query;\n+import org.apache.lucene.search.join.BitSetProducer;\n+import org.apache.lucene.search.join.ToChildBlockJoinQuery;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.lucene.search.Queries;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.BoostingQueryBuilder;\n+import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n+import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryRewriteContext;\n+import org.elasticsearch.index.query.QueryShardContext;\n+import org.elasticsearch.index.query.Rewriteable;\n+import org.elasticsearch.index.query.TermsQueryBuilder;\n+import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n+import org.elasticsearch.index.search.NestedHelper;\n+import org.elasticsearch.index.shard.ShardId;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.xpack.core.security.authz.support.SecurityQueryTemplateEvaluator;\n+import org.elasticsearch.xpack.core.security.user.User;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.function.Function;\n+\n+import static org.apache.lucene.search.BooleanClause.Occur.FILTER;\n+import static org.apache.lucene.search.BooleanClause.Occur.SHOULD;\n+\n+/**\n+ * Stores document level permissions in the form queries that match all the accessible documents.<br>\n+ * The document level permissions may be limited by another set of queries in that case the limited\n+ * queries are used as an additional filter.\n+ */\n+public final class DocumentPermissions {\n+    private final Set<BytesReference> queries;\n+    private final Set<BytesReference> limitedByQueries;\n+\n+    private static DocumentPermissions ALLOW_ALL = new DocumentPermissions();\n+\n+    DocumentPermissions() {\n+        this.queries = null;\n+        this.limitedByQueries = null;\n+    }\n+\n+    DocumentPermissions(Set<BytesReference> queries) {\n+        this(queries, null);\n+    }\n+\n+    DocumentPermissions(Set<BytesReference> queries, Set<BytesReference> scopedByQueries) {\n+        if (queries == null && scopedByQueries == null) {\n+            throw new IllegalArgumentException(\"one of the queries or scoped queries must be provided\");\n+        }\n+        this.queries = (queries != null) ? Collections.unmodifiableSet(queries) : queries;\n+        this.limitedByQueries = (scopedByQueries != null) ? Collections.unmodifiableSet(scopedByQueries) : scopedByQueries;\n+    }\n+\n+    public Set<BytesReference> getQueries() {\n+        return queries;\n+    }\n+\n+    public Set<BytesReference> getLimitedByQueries() {\n+        return limitedByQueries;\n+    }\n+\n+    /**\n+     * @return {@code true} if either queries or scoped queries are present for document level security else returns {@code false}\n+     */\n+    public boolean hasDocumentLevelPermissions() {\n+        return queries != null || limitedByQueries != null;\n+    }\n+\n+    /**\n+     * Creates a {@link BooleanQuery} to be used as filter to restrict access to documents.<br>\n+     * Document permission queries are used to create an boolean query.<br>\n+     * If the document permissions are limited, then there is an additional filter added restricting access to documents only allowed by the\n+     * limited queries.\n+     *\n+     * @param user authenticated {@link User}\n+     * @param scriptService {@link ScriptService} for evaluating query templates\n+     * @param shardId {@link ShardId}\n+     * @param queryShardContextProvider {@link QueryShardContext}\n+     * @return {@link BooleanQuery} for the filter\n+     * @throws IOException thrown if there is an exception during parsing\n+     */\n+    public BooleanQuery filter(User user, ScriptService scriptService, ShardId shardId,\n+                                      Function<ShardId, QueryShardContext> queryShardContextProvider) throws IOException {\n+        if (hasDocumentLevelPermissions()) {\n+            BooleanQuery.Builder filter;\n+            if (queries != null && limitedByQueries != null) {\n+                filter = new BooleanQuery.Builder();\n+                BooleanQuery.Builder scopedFilter = new BooleanQuery.Builder();\n+                buildRoleQuery(user, scriptService, shardId, queryShardContextProvider, limitedByQueries, scopedFilter);\n+                filter.add(scopedFilter.build(), FILTER);\n+\n+                buildRoleQuery(user, scriptService, shardId, queryShardContextProvider, queries, filter);\n+            } else if (queries != null) {\n+                filter = new BooleanQuery.Builder();\n+                buildRoleQuery(user, scriptService, shardId, queryShardContextProvider, queries, filter);\n+            } else if (limitedByQueries != null) {\n+                filter = new BooleanQuery.Builder();\n+                buildRoleQuery(user, scriptService, shardId, queryShardContextProvider, limitedByQueries, filter);\n+            } else {\n+                return null;\n+            }\n+            return filter.build();\n+        }\n+        return null;\n+    }\n+\n+    private static void buildRoleQuery(User user, ScriptService scriptService, ShardId shardId,\n+                                       Function<ShardId, QueryShardContext> queryShardContextProvider, Set<BytesReference> queries,\n+                                       BooleanQuery.Builder filter) throws IOException {\n+        for (BytesReference bytesReference : queries) {\n+            QueryShardContext queryShardContext = queryShardContextProvider.apply(shardId);\n+            String templateResult = SecurityQueryTemplateEvaluator.evaluateTemplate(bytesReference.utf8ToString(), scriptService, user);\n+            try (XContentParser parser = XContentFactory.xContent(templateResult).createParser(queryShardContext.getXContentRegistry(),\n+                    LoggingDeprecationHandler.INSTANCE, templateResult)) {\n+                QueryBuilder queryBuilder = queryShardContext.parseInnerQueryBuilder(parser);\n+                verifyRoleQuery(queryBuilder);\n+                failIfQueryUsesClient(queryBuilder, queryShardContext);\n+                Query roleQuery = queryShardContext.toQuery(queryBuilder).query();\n+                filter.add(roleQuery, SHOULD);\n+                if (queryShardContext.getMapperService().hasNested()) {\n+                    NestedHelper nestedHelper = new NestedHelper(queryShardContext.getMapperService());\n+                    if (nestedHelper.mightMatchNestedDocs(roleQuery)) {\n+                        roleQuery = new BooleanQuery.Builder().add(roleQuery, FILTER)\n+                                .add(Queries.newNonNestedFilter(queryShardContext.indexVersionCreated()), FILTER).build();\n+                    }\n+                    // If access is allowed on root doc then also access is allowed on all nested docs of that root document:\n+                    BitSetProducer rootDocs = queryShardContext\n+                            .bitsetFilter(Queries.newNonNestedFilter(queryShardContext.indexVersionCreated()));\n+                    ToChildBlockJoinQuery includeNestedDocs = new ToChildBlockJoinQuery(roleQuery, rootDocs);\n+                    filter.add(includeNestedDocs, SHOULD);\n+                }\n+            }\n+        }\n+        // at least one of the queries should match\n+        filter.setMinimumNumberShouldMatch(1);\n+    }\n+\n+    /**\n+     * Checks whether the role query contains queries we know can't be used as DLS role query.\n+     */\n+    static void verifyRoleQuery(QueryBuilder queryBuilder) throws IOException {\n+        if (queryBuilder instanceof TermsQueryBuilder) {\n+            TermsQueryBuilder termsQueryBuilder = (TermsQueryBuilder) queryBuilder;\n+            if (termsQueryBuilder.termsLookup() != null) {\n+                throw new IllegalArgumentException(\"terms query with terms lookup isn't supported as part of a role query\");\n+            }\n+        } else if (queryBuilder instanceof GeoShapeQueryBuilder) {\n+            GeoShapeQueryBuilder geoShapeQueryBuilder = (GeoShapeQueryBuilder) queryBuilder;\n+            if (geoShapeQueryBuilder.shape() == null) {\n+                throw new IllegalArgumentException(\"geoshape query referring to indexed shapes isn't support as part of a role query\");\n+            }\n+        } else if (queryBuilder.getName().equals(\"percolate\")) {\n+            // actually only if percolate query is referring to an existing document then this is problematic,\n+            // a normal percolate query does work. However we can't check that here as this query builder is inside\n+            // another module. So we don't allow the entire percolate query. I don't think users would ever use\n+            // a percolate query as role query, so this restriction shouldn't prohibit anyone from using dls.\n+            throw new IllegalArgumentException(\"percolate query isn't support as part of a role query\");\n+        } else if (queryBuilder.getName().equals(\"has_child\")) {\n+            throw new IllegalArgumentException(\"has_child query isn't support as part of a role query\");\n+        } else if (queryBuilder.getName().equals(\"has_parent\")) {\n+            throw new IllegalArgumentException(\"has_parent query isn't support as part of a role query\");\n+        } else if (queryBuilder instanceof BoolQueryBuilder) {\n+            BoolQueryBuilder boolQueryBuilder = (BoolQueryBuilder) queryBuilder;\n+            List<QueryBuilder> clauses = new ArrayList<>();\n+            clauses.addAll(boolQueryBuilder.filter());\n+            clauses.addAll(boolQueryBuilder.must());\n+            clauses.addAll(boolQueryBuilder.mustNot());\n+            clauses.addAll(boolQueryBuilder.should());\n+            for (QueryBuilder clause : clauses) {\n+                verifyRoleQuery(clause);\n+            }\n+        } else if (queryBuilder instanceof ConstantScoreQueryBuilder) {\n+            verifyRoleQuery(((ConstantScoreQueryBuilder) queryBuilder).innerQuery());\n+        } else if (queryBuilder instanceof FunctionScoreQueryBuilder) {\n+            verifyRoleQuery(((FunctionScoreQueryBuilder) queryBuilder).query());\n+        } else if (queryBuilder instanceof BoostingQueryBuilder) {\n+            verifyRoleQuery(((BoostingQueryBuilder) queryBuilder).negativeQuery());\n+            verifyRoleQuery(((BoostingQueryBuilder) queryBuilder).positiveQuery());\n+        }\n+    }\n+\n+    /**\n+     * Fall back validation that verifies that queries during rewrite don't use\n+     * the client to make remote calls. In the case of DLS this can cause a dead\n+     * lock if DLS is also applied on these remote calls. For example in the\n+     * case of terms query with lookup, this can cause recursive execution of\n+     * the DLS query until the get thread pool has been exhausted:\n+     * https://github.com/elastic/x-plugins/issues/3145\n+     */\n+    static void failIfQueryUsesClient(QueryBuilder queryBuilder, QueryRewriteContext original)\n+            throws IOException {\n+        QueryRewriteContext copy = new QueryRewriteContext(\n+                original.getXContentRegistry(), original.getWriteableRegistry(), null, original::nowInMillis);\n+        Rewriteable.rewrite(queryBuilder, copy);\n+        if (copy.hasAsyncActions()) {\n+            throw new IllegalStateException(\"role queries are not allowed to execute additional requests\");\n+        }\n+    }\n+\n+    /**\n+     * Create {@link DocumentPermissions} for given set of queries\n+     * @param queries set of queries\n+     * @return {@link DocumentPermissions}\n+     */\n+    public static DocumentPermissions filteredBy(Set<BytesReference> queries) {\n+        if (queries == null || queries.isEmpty()) {\n+            throw new IllegalArgumentException(\"null or empty queries not permitted\");\n+        }\n+        return new DocumentPermissions(queries);\n+    }\n+\n+    /**\n+     * Create {@link DocumentPermissions} with no restriction. The {@link #getQueries()}\n+     * will return {@code null} in this case and {@link #hasDocumentLevelPermissions()}\n+     * will be {@code false}\n+     * @return {@link DocumentPermissions}\n+     */\n+    public static DocumentPermissions allowAll() {\n+        return ALLOW_ALL;\n+    }\n+\n+    /**\n+     * Create a document permissions, where the permissions for {@code this} are\n+     * limited by the queries from other document permissions.<br>\n+     *\n+     * @param limitedByDocumentPermissions {@link DocumentPermissions} used to limit the document level access\n+     * @return instance of {@link DocumentPermissions}\n+     */\n+    public DocumentPermissions limitDocumentPermissions(\n+            DocumentPermissions limitedByDocumentPermissions) {\n+        assert limitedByQueries == null\n+                && limitedByDocumentPermissions.limitedByQueries == null : \"nested scoping for document permissions is not permitted\";\n+        if (queries == null && limitedByDocumentPermissions.queries == null) {\n+            return DocumentPermissions.allowAll();\n+        }\n+        return new DocumentPermissions(queries, limitedByDocumentPermissions.queries);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"DocumentPermissions [queries=\" + queries + \", scopedByQueries=\" + limitedByQueries + \"]\";\n+    }\n+\n+}"
        },
        {
            "sha": "f58367dc43886bf52e7d90854973180e5160a611",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/FieldPermissions.java",
            "status": "modified",
            "additions": 31,
            "deletions": 8,
            "changes": 39,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissions.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissions.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissions.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -90,13 +90,15 @@ public FieldPermissions(FieldPermissionsDefinition fieldPermissionsDefinition) {\n \n         long ramBytesUsed = BASE_FIELD_PERM_DEF_BYTES;\n \n-        for (FieldGrantExcludeGroup group : fieldPermissionsDefinition.getFieldGrantExcludeGroups()) {\n-            ramBytesUsed += BASE_FIELD_GROUP_BYTES + BASE_HASHSET_ENTRY_SIZE;\n-            if (group.getGrantedFields() != null) {\n-                ramBytesUsed += RamUsageEstimator.shallowSizeOf(group.getGrantedFields());\n-            }\n-            if (group.getExcludedFields() != null) {\n-                ramBytesUsed += RamUsageEstimator.shallowSizeOf(group.getExcludedFields());\n+        if (fieldPermissionsDefinition != null) {\n+            for (FieldGrantExcludeGroup group : fieldPermissionsDefinition.getFieldGrantExcludeGroups()) {\n+                ramBytesUsed += BASE_FIELD_GROUP_BYTES + BASE_HASHSET_ENTRY_SIZE;\n+                if (group.getGrantedFields() != null) {\n+                    ramBytesUsed += RamUsageEstimator.shallowSizeOf(group.getGrantedFields());\n+                }\n+                if (group.getExcludedFields() != null) {\n+                    ramBytesUsed += RamUsageEstimator.shallowSizeOf(group.getExcludedFields());\n+                }\n             }\n         }\n         ramBytesUsed += permittedFieldsAutomaton.ramBytesUsed();\n@@ -153,6 +155,28 @@ private static Automaton initializePermittedFieldsAutomaton(final String[] grant\n         return grantedFieldsAutomaton;\n     }\n \n+    /**\n+     * Returns a field permissions instance where it is limited by the given field permissions.<br>\n+     * If the current and the other field permissions have field level security then it takes\n+     * an intersection of permitted fields.<br>\n+     * If none of the permissions have field level security enabled, then returns permissions\n+     * instance where all fields are allowed.\n+     *\n+     * @param limitedBy {@link FieldPermissions} used to limit current field permissions\n+     * @return {@link FieldPermissions}\n+     */\n+    public FieldPermissions limitFieldPermissions(FieldPermissions limitedBy) {\n+        if (hasFieldLevelSecurity() && limitedBy != null && limitedBy.hasFieldLevelSecurity()) {\n+            Automaton permittedFieldsAutomaton = Automatons.intersectAndMinimize(getIncludeAutomaton(), limitedBy.getIncludeAutomaton());\n+            return new FieldPermissions(null, permittedFieldsAutomaton);\n+        } else if (limitedBy != null && limitedBy.hasFieldLevelSecurity()) {\n+            return new FieldPermissions(limitedBy.getFieldPermissionsDefinition(), limitedBy.getIncludeAutomaton());\n+        } else if (hasFieldLevelSecurity()) {\n+            return new FieldPermissions(getFieldPermissionsDefinition(), getIncludeAutomaton());\n+        }\n+        return FieldPermissions.DEFAULT;\n+    }\n+\n     /**\n      * Returns true if this field permission policy allows access to the field and false if not.\n      * fieldName can be a wildcard.\n@@ -178,7 +202,6 @@ public DirectoryReader filter(DirectoryReader reader) throws IOException {\n         return FieldSubsetReader.wrap(reader, permittedFieldsAutomaton);\n     }\n \n-    // for testing only\n     Automaton getIncludeAutomaton() {\n         return originalAutomaton;\n     }"
        },
        {
            "sha": "006c6661d2c4caffbc3fd84cee5c1db851e7a3c3",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/IndicesPermission.java",
            "status": "modified",
            "additions": 47,
            "deletions": 1,
            "changes": 48,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FIndicesPermission.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FIndicesPermission.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FIndicesPermission.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -7,6 +7,7 @@\n \n import org.apache.logging.log4j.LogManager;\n import org.apache.lucene.util.automaton.Automaton;\n+import org.apache.lucene.util.automaton.Operations;\n import org.apache.lucene.util.automaton.TooComplexToDeterminizeException;\n import org.elasticsearch.ElasticsearchSecurityException;\n import org.elasticsearch.cluster.metadata.AliasOrIndex;\n@@ -23,6 +24,7 @@\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n+import java.util.Collections;\n import java.util.HashMap;\n import java.util.HashSet;\n import java.util.List;\n@@ -123,6 +125,49 @@ public boolean check(String action) {\n         return false;\n     }\n \n+    /**\n+     * For given index patterns and index privileges determines allowed privileges and creates an instance of {@link ResourcePrivilegesMap}\n+     * holding a map of resource to {@link ResourcePrivileges} where resource is index pattern and the map of index privilege to whether it\n+     * is allowed or not.\n+     *\n+     * @param checkForIndexPatterns check permission grants for the set of index patterns\n+     * @param allowRestrictedIndices if {@code true} then checks permission grants even for restricted indices by index matching\n+     * @param checkForPrivileges check permission grants for the set of index privileges\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    public ResourcePrivilegesMap checkResourcePrivileges(Set<String> checkForIndexPatterns, boolean allowRestrictedIndices,\n+                                                         Set<String> checkForPrivileges) {\n+        final ResourcePrivilegesMap.Builder resourcePrivilegesMapBuilder = ResourcePrivilegesMap.builder();\n+        final Map<IndicesPermission.Group, Automaton> predicateCache = new HashMap<>();\n+        for (String forIndexPattern : checkForIndexPatterns) {\n+            final Automaton checkIndexAutomaton = IndicesPermission.Group.buildIndexMatcherAutomaton(allowRestrictedIndices,\n+                    forIndexPattern);\n+            Automaton allowedIndexPrivilegesAutomaton = null;\n+            for (Group group : groups) {\n+                final Automaton groupIndexAutomaton = predicateCache.computeIfAbsent(group,\n+                        g -> IndicesPermission.Group.buildIndexMatcherAutomaton(g.allowRestrictedIndices(), g.indices()));\n+                if (Operations.subsetOf(checkIndexAutomaton, groupIndexAutomaton)) {\n+                    if (allowedIndexPrivilegesAutomaton != null) {\n+                        allowedIndexPrivilegesAutomaton = Automatons\n+                                .unionAndMinimize(Arrays.asList(allowedIndexPrivilegesAutomaton, group.privilege().getAutomaton()));\n+                    } else {\n+                        allowedIndexPrivilegesAutomaton = group.privilege().getAutomaton();\n+                    }\n+                }\n+            }\n+            for (String privilege : checkForPrivileges) {\n+                IndexPrivilege indexPrivilege = IndexPrivilege.get(Collections.singleton(privilege));\n+                if (allowedIndexPrivilegesAutomaton != null\n+                        && Operations.subsetOf(indexPrivilege.getAutomaton(), allowedIndexPrivilegesAutomaton)) {\n+                    resourcePrivilegesMapBuilder.addResourcePrivilege(forIndexPattern, privilege, Boolean.TRUE);\n+                } else {\n+                    resourcePrivilegesMapBuilder.addResourcePrivilege(forIndexPattern, privilege, Boolean.FALSE);\n+                }\n+            }\n+        }\n+        return resourcePrivilegesMapBuilder.build();\n+    }\n+\n     public Automaton allowedActionsMatcher(String index) {\n         List<Automaton> automatonList = new ArrayList<>();\n         for (Group group : groups) {\n@@ -207,7 +252,8 @@ public Map<String, IndicesAccessControl.IndexAccessControl> authorize(String act\n             } else {\n                 fieldPermissions = FieldPermissions.DEFAULT;\n             }\n-            indexPermissions.put(index, new IndicesAccessControl.IndexAccessControl(entry.getValue(), fieldPermissions, roleQueries));\n+            indexPermissions.put(index, new IndicesAccessControl.IndexAccessControl(entry.getValue(), fieldPermissions,\n+                    (roleQueries != null) ? DocumentPermissions.filteredBy(roleQueries) : DocumentPermissions.allowAll()));\n         }\n         return unmodifiableMap(indexPermissions);\n     }"
        },
        {
            "sha": "809b95965340e2e3e88ff14ad0a6e9a8a084bf7f",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/LimitedRole.java",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRole.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRole.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRole.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,152 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.transport.TransportRequest;\n+import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n+\n+import java.util.Collection;\n+import java.util.Objects;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+/**\n+ * A {@link Role} limited by another role.<br>\n+ * The effective permissions returned on {@link #authorize(String, Set, MetaData, FieldPermissionsCache)} call would be limited by the\n+ * provided role.\n+ */\n+public final class LimitedRole extends Role {\n+    private final Role limitedBy;\n+\n+    LimitedRole(String[] names, ClusterPermission cluster, IndicesPermission indices, ApplicationPermission application,\n+            RunAsPermission runAs, Role limitedBy) {\n+        super(names, cluster, indices, application, runAs);\n+        assert limitedBy != null : \"limiting role is required\";\n+        this.limitedBy = limitedBy;\n+    }\n+\n+    public Role limitedBy() {\n+        return limitedBy;\n+    }\n+\n+    @Override\n+    public IndicesAccessControl authorize(String action, Set<String> requestedIndicesOrAliases, MetaData metaData,\n+                                          FieldPermissionsCache fieldPermissionsCache) {\n+        IndicesAccessControl indicesAccessControl = super.authorize(action, requestedIndicesOrAliases, metaData, fieldPermissionsCache);\n+        IndicesAccessControl limitedByIndicesAccessControl = limitedBy.authorize(action, requestedIndicesOrAliases, metaData,\n+                fieldPermissionsCache);\n+\n+        return indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+    }\n+\n+    /**\n+     * @return A predicate that will match all the indices that this role and the limited by role has the privilege for executing the given\n+     * action on.\n+     */\n+    @Override\n+    public Predicate<String> allowedIndicesMatcher(String action) {\n+        Predicate<String> predicate = indices().allowedIndicesMatcher(action);\n+        predicate = predicate.and(limitedBy.indices().allowedIndicesMatcher(action));\n+        return predicate;\n+    }\n+\n+    /**\n+     * Check if indices permissions allow for the given action, also checks whether the limited by role allows the given actions\n+     *\n+     * @param action indices action\n+     * @return {@code true} if action is allowed else returns {@code false}\n+     */\n+    @Override\n+    public boolean checkIndicesAction(String action) {\n+        return super.checkIndicesAction(action) && limitedBy.checkIndicesAction(action);\n+    }\n+\n+    /**\n+     * For given index patterns and index privileges determines allowed privileges and creates an instance of {@link ResourcePrivilegesMap}\n+     * holding a map of resource to {@link ResourcePrivileges} where resource is index pattern and the map of index privilege to whether it\n+     * is allowed or not.<br>\n+     * This one takes intersection of resource privileges with the resource privileges from the limited-by role.\n+     *\n+     * @param checkForIndexPatterns check permission grants for the set of index patterns\n+     * @param allowRestrictedIndices if {@code true} then checks permission grants even for restricted indices by index matching\n+     * @param checkForPrivileges check permission grants for the set of index privileges\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    @Override\n+    public ResourcePrivilegesMap checkIndicesPrivileges(Set<String> checkForIndexPatterns, boolean allowRestrictedIndices,\n+                                                        Set<String> checkForPrivileges) {\n+        ResourcePrivilegesMap resourcePrivilegesMap = super.indices().checkResourcePrivileges(checkForIndexPatterns, allowRestrictedIndices,\n+                checkForPrivileges);\n+        ResourcePrivilegesMap resourcePrivilegesMapForLimitedRole = limitedBy.indices().checkResourcePrivileges(checkForIndexPatterns,\n+                allowRestrictedIndices, checkForPrivileges);\n+        return ResourcePrivilegesMap.intersection(resourcePrivilegesMap, resourcePrivilegesMapForLimitedRole);\n+    }\n+\n+    /**\n+     * Check if cluster permissions allow for the given action, also checks whether the limited by role allows the given actions\n+     *\n+     * @param action cluster action\n+     * @param request {@link TransportRequest}\n+     * @return {@code true} if action is allowed else returns {@code false}\n+     */\n+    @Override\n+    public boolean checkClusterAction(String action, TransportRequest request) {\n+        return super.checkClusterAction(action, request) && limitedBy.checkClusterAction(action, request);\n+    }\n+\n+    /**\n+     * Check if cluster permissions grants the given cluster privilege, also checks whether the limited by role grants the given cluster\n+     * privilege\n+     *\n+     * @param clusterPrivilege cluster privilege\n+     * @return {@code true} if cluster privilege is allowed else returns {@code false}\n+     */\n+    @Override\n+    public boolean grants(ClusterPrivilege clusterPrivilege) {\n+        return super.grants(clusterPrivilege) && limitedBy.grants(clusterPrivilege);\n+    }\n+\n+    /**\n+     * For a given application, checks for the privileges for resources and returns an instance of {@link ResourcePrivilegesMap} holding a\n+     * map of resource to {@link ResourcePrivileges} where the resource is application resource and the map of application privilege to\n+     * whether it is allowed or not.<br>\n+     * This one takes intersection of resource privileges with the resource privileges from the limited-by role.\n+     *\n+     * @param applicationName checks privileges for the provided application name\n+     * @param checkForResources check permission grants for the set of resources\n+     * @param checkForPrivilegeNames check permission grants for the set of privilege names\n+     * @param storedPrivileges stored {@link ApplicationPrivilegeDescriptor} for an application against which the access checks are\n+     * performed\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    @Override\n+    public ResourcePrivilegesMap checkApplicationResourcePrivileges(final String applicationName, Set<String> checkForResources,\n+                                                                    Set<String> checkForPrivilegeNames,\n+                                                                    Collection<ApplicationPrivilegeDescriptor> storedPrivileges) {\n+        ResourcePrivilegesMap resourcePrivilegesMap = super.application().checkResourcePrivileges(applicationName, checkForResources,\n+                checkForPrivilegeNames, storedPrivileges);\n+        ResourcePrivilegesMap resourcePrivilegesMapForLimitedRole = limitedBy.application().checkResourcePrivileges(applicationName,\n+                checkForResources, checkForPrivilegeNames, storedPrivileges);\n+        return ResourcePrivilegesMap.intersection(resourcePrivilegesMap, resourcePrivilegesMapForLimitedRole);\n+    }\n+\n+    /**\n+     * Create a new role defined by given role and the limited role.\n+     *\n+     * @param fromRole existing role {@link Role}\n+     * @param limitedByRole restrict the newly formed role to the permissions defined by this limited {@link Role}\n+     * @return {@link LimitedRole}\n+     */\n+    public static LimitedRole createLimitedRole(Role fromRole, Role limitedByRole) {\n+        Objects.requireNonNull(limitedByRole, \"limited by role is required to create limited role\");\n+        return new LimitedRole(fromRole.names(), fromRole.cluster(), fromRole.indices(), fromRole.application(), fromRole.runAs(),\n+                limitedByRole);\n+    }\n+}"
        },
        {
            "sha": "3c64cc4afa8a1faff26f31e857445175a5f7832e",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/ResourcePrivileges.java",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivileges.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivileges.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivileges.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,93 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+\n+/**\n+ * A generic structure to encapsulate resource to privileges map.\n+ */\n+public final class ResourcePrivileges {\n+\n+    private final String resource;\n+    private final Map<String, Boolean> privileges;\n+\n+    ResourcePrivileges(String resource, Map<String, Boolean> privileges) {\n+        this.resource = Objects.requireNonNull(resource);\n+        this.privileges = Collections.unmodifiableMap(privileges);\n+    }\n+\n+    public String getResource() {\n+        return resource;\n+    }\n+\n+    public Map<String, Boolean> getPrivileges() {\n+        return privileges;\n+    }\n+\n+    public boolean isAllowed(String privilege) {\n+        return Boolean.TRUE.equals(privileges.get(privilege));\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return getClass().getSimpleName() + \"{\" + \"resource='\" + resource + '\\'' + \", privileges=\" + privileges + '}';\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result = resource.hashCode();\n+        result = 31 * result + privileges.hashCode();\n+        return result;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+        if (o == null || getClass() != o.getClass()) {\n+            return false;\n+        }\n+\n+        final ResourcePrivileges other = (ResourcePrivileges) o;\n+        return this.resource.equals(other.resource) && this.privileges.equals(other.privileges);\n+    }\n+\n+    public static Builder builder(String resource) {\n+        return new Builder(resource);\n+    }\n+\n+    public static final class Builder {\n+        private final String resource;\n+        private Map<String, Boolean> privileges = new HashMap<>();\n+\n+        private Builder(String resource) {\n+            this.resource = resource;\n+        }\n+\n+        public Builder addPrivilege(String privilege, Boolean allowed) {\n+            this.privileges.compute(privilege, (k, v) -> ((v == null) ? allowed : v && allowed));\n+            return this;\n+        }\n+\n+        public Builder addPrivileges(Map<String, Boolean> privileges) {\n+            for (Entry<String, Boolean> entry : privileges.entrySet()) {\n+                addPrivilege(entry.getKey(), entry.getValue());\n+            }\n+            return this;\n+        }\n+\n+        public ResourcePrivileges build() {\n+            return new ResourcePrivileges(resource, privileges);\n+        }\n+    }\n+}"
        },
        {
            "sha": "814a6ed29d39f387a4d51f81e27f33da2fc8e6cf",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/ResourcePrivilegesMap.java",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMap.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMap.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMap.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Objects;\n+import java.util.stream.Collectors;\n+\n+/**\n+ * A generic structure to encapsulate resources to {@link ResourcePrivileges}. Also keeps track of whether the resource privileges allow\n+ * permissions to all resources.\n+ */\n+public final class ResourcePrivilegesMap {\n+\n+    private final boolean allAllowed;\n+    private final Map<String, ResourcePrivileges> resourceToResourcePrivileges;\n+\n+    public ResourcePrivilegesMap(boolean allAllowed, Map<String, ResourcePrivileges> resToResPriv) {\n+        this.allAllowed = allAllowed;\n+        this.resourceToResourcePrivileges = Collections.unmodifiableMap(Objects.requireNonNull(resToResPriv));\n+    }\n+\n+    public boolean allAllowed() {\n+        return allAllowed;\n+    }\n+\n+    public Map<String, ResourcePrivileges> getResourceToResourcePrivileges() {\n+        return resourceToResourcePrivileges;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return Objects.hash(allAllowed, resourceToResourcePrivileges);\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+        if (this == obj) {\n+            return true;\n+        }\n+        if (obj == null) {\n+            return false;\n+        }\n+        if (getClass() != obj.getClass()) {\n+            return false;\n+        }\n+        final ResourcePrivilegesMap other = (ResourcePrivilegesMap) obj;\n+        return allAllowed == other.allAllowed && Objects.equals(resourceToResourcePrivileges, other.resourceToResourcePrivileges);\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"ResourcePrivilegesMap [allAllowed=\" + allAllowed + \", resourceToResourcePrivileges=\" + resourceToResourcePrivileges + \"]\";\n+    }\n+\n+    public static final class Builder {\n+        private boolean allowAll = true;\n+        private Map<String, ResourcePrivileges.Builder> resourceToResourcePrivilegesBuilder = new LinkedHashMap<>();\n+\n+        public Builder addResourcePrivilege(String resource, String privilege, Boolean allowed) {\n+            assert resource != null && privilege != null\n+                    && allowed != null : \"resource, privilege and permission(allowed or denied) are required\";\n+            ResourcePrivileges.Builder builder = resourceToResourcePrivilegesBuilder.computeIfAbsent(resource, ResourcePrivileges::builder);\n+            builder.addPrivilege(privilege, allowed);\n+            allowAll = allowAll && allowed;\n+            return this;\n+        }\n+\n+        public Builder addResourcePrivilege(String resource, Map<String, Boolean> privilegePermissions) {\n+            assert resource != null && privilegePermissions != null : \"resource, privilege permissions(allowed or denied) are required\";\n+            ResourcePrivileges.Builder builder = resourceToResourcePrivilegesBuilder.computeIfAbsent(resource, ResourcePrivileges::builder);\n+            builder.addPrivileges(privilegePermissions);\n+            allowAll = allowAll && privilegePermissions.values().stream().allMatch(b -> Boolean.TRUE.equals(b));\n+            return this;\n+        }\n+\n+        public Builder addResourcePrivilegesMap(ResourcePrivilegesMap resourcePrivilegesMap) {\n+            resourcePrivilegesMap.getResourceToResourcePrivileges().entrySet().stream()\n+                    .forEach(e -> this.addResourcePrivilege(e.getKey(), e.getValue().getPrivileges()));\n+            return this;\n+        }\n+\n+        public ResourcePrivilegesMap build() {\n+            Map<String, ResourcePrivileges> result = resourceToResourcePrivilegesBuilder.entrySet().stream()\n+                    .collect(Collectors.toMap(e -> e.getKey(), e -> e.getValue().build()));\n+            return new ResourcePrivilegesMap(allowAll, result);\n+        }\n+    }\n+\n+    public static Builder builder() {\n+        return new Builder();\n+    }\n+\n+    /**\n+     * Takes an intersection of resource privileges and returns a new instance of {@link ResourcePrivilegesMap}. If one of the resource\n+     * privileges map does not allow access to a resource then the resulting map would also not allow access.\n+     *\n+     * @param left an instance of {@link ResourcePrivilegesMap}\n+     * @param right an instance of {@link ResourcePrivilegesMap}\n+     * @return a new instance of {@link ResourcePrivilegesMap}, an intersection of resource privileges.\n+     */\n+    public static ResourcePrivilegesMap intersection(final ResourcePrivilegesMap left, final ResourcePrivilegesMap right) {\n+        Objects.requireNonNull(left);\n+        Objects.requireNonNull(right);\n+        final ResourcePrivilegesMap.Builder builder = ResourcePrivilegesMap.builder();\n+        for (Entry<String, ResourcePrivileges> leftResPrivsEntry : left.getResourceToResourcePrivileges().entrySet()) {\n+            final ResourcePrivileges leftResPrivs = leftResPrivsEntry.getValue();\n+            final ResourcePrivileges rightResPrivs = right.getResourceToResourcePrivileges().get(leftResPrivsEntry.getKey());\n+            builder.addResourcePrivilege(leftResPrivsEntry.getKey(), leftResPrivs.getPrivileges());\n+            builder.addResourcePrivilege(leftResPrivsEntry.getKey(), rightResPrivs.getPrivileges());\n+        }\n+        return builder.build();\n+    }\n+}"
        },
        {
            "sha": "570fa02a9b5ba18d91461f820c545bd6cb2d8e98",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/permission/Role.java",
            "status": "modified",
            "additions": 80,
            "deletions": 1,
            "changes": 81,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FRole.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FRole.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FRole.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -10,23 +10,27 @@\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.transport.TransportRequest;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.ConditionalClusterPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.IndexPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.Privilege;\n \n import java.util.ArrayList;\n import java.util.Arrays;\n+import java.util.Collection;\n import java.util.Collections;\n import java.util.List;\n import java.util.Map;\n import java.util.Objects;\n import java.util.Set;\n+import java.util.function.Predicate;\n \n-public final class Role {\n+public class Role {\n \n     public static final Role EMPTY = Role.builder(\"__empty\").build();\n \n@@ -44,6 +48,7 @@ public final class Role {\n         this.runAs = Objects.requireNonNull(runAs);\n     }\n \n+\n     public String[] names() {\n         return names;\n     }\n@@ -72,6 +77,79 @@ public static Builder builder(RoleDescriptor rd, FieldPermissionsCache fieldPerm\n         return new Builder(rd, fieldPermissionsCache);\n     }\n \n+    /**\n+     * @return A predicate that will match all the indices that this role\n+     * has the privilege for executing the given action on.\n+     */\n+    public Predicate<String> allowedIndicesMatcher(String action) {\n+        return indices().allowedIndicesMatcher(action);\n+    }\n+\n+    /**\n+     * Check if indices permissions allow for the given action\n+     *\n+     * @param action indices action\n+     * @return {@code true} if action is allowed else returns {@code false}\n+     */\n+    public boolean checkIndicesAction(String action) {\n+        return indices().check(action);\n+    }\n+\n+\n+    /**\n+     * For given index patterns and index privileges determines allowed privileges and creates an instance of {@link ResourcePrivilegesMap}\n+     * holding a map of resource to {@link ResourcePrivileges} where resource is index pattern and the map of index privilege to whether it\n+     * is allowed or not.\n+     *\n+     * @param checkForIndexPatterns check permission grants for the set of index patterns\n+     * @param allowRestrictedIndices if {@code true} then checks permission grants even for restricted indices by index matching\n+     * @param checkForPrivileges check permission grants for the set of index privileges\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    public ResourcePrivilegesMap checkIndicesPrivileges(Set<String> checkForIndexPatterns, boolean allowRestrictedIndices,\n+                                                                 Set<String> checkForPrivileges) {\n+        return indices().checkResourcePrivileges(checkForIndexPatterns, allowRestrictedIndices, checkForPrivileges);\n+    }\n+\n+    /**\n+     * Check if cluster permissions allow for the given action\n+     *\n+     * @param action cluster action\n+     * @param request {@link TransportRequest}\n+     * @return {@code true} if action is allowed else returns {@code false}\n+     */\n+    public boolean checkClusterAction(String action, TransportRequest request) {\n+        return cluster().check(action, request);\n+    }\n+\n+    /**\n+     * Check if cluster permissions grants the given cluster privilege\n+     *\n+     * @param clusterPrivilege cluster privilege\n+     * @return {@code true} if cluster privilege is allowed else returns {@code false}\n+     */\n+    public boolean grants(ClusterPrivilege clusterPrivilege) {\n+        return cluster().grants(clusterPrivilege);\n+    }\n+\n+    /**\n+     * For a given application, checks for the privileges for resources and returns an instance of {@link ResourcePrivilegesMap} holding a\n+     * map of resource to {@link ResourcePrivileges} where the resource is application resource and the map of application privilege to\n+     * whether it is allowed or not.\n+     *\n+     * @param applicationName checks privileges for the provided application name\n+     * @param checkForResources check permission grants for the set of resources\n+     * @param checkForPrivilegeNames check permission grants for the set of privilege names\n+     * @param storedPrivileges stored {@link ApplicationPrivilegeDescriptor} for an application against which the access checks are\n+     * performed\n+     * @return an instance of {@link ResourcePrivilegesMap}\n+     */\n+    public ResourcePrivilegesMap checkApplicationResourcePrivileges(final String applicationName, Set<String> checkForResources,\n+                                                                    Set<String> checkForPrivilegeNames,\n+                                                                    Collection<ApplicationPrivilegeDescriptor> storedPrivileges) {\n+        return application().checkResourcePrivileges(applicationName, checkForResources, checkForPrivilegeNames, storedPrivileges);\n+    }\n+\n     /**\n      * Returns whether at least one group encapsulated by this indices permissions is authorized to execute the\n      * specified action with the requested indices/aliases. At the same time if field and/or document level security\n@@ -204,4 +282,5 @@ static Tuple<ApplicationPrivilege, Set<String>> convertApplicationPrivilege(Stri\n             ), Sets.newHashSet(arp.getResources()));\n         }\n     }\n+\n }"
        },
        {
            "sha": "951c4acf10d0d8484c50660af1acfa6b5f886626",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/authz/support/SecurityQueryTemplateEvaluator.java",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluator.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluator.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluator.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,92 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.support;\n+\n+import org.elasticsearch.ElasticsearchParseException;\n+import org.elasticsearch.common.xcontent.LoggingDeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.script.TemplateScript;\n+import org.elasticsearch.xpack.core.security.user.User;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Helper class that helps to evaluate the query source template.\n+ */\n+public final class SecurityQueryTemplateEvaluator {\n+\n+    private SecurityQueryTemplateEvaluator() {\n+    }\n+\n+    /**\n+     * If the query source is a template, then parses the script, compiles the\n+     * script with user details parameters and then executes it to return the\n+     * query string.\n+     * <p>\n+     * Note: This method always enforces \"mustache\" script language for the\n+     * template.\n+     *\n+     * @param querySource query string template to be evaluated.\n+     * @param scriptService {@link ScriptService}\n+     * @param user {@link User} details for user defined parameters in the\n+     * script.\n+     * @return resultant query string after compiling and executing the script.\n+     * If the source does not contain template then it will return the query\n+     * source without any modifications.\n+     * @throws IOException thrown when there is any error parsing the query\n+     * string.\n+     */\n+    public static String evaluateTemplate(final String querySource, final ScriptService scriptService, final User user) throws IOException {\n+        // EMPTY is safe here because we never use namedObject\n+        try (XContentParser parser = XContentFactory.xContent(querySource).createParser(NamedXContentRegistry.EMPTY,\n+                LoggingDeprecationHandler.INSTANCE, querySource)) {\n+            XContentParser.Token token = parser.nextToken();\n+            if (token != XContentParser.Token.START_OBJECT) {\n+                throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n+            }\n+            token = parser.nextToken();\n+            if (token != XContentParser.Token.FIELD_NAME) {\n+                throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n+            }\n+            if (\"template\".equals(parser.currentName())) {\n+                token = parser.nextToken();\n+                if (token != XContentParser.Token.START_OBJECT) {\n+                    throw new ElasticsearchParseException(\"Unexpected token [\" + token + \"]\");\n+                }\n+                Script script = Script.parse(parser);\n+                // Add the user details to the params\n+                Map<String, Object> params = new HashMap<>();\n+                if (script.getParams() != null) {\n+                    params.putAll(script.getParams());\n+                }\n+                Map<String, Object> userModel = new HashMap<>();\n+                userModel.put(\"username\", user.principal());\n+                userModel.put(\"full_name\", user.fullName());\n+                userModel.put(\"email\", user.email());\n+                userModel.put(\"roles\", Arrays.asList(user.roles()));\n+                userModel.put(\"metadata\", Collections.unmodifiableMap(user.metadata()));\n+                params.put(\"_user\", userModel);\n+                // Always enforce mustache script lang:\n+                script = new Script(script.getType(), script.getType() == ScriptType.STORED ? null : \"mustache\", script.getIdOrCode(),\n+                        script.getOptions(), params);\n+                TemplateScript compiledTemplate = scriptService.compile(script, TemplateScript.CONTEXT).newInstance(script.getParams());\n+                return compiledTemplate.execute();\n+            } else {\n+                return querySource;\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "4619035d0daaf75ca5a19be320c766b7ca53a509",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/client/SecurityClient.java",
            "status": "modified",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fclient%2FSecurityClient.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fclient%2FSecurityClient.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fclient%2FSecurityClient.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -10,6 +10,16 @@\n import org.elasticsearch.client.ElasticsearchClient;\n import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesAction;\n import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesRequestBuilder;\n import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesAction;\n@@ -334,6 +344,27 @@ public void invalidateToken(InvalidateTokenRequest request, ActionListener<Inval\n         client.execute(InvalidateTokenAction.INSTANCE, request, listener);\n     }\n \n+    /* -- Api Keys -- */\n+    public CreateApiKeyRequestBuilder prepareCreateApiKey() {\n+        return new CreateApiKeyRequestBuilder(client);\n+    }\n+\n+    public CreateApiKeyRequestBuilder prepareCreateApiKey(BytesReference bytesReference, XContentType xContentType) throws IOException {\n+        return new CreateApiKeyRequestBuilder(client).source(bytesReference, xContentType);\n+    }\n+\n+    public void createApiKey(CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        client.execute(CreateApiKeyAction.INSTANCE, request, listener);\n+    }\n+\n+    public void invalidateApiKey(InvalidateApiKeyRequest request, ActionListener<InvalidateApiKeyResponse> listener) {\n+        client.execute(InvalidateApiKeyAction.INSTANCE, request, listener);\n+    }\n+\n+    public void getApiKey(GetApiKeyRequest request, ActionListener<GetApiKeyResponse> listener) {\n+        client.execute(GetApiKeyAction.INSTANCE, request, listener);\n+    }\n+\n     public SamlAuthenticateRequestBuilder prepareSamlAuthenticate(byte[] xmlContent, List<String> validIds) {\n         final SamlAuthenticateRequestBuilder builder = new SamlAuthenticateRequestBuilder(client);\n         builder.saml(xmlContent);"
        },
        {
            "sha": "7e6fd7ca4628350408aaa1d940a5257859ac4f71",
            "filename": "x-pack/plugin/core/src/main/java/org/elasticsearch/xpack/core/security/support/Automatons.java",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fsupport%2FAutomatons.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fsupport%2FAutomatons.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fsupport%2FAutomatons.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -26,6 +26,7 @@\n import static org.apache.lucene.util.automaton.MinimizationOperations.minimize;\n import static org.apache.lucene.util.automaton.Operations.DEFAULT_MAX_DETERMINIZED_STATES;\n import static org.apache.lucene.util.automaton.Operations.concatenate;\n+import static org.apache.lucene.util.automaton.Operations.intersection;\n import static org.apache.lucene.util.automaton.Operations.minus;\n import static org.apache.lucene.util.automaton.Operations.union;\n import static org.elasticsearch.common.Strings.collectionToDelimitedString;\n@@ -173,6 +174,11 @@ public static Automaton minusAndMinimize(Automaton a1, Automaton a2) {\n         return minimize(res, maxDeterminizedStates);\n     }\n \n+    public static Automaton intersectAndMinimize(Automaton a1, Automaton a2) {\n+        Automaton res = intersection(a1, a2);\n+        return minimize(res, maxDeterminizedStates);\n+    }\n+\n     public static Predicate<String> predicate(String... patterns) {\n         return predicate(Arrays.asList(patterns));\n     }"
        },
        {
            "sha": "183ffff4ea53455cee801c4d646eb33e2f2facb1",
            "filename": "x-pack/plugin/core/src/main/resources/security-index-template.json",
            "status": "modified",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fresources%2Fsecurity-index-template.json",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fresources%2Fsecurity-index-template.json",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Fmain%2Fresources%2Fsecurity-index-template.json?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -152,6 +152,40 @@\n           \"type\" : \"date\",\n           \"format\" : \"epoch_millis\"\n         },\n+        \"api_key_hash\" : {\n+          \"type\" : \"keyword\",\n+          \"index\": false,\n+          \"doc_values\": false\n+        },\n+        \"api_key_invalidated\" : {\n+          \"type\" : \"boolean\"\n+        },\n+        \"role_descriptors\" : {\n+          \"type\" : \"object\",\n+          \"enabled\": false\n+        },\n+        \"limited_by_role_descriptors\" : {\n+          \"type\" : \"object\",\n+          \"enabled\": false\n+        },\n+        \"version\" : {\n+          \"type\" : \"integer\"\n+        },\n+        \"creator\" : {\n+          \"type\" : \"object\",\n+          \"properties\" : {\n+            \"principal\" : {\n+              \"type\": \"keyword\"\n+            },\n+            \"metadata\" : {\n+              \"type\" : \"object\",\n+              \"dynamic\" : true\n+            },\n+            \"realm\" : {\n+              \"type\" : \"keyword\"\n+            }\n+          }\n+        },\n         \"rules\" : {\n           \"type\" : \"object\",\n           \"dynamic\" : true"
        },
        {
            "sha": "fb4f87089e8e7b0034d3420ffa603b22c939b125",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyRequestBuilderTests.java",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilderTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilderTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestBuilderTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor.IndicesPrivileges;\n+\n+import java.io.IOException;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.arrayContainingInAnyOrder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+\n+public class CreateApiKeyRequestBuilderTests extends ESTestCase {\n+\n+    public void testParserAndCreateApiRequestBuilder() throws IOException {\n+        boolean withExpiration = randomBoolean();\n+        final String json = \"{ \\\"name\\\" : \\\"my-api-key\\\", \"\n+                + ((withExpiration) ? \" \\\"expiration\\\": \\\"1d\\\", \" : \"\")\n+                +\" \\\"role_descriptors\\\": { \\\"role-a\\\": {\\\"cluster\\\":[\\\"a-1\\\", \\\"a-2\\\"],\"\n+                + \" \\\"index\\\": [{\\\"names\\\": [\\\"indx-a\\\"], \\\"privileges\\\": [\\\"read\\\"] }] }, \"\n+                + \" \\\"role-b\\\": {\\\"cluster\\\":[\\\"b\\\"],\"\n+                + \" \\\"index\\\": [{\\\"names\\\": [\\\"indx-b\\\"], \\\"privileges\\\": [\\\"read\\\"] }] } \"\n+                + \"} }\";\n+        final BytesArray source = new BytesArray(json);\n+        final NodeClient mockClient = mock(NodeClient.class);\n+        final CreateApiKeyRequest request = new CreateApiKeyRequestBuilder(mockClient).source(source, XContentType.JSON).request();\n+        final List<RoleDescriptor> actualRoleDescriptors = request.getRoleDescriptors();\n+        assertThat(request.getName(), equalTo(\"my-api-key\"));\n+        assertThat(actualRoleDescriptors.size(), is(2));\n+        for (RoleDescriptor rd : actualRoleDescriptors) {\n+            String[] clusters = null;\n+            IndicesPrivileges indicesPrivileges = null;\n+            if (rd.getName().equals(\"role-a\")) {\n+                clusters = new String[] { \"a-1\", \"a-2\" };\n+                indicesPrivileges = RoleDescriptor.IndicesPrivileges.builder().indices(\"indx-a\").privileges(\"read\").build();\n+            } else if (rd.getName().equals(\"role-b\")){\n+                clusters = new String[] { \"b\" };\n+                indicesPrivileges = RoleDescriptor.IndicesPrivileges.builder().indices(\"indx-b\").privileges(\"read\").build();\n+            } else {\n+                fail(\"unexpected role name\");\n+            }\n+            assertThat(rd.getClusterPrivileges(), arrayContainingInAnyOrder(clusters));\n+            assertThat(rd.getIndicesPrivileges(),\n+                    arrayContainingInAnyOrder(indicesPrivileges));\n+        }\n+        if (withExpiration) {\n+            assertThat(request.getExpiration(), equalTo(TimeValue.parseTimeValue(\"1d\", \"expiration\")));\n+        }\n+    }\n+}"
        },
        {
            "sha": "654d56b42130eba59aa1b16561e3267de6ccb3a9",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyRequestTests.java",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,113 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.is;\n+\n+public class CreateApiKeyRequestTests extends ESTestCase {\n+\n+    public void testNameValidation() {\n+        final String name = randomAlphaOfLengthBetween(1, 256);\n+        CreateApiKeyRequest request = new CreateApiKeyRequest();\n+\n+        ActionRequestValidationException ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name is required\"));\n+\n+        request.setName(name);\n+        ve = request.validate();\n+        assertNull(ve);\n+\n+        IllegalArgumentException e = expectThrows(IllegalArgumentException.class, () -> request.setName(\"\"));\n+        assertThat(e.getMessage(), containsString(\"name must not be null or empty\"));\n+\n+        e = expectThrows(IllegalArgumentException.class, () -> request.setName(null));\n+        assertThat(e.getMessage(), containsString(\"name must not be null or empty\"));\n+\n+        request.setName(randomAlphaOfLength(257));\n+        ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name may not be more than 256 characters long\"));\n+\n+        request.setName(\" leading space\");\n+        ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name may not begin or end with whitespace\"));\n+\n+        request.setName(\"trailing space \");\n+        ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name may not begin or end with whitespace\"));\n+\n+        request.setName(\" leading and trailing space \");\n+        ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name may not begin or end with whitespace\"));\n+\n+        request.setName(\"inner space\");\n+        ve = request.validate();\n+        assertNull(ve);\n+\n+        request.setName(\"_foo\");\n+        ve = request.validate();\n+        assertNotNull(ve);\n+        assertThat(ve.validationErrors().size(), is(1));\n+        assertThat(ve.validationErrors().get(0), containsString(\"name may not begin with an underscore\"));\n+    }\n+\n+    public void testSerialization() throws IOException {\n+        final String name = randomAlphaOfLengthBetween(1, 256);\n+        final TimeValue expiration = randomBoolean() ? null :\n+            TimeValue.parseTimeValue(randomTimeValue(), \"test serialization of create api key\");\n+        final WriteRequest.RefreshPolicy refreshPolicy = randomFrom(WriteRequest.RefreshPolicy.values());\n+        final int numDescriptors = randomIntBetween(0, 4);\n+        final List<RoleDescriptor> descriptorList = new ArrayList<>();\n+        for (int i = 0; i < numDescriptors; i++) {\n+            descriptorList.add(new RoleDescriptor(\"role_\" + i, new String[] { \"all\" }, null, null));\n+        }\n+\n+        final CreateApiKeyRequest request = new CreateApiKeyRequest();\n+        request.setName(name);\n+        request.setExpiration(expiration);\n+\n+        if (refreshPolicy != request.getRefreshPolicy() || randomBoolean()) {\n+            request.setRefreshPolicy(refreshPolicy);\n+        }\n+        if (descriptorList.isEmpty() == false || randomBoolean()) {\n+            request.setRoleDescriptors(descriptorList);\n+        }\n+\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            request.writeTo(out);\n+            try (StreamInput in = out.bytes().streamInput()) {\n+                final CreateApiKeyRequest serialized = new CreateApiKeyRequest(in);\n+                assertEquals(name, serialized.getName());\n+                assertEquals(expiration, serialized.getExpiration());\n+                assertEquals(refreshPolicy, serialized.getRefreshPolicy());\n+                assertEquals(descriptorList, serialized.getRoleDescriptors());\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "20ff4bc251d15580e981b1fcd6f6c092b110c51e",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/CreateApiKeyResponseTests.java",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FCreateApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.test.AbstractXContentTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class CreateApiKeyResponseTests extends AbstractXContentTestCase<CreateApiKeyResponse> {\n+\n+    @Override\n+    protected CreateApiKeyResponse doParseInstance(XContentParser parser) throws IOException {\n+        return CreateApiKeyResponse.fromXContent(parser);\n+    }\n+\n+    @Override\n+    protected CreateApiKeyResponse createTestInstance() {\n+        final String name = randomAlphaOfLengthBetween(1, 256);\n+        final SecureString key = new SecureString(UUIDs.randomBase64UUID().toCharArray());\n+        final Instant expiration = randomBoolean() ? Instant.now().plus(7L, ChronoUnit.DAYS) : null;\n+        final String id = randomAlphaOfLength(100);\n+        return new CreateApiKeyResponse(name, id, key, expiration);\n+    }\n+\n+    @Override\n+    protected boolean supportsUnknownFields() {\n+        return false;\n+    }\n+\n+    public void testSerialization() throws IOException {\n+        final CreateApiKeyResponse response = createTestInstance();\n+        try (BytesStreamOutput out = new BytesStreamOutput()) {\n+            response.writeTo(out);\n+             try (StreamInput in = out.bytes().streamInput()) {\n+                CreateApiKeyResponse serialized = new CreateApiKeyResponse(in);\n+                assertThat(serialized, equalTo(response));\n+            }\n+        }\n+    }\n+\n+    public void testEqualsHashCode() {\n+        CreateApiKeyResponse createApiKeyResponse = createTestInstance();\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyResponse, (original) -> {\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), original.getExpiration());\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(createApiKeyResponse, (original) -> {\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), original.getExpiration());\n+        }, CreateApiKeyResponseTests::mutateTestItem);\n+    }\n+\n+    private static CreateApiKeyResponse mutateTestItem(CreateApiKeyResponse original) {\n+        switch (randomIntBetween(0, 3)) {\n+        case 0:\n+            return new CreateApiKeyResponse(randomAlphaOfLength(5), original.getId(), original.getKey(), original.getExpiration());\n+        case 1:\n+            return new CreateApiKeyResponse(original.getName(), randomAlphaOfLength(5), original.getKey(), original.getExpiration());\n+        case 2:\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), new SecureString(UUIDs.randomBase64UUID().toCharArray()),\n+                    original.getExpiration());\n+        case 3:\n+            return new CreateApiKeyResponse(original.getName(), original.getId(), original.getKey(), Instant.now());\n+        default:\n+            return new CreateApiKeyResponse(randomAlphaOfLength(5), original.getId(), original.getKey(), original.getExpiration());\n+        }\n+    }\n+}"
        },
        {
            "sha": "27be0d88eb82c1d4d2256feb2c83c3e813c64812",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/GetApiKeyRequestTests.java",
            "status": "added",
            "additions": 103,
            "deletions": 0,
            "changes": 103,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,103 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.io.stream.InputStreamStreamInput;\n+import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+\n+public class GetApiKeyRequestTests extends ESTestCase {\n+\n+    public void testRequestValidation() {\n+        GetApiKeyRequest request = GetApiKeyRequest.usingApiKeyId(randomAlphaOfLength(5));\n+        ActionRequestValidationException ve = request.validate();\n+        assertNull(ve);\n+        request = GetApiKeyRequest.usingApiKeyName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = GetApiKeyRequest.usingRealmName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = GetApiKeyRequest.usingUserName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = GetApiKeyRequest.usingRealmAndUserName(randomAlphaOfLength(5), randomAlphaOfLength(7));\n+        ve = request.validate();\n+        assertNull(ve);\n+    }\n+\n+    public void testRequestValidationFailureScenarios() throws IOException {\n+        class Dummy extends ActionRequest {\n+            String realm;\n+            String user;\n+            String apiKeyId;\n+            String apiKeyName;\n+\n+            Dummy(String[] a) {\n+                realm = a[0];\n+                user = a[1];\n+                apiKeyId = a[2];\n+                apiKeyName = a[3];\n+            }\n+\n+            @Override\n+            public ActionRequestValidationException validate() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void writeTo(StreamOutput out) throws IOException {\n+                super.writeTo(out);\n+                out.writeOptionalString(realm);\n+                out.writeOptionalString(user);\n+                out.writeOptionalString(apiKeyId);\n+                out.writeOptionalString(apiKeyName);\n+            }\n+        }\n+\n+        String[][] inputs = new String[][] {\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }),\n+                        randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), \"user\", \"api-kid\", \"api-kname\" },\n+                { \"realm\", randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" },\n+                { \"realm\", \"user\", \"api-kid\", randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" } };\n+        String[][] expectedErrorMessages = new String[][] { { \"One of [api key id, api key name, username, realm name] must be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        \"only one of [api key id, api key name] can be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        \"only one of [api key id, api key name] can be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\" },\n+                { \"only one of [api key id, api key name] can be specified\" } };\n+\n+        for (int caseNo = 0; caseNo < inputs.length; caseNo++) {\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                    OutputStreamStreamOutput osso = new OutputStreamStreamOutput(bos)) {\n+                Dummy d = new Dummy(inputs[caseNo]);\n+                d.writeTo(osso);\n+\n+                ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+                InputStreamStreamInput issi = new InputStreamStreamInput(bis);\n+\n+                GetApiKeyRequest request = new GetApiKeyRequest(issi);\n+                ActionRequestValidationException ve = request.validate();\n+                assertNotNull(ve);\n+                assertEquals(expectedErrorMessages[caseNo].length, ve.validationErrors().size());\n+                assertThat(ve.validationErrors(), containsInAnyOrder(expectedErrorMessages[caseNo]));\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "c278c135edaf8b4fb77fe3fdde72b994eb59c656",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/GetApiKeyResponseTests.java",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FGetApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,64 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.time.Instant;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class GetApiKeyResponseTests extends ESTestCase {\n+\n+    public void testSerialization() throws IOException {\n+        boolean withExpiration = randomBoolean();\n+        ApiKey apiKeyInfo = createApiKeyInfo(randomAlphaOfLength(4), randomAlphaOfLength(5), Instant.now(),\n+                (withExpiration) ? Instant.now() : null, false, randomAlphaOfLength(4), randomAlphaOfLength(5));\n+        GetApiKeyResponse response = new GetApiKeyResponse(Collections.singletonList(apiKeyInfo));\n+        try (BytesStreamOutput output = new BytesStreamOutput()) {\n+            response.writeTo(output);\n+            try (StreamInput input = output.bytes().streamInput()) {\n+                GetApiKeyResponse serialized = new GetApiKeyResponse(input);\n+                assertThat(serialized.getApiKeyInfos(), equalTo(response.getApiKeyInfos()));\n+            }\n+        }\n+    }\n+\n+    public void testToXContent() throws IOException {\n+        ApiKey apiKeyInfo1 = createApiKeyInfo(\"name1\", \"id-1\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), false,\n+                \"user-a\", \"realm-x\");\n+        ApiKey apiKeyInfo2 = createApiKeyInfo(\"name2\", \"id-2\", Instant.ofEpochMilli(100000L), Instant.ofEpochMilli(10000000L), true,\n+                \"user-b\", \"realm-y\");\n+        GetApiKeyResponse response = new GetApiKeyResponse(Arrays.asList(apiKeyInfo1, apiKeyInfo2));\n+        XContentBuilder builder = XContentFactory.jsonBuilder();\n+        response.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+        assertThat(Strings.toString(builder), equalTo(\n+                \"{\"\n+                + \"\\\"api_keys\\\":[\"\n+                + \"{\\\"id\\\":\\\"id-1\\\",\\\"name\\\":\\\"name1\\\",\\\"creation\\\":100000,\\\"expiration\\\":10000000,\\\"invalidated\\\":false,\"\n+                + \"\\\"username\\\":\\\"user-a\\\",\\\"realm\\\":\\\"realm-x\\\"},\"\n+                + \"{\\\"id\\\":\\\"id-2\\\",\\\"name\\\":\\\"name2\\\",\\\"creation\\\":100000,\\\"expiration\\\":10000000,\\\"invalidated\\\":true,\"\n+                + \"\\\"username\\\":\\\"user-b\\\",\\\"realm\\\":\\\"realm-y\\\"}\"\n+                + \"]\"\n+                + \"}\"));\n+    }\n+\n+    private ApiKey createApiKeyInfo(String name, String id, Instant creation, Instant expiration, boolean invalidated, String username,\n+                                        String realm) {\n+        return new ApiKey(name, id, creation, expiration, invalidated, username, realm);\n+    }\n+}\n+"
        },
        {
            "sha": "3d7fd9023428660da71da6f098e8d05f4a62f770",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/InvalidateApiKeyRequestTests.java",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequestTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequestTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyRequestTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,104 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.common.io.stream.InputStreamStreamInput;\n+import org.elasticsearch.common.io.stream.OutputStreamStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamOutput;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+\n+public class InvalidateApiKeyRequestTests extends ESTestCase {\n+\n+    public void testRequestValidation() {\n+        InvalidateApiKeyRequest request = InvalidateApiKeyRequest.usingApiKeyId(randomAlphaOfLength(5));\n+        ActionRequestValidationException ve = request.validate();\n+        assertNull(ve);\n+        request = InvalidateApiKeyRequest.usingApiKeyName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = InvalidateApiKeyRequest.usingRealmName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = InvalidateApiKeyRequest.usingUserName(randomAlphaOfLength(5));\n+        ve = request.validate();\n+        assertNull(ve);\n+        request = InvalidateApiKeyRequest.usingRealmAndUserName(randomAlphaOfLength(5), randomAlphaOfLength(7));\n+        ve = request.validate();\n+        assertNull(ve);\n+    }\n+\n+    public void testRequestValidationFailureScenarios() throws IOException {\n+        class Dummy extends ActionRequest {\n+            String realm;\n+            String user;\n+            String apiKeyId;\n+            String apiKeyName;\n+\n+            Dummy(String[] a) {\n+                realm = a[0];\n+                user = a[1];\n+                apiKeyId = a[2];\n+                apiKeyName = a[3];\n+            }\n+\n+            @Override\n+            public ActionRequestValidationException validate() {\n+                return null;\n+            }\n+\n+            @Override\n+            public void writeTo(StreamOutput out) throws IOException {\n+                super.writeTo(out);\n+                out.writeOptionalString(realm);\n+                out.writeOptionalString(user);\n+                out.writeOptionalString(apiKeyId);\n+                out.writeOptionalString(apiKeyName);\n+            }\n+        }\n+\n+        String[][] inputs = new String[][] {\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }),\n+                        randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), \"user\", \"api-kid\", \"api-kname\" },\n+                { \"realm\", randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" },\n+                { \"realm\", \"user\", \"api-kid\", randomFrom(new String[] { null, \"\" }) },\n+                { randomFrom(new String[] { null, \"\" }), randomFrom(new String[] { null, \"\" }), \"api-kid\", \"api-kname\" } };\n+        String[][] expectedErrorMessages = new String[][] { { \"One of [api key id, api key name, username, realm name] must be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        \"only one of [api key id, api key name] can be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\",\n+                        \"only one of [api key id, api key name] can be specified\" },\n+                { \"username or realm name must not be specified when the api key id or api key name is specified\" },\n+                { \"only one of [api key id, api key name] can be specified\" } };\n+\n+\n+        for (int caseNo = 0; caseNo < inputs.length; caseNo++) {\n+            try (ByteArrayOutputStream bos = new ByteArrayOutputStream();\n+                    OutputStreamStreamOutput osso = new OutputStreamStreamOutput(bos)) {\n+                Dummy d = new Dummy(inputs[caseNo]);\n+                d.writeTo(osso);\n+\n+                ByteArrayInputStream bis = new ByteArrayInputStream(bos.toByteArray());\n+                InputStreamStreamInput issi = new InputStreamStreamInput(bis);\n+\n+                InvalidateApiKeyRequest request = new InvalidateApiKeyRequest(issi);\n+                ActionRequestValidationException ve = request.validate();\n+                assertNotNull(ve);\n+                assertEquals(expectedErrorMessages[caseNo].length, ve.validationErrors().size());\n+                assertThat(ve.validationErrors(), containsInAnyOrder(expectedErrorMessages[caseNo]));\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "f4606a4f20f1b0ad9d4960dded6c5a0c16df7299",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/InvalidateApiKeyResponseTests.java",
            "status": "added",
            "additions": 88,
            "deletions": 0,
            "changes": 88,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2FInvalidateApiKeyResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,88 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.action;\n+\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.io.stream.BytesStreamOutput;\n+import org.elasticsearch.common.io.stream.StreamInput;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+\n+public class InvalidateApiKeyResponseTests extends ESTestCase {\n+\n+    public void testSerialization() throws IOException {\n+        InvalidateApiKeyResponse response = new InvalidateApiKeyResponse(Arrays.asList(\"api-key-id-1\"),\n+                Arrays.asList(\"api-key-id-2\", \"api-key-id-3\"),\n+                Arrays.asList(new ElasticsearchException(\"error1\"),\n+                        new ElasticsearchException(\"error2\")));\n+        try (BytesStreamOutput output = new BytesStreamOutput()) {\n+            response.writeTo(output);\n+            try (StreamInput input = output.bytes().streamInput()) {\n+                InvalidateApiKeyResponse serialized = new InvalidateApiKeyResponse(input);\n+                assertThat(serialized.getInvalidatedApiKeys(), equalTo(response.getInvalidatedApiKeys()));\n+                assertThat(serialized.getPreviouslyInvalidatedApiKeys(),\n+                    equalTo(response.getPreviouslyInvalidatedApiKeys()));\n+                assertThat(serialized.getErrors().size(), equalTo(response.getErrors().size()));\n+                assertThat(serialized.getErrors().get(0).toString(), containsString(\"error1\"));\n+                assertThat(serialized.getErrors().get(1).toString(), containsString(\"error2\"));\n+            }\n+        }\n+\n+        response = new InvalidateApiKeyResponse(Arrays.asList(generateRandomStringArray(20, 15, false)),\n+            Arrays.asList(generateRandomStringArray(20, 15, false)),\n+            Collections.emptyList());\n+        try (BytesStreamOutput output = new BytesStreamOutput()) {\n+            response.writeTo(output);\n+            try (StreamInput input = output.bytes().streamInput()) {\n+                InvalidateApiKeyResponse serialized = new InvalidateApiKeyResponse(input);\n+                assertThat(serialized.getInvalidatedApiKeys(), equalTo(response.getInvalidatedApiKeys()));\n+                assertThat(serialized.getPreviouslyInvalidatedApiKeys(),\n+                    equalTo(response.getPreviouslyInvalidatedApiKeys()));\n+                assertThat(serialized.getErrors().size(), equalTo(response.getErrors().size()));\n+            }\n+        }\n+    }\n+\n+    public void testToXContent() throws IOException {\n+        InvalidateApiKeyResponse response = new InvalidateApiKeyResponse(Arrays.asList(\"api-key-id-1\"),\n+                Arrays.asList(\"api-key-id-2\", \"api-key-id-3\"),\n+                Arrays.asList(new ElasticsearchException(\"error1\", new IllegalArgumentException(\"msg - 1\")),\n+                        new ElasticsearchException(\"error2\", new IllegalArgumentException(\"msg - 2\"))));\n+        XContentBuilder builder = XContentFactory.jsonBuilder();\n+        response.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+        assertThat(Strings.toString(builder),\n+            equalTo(\"{\" +\n+                \"\\\"invalidated_api_keys\\\":[\\\"api-key-id-1\\\"],\" +\n+                \"\\\"previously_invalidated_api_keys\\\":[\\\"api-key-id-2\\\",\\\"api-key-id-3\\\"],\" +\n+                \"\\\"error_count\\\":2,\" +\n+                \"\\\"error_details\\\":[\" +\n+                \"{\\\"type\\\":\\\"exception\\\",\" +\n+                \"\\\"reason\\\":\\\"error1\\\",\" +\n+                \"\\\"caused_by\\\":{\" +\n+                \"\\\"type\\\":\\\"illegal_argument_exception\\\",\" +\n+                \"\\\"reason\\\":\\\"msg - 1\\\"}\" +\n+                \"},\" +\n+                \"{\\\"type\\\":\\\"exception\\\",\" +\n+                \"\\\"reason\\\":\\\"error2\\\",\" +\n+                \"\\\"caused_by\\\":\" +\n+                \"{\\\"type\\\":\\\"illegal_argument_exception\\\",\" +\n+                \"\\\"reason\\\":\\\"msg - 2\\\"}\" +\n+                \"}\" +\n+                \"]\" +\n+                \"}\"));\n+    }\n+}"
        },
        {
            "sha": "a605917f01c2d2ec5742406989a2eb6d0a08aeca",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/action/user/HasPrivilegesResponseTests.java",
            "status": "modified",
            "additions": 19,
            "deletions": 17,
            "changes": 36,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponseTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponseTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Faction%2Fuser%2FHasPrivilegesResponseTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -18,6 +18,7 @@\n import org.elasticsearch.common.xcontent.XContentType;\n import org.elasticsearch.protocol.AbstractHlrcStreamableXContentTestCase;\n import org.elasticsearch.test.VersionUtils;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n import org.hamcrest.Matchers;\n \n import java.io.IOException;\n@@ -59,16 +60,17 @@ public void testSerializationV63() throws IOException {\n     }\n \n     public void testToXContent() throws Exception {\n-        final HasPrivilegesResponse response = new HasPrivilegesResponse(\"daredevil\", false,\n-            Collections.singletonMap(\"manage\", true),\n-            Arrays.asList(\n-                new HasPrivilegesResponse.ResourcePrivileges(\"staff\",\n-                    MapBuilder.<String, Boolean>newMapBuilder(new LinkedHashMap<>())\n-                        .put(\"read\", true).put(\"index\", true).put(\"delete\", false).put(\"manage\", false).map()),\n-                new HasPrivilegesResponse.ResourcePrivileges(\"customers\",\n-                    MapBuilder.<String, Boolean>newMapBuilder(new LinkedHashMap<>())\n-                        .put(\"read\", true).put(\"index\", true).put(\"delete\", true).put(\"manage\", false).map())\n-            ), Collections.emptyMap());\n+        final HasPrivilegesResponse response = new HasPrivilegesResponse(\"daredevil\", false, Collections.singletonMap(\"manage\", true),\n+                Arrays.asList(\n+                        ResourcePrivileges.builder(\"staff\")\n+                                .addPrivileges(MapBuilder.<String, Boolean>newMapBuilder(new LinkedHashMap<>()).put(\"read\", true)\n+                                        .put(\"index\", true).put(\"delete\", false).put(\"manage\", false).map())\n+                                .build(),\n+                        ResourcePrivileges.builder(\"customers\")\n+                                .addPrivileges(MapBuilder.<String, Boolean>newMapBuilder(new LinkedHashMap<>()).put(\"read\", true)\n+                                        .put(\"index\", true).put(\"delete\", true).put(\"manage\", false).map())\n+                                .build()),\n+                Collections.emptyMap());\n \n         final XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent());\n         response.toXContent(builder, ToXContent.EMPTY_PARAMS);\n@@ -120,9 +122,9 @@ public HasPrivilegesResponse convertHlrcToInternal(org.elasticsearch.client.secu\n             );\n     }\n \n-    private static List<HasPrivilegesResponse.ResourcePrivileges> toResourcePrivileges(Map<String, Map<String, Boolean>> map) {\n+    private static List<ResourcePrivileges> toResourcePrivileges(Map<String, Map<String, Boolean>> map) {\n         return map.entrySet().stream()\n-            .map(e -> new HasPrivilegesResponse.ResourcePrivileges(e.getKey(), e.getValue()))\n+            .map(e -> ResourcePrivileges.builder(e.getKey()).addPrivileges(e.getValue()).build())\n             .collect(Collectors.toList());\n     }\n \n@@ -146,23 +148,23 @@ private HasPrivilegesResponse randomResponse() {\n         for (String priv : randomArray(1, 6, String[]::new, () -> randomAlphaOfLengthBetween(3, 12))) {\n             cluster.put(priv, randomBoolean());\n         }\n-        final Collection<HasPrivilegesResponse.ResourcePrivileges> index = randomResourcePrivileges();\n-        final Map<String, Collection<HasPrivilegesResponse.ResourcePrivileges>> application = new HashMap<>();\n+        final Collection<ResourcePrivileges> index = randomResourcePrivileges();\n+        final Map<String, Collection<ResourcePrivileges>> application = new HashMap<>();\n         for (String app : randomArray(1, 3, String[]::new, () -> randomAlphaOfLengthBetween(3, 6).toLowerCase(Locale.ROOT))) {\n             application.put(app, randomResourcePrivileges());\n         }\n         return new HasPrivilegesResponse(username, randomBoolean(), cluster, index, application);\n     }\n \n-    private Collection<HasPrivilegesResponse.ResourcePrivileges> randomResourcePrivileges() {\n-        final Collection<HasPrivilegesResponse.ResourcePrivileges> list = new ArrayList<>();\n+    private Collection<ResourcePrivileges> randomResourcePrivileges() {\n+        final Collection<ResourcePrivileges> list = new ArrayList<>();\n         // Use hash set to force a unique set of resources\n         for (String resource : Sets.newHashSet(randomArray(1, 3, String[]::new, () -> randomAlphaOfLengthBetween(2, 6)))) {\n             final Map<String, Boolean> privileges = new HashMap<>();\n             for (String priv : randomArray(1, 5, String[]::new, () -> randomAlphaOfLengthBetween(3, 8))) {\n                 privileges.put(priv, randomBoolean());\n             }\n-            list.add(new HasPrivilegesResponse.ResourcePrivileges(resource, privileges));\n+            list.add(ResourcePrivileges.builder(resource).addPrivileges(privileges).build());\n         }\n         return list;\n     }"
        },
        {
            "sha": "9b5bf450924a237245a2bd12abe5cb7213e8ebb7",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authc/DefaultAuthenticationFailureHandlerTests.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandlerTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandlerTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthc%2FDefaultAuthenticationFailureHandlerTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -122,8 +122,9 @@ public void testSortsWWWAuthenticateHeaderValues() {\n         final String basicAuthScheme = \"Basic realm=\\\"\" + XPackField.SECURITY + \"\\\" charset=\\\"UTF-8\\\"\";\n         final String bearerAuthScheme = \"Bearer realm=\\\"\" + XPackField.SECURITY + \"\\\"\";\n         final String negotiateAuthScheme = randomFrom(\"Negotiate\", \"Negotiate Ijoijksdk\");\n+        final String apiKeyAuthScheme = \"ApiKey\";\n         final Map<String, List<String>> failureResponeHeaders = new HashMap<>();\n-        final List<String> supportedSchemes = Arrays.asList(basicAuthScheme, bearerAuthScheme, negotiateAuthScheme);\n+        final List<String> supportedSchemes = Arrays.asList(basicAuthScheme, bearerAuthScheme, negotiateAuthScheme, apiKeyAuthScheme);\n         Collections.shuffle(supportedSchemes, random());\n         failureResponeHeaders.put(\"WWW-Authenticate\", supportedSchemes);\n         final DefaultAuthenticationFailureHandler failuerHandler = new DefaultAuthenticationFailureHandler(failureResponeHeaders);\n@@ -134,7 +135,7 @@ public void testSortsWWWAuthenticateHeaderValues() {\n         assertThat(ese, is(notNullValue()));\n         assertThat(ese.getHeader(\"WWW-Authenticate\"), is(notNullValue()));\n         assertThat(ese.getMessage(), equalTo(\"error attempting to authenticate request\"));\n-        assertWWWAuthenticateWithSchemes(ese, negotiateAuthScheme, bearerAuthScheme, basicAuthScheme);\n+        assertWWWAuthenticateWithSchemes(ese, negotiateAuthScheme, bearerAuthScheme, apiKeyAuthScheme, basicAuthScheme);\n     }\n \n     private void assertWWWAuthenticateWithSchemes(final ElasticsearchSecurityException ese, final String... schemes) {"
        },
        {
            "sha": "5eccd4090e8bffd4db21ba04831f38ad420b0c3b",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/SecurityIndexSearcherWrapperIntegrationTests.java",
            "status": "modified",
            "additions": 128,
            "deletions": 3,
            "changes": 131,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperIntegrationTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperIntegrationTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperIntegrationTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -8,6 +8,7 @@\n import org.apache.lucene.analysis.standard.StandardAnalyzer;\n import org.apache.lucene.document.Document;\n import org.apache.lucene.document.Field;\n+import org.apache.lucene.document.Field.Store;\n import org.apache.lucene.document.StringField;\n import org.apache.lucene.index.DirectoryReader;\n import org.apache.lucene.index.IndexWriter;\n@@ -16,12 +17,14 @@\n import org.apache.lucene.index.Term;\n import org.apache.lucene.search.IndexSearcher;\n import org.apache.lucene.search.MatchAllDocsQuery;\n+import org.apache.lucene.search.ScoreDoc;\n import org.apache.lucene.search.TermQuery;\n import org.apache.lucene.search.TotalHitCountCollector;\n import org.apache.lucene.store.Directory;\n import org.apache.lucene.util.Accountable;\n import org.elasticsearch.client.Client;\n import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.lucene.index.ElasticsearchDirectoryReader;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n@@ -36,14 +39,21 @@\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.license.XPackLicenseState;\n import org.elasticsearch.script.ScriptService;\n-import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.AbstractBuilderTestCase;\n import org.elasticsearch.test.IndexSettingsModule;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n+import org.elasticsearch.xpack.core.security.user.User;\n \n import java.util.Collections;\n+import java.util.HashSet;\n+import java.util.Set;\n \n import static java.util.Collections.singleton;\n import static java.util.Collections.singletonMap;\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n import static org.hamcrest.Matchers.equalTo;\n import static org.mockito.Matchers.any;\n import static org.mockito.Matchers.anyString;\n@@ -52,7 +62,7 @@\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.when;\n \n-public class SecurityIndexSearcherWrapperIntegrationTests extends ESTestCase {\n+public class SecurityIndexSearcherWrapperIntegrationTests extends AbstractBuilderTestCase {\n \n     public void testDLS() throws Exception {\n         ShardId shardId = new ShardId(\"_index\", \"_na_\", 0);\n@@ -63,9 +73,12 @@ public void testDLS() throws Exception {\n                 .then(invocationOnMock -> Collections.singletonList((String) invocationOnMock.getArguments()[0]));\n \n         ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        final Authentication authentication = mock(Authentication.class);\n+        when(authentication.getUser()).thenReturn(mock(User.class));\n+        threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication);\n         IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new\n                 FieldPermissions(),\n-                singleton(new BytesArray(\"{\\\"match_all\\\" : {}}\")));\n+                DocumentPermissions.filteredBy(singleton(new BytesArray(\"{\\\"match_all\\\" : {}}\"))));\n         IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(shardId.getIndex(), Settings.EMPTY);\n         Client client = mock(Client.class);\n         when(client.settings()).thenReturn(Settings.EMPTY);\n@@ -158,4 +171,116 @@ protected IndicesAccessControl getIndicesAccessControl() {\n         directoryReader.close();\n         directory.close();\n     }\n+\n+    public void testDLSWithLimitedPermissions() throws Exception {\n+        ShardId shardId = new ShardId(\"_index\", \"_na_\", 0);\n+        MapperService mapperService = mock(MapperService.class);\n+        ScriptService  scriptService = mock(ScriptService.class);\n+        when(mapperService.documentMapper()).thenReturn(null);\n+        when(mapperService.simpleMatchToFullName(anyString()))\n+                .then(invocationOnMock -> Collections.singletonList((String) invocationOnMock.getArguments()[0]));\n+\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        final Authentication authentication = mock(Authentication.class);\n+        when(authentication.getUser()).thenReturn(mock(User.class));\n+        threadContext.putTransient(AuthenticationField.AUTHENTICATION_KEY, authentication);\n+        final boolean noFilteredIndexPermissions = randomBoolean();\n+        boolean restrictiveLimitedIndexPermissions = false;\n+        if (noFilteredIndexPermissions == false) {\n+            restrictiveLimitedIndexPermissions = randomBoolean();\n+        }\n+        Set<BytesReference> queries = new HashSet<>();\n+        queries.add(new BytesArray(\"{\\\"terms\\\" : { \\\"f2\\\" : [\\\"fv22\\\"] } }\"));\n+        queries.add(new BytesArray(\"{\\\"terms\\\" : { \\\"f2\\\" : [\\\"fv32\\\"] } }\"));\n+        IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new\n+                FieldPermissions(),\n+                DocumentPermissions.filteredBy(queries));\n+        queries = singleton(new BytesArray(\"{\\\"terms\\\" : { \\\"f1\\\" : [\\\"fv11\\\", \\\"fv21\\\", \\\"fv31\\\"] } }\"));\n+        if (restrictiveLimitedIndexPermissions) {\n+            queries = singleton(new BytesArray(\"{\\\"terms\\\" : { \\\"f1\\\" : [\\\"fv11\\\", \\\"fv31\\\"] } }\"));\n+        }\n+        IndicesAccessControl.IndexAccessControl limitedIndexAccessControl = new IndicesAccessControl.IndexAccessControl(true, new\n+                FieldPermissions(),\n+                DocumentPermissions.filteredBy(queries));\n+        IndexSettings indexSettings = IndexSettingsModule.newIndexSettings(shardId.getIndex(), Settings.EMPTY);\n+        Client client = mock(Client.class);\n+        when(client.settings()).thenReturn(Settings.EMPTY);\n+        final long nowInMillis = randomNonNegativeLong();\n+        QueryShardContext realQueryShardContext = new QueryShardContext(shardId.id(), indexSettings, null, null, mapperService, null,\n+                null, xContentRegistry(), writableRegistry(), client, null, () -> nowInMillis, null);\n+        QueryShardContext queryShardContext = spy(realQueryShardContext);\n+        IndexSettings settings = IndexSettingsModule.newIndexSettings(\"_index\", Settings.EMPTY);\n+        BitsetFilterCache bitsetFilterCache = new BitsetFilterCache(settings, new BitsetFilterCache.Listener() {\n+            @Override\n+            public void onCache(ShardId shardId, Accountable accountable) {\n+            }\n+\n+            @Override\n+            public void onRemoval(ShardId shardId, Accountable accountable) {\n+            }\n+        });\n+\n+        XPackLicenseState licenseState = mock(XPackLicenseState.class);\n+        when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(true);\n+        SecurityIndexSearcherWrapper wrapper = new SecurityIndexSearcherWrapper(s -> queryShardContext,\n+                bitsetFilterCache, threadContext, licenseState, scriptService) {\n+\n+            @Override\n+            protected IndicesAccessControl getIndicesAccessControl() {\n+                IndicesAccessControl indicesAccessControl = new IndicesAccessControl(true, singletonMap(\"_index\", indexAccessControl));\n+                if (noFilteredIndexPermissions) {\n+                    return indicesAccessControl;\n+                }\n+                IndicesAccessControl limitedByIndicesAccessControl = new IndicesAccessControl(true,\n+                        singletonMap(\"_index\", limitedIndexAccessControl));\n+                return indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+            }\n+        };\n+\n+        Directory directory = newDirectory();\n+        IndexWriter iw = new IndexWriter(\n+                directory,\n+                new IndexWriterConfig(new StandardAnalyzer()).setMergePolicy(NoMergePolicy.INSTANCE)\n+        );\n+\n+        Document doc1 = new Document();\n+        doc1.add(new StringField(\"f1\", \"fv11\", Store.NO));\n+        doc1.add(new StringField(\"f2\", \"fv12\", Store.NO));\n+        iw.addDocument(doc1);\n+        Document doc2 = new Document();\n+        doc2.add(new StringField(\"f1\", \"fv21\", Store.NO));\n+        doc2.add(new StringField(\"f2\", \"fv22\", Store.NO));\n+        iw.addDocument(doc2);\n+        Document doc3 = new Document();\n+        doc3.add(new StringField(\"f1\", \"fv31\", Store.NO));\n+        doc3.add(new StringField(\"f2\", \"fv32\", Store.NO));\n+        iw.addDocument(doc3);\n+        iw.commit();\n+        iw.close();\n+\n+        DirectoryReader directoryReader = ElasticsearchDirectoryReader.wrap(DirectoryReader.open(directory), shardId);\n+        DirectoryReader wrappedDirectoryReader = wrapper.wrap(directoryReader);\n+        IndexSearcher indexSearcher = wrapper.wrap(new IndexSearcher(wrappedDirectoryReader));\n+\n+        ScoreDoc[] hits = indexSearcher.search(new MatchAllDocsQuery(), 1000).scoreDocs;\n+        Set<Integer> actualDocIds = new HashSet<>();\n+        for (ScoreDoc doc : hits) {\n+            actualDocIds.add(doc.doc);\n+        }\n+\n+        if (noFilteredIndexPermissions) {\n+            assertThat(actualDocIds, containsInAnyOrder(1, 2));\n+        } else {\n+            if (restrictiveLimitedIndexPermissions) {\n+                assertThat(actualDocIds, containsInAnyOrder(2));\n+            } else {\n+                assertThat(actualDocIds, containsInAnyOrder(1, 2));\n+            }\n+        }\n+\n+        bitsetFilterCache.close();\n+        directoryReader.close();\n+        directory.close();\n+    }\n+\n }"
        },
        {
            "sha": "7900eaba4c848ba55a354232ea97db39a4a4e97e",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/accesscontrol/SecurityIndexSearcherWrapperUnitTests.java",
            "status": "modified",
            "additions": 5,
            "deletions": 147,
            "changes": 152,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperUnitTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperUnitTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Faccesscontrol%2FSecurityIndexSearcherWrapperUnitTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -28,81 +28,52 @@\n import org.apache.lucene.search.Scorer;\n import org.apache.lucene.search.TermQuery;\n import org.apache.lucene.search.Weight;\n-import org.apache.lucene.search.join.ScoreMode;\n import org.apache.lucene.store.Directory;\n-import org.apache.lucene.store.RAMDirectory;\n+import org.apache.lucene.store.MMapDirectory;\n import org.apache.lucene.util.Accountable;\n import org.apache.lucene.util.BitSet;\n import org.apache.lucene.util.FixedBitSet;\n-import org.elasticsearch.core.internal.io.IOUtils;\n import org.apache.lucene.util.SparseFixedBitSet;\n-import org.elasticsearch.client.Client;\n-import org.elasticsearch.common.Strings;\n import org.elasticsearch.common.lucene.index.ElasticsearchDirectoryReader;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n-import org.elasticsearch.common.xcontent.ToXContent;\n-import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.core.internal.io.IOUtils;\n import org.elasticsearch.index.Index;\n import org.elasticsearch.index.IndexSettings;\n import org.elasticsearch.index.cache.bitset.BitsetFilterCache;\n import org.elasticsearch.index.mapper.FieldNamesFieldMapper;\n import org.elasticsearch.index.mapper.MapperService;\n import org.elasticsearch.index.mapper.SeqNoFieldMapper;\n import org.elasticsearch.index.mapper.SourceFieldMapper;\n-import org.elasticsearch.index.query.BoolQueryBuilder;\n-import org.elasticsearch.index.query.BoostingQueryBuilder;\n-import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n-import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n-import org.elasticsearch.index.query.MatchAllQueryBuilder;\n-import org.elasticsearch.index.query.QueryBuilder;\n-import org.elasticsearch.index.query.QueryRewriteContext;\n-import org.elasticsearch.index.query.TermQueryBuilder;\n-import org.elasticsearch.index.query.TermsQueryBuilder;\n-import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n import org.elasticsearch.index.shard.IndexShard;\n import org.elasticsearch.index.shard.ShardId;\n-import org.elasticsearch.indices.TermsLookup;\n-import org.elasticsearch.join.query.HasChildQueryBuilder;\n-import org.elasticsearch.join.query.HasParentQueryBuilder;\n import org.elasticsearch.license.XPackLicenseState;\n-import org.elasticsearch.script.Script;\n import org.elasticsearch.script.ScriptService;\n-import org.elasticsearch.script.ScriptType;\n-import org.elasticsearch.script.TemplateScript;\n import org.elasticsearch.search.aggregations.LeafBucketCollector;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.test.IndexSettingsModule;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.DocumentSubsetReader.DocumentSubsetDirectoryReader;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n-import org.elasticsearch.xpack.core.security.user.User;\n import org.junit.After;\n import org.junit.Before;\n-import org.mockito.ArgumentCaptor;\n \n import java.io.IOException;\n import java.util.Arrays;\n import java.util.Collections;\n-import java.util.HashMap;\n import java.util.HashSet;\n import java.util.IdentityHashMap;\n-import java.util.Map;\n import java.util.Set;\n \n import static java.util.Collections.singletonMap;\n-import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n import static org.elasticsearch.xpack.core.security.authz.accesscontrol.SecurityIndexSearcherWrapper.intersectScorerAndRoleBits;\n import static org.hamcrest.Matchers.equalTo;\n import static org.hamcrest.Matchers.instanceOf;\n import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.not;\n import static org.hamcrest.Matchers.sameInstance;\n-import static org.mockito.Matchers.any;\n-import static org.mockito.Matchers.eq;\n import static org.mockito.Mockito.mock;\n-import static org.mockito.Mockito.verify;\n-import static org.mockito.Mockito.verifyZeroInteractions;\n import static org.mockito.Mockito.when;\n \n public class SecurityIndexSearcherWrapperUnitTests extends ESTestCase {\n@@ -136,7 +107,7 @@ public void setup() throws Exception {\n         IndexShard indexShard = mock(IndexShard.class);\n         when(indexShard.shardId()).thenReturn(shardId);\n \n-        Directory directory = new RAMDirectory();\n+        Directory directory = new MMapDirectory(createTempDir());\n         IndexWriter writer = new IndexWriter(directory, newIndexWriterConfig());\n         writer.close();\n \n@@ -156,7 +127,7 @@ public void testDefaultMetaFields() throws Exception {\n             @Override\n             protected IndicesAccessControl getIndicesAccessControl() {\n                 IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(true,\n-                        new FieldPermissions(fieldPermissionDef(new String[]{}, null)), null);\n+                        new FieldPermissions(fieldPermissionDef(new String[]{}, null)), DocumentPermissions.allowAll());\n                 return new IndicesAccessControl(true, singletonMap(\"_index\", indexAccessControl));\n             }\n         };\n@@ -423,66 +394,6 @@ public void testIndexSearcherWrapperDenseWithDeletions() throws IOException {\n         doTestIndexSearcherWrapper(false, true);\n     }\n \n-    public void testTemplating() throws Exception {\n-        User user = new User(\"_username\", new String[]{\"role1\", \"role2\"}, \"_full_name\", \"_email\",\n-                Collections.singletonMap(\"key\", \"value\"), true);\n-        securityIndexSearcherWrapper =\n-                new SecurityIndexSearcherWrapper(null, null, threadContext, licenseState, scriptService) {\n-\n-                    @Override\n-                    protected User getUser() {\n-                        return user;\n-                    }\n-                };\n-\n-        TemplateScript.Factory compiledTemplate = templateParams ->\n-                new TemplateScript(templateParams) {\n-                    @Override\n-                    public String execute() {\n-                        return \"rendered_text\";\n-                    }\n-                };\n-\n-        when(scriptService.compile(any(Script.class), eq(TemplateScript.CONTEXT))).thenReturn(compiledTemplate);\n-\n-        XContentBuilder builder = jsonBuilder();\n-        String query = Strings.toString(new TermQueryBuilder(\"field\", \"{{_user.username}}\").toXContent(builder, ToXContent.EMPTY_PARAMS));\n-        Script script = new Script(ScriptType.INLINE, \"mustache\", query, Collections.singletonMap(\"custom\", \"value\"));\n-        builder = jsonBuilder().startObject().field(\"template\");\n-        script.toXContent(builder, ToXContent.EMPTY_PARAMS);\n-        String querySource = Strings.toString(builder.endObject());\n-\n-        securityIndexSearcherWrapper.evaluateTemplate(querySource);\n-        ArgumentCaptor<Script> argument = ArgumentCaptor.forClass(Script.class);\n-        verify(scriptService).compile(argument.capture(), eq(TemplateScript.CONTEXT));\n-        Script usedScript = argument.getValue();\n-        assertThat(usedScript.getIdOrCode(), equalTo(script.getIdOrCode()));\n-        assertThat(usedScript.getType(), equalTo(script.getType()));\n-        assertThat(usedScript.getLang(), equalTo(\"mustache\"));\n-        assertThat(usedScript.getOptions(), equalTo(script.getOptions()));\n-        assertThat(usedScript.getParams().size(), equalTo(2));\n-        assertThat(usedScript.getParams().get(\"custom\"), equalTo(\"value\"));\n-\n-        Map<String, Object> userModel = new HashMap<>();\n-        userModel.put(\"username\", user.principal());\n-        userModel.put(\"full_name\", user.fullName());\n-        userModel.put(\"email\", user.email());\n-        userModel.put(\"roles\", Arrays.asList(user.roles()));\n-        userModel.put(\"metadata\", user.metadata());\n-        assertThat(usedScript.getParams().get(\"_user\"), equalTo(userModel));\n-\n-    }\n-\n-    public void testSkipTemplating() throws Exception {\n-        securityIndexSearcherWrapper =\n-                new SecurityIndexSearcherWrapper(null, null, threadContext, licenseState, scriptService);\n-        XContentBuilder builder = jsonBuilder();\n-        String querySource =  Strings.toString(new TermQueryBuilder(\"field\", \"value\").toXContent(builder, ToXContent.EMPTY_PARAMS));\n-        String result = securityIndexSearcherWrapper.evaluateTemplate(querySource);\n-        assertThat(result, sameInstance(querySource));\n-        verifyZeroInteractions(scriptService);\n-    }\n-\n     static class CreateScorerOnceWeight extends Weight {\n \n         private final Weight weight;\n@@ -622,59 +533,6 @@ public void onRemoval(ShardId shardId, Accountable accountable) {\n         IOUtils.close(reader, w, dir);\n     }\n \n-    public void testVerifyRoleQuery() throws Exception {\n-        QueryBuilder queryBuilder1 = new TermsQueryBuilder(\"field\", \"val1\", \"val2\");\n-        SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder1);\n-\n-        QueryBuilder queryBuilder2 = new TermsQueryBuilder(\"field\", new TermsLookup(\"_index\", \"_type\", \"_id\", \"_path\"));\n-        Exception e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder2));\n-        assertThat(e.getMessage(), equalTo(\"terms query with terms lookup isn't supported as part of a role query\"));\n-\n-        QueryBuilder queryBuilder3 = new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\");\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder3));\n-        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder4 = new HasChildQueryBuilder(\"_type\", new MatchAllQueryBuilder(), ScoreMode.None);\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder4));\n-        assertThat(e.getMessage(), equalTo(\"has_child query isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder5 = new HasParentQueryBuilder(\"_type\", new MatchAllQueryBuilder(), false);\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder5));\n-        assertThat(e.getMessage(), equalTo(\"has_parent query isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder6 = new BoolQueryBuilder().must(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder6));\n-        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder7 = new ConstantScoreQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder7));\n-        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder8 = new FunctionScoreQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder8));\n-        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n-\n-        QueryBuilder queryBuilder9 = new BoostingQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"),\n-                new MatchAllQueryBuilder());\n-        e = expectThrows(IllegalArgumentException.class, () -> SecurityIndexSearcherWrapper.verifyRoleQuery(queryBuilder9));\n-        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n-    }\n-\n-    public void testFailIfQueryUsesClient() throws Exception {\n-        Client client = mock(Client.class);\n-        when(client.settings()).thenReturn(Settings.EMPTY);\n-        final long nowInMillis = randomNonNegativeLong();\n-        QueryRewriteContext context = new QueryRewriteContext(xContentRegistry(), writableRegistry(), client,\n-                () -> nowInMillis);\n-        QueryBuilder queryBuilder1 = new TermsQueryBuilder(\"field\", \"val1\", \"val2\");\n-        SecurityIndexSearcherWrapper.failIfQueryUsesClient(queryBuilder1, context);\n-\n-        QueryBuilder queryBuilder2 = new TermsQueryBuilder(\"field\", new TermsLookup(\"_index\", \"_type\", \"_id\", \"_path\"));\n-        Exception e = expectThrows(IllegalStateException.class,\n-                () -> SecurityIndexSearcherWrapper.failIfQueryUsesClient(queryBuilder2, context));\n-        assertThat(e.getMessage(), equalTo(\"role queries are not allowed to execute additional requests\"));\n-    }\n-\n     private static FieldPermissionsDefinition fieldPermissionDef(String[] granted, String[] denied) {\n         return new FieldPermissionsDefinition(granted, denied);\n     }"
        },
        {
            "sha": "f8d1334df7e4e539fa55d21dc6854cc4b3e9be34",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/permission/DocumentPermissionsTests.java",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissionsTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissionsTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FDocumentPermissionsTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,123 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.apache.lucene.search.join.ScoreMode;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.BoostingQueryBuilder;\n+import org.elasticsearch.index.query.ConstantScoreQueryBuilder;\n+import org.elasticsearch.index.query.GeoShapeQueryBuilder;\n+import org.elasticsearch.index.query.MatchAllQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilder;\n+import org.elasticsearch.index.query.QueryRewriteContext;\n+import org.elasticsearch.index.query.TermsQueryBuilder;\n+import org.elasticsearch.index.query.functionscore.FunctionScoreQueryBuilder;\n+import org.elasticsearch.indices.TermsLookup;\n+import org.elasticsearch.join.query.HasChildQueryBuilder;\n+import org.elasticsearch.join.query.HasParentQueryBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+\n+import java.io.IOException;\n+import java.util.Collections;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class DocumentPermissionsTests extends ESTestCase {\n+\n+    public void testHasDocumentPermissions() throws IOException {\n+        final DocumentPermissions documentPermissions1 = DocumentPermissions.allowAll();\n+        assertThat(documentPermissions1, is(notNullValue()));\n+        assertThat(documentPermissions1.hasDocumentLevelPermissions(), is(false));\n+        assertThat(documentPermissions1.filter(null, null, null, null), is(nullValue()));\n+\n+        Set<BytesReference> queries = Collections.singleton(new BytesArray(\"{\\\"match_all\\\" : {}}\"));\n+        final DocumentPermissions documentPermissions2 = DocumentPermissions\n+                .filteredBy(queries);\n+        assertThat(documentPermissions2, is(notNullValue()));\n+        assertThat(documentPermissions2.hasDocumentLevelPermissions(), is(true));\n+        assertThat(documentPermissions2.getQueries(), equalTo(queries));\n+\n+        final DocumentPermissions documentPermissions3 = documentPermissions1.limitDocumentPermissions(documentPermissions2);\n+        assertThat(documentPermissions3, is(notNullValue()));\n+        assertThat(documentPermissions3.hasDocumentLevelPermissions(), is(true));\n+        assertThat(documentPermissions3.getQueries(), is(nullValue()));\n+        assertThat(documentPermissions3.getLimitedByQueries(), equalTo(queries));\n+\n+        final DocumentPermissions documentPermissions4 = DocumentPermissions.allowAll()\n+                .limitDocumentPermissions(DocumentPermissions.allowAll());\n+        assertThat(documentPermissions4, is(notNullValue()));\n+        assertThat(documentPermissions4.hasDocumentLevelPermissions(), is(false));\n+\n+        AssertionError ae = expectThrows(AssertionError.class,\n+                () -> DocumentPermissions.allowAll().limitDocumentPermissions(documentPermissions3));\n+        assertThat(ae.getMessage(), containsString(\"nested scoping for document permissions is not permitted\"));\n+    }\n+\n+    public void testVerifyRoleQuery() throws Exception {\n+        QueryBuilder queryBuilder1 = new TermsQueryBuilder(\"field\", \"val1\", \"val2\");\n+        DocumentPermissions.verifyRoleQuery(queryBuilder1);\n+\n+        QueryBuilder queryBuilder2 = new TermsQueryBuilder(\"field\", new TermsLookup(\"_index\", \"_type\", \"_id\", \"_path\"));\n+        Exception e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder2));\n+        assertThat(e.getMessage(), equalTo(\"terms query with terms lookup isn't supported as part of a role query\"));\n+\n+        QueryBuilder queryBuilder3 = new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\");\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder3));\n+        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder4 = new HasChildQueryBuilder(\"_type\", new MatchAllQueryBuilder(), ScoreMode.None);\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder4));\n+        assertThat(e.getMessage(), equalTo(\"has_child query isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder5 = new HasParentQueryBuilder(\"_type\", new MatchAllQueryBuilder(), false);\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder5));\n+        assertThat(e.getMessage(), equalTo(\"has_parent query isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder6 = new BoolQueryBuilder().must(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder6));\n+        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder7 = new ConstantScoreQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder7));\n+        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder8 = new FunctionScoreQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"));\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder8));\n+        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n+\n+        QueryBuilder queryBuilder9 = new BoostingQueryBuilder(new GeoShapeQueryBuilder(\"field\", \"_id\", \"_type\"),\n+                new MatchAllQueryBuilder());\n+        e = expectThrows(IllegalArgumentException.class, () -> DocumentPermissions.verifyRoleQuery(queryBuilder9));\n+        assertThat(e.getMessage(), equalTo(\"geoshape query referring to indexed shapes isn't support as part of a role query\"));\n+    }\n+\n+    public void testFailIfQueryUsesClient() throws Exception {\n+        Client client = mock(Client.class);\n+        when(client.settings()).thenReturn(Settings.EMPTY);\n+        final long nowInMillis = randomNonNegativeLong();\n+        QueryRewriteContext context = new QueryRewriteContext(xContentRegistry(), writableRegistry(), client,\n+                () -> nowInMillis);\n+        QueryBuilder queryBuilder1 = new TermsQueryBuilder(\"field\", \"val1\", \"val2\");\n+        DocumentPermissions.failIfQueryUsesClient(queryBuilder1, context);\n+\n+        QueryBuilder queryBuilder2 = new TermsQueryBuilder(\"field\", new TermsLookup(\"_index\", \"_type\", \"_id\", \"_path\"));\n+        Exception e = expectThrows(IllegalStateException.class,\n+                () -> DocumentPermissions.failIfQueryUsesClient(queryBuilder2, context));\n+        assertThat(e.getMessage(), equalTo(\"role queries are not allowed to execute additional requests\"));\n+    }\n+}"
        },
        {
            "sha": "8dc4bf379c5618e0b26431d77285e673cdce64ac",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/permission/FieldPermissionsTests.java",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissionsTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissionsTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FFieldPermissionsTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.apache.lucene.util.automaton.CharacterRunAutomaton;\n+import org.elasticsearch.test.ESTestCase;\n+import org.hamcrest.core.IsSame;\n+\n+import java.io.IOException;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.mockito.Matchers.same;\n+\n+public class FieldPermissionsTests extends ESTestCase {\n+\n+    public void testFieldPermissionsIntersection() throws IOException {\n+\n+        final FieldPermissions fieldPermissions = FieldPermissions.DEFAULT;\n+        final FieldPermissions fieldPermissions1 = new FieldPermissions(\n+                fieldPermissionDef(new String[] { \"f1\", \"f2\", \"f3*\" }, new String[] { \"f3\" }));\n+        final FieldPermissions fieldPermissions2 = new FieldPermissions(\n+                fieldPermissionDef(new String[] { \"f1\", \"f3*\", \"f4\" }, new String[] { \"f3\" }));\n+\n+        {\n+            FieldPermissions result = fieldPermissions.limitFieldPermissions(randomFrom(new FieldPermissions(), null));\n+            assertThat(result, is(notNullValue()));\n+            assertThat(result, IsSame.sameInstance(FieldPermissions.DEFAULT));\n+        }\n+\n+        {\n+            FieldPermissions result = fieldPermissions1.limitFieldPermissions(new FieldPermissions());\n+            assertThat(result, is(notNullValue()));\n+            assertThat(result, not(same(fieldPermissions)));\n+            assertThat(result, not(same(fieldPermissions1)));\n+            CharacterRunAutomaton automaton = new CharacterRunAutomaton(result.getIncludeAutomaton());\n+            assertThat(automaton.run(\"f1\"), is(true));\n+            assertThat(automaton.run(\"f2\"), is(true));\n+            assertThat(automaton.run(\"f3\"), is(false));\n+            assertThat(automaton.run(\"f31\"), is(true));\n+            assertThat(automaton.run(\"f4\"), is(false));\n+        }\n+\n+        {\n+            FieldPermissions result = fieldPermissions1.limitFieldPermissions(fieldPermissions2);\n+            assertThat(result, is(notNullValue()));\n+            assertThat(result, not(same(fieldPermissions1)));\n+            assertThat(result, not(same(fieldPermissions2)));\n+            CharacterRunAutomaton automaton = new CharacterRunAutomaton(result.getIncludeAutomaton());\n+            assertThat(automaton.run(\"f1\"), is(true));\n+            assertThat(automaton.run(\"f2\"), is(false));\n+            assertThat(automaton.run(\"f3\"), is(false));\n+            assertThat(automaton.run(\"f31\"), is(true));\n+            assertThat(automaton.run(\"f4\"), is(false));\n+        }\n+\n+        {\n+            FieldPermissions result = fieldPermissions.limitFieldPermissions(fieldPermissions2);\n+            assertThat(result, is(notNullValue()));\n+            assertThat(result, not(same(fieldPermissions1)));\n+            assertThat(result, not(same(fieldPermissions2)));\n+            CharacterRunAutomaton automaton = new CharacterRunAutomaton(result.getIncludeAutomaton());\n+            assertThat(automaton.run(\"f1\"), is(true));\n+            assertThat(automaton.run(\"f2\"), is(false));\n+            assertThat(automaton.run(\"f3\"), is(false));\n+            assertThat(automaton.run(\"f31\"), is(true));\n+            assertThat(automaton.run(\"f4\"), is(true));\n+            assertThat(automaton.run(\"f5\"), is(false));\n+        }\n+    }\n+\n+    private static FieldPermissionsDefinition fieldPermissionDef(String[] granted, String[] denied) {\n+        return new FieldPermissionsDefinition(granted, denied);\n+    }\n+\n+}"
        },
        {
            "sha": "eef358271b61a3f50a8d14159f4257754bc88ea0",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/permission/LimitedRoleTests.java",
            "status": "added",
            "additions": 403,
            "deletions": 0,
            "changes": 403,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRoleTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRoleTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FLimitedRoleTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,403 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.admin.indices.create.CreateIndexAction;\n+import org.elasticsearch.action.admin.indices.delete.DeleteIndexAction;\n+import org.elasticsearch.action.search.SearchAction;\n+import org.elasticsearch.client.security.user.privileges.Role.ClusterPrivilegeName;\n+import org.elasticsearch.cluster.metadata.AliasMetaData;\n+import org.elasticsearch.cluster.metadata.IndexMetaData;\n+import org.elasticsearch.cluster.metadata.MetaData;\n+import org.elasticsearch.common.collect.MapBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.set.Sets;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.transport.TransportRequest;\n+import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n+import org.elasticsearch.xpack.core.security.authz.privilege.IndexPrivilege;\n+import org.junit.Before;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.mockito.Mockito.mock;\n+\n+public class LimitedRoleTests extends ESTestCase {\n+    List<ApplicationPrivilegeDescriptor> applicationPrivilegeDescriptors;\n+\n+    @Before\n+    public void setup() {\n+        applicationPrivilegeDescriptors = new ArrayList<>();\n+    }\n+\n+    public void testRoleConstructorWithLimitedRole() {\n+        Role fromRole = Role.builder(\"a-role\").build();\n+        Role limitedByRole = Role.builder(\"limited-role\").build();\n+        Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+        assertNotNull(role);\n+\n+        NullPointerException npe = expectThrows(NullPointerException.class, () -> LimitedRole.createLimitedRole(fromRole, null));\n+        assertThat(npe.getMessage(), containsString(\"limited by role is required to create limited role\"));\n+    }\n+\n+    public void testAuthorize() {\n+        IndexMetaData.Builder imbBuilder = IndexMetaData\n+                .builder(\"_index\").settings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n+                .putAlias(AliasMetaData.builder(\"_alias\"));\n+        IndexMetaData.Builder imbBuilder1 = IndexMetaData\n+                .builder(\"_index1\").settings(Settings.builder().put(IndexMetaData.SETTING_NUMBER_OF_SHARDS, 1)\n+                        .put(IndexMetaData.SETTING_NUMBER_OF_REPLICAS, 1).put(IndexMetaData.SETTING_VERSION_CREATED, Version.CURRENT))\n+                .putAlias(AliasMetaData.builder(\"_alias1\"));\n+        MetaData md = MetaData.builder().put(imbBuilder).put(imbBuilder1).build();\n+        FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n+        Role fromRole = Role.builder(\"a-role\").cluster(Collections.singleton(ClusterPrivilegeName.MANAGE_SECURITY), Collections.emptyList())\n+                .add(IndexPrivilege.ALL, \"_index\").add(IndexPrivilege.CREATE_INDEX, \"_index1\").build();\n+\n+        IndicesAccessControl iac = fromRole.authorize(SearchAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+        assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+        assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(true));\n+        assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+        assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+        iac = fromRole.authorize(CreateIndexAction.NAME, Sets.newHashSet(\"_index\", \"_index1\"), md, fieldPermissionsCache);\n+        assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+        assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(true));\n+        assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+        assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(true));\n+\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\")\n+                    .cluster(Collections.singleton(ClusterPrivilegeName.ALL), Collections.emptyList()).add(IndexPrivilege.READ, \"_index\")\n+                    .add(IndexPrivilege.NONE, \"_index1\").build();\n+            iac = limitedByRole.authorize(SearchAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(true));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+            iac = limitedByRole.authorize(DeleteIndexAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(false));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+            iac = limitedByRole.authorize(CreateIndexAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(false));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            iac = role.authorize(SearchAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(true));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+            iac = role.authorize(DeleteIndexAction.NAME, Sets.newHashSet(\"_index\", \"_alias1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(false));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+            iac = role.authorize(CreateIndexAction.NAME, Sets.newHashSet(\"_index\", \"_index1\"), md, fieldPermissionsCache);\n+            assertThat(iac.getIndexPermissions(\"_index\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index\").isGranted(), is(false));\n+            assertThat(iac.getIndexPermissions(\"_index1\"), is(notNullValue()));\n+            assertThat(iac.getIndexPermissions(\"_index1\").isGranted(), is(false));\n+        }\n+    }\n+\n+    public void testCheckClusterAction() {\n+        Role fromRole = Role.builder(\"a-role\").cluster(Collections.singleton(ClusterPrivilegeName.MANAGE_SECURITY), Collections.emptyList())\n+                .build();\n+        assertThat(fromRole.checkClusterAction(\"cluster:admin/xpack/security/x\", mock(TransportRequest.class)), is(true));\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\")\n+                    .cluster(Collections.singleton(ClusterPrivilegeName.ALL), Collections.emptyList()).build();\n+            assertThat(limitedByRole.checkClusterAction(\"cluster:admin/xpack/security/x\", mock(TransportRequest.class)), is(true));\n+            assertThat(limitedByRole.checkClusterAction(\"cluster:other-action\", mock(TransportRequest.class)), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.checkClusterAction(\"cluster:admin/xpack/security/x\", mock(TransportRequest.class)), is(true));\n+            assertThat(role.checkClusterAction(\"cluster:other-action\", mock(TransportRequest.class)), is(false));\n+        }\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\")\n+                    .cluster(Collections.singleton(ClusterPrivilegeName.MONITOR), Collections.emptyList()).build();\n+            assertThat(limitedByRole.checkClusterAction(\"cluster:monitor/me\", mock(TransportRequest.class)), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.checkClusterAction(\"cluster:monitor/me\", mock(TransportRequest.class)), is(false));\n+            assertThat(role.checkClusterAction(\"cluster:admin/xpack/security/x\", mock(TransportRequest.class)), is(false));\n+        }\n+    }\n+\n+    public void testCheckIndicesAction() {\n+        Role fromRole = Role.builder(\"a-role\").add(IndexPrivilege.READ, \"ind-1\").build();\n+        assertThat(fromRole.checkIndicesAction(SearchAction.NAME), is(true));\n+        assertThat(fromRole.checkIndicesAction(CreateIndexAction.NAME), is(false));\n+\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.ALL, \"ind-1\").build();\n+            assertThat(limitedByRole.checkIndicesAction(SearchAction.NAME), is(true));\n+            assertThat(limitedByRole.checkIndicesAction(CreateIndexAction.NAME), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.checkIndicesAction(SearchAction.NAME), is(true));\n+            assertThat(role.checkIndicesAction(CreateIndexAction.NAME), is(false));\n+        }\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.NONE, \"ind-1\").build();\n+            assertThat(limitedByRole.checkIndicesAction(SearchAction.NAME), is(false));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.checkIndicesAction(SearchAction.NAME), is(false));\n+            assertThat(role.checkIndicesAction(CreateIndexAction.NAME), is(false));\n+        }\n+    }\n+\n+    public void testAllowedIndicesMatcher() {\n+        Role fromRole = Role.builder(\"a-role\").add(IndexPrivilege.READ, \"ind-1*\").build();\n+        assertThat(fromRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-1\"), is(true));\n+        assertThat(fromRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-11\"), is(true));\n+        assertThat(fromRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-2\"), is(false));\n+\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.READ, \"ind-1\", \"ind-2\").build();\n+            assertThat(limitedByRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-1\"), is(true));\n+            assertThat(limitedByRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-11\"), is(false));\n+            assertThat(limitedByRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-2\"), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-1\"), is(true));\n+            assertThat(role.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-11\"), is(false));\n+            assertThat(role.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-2\"), is(false));\n+        }\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.READ, \"ind-*\").build();\n+            assertThat(limitedByRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-1\"), is(true));\n+            assertThat(limitedByRole.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-2\"), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-1\"), is(true));\n+            assertThat(role.allowedIndicesMatcher(SearchAction.NAME).test(\"ind-2\"), is(false));\n+        }\n+    }\n+\n+    public void testCheckClusterPrivilege() {\n+        Role fromRole = Role.builder(\"a-role\").cluster(Collections.singleton(ClusterPrivilegeName.MANAGE_SECURITY), Collections.emptyList())\n+                .build();\n+        assertThat(fromRole.grants(ClusterPrivilege.ALL), is(false));\n+        assertThat(fromRole.grants(ClusterPrivilege.MANAGE_SECURITY), is(true));\n+\n+        {\n+            Role limitedByRole = Role.builder(\"scoped-role\")\n+                    .cluster(Collections.singleton(ClusterPrivilegeName.ALL), Collections.emptyList()).build();\n+            assertThat(limitedByRole.grants(ClusterPrivilege.ALL), is(true));\n+            assertThat(limitedByRole.grants(ClusterPrivilege.MANAGE_SECURITY), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.grants(ClusterPrivilege.ALL), is(false));\n+            assertThat(role.grants(ClusterPrivilege.MANAGE_SECURITY), is(true));\n+        }\n+        {\n+            Role limitedByRole = Role.builder(\"scoped-role\")\n+                    .cluster(Collections.singleton(ClusterPrivilegeName.MONITOR), Collections.emptyList()).build();\n+            assertThat(limitedByRole.grants(ClusterPrivilege.ALL), is(false));\n+            assertThat(limitedByRole.grants(ClusterPrivilege.MONITOR), is(true));\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            assertThat(role.grants(ClusterPrivilege.ALL), is(false));\n+            assertThat(role.grants(ClusterPrivilege.MANAGE_SECURITY), is(false));\n+            assertThat(role.grants(ClusterPrivilege.MONITOR), is(false));\n+        }\n+    }\n+\n+    public void testGetPrivilegesForIndexPatterns() {\n+        Role fromRole = Role.builder(\"a-role\").add(IndexPrivilege.READ, \"ind-1*\").build();\n+        ResourcePrivilegesMap resourcePrivileges = fromRole.checkIndicesPrivileges(Collections.singleton(\"ind-1-1-*\"), true,\n+                Sets.newHashSet(\"read\", \"write\"));\n+        ResourcePrivilegesMap expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"ind-1-1-*\",\n+                ResourcePrivileges.builder(\"ind-1-1-*\").addPrivilege(\"read\", true).addPrivilege(\"write\", false).build()));\n+        verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+        resourcePrivileges = fromRole.checkIndicesPrivileges(Collections.singleton(\"ind-*\"), true, Sets.newHashSet(\"read\", \"write\"));\n+        expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"ind-*\",\n+                ResourcePrivileges.builder(\"ind-*\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).build()));\n+        verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+        {\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.READ, \"ind-1\", \"ind-2\").build();\n+            resourcePrivileges = limitedByRole.checkIndicesPrivileges(Collections.singleton(\"ind-1\"), true, Collections.singleton(\"read\"));\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(true,\n+                    Collections.singletonMap(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build()));\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            resourcePrivileges = limitedByRole.checkIndicesPrivileges(Collections.singleton(\"ind-1-1-*\"), true,\n+                    Collections.singleton(\"read\"));\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    Collections.singletonMap(\"ind-1-1-*\", ResourcePrivileges.builder(\"ind-1-1-*\").addPrivilege(\"read\", false).build()));\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            resourcePrivileges = limitedByRole.checkIndicesPrivileges(Collections.singleton(\"ind-*\"), true, Collections.singleton(\"read\"));\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    Collections.singletonMap(\"ind-*\", ResourcePrivileges.builder(\"ind-*\").addPrivilege(\"read\", false).build()));\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            resourcePrivileges = role.checkIndicesPrivileges(Collections.singleton(\"ind-1\"), true, Collections.singleton(\"read\"));\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(true,\n+                    Collections.singletonMap(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build()));\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            resourcePrivileges = role.checkIndicesPrivileges(Sets.newHashSet(\"ind-1-1-*\", \"ind-1\"), true, Collections.singleton(\"read\"));\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    mapBuilder().put(\"ind-1-1-*\", ResourcePrivileges.builder(\"ind-1-1-*\").addPrivilege(\"read\", false).build())\n+                            .put(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build()).map());\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+        }\n+        {\n+            fromRole = Role.builder(\"a-role\")\n+                    .add(FieldPermissions.DEFAULT, Collections.emptySet(), IndexPrivilege.READ, true, \"ind-1*\", \".security\").build();\n+            resourcePrivileges = fromRole.checkIndicesPrivileges(Sets.newHashSet(\"ind-1\", \".security\"), true,\n+                    Collections.singleton(\"read\"));\n+            // Map<String, ResourcePrivileges> expectedResourceToResourcePrivs = new HashMap<>();\n+            ;\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(true,\n+                    mapBuilder().put(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build())\n+                            .put(\".security\", ResourcePrivileges.builder(\".security\").addPrivilege(\"read\", true).build()).map());\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            Role limitedByRole = Role.builder(\"limited-role\").add(IndexPrivilege.READ, \"ind-1\", \"ind-2\").build();\n+            resourcePrivileges = limitedByRole.checkIndicesPrivileges(Sets.newHashSet(\"ind-1\", \"ind-2\", \".security\"), true,\n+                    Collections.singleton(\"read\"));\n+\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    mapBuilder().put(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build())\n+                            .put(\"ind-2\", ResourcePrivileges.builder(\"ind-2\").addPrivilege(\"read\", true).build())\n+                            .put(\".security\", ResourcePrivileges.builder(\".security\").addPrivilege(\"read\", false).build()).map());\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            resourcePrivileges = role.checkIndicesPrivileges(Sets.newHashSet(\"ind-1\", \"ind-2\", \".security\"), true,\n+                    Collections.singleton(\"read\"));\n+\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    mapBuilder().put(\"ind-1\", ResourcePrivileges.builder(\"ind-1\").addPrivilege(\"read\", true).build())\n+                            .put(\"ind-2\", ResourcePrivileges.builder(\"ind-2\").addPrivilege(\"read\", false).build())\n+                            .put(\".security\", ResourcePrivileges.builder(\".security\").addPrivilege(\"read\", false).build()).map());\n+            verifyResourcesPrivileges(resourcePrivileges, expectedAppPrivsByResource);\n+        }\n+    }\n+\n+    public void testGetApplicationPrivilegesByResource() {\n+        final ApplicationPrivilege app1Read = defineApplicationPrivilege(\"app1\", \"read\", \"data:read/*\");\n+        final ApplicationPrivilege app1All = defineApplicationPrivilege(\"app1\", \"all\", \"*\");\n+        final ApplicationPrivilege app2Read = defineApplicationPrivilege(\"app2\", \"read\", \"data:read/*\");\n+        final ApplicationPrivilege app2Write = defineApplicationPrivilege(\"app2\", \"write\", \"data:write/*\");\n+\n+        Role fromRole = Role.builder(\"test-role\").addApplicationPrivilege(app1Read, Collections.singleton(\"foo/*\"))\n+                .addApplicationPrivilege(app1All, Collections.singleton(\"foo/bar/baz\"))\n+                .addApplicationPrivilege(app2Read, Collections.singleton(\"foo/bar/*\"))\n+                .addApplicationPrivilege(app2Write, Collections.singleton(\"*/bar/*\")).build();\n+\n+        Set<String> forPrivilegeNames = Sets.newHashSet(\"read\", \"write\", \"all\");\n+        ResourcePrivilegesMap appPrivsByResource = fromRole.checkApplicationResourcePrivileges(\"app1\", Collections.singleton(\"*\"),\n+                forPrivilegeNames, applicationPrivilegeDescriptors);\n+        ResourcePrivilegesMap expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"*\", ResourcePrivileges\n+                .builder(\"*\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+        verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+        appPrivsByResource = fromRole.checkApplicationResourcePrivileges(\"app1\", Collections.singleton(\"foo/x/y\"), forPrivilegeNames,\n+                applicationPrivilegeDescriptors);\n+        expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"foo/x/y\", ResourcePrivileges\n+                .builder(\"foo/x/y\").addPrivilege(\"read\", true).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+        verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+        appPrivsByResource = fromRole.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"foo/bar/a\"), forPrivilegeNames,\n+                applicationPrivilegeDescriptors);\n+        expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"foo/bar/a\", ResourcePrivileges\n+                .builder(\"foo/bar/a\").addPrivilege(\"read\", true).addPrivilege(\"write\", true).addPrivilege(\"all\", false).build()));\n+        verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+        appPrivsByResource = fromRole.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"moon/bar/a\"), forPrivilegeNames,\n+                applicationPrivilegeDescriptors);\n+        expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"moon/bar/a\", ResourcePrivileges\n+                .builder(\"moon/bar/a\").addPrivilege(\"read\", false).addPrivilege(\"write\", true).addPrivilege(\"all\", false).build()));\n+        verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+        {\n+            Role limitedByRole = Role.builder(\"test-role-scoped\").addApplicationPrivilege(app1Read, Collections.singleton(\"foo/scoped/*\"))\n+                    .addApplicationPrivilege(app2Read, Collections.singleton(\"foo/bar/*\"))\n+                    .addApplicationPrivilege(app2Write, Collections.singleton(\"moo/bar/*\")).build();\n+            appPrivsByResource = limitedByRole.checkApplicationResourcePrivileges(\"app1\", Collections.singleton(\"*\"), forPrivilegeNames,\n+                    applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"*\", ResourcePrivileges.builder(\"*\")\n+                    .addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = limitedByRole.checkApplicationResourcePrivileges(\"app1\", Collections.singleton(\"foo/x/y\"),\n+                    forPrivilegeNames, applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"foo/x/y\", ResourcePrivileges\n+                    .builder(\"foo/x/y\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = limitedByRole.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"foo/bar/a\"),\n+                    forPrivilegeNames, applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"foo/bar/a\", ResourcePrivileges\n+                    .builder(\"foo/bar/a\").addPrivilege(\"read\", true).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = limitedByRole.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"moon/bar/a\"),\n+                    forPrivilegeNames, applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"moon/bar/a\", ResourcePrivileges\n+                    .builder(\"moon/bar/a\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            Role role = LimitedRole.createLimitedRole(fromRole, limitedByRole);\n+            appPrivsByResource = role.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"foo/bar/a\"), forPrivilegeNames,\n+                    applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"foo/bar/a\", ResourcePrivileges\n+                    .builder(\"foo/bar/a\").addPrivilege(\"read\", true).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = role.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"moon/bar/a\"), forPrivilegeNames,\n+                    applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"moon/bar/a\", ResourcePrivileges\n+                    .builder(\"moon/bar/a\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = role.checkApplicationResourcePrivileges(\"unknown\", Collections.singleton(\"moon/bar/a\"), forPrivilegeNames,\n+                    applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false, Collections.singletonMap(\"moon/bar/a\", ResourcePrivileges\n+                    .builder(\"moon/bar/a\").addPrivilege(\"read\", false).addPrivilege(\"write\", false).addPrivilege(\"all\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+\n+            appPrivsByResource = role.checkApplicationResourcePrivileges(\"app2\", Collections.singleton(\"moo/bar/a\"),\n+                    Sets.newHashSet(\"read\", \"write\", \"all\", \"unknown\"), applicationPrivilegeDescriptors);\n+            expectedAppPrivsByResource = new ResourcePrivilegesMap(false,\n+                    Collections.singletonMap(\"moo/bar/a\", ResourcePrivileges.builder(\"moo/bar/a\").addPrivilege(\"read\", false)\n+                            .addPrivilege(\"write\", true).addPrivilege(\"all\", false).addPrivilege(\"unknown\", false).build()));\n+            verifyResourcesPrivileges(appPrivsByResource, expectedAppPrivsByResource);\n+        }\n+    }\n+\n+    private void verifyResourcesPrivileges(ResourcePrivilegesMap resourcePrivileges, ResourcePrivilegesMap expectedAppPrivsByResource) {\n+        assertThat(resourcePrivileges, equalTo(expectedAppPrivsByResource));\n+    }\n+\n+    private ApplicationPrivilege defineApplicationPrivilege(String app, String name, String... actions) {\n+        applicationPrivilegeDescriptors\n+                .add(new ApplicationPrivilegeDescriptor(app, name, Sets.newHashSet(actions), Collections.emptyMap()));\n+        return new ApplicationPrivilege(app, name, actions);\n+    }\n+\n+    private static MapBuilder<String, ResourcePrivileges> mapBuilder() {\n+        return MapBuilder.newMapBuilder();\n+    }\n+\n+}"
        },
        {
            "sha": "4a97f62b3ce84155da19bd8de3e4f00df2ff6abf",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/permission/ResourcePrivilegesMapTests.java",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMapTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMapTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesMapTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.elasticsearch.common.collect.MapBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.nullValue;\n+\n+public class ResourcePrivilegesMapTests extends ESTestCase {\n+\n+    public void testBuilder() {\n+        ResourcePrivilegesMap instance = ResourcePrivilegesMap.builder()\n+                .addResourcePrivilege(\"*\", mapBuilder().put(\"read\", true).put(\"write\", true).map()).build();\n+        assertThat(instance.allAllowed(), is(true));\n+        assertThat(instance.getResourceToResourcePrivileges().size(), is(1));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"read\"), is(true));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"write\"), is(true));\n+\n+        instance = ResourcePrivilegesMap.builder().addResourcePrivilege(\"*\", mapBuilder().put(\"read\", true).put(\"write\", false).map())\n+                .build();\n+        assertThat(instance.allAllowed(), is(false));\n+        assertThat(instance.getResourceToResourcePrivileges().size(), is(1));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"read\"), is(true));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"write\"), is(false));\n+\n+        instance = ResourcePrivilegesMap.builder()\n+                .addResourcePrivilege(\"some-other\", mapBuilder().put(\"index\", true).put(\"write\", true).map())\n+                .addResourcePrivilegesMap(instance).build();\n+        assertThat(instance.allAllowed(), is(false));\n+        assertThat(instance.getResourceToResourcePrivileges().size(), is(2));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"read\"), is(true));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"write\"), is(false));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"some-other\").isAllowed(\"index\"), is(true));\n+        assertThat(instance.getResourceToResourcePrivileges().get(\"some-other\").isAllowed(\"write\"), is(true));\n+    }\n+\n+    public void testIntersection() {\n+        ResourcePrivilegesMap instance = ResourcePrivilegesMap.builder()\n+                .addResourcePrivilege(\"*\", mapBuilder().put(\"read\", true).put(\"write\", true).map())\n+                .addResourcePrivilege(\"index-*\", mapBuilder().put(\"read\", true).put(\"write\", true).map()).build();\n+        ResourcePrivilegesMap otherInstance = ResourcePrivilegesMap.builder()\n+                .addResourcePrivilege(\"*\", mapBuilder().put(\"read\", true).put(\"write\", false).map())\n+                .addResourcePrivilege(\"index-*\", mapBuilder().put(\"read\", false).put(\"write\", true).map())\n+                .addResourcePrivilege(\"index-uncommon\", mapBuilder().put(\"read\", false).put(\"write\", true).map()).build();\n+        ResourcePrivilegesMap result = ResourcePrivilegesMap.intersection(instance, otherInstance);\n+        assertThat(result.allAllowed(), is(false));\n+        assertThat(result.getResourceToResourcePrivileges().size(), is(2));\n+        assertThat(result.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"read\"), is(true));\n+        assertThat(result.getResourceToResourcePrivileges().get(\"*\").isAllowed(\"write\"), is(false));\n+        assertThat(result.getResourceToResourcePrivileges().get(\"index-*\").isAllowed(\"read\"), is(false));\n+        assertThat(result.getResourceToResourcePrivileges().get(\"index-*\").isAllowed(\"write\"), is(true));\n+        assertThat(result.getResourceToResourcePrivileges().get(\"index-uncommon\"), is(nullValue()));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        ResourcePrivilegesMap instance = ResourcePrivilegesMap.builder()\n+                .addResourcePrivilege(\"*\", mapBuilder().put(\"read\", true).put(\"write\", true).map()).build();\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(instance, (original) -> {\n+            return ResourcePrivilegesMap.builder().addResourcePrivilegesMap(original).build();\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(instance, (original) -> {\n+            return ResourcePrivilegesMap.builder().addResourcePrivilegesMap(original).build();\n+        }, ResourcePrivilegesMapTests::mutateTestItem);\n+    }\n+\n+    private static ResourcePrivilegesMap mutateTestItem(ResourcePrivilegesMap original) {\n+        switch (randomIntBetween(0, 1)) {\n+        case 0:\n+            return ResourcePrivilegesMap.builder()\n+                    .addResourcePrivilege(randomAlphaOfLength(6), mapBuilder().put(\"read\", true).put(\"write\", true).map()).build();\n+        case 1:\n+            return ResourcePrivilegesMap.builder().addResourcePrivilege(\"*\", mapBuilder().put(\"read\", false).put(\"write\", false).map())\n+                    .build();\n+        default:\n+            return ResourcePrivilegesMap.builder()\n+                    .addResourcePrivilege(randomAlphaOfLength(6), mapBuilder().put(\"read\", true).put(\"write\", true).map()).build();\n+        }\n+    }\n+\n+    private static MapBuilder<String, Boolean> mapBuilder() {\n+        return MapBuilder.newMapBuilder();\n+    }\n+}"
        },
        {
            "sha": "5aa44c2cf7f12cac0b9bc20127b3e9ec9195a30a",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/permission/ResourcePrivilegesTests.java",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fpermission%2FResourcePrivilegesTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.permission;\n+\n+import org.elasticsearch.common.collect.MapBuilder;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.EqualsHashCodeTestUtils;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+\n+public class ResourcePrivilegesTests extends ESTestCase {\n+\n+    public void testBuilder() {\n+        ResourcePrivileges instance = createInstance();\n+        ResourcePrivileges expected = new ResourcePrivileges(\"*\", mapBuilder().put(\"read\", true).put(\"write\", false).map());\n+        assertThat(instance, equalTo(expected));\n+    }\n+\n+    public void testWhenSamePrivilegeExists() {\n+        ResourcePrivileges.Builder builder = ResourcePrivileges.builder(\"*\").addPrivilege(\"read\", true);\n+\n+        Map<String, Boolean> mapWhereReadIsAllowed = mapBuilder().put(\"read\", true).map();\n+        builder.addPrivileges(mapWhereReadIsAllowed);\n+        assertThat(builder.build().isAllowed(\"read\"), is(true));\n+\n+        Map<String, Boolean> mapWhereReadIsDenied = mapBuilder().put(\"read\", false).map();\n+        builder.addPrivileges(mapWhereReadIsDenied);\n+        assertThat(builder.build().isAllowed(\"read\"), is(false));\n+    }\n+\n+    public void testEqualsHashCode() {\n+        ResourcePrivileges instance = createInstance();\n+\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(instance, (original) -> {\n+            return ResourcePrivileges.builder(original.getResource()).addPrivileges(original.getPrivileges()).build();\n+        });\n+        EqualsHashCodeTestUtils.checkEqualsAndHashCode(instance, (original) -> {\n+            return ResourcePrivileges.builder(original.getResource()).addPrivileges(original.getPrivileges()).build();\n+        }, ResourcePrivilegesTests::mutateTestItem);\n+    }\n+\n+    private ResourcePrivileges createInstance() {\n+        ResourcePrivileges instance = ResourcePrivileges.builder(\"*\").addPrivilege(\"read\", true)\n+                .addPrivileges(Collections.singletonMap(\"write\", false)).build();\n+        return instance;\n+    }\n+\n+    private static ResourcePrivileges mutateTestItem(ResourcePrivileges original) {\n+        switch (randomIntBetween(0, 1)) {\n+        case 0:\n+            return ResourcePrivileges.builder(randomAlphaOfLength(6)).addPrivileges(original.getPrivileges()).build();\n+        case 1:\n+            return ResourcePrivileges.builder(original.getResource()).addPrivileges(Collections.emptyMap()).build();\n+        default:\n+            return ResourcePrivileges.builder(randomAlphaOfLength(6)).addPrivileges(Collections.emptyMap()).build();\n+        }\n+    }\n+\n+    private static MapBuilder<String, Boolean> mapBuilder() {\n+        return MapBuilder.newMapBuilder();\n+    }\n+}"
        },
        {
            "sha": "086c3a406b62f3a840c4d0746e92a3635e9711fd",
            "filename": "x-pack/plugin/core/src/test/java/org/elasticsearch/xpack/core/security/authz/support/SecurityQueryTemplateEvaluatorTests.java",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluatorTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluatorTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fcore%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fcore%2Fsecurity%2Fauthz%2Fsupport%2FSecurityQueryTemplateEvaluatorTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,94 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.core.security.authz.support;\n+\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.index.query.TermQueryBuilder;\n+import org.elasticsearch.script.Script;\n+import org.elasticsearch.script.ScriptService;\n+import org.elasticsearch.script.ScriptType;\n+import org.elasticsearch.script.TemplateScript;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.junit.Before;\n+import org.mockito.ArgumentCaptor;\n+\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.elasticsearch.common.xcontent.XContentFactory.jsonBuilder;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.sameInstance;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.verify;\n+import static org.mockito.Mockito.verifyZeroInteractions;\n+import static org.mockito.Mockito.when;\n+\n+public class SecurityQueryTemplateEvaluatorTests extends ESTestCase {\n+    private ScriptService scriptService;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        scriptService = mock(ScriptService.class);\n+    }\n+\n+    public void testTemplating() throws Exception {\n+        User user = new User(\"_username\", new String[] { \"role1\", \"role2\" }, \"_full_name\", \"_email\",\n+                Collections.singletonMap(\"key\", \"value\"), true);\n+\n+        TemplateScript.Factory compiledTemplate = templateParams -> new TemplateScript(templateParams) {\n+            @Override\n+            public String execute() {\n+                return \"rendered_text\";\n+            }\n+        };\n+\n+        when(scriptService.compile(any(Script.class), eq(TemplateScript.CONTEXT))).thenReturn(compiledTemplate);\n+\n+        XContentBuilder builder = jsonBuilder();\n+        String query = Strings.toString(new TermQueryBuilder(\"field\", \"{{_user.username}}\").toXContent(builder, ToXContent.EMPTY_PARAMS));\n+        Script script = new Script(ScriptType.INLINE, \"mustache\", query, Collections.singletonMap(\"custom\", \"value\"));\n+        builder = jsonBuilder().startObject().field(\"template\");\n+        script.toXContent(builder, ToXContent.EMPTY_PARAMS);\n+        String querySource = Strings.toString(builder.endObject());\n+\n+        SecurityQueryTemplateEvaluator.evaluateTemplate(querySource, scriptService, user);\n+        ArgumentCaptor<Script> argument = ArgumentCaptor.forClass(Script.class);\n+        verify(scriptService).compile(argument.capture(), eq(TemplateScript.CONTEXT));\n+        Script usedScript = argument.getValue();\n+        assertThat(usedScript.getIdOrCode(), equalTo(script.getIdOrCode()));\n+        assertThat(usedScript.getType(), equalTo(script.getType()));\n+        assertThat(usedScript.getLang(), equalTo(\"mustache\"));\n+        assertThat(usedScript.getOptions(), equalTo(script.getOptions()));\n+        assertThat(usedScript.getParams().size(), equalTo(2));\n+        assertThat(usedScript.getParams().get(\"custom\"), equalTo(\"value\"));\n+\n+        Map<String, Object> userModel = new HashMap<>();\n+        userModel.put(\"username\", user.principal());\n+        userModel.put(\"full_name\", user.fullName());\n+        userModel.put(\"email\", user.email());\n+        userModel.put(\"roles\", Arrays.asList(user.roles()));\n+        userModel.put(\"metadata\", user.metadata());\n+        assertThat(usedScript.getParams().get(\"_user\"), equalTo(userModel));\n+\n+    }\n+\n+    public void testSkipTemplating() throws Exception {\n+        XContentBuilder builder = jsonBuilder();\n+        String querySource = Strings.toString(new TermQueryBuilder(\"field\", \"value\").toXContent(builder, ToXContent.EMPTY_PARAMS));\n+        String result = SecurityQueryTemplateEvaluator.evaluateTemplate(querySource, scriptService, null);\n+        assertThat(result, sameInstance(querySource));\n+        verifyZeroInteractions(scriptService);\n+    }\n+\n+}"
        },
        {
            "sha": "c5a8fee50a58102ceb94e8331e3d338d3f6bde36",
            "filename": "x-pack/plugin/ml/src/main/java/org/elasticsearch/xpack/ml/action/TransportPutDatafeedAction.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fml%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fml%2Faction%2FTransportPutDatafeedAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fml%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fml%2Faction%2FTransportPutDatafeedAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fml%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fml%2Faction%2FTransportPutDatafeedAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -34,15 +34,16 @@\n import org.elasticsearch.xpack.core.XPackSettings;\n import org.elasticsearch.xpack.core.ml.MlMetadata;\n import org.elasticsearch.xpack.core.ml.action.PutDatafeedAction;\n-import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n import org.elasticsearch.xpack.core.ml.datafeed.DatafeedConfig;\n+import org.elasticsearch.xpack.core.ml.utils.ExceptionsHelper;\n import org.elasticsearch.xpack.core.rollup.action.GetRollupIndexCapsAction;\n import org.elasticsearch.xpack.core.rollup.action.RollupSearchAction;\n import org.elasticsearch.xpack.core.security.SecurityContext;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesAction;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n import org.elasticsearch.xpack.core.security.support.Exceptions;\n import org.elasticsearch.xpack.ml.datafeed.persistence.DatafeedConfigProvider;\n import org.elasticsearch.xpack.ml.job.persistence.JobConfigProvider;\n@@ -149,7 +150,7 @@ private void handlePrivsResponse(String username, PutDatafeedAction.Request requ\n         } else {\n             XContentBuilder builder = JsonXContent.contentBuilder();\n             builder.startObject();\n-            for (HasPrivilegesResponse.ResourcePrivileges index : response.getIndexPrivileges()) {\n+            for (ResourcePrivileges index : response.getIndexPrivileges()) {\n                 builder.field(index.getResource());\n                 builder.map(index.getPrivileges());\n             }"
        },
        {
            "sha": "26eec509210b69934bf6641e31acdcbaee81d8e3",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/ApiKeySSLBootstrapCheck.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheck.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheck.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheck.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security;\n+\n+import org.elasticsearch.bootstrap.BootstrapCheck;\n+import org.elasticsearch.bootstrap.BootstrapContext;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+\n+import java.util.Locale;\n+\n+/**\n+ * Bootstrap check to ensure that the user has enabled HTTPS when using the api key service\n+ */\n+public final class ApiKeySSLBootstrapCheck implements BootstrapCheck {\n+\n+    @Override\n+    public BootstrapCheckResult check(BootstrapContext context) {\n+        final Boolean httpsEnabled = XPackSettings.HTTP_SSL_ENABLED.get(context.settings());\n+        final Boolean apiKeyServiceEnabled = XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.get(context.settings());\n+        if (httpsEnabled == false && apiKeyServiceEnabled) {\n+            final String message = String.format(\n+                    Locale.ROOT,\n+                    \"HTTPS is required in order to use the API key service; \"\n+                            + \"please enable HTTPS using the [%s] setting or disable the API key service using the [%s] setting\",\n+                    XPackSettings.HTTP_SSL_ENABLED.getKey(),\n+                    XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey());\n+            return BootstrapCheckResult.failure(message);\n+        }\n+        return BootstrapCheckResult.success();\n+    }\n+\n+\n+}"
        },
        {
            "sha": "b5514c8ad98fc1e644b211a9917a4d176f5f1689",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/Security.java",
            "status": "modified",
            "additions": 45,
            "deletions": 12,
            "changes": 57,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurity.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurity.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurity.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -77,6 +77,9 @@\n import org.elasticsearch.xpack.core.security.SecurityExtension;\n import org.elasticsearch.xpack.core.security.SecurityField;\n import org.elasticsearch.xpack.core.security.SecuritySettings;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyAction;\n import org.elasticsearch.xpack.core.security.action.privilege.DeletePrivilegesAction;\n import org.elasticsearch.xpack.core.security.action.privilege.GetPrivilegesAction;\n import org.elasticsearch.xpack.core.security.action.privilege.PutPrivilegesAction;\n@@ -127,6 +130,9 @@\n import org.elasticsearch.xpack.core.ssl.action.GetCertificateInfoAction;\n import org.elasticsearch.xpack.core.ssl.action.TransportGetCertificateInfoAction;\n import org.elasticsearch.xpack.core.ssl.rest.RestGetCertificateInfoAction;\n+import org.elasticsearch.xpack.security.action.TransportCreateApiKeyAction;\n+import org.elasticsearch.xpack.security.action.TransportGetApiKeyAction;\n+import org.elasticsearch.xpack.security.action.TransportInvalidateApiKeyAction;\n import org.elasticsearch.xpack.security.action.filter.SecurityActionFilter;\n import org.elasticsearch.xpack.security.action.interceptor.BulkShardRequestInterceptor;\n import org.elasticsearch.xpack.security.action.interceptor.IndicesAliasesRequestInterceptor;\n@@ -163,6 +169,7 @@\n import org.elasticsearch.xpack.security.audit.AuditTrail;\n import org.elasticsearch.xpack.security.audit.AuditTrailService;\n import org.elasticsearch.xpack.security.audit.logfile.LoggingAuditTrail;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n import org.elasticsearch.xpack.security.authc.AuthenticationService;\n import org.elasticsearch.xpack.security.authc.InternalRealms;\n import org.elasticsearch.xpack.security.authc.Realms;\n@@ -180,6 +187,9 @@\n import org.elasticsearch.xpack.security.ingest.SetSecurityUserProcessor;\n import org.elasticsearch.xpack.security.rest.SecurityRestFilter;\n import org.elasticsearch.xpack.security.rest.action.RestAuthenticateAction;\n+import org.elasticsearch.xpack.security.rest.action.RestCreateApiKeyAction;\n+import org.elasticsearch.xpack.security.rest.action.RestGetApiKeyAction;\n+import org.elasticsearch.xpack.security.rest.action.RestInvalidateApiKeyAction;\n import org.elasticsearch.xpack.security.rest.action.oauth2.RestGetTokenAction;\n import org.elasticsearch.xpack.security.rest.action.oauth2.RestInvalidateTokenAction;\n import org.elasticsearch.xpack.security.rest.action.privilege.RestDeletePrivilegesAction;\n@@ -235,6 +245,7 @@\n import static java.util.Collections.emptyList;\n import static java.util.Collections.singletonList;\n import static org.elasticsearch.cluster.metadata.IndexMetaData.INDEX_FORMAT_SETTING;\n+import static org.elasticsearch.xpack.core.XPackSettings.API_KEY_SERVICE_ENABLED_SETTING;\n import static org.elasticsearch.xpack.core.XPackSettings.HTTP_SSL_ENABLED;\n import static org.elasticsearch.xpack.security.support.SecurityIndexManager.INTERNAL_INDEX_FORMAT;\n import static org.elasticsearch.xpack.security.support.SecurityIndexManager.SECURITY_INDEX_NAME;\n@@ -280,6 +291,7 @@ public Security(Settings settings, final Path configPath) {\n             // fetched\n             final List<BootstrapCheck> checks = new ArrayList<>();\n             checks.addAll(Arrays.asList(\n+                new ApiKeySSLBootstrapCheck(),\n                 new TokenSSLBootstrapCheck(),\n                 new PkiRealmBootstrapCheck(getSslService()),\n                 new TLSLicenseBootstrapCheck(),\n@@ -413,16 +425,10 @@ Collection<Object> createComponents(Client client, ThreadPool threadPool, Cluste\n \n         securityIndex.get().addIndexStateListener(nativeRoleMappingStore::onSecurityIndexStateChange);\n \n-        final AuthenticationFailureHandler failureHandler = createAuthenticationFailureHandler(realms);\n-\n-        authcService.set(new AuthenticationService(settings, realms, auditTrailService, failureHandler, threadPool,\n-                anonymousUser, tokenService));\n-        components.add(authcService.get());\n-        securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange);\n-\n         final NativePrivilegeStore privilegeStore = new NativePrivilegeStore(settings, client, securityIndex.get());\n         components.add(privilegeStore);\n \n+        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(settings);\n         final FileRolesStore fileRolesStore = new FileRolesStore(settings, env, resourceWatcherService, getLicenseState());\n         final NativeRolesStore nativeRolesStore = new NativeRolesStore(settings, client, getLicenseState(), securityIndex.get());\n         final ReservedRolesStore reservedRolesStore = new ReservedRolesStore();\n@@ -431,13 +437,24 @@ Collection<Object> createComponents(Client client, ThreadPool threadPool, Cluste\n             rolesProviders.addAll(extension.getRolesProviders(settings, resourceWatcherService));\n         }\n         final CompositeRolesStore allRolesStore = new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore,\n-            reservedRolesStore, privilegeStore, rolesProviders, threadPool.getThreadContext(), getLicenseState());\n+            reservedRolesStore, privilegeStore, rolesProviders, threadPool.getThreadContext(), getLicenseState(), fieldPermissionsCache);\n         securityIndex.get().addIndexStateListener(allRolesStore::onSecurityIndexStateChange);\n         // to keep things simple, just invalidate all cached entries on license change. this happens so rarely that the impact should be\n         // minimal\n         getLicenseState().addListener(allRolesStore::invalidateAll);\n+\n+        final ApiKeyService apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex.get(), clusterService,\n+                allRolesStore);\n+        components.add(apiKeyService);\n+\n+        final AuthenticationFailureHandler failureHandler = createAuthenticationFailureHandler(realms);\n+        authcService.set(new AuthenticationService(settings, realms, auditTrailService, failureHandler, threadPool,\n+                anonymousUser, tokenService, apiKeyService));\n+        components.add(authcService.get());\n+        securityIndex.get().addIndexStateListener(authcService.get()::onSecurityIndexStateChange);\n+\n         final AuthorizationService authzService = new AuthorizationService(settings, allRolesStore, clusterService,\n-            auditTrailService, failureHandler, threadPool, anonymousUser);\n+            auditTrailService, failureHandler, threadPool, anonymousUser, apiKeyService, fieldPermissionsCache);\n         components.add(nativeRolesStore); // used by roles actions\n         components.add(reservedRolesStore); // used by roles actions\n         components.add(allRolesStore); // for SecurityFeatureSet and clear roles cache\n@@ -499,6 +516,13 @@ private AuthenticationFailureHandler createAuthenticationFailureHandler(final Re\n                     defaultFailureResponseHeaders.get(\"WWW-Authenticate\").add(bearerScheme);\n                 }\n             }\n+            if (API_KEY_SERVICE_ENABLED_SETTING.get(settings)) {\n+                final String apiKeyScheme = \"ApiKey\";\n+                if (defaultFailureResponseHeaders.computeIfAbsent(\"WWW-Authenticate\", x -> new ArrayList<>())\n+                    .contains(apiKeyScheme) == false) {\n+                    defaultFailureResponseHeaders.get(\"WWW-Authenticate\").add(apiKeyScheme);\n+                }\n+            }\n             failureHandler = new DefaultAuthenticationFailureHandler(defaultFailureResponseHeaders);\n         } else {\n             logger.debug(\"Using authentication failure handler from extension [\" + extensionName + \"]\");\n@@ -583,6 +607,9 @@ public static List<Setting<?>> getSettings(boolean transportClientMode, List<Sec\n         settingsList.add(TokenService.DELETE_TIMEOUT);\n         settingsList.add(SecurityServerTransportInterceptor.TRANSPORT_TYPE_PROFILE_SETTING);\n         settingsList.addAll(SSLConfigurationSettings.getProfileSettings());\n+        settingsList.add(ApiKeyService.PASSWORD_HASHING_ALGORITHM);\n+        settingsList.add(ApiKeyService.DELETE_TIMEOUT);\n+        settingsList.add(ApiKeyService.DELETE_INTERVAL);\n \n         // hide settings\n         settingsList.add(Setting.listSetting(SecurityField.setting(\"hide_settings\"), Collections.emptyList(), Function.identity(),\n@@ -686,7 +713,10 @@ public void onIndexModule(IndexModule module) {\n                 new ActionHandler<>(SamlInvalidateSessionAction.INSTANCE, TransportSamlInvalidateSessionAction.class),\n                 new ActionHandler<>(GetPrivilegesAction.INSTANCE, TransportGetPrivilegesAction.class),\n                 new ActionHandler<>(PutPrivilegesAction.INSTANCE, TransportPutPrivilegesAction.class),\n-                new ActionHandler<>(DeletePrivilegesAction.INSTANCE, TransportDeletePrivilegesAction.class)\n+                new ActionHandler<>(DeletePrivilegesAction.INSTANCE, TransportDeletePrivilegesAction.class),\n+                new ActionHandler<>(CreateApiKeyAction.INSTANCE, TransportCreateApiKeyAction.class),\n+                new ActionHandler<>(InvalidateApiKeyAction.INSTANCE, TransportInvalidateApiKeyAction.class),\n+                new ActionHandler<>(GetApiKeyAction.INSTANCE, TransportGetApiKeyAction.class)\n         );\n     }\n \n@@ -735,7 +765,10 @@ public List<RestHandler> getRestHandlers(Settings settings, RestController restC\n                 new RestSamlInvalidateSessionAction(settings, restController, getLicenseState()),\n                 new RestGetPrivilegesAction(settings, restController, getLicenseState()),\n                 new RestPutPrivilegesAction(settings, restController, getLicenseState()),\n-                new RestDeletePrivilegesAction(settings, restController, getLicenseState())\n+                new RestDeletePrivilegesAction(settings, restController, getLicenseState()),\n+                new RestCreateApiKeyAction(settings, restController, getLicenseState()),\n+                new RestInvalidateApiKeyAction(settings, restController, getLicenseState()),\n+                new RestGetApiKeyAction(settings, restController, getLicenseState())\n         );\n     }\n \n@@ -887,7 +920,7 @@ public Function<String, Predicate<String>> getFieldFilter() {\n                     throw new IllegalStateException(\"unexpected call to getFieldFilter for index [\" + index + \"] which is not granted\");\n                 }\n                 FieldPermissions fieldPermissions = indexPermissions.getFieldPermissions();\n-                if (fieldPermissions == null) {\n+                if (fieldPermissions.hasFieldLevelSecurity() == false) {\n                     return MapperPlugin.NOOP_FIELD_PREDICATE;\n                 }\n                 return fieldPermissions::grantsAccessTo;"
        },
        {
            "sha": "53f9209ff2d7e99750cd7adc41cba3970cdde24d",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportCreateApiKeyAction.java",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportCreateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportCreateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportCreateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.SecurityContext;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+\n+/**\n+ * Implementation of the action needed to create an API key\n+ */\n+public final class TransportCreateApiKeyAction extends HandledTransportAction<CreateApiKeyRequest, CreateApiKeyResponse> {\n+\n+    private final ApiKeyService apiKeyService;\n+    private final SecurityContext securityContext;\n+\n+    @Inject\n+    public TransportCreateApiKeyAction(TransportService transportService, ActionFilters actionFilters, ApiKeyService apiKeyService,\n+                                       SecurityContext context) {\n+        super(CreateApiKeyAction.NAME, transportService, actionFilters, (Writeable.Reader<CreateApiKeyRequest>) CreateApiKeyRequest::new);\n+        this.apiKeyService = apiKeyService;\n+        this.securityContext = context;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        final Authentication authentication = securityContext.getAuthentication();\n+        if (authentication == null) {\n+            listener.onFailure(new IllegalStateException(\"authentication is required\"));\n+        } else {\n+            apiKeyService.createApiKey(authentication, request, listener);\n+        }\n+    }\n+}"
        },
        {
            "sha": "403ce482805a219fd01d9acdc3742abaf4b3664d",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportGetApiKeyAction.java",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportGetApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportGetApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportGetApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+\n+public final class TransportGetApiKeyAction extends HandledTransportAction<GetApiKeyRequest,GetApiKeyResponse> {\n+\n+    private final ApiKeyService apiKeyService;\n+\n+    @Inject\n+    public TransportGetApiKeyAction(TransportService transportService, ActionFilters actionFilters, ApiKeyService apiKeyService) {\n+        super(GetApiKeyAction.NAME, transportService, actionFilters,\n+                (Writeable.Reader<GetApiKeyRequest>) GetApiKeyRequest::new);\n+        this.apiKeyService = apiKeyService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, GetApiKeyRequest request, ActionListener<GetApiKeyResponse> listener) {\n+        if (Strings.hasText(request.getRealmName()) || Strings.hasText(request.getUserName())) {\n+            apiKeyService.getApiKeysForRealmAndUser(request.getRealmName(), request.getUserName(), listener);\n+        } else if (Strings.hasText(request.getApiKeyId())) {\n+            apiKeyService.getApiKeyForApiKeyId(request.getApiKeyId(), listener);\n+        } else if (Strings.hasText(request.getApiKeyName())) {\n+            apiKeyService.getApiKeyForApiKeyName(request.getApiKeyName(), listener);\n+        } else {\n+            listener.onFailure(new IllegalArgumentException(\"One of [api key id, api key name, username, realm name] must be specified\"));\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "886d15b1f257df71b4e076cbbfa54ed25a4f7db2",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/TransportInvalidateApiKeyAction.java",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportInvalidateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportInvalidateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2FTransportInvalidateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,44 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.action;\n+\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.ActionFilters;\n+import org.elasticsearch.action.support.HandledTransportAction;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.inject.Inject;\n+import org.elasticsearch.common.io.stream.Writeable;\n+import org.elasticsearch.tasks.Task;\n+import org.elasticsearch.transport.TransportService;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n+\n+public final class TransportInvalidateApiKeyAction extends HandledTransportAction<InvalidateApiKeyRequest, InvalidateApiKeyResponse> {\n+\n+    private final ApiKeyService apiKeyService;\n+\n+    @Inject\n+    public TransportInvalidateApiKeyAction(TransportService transportService, ActionFilters actionFilters, ApiKeyService apiKeyService) {\n+        super(InvalidateApiKeyAction.NAME, transportService, actionFilters,\n+                (Writeable.Reader<InvalidateApiKeyRequest>) InvalidateApiKeyRequest::new);\n+        this.apiKeyService = apiKeyService;\n+    }\n+\n+    @Override\n+    protected void doExecute(Task task, InvalidateApiKeyRequest request, ActionListener<InvalidateApiKeyResponse> listener) {\n+        if (Strings.hasText(request.getRealmName()) || Strings.hasText(request.getUserName())) {\n+            apiKeyService.invalidateApiKeysForRealmAndUser(request.getRealmName(), request.getUserName(), listener);\n+        } else if (Strings.hasText(request.getId())) {\n+            apiKeyService.invalidateApiKeyForApiKeyId(request.getId(), listener);\n+        } else {\n+            apiKeyService.invalidateApiKeyForApiKeyName(request.getName(), listener);\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "6cbd47e475bea4e09bf6a524c25664bbfae36b12",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/interceptor/BulkShardRequestInterceptor.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FBulkShardRequestInterceptor.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FBulkShardRequestInterceptor.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FBulkShardRequestInterceptor.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -46,7 +46,7 @@ public void intercept(BulkShardRequest request, Authentication authentication, R\n                     indicesAccessControl.getIndexPermissions(bulkItemRequest.index());\n                 if (indexAccessControl != null) {\n                     boolean fls = indexAccessControl.getFieldPermissions().hasFieldLevelSecurity();\n-                    boolean dls = indexAccessControl.getQueries() != null;\n+                    boolean dls = indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions();\n                     if (fls || dls) {\n                         if (bulkItemRequest.request() instanceof UpdateRequest) {\n                             throw new ElasticsearchSecurityException(\"Can't execute a bulk request with update requests embedded if \" +"
        },
        {
            "sha": "c9acd02e74cde97281115107c7d2e0afc37dcc05",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/interceptor/FieldAndDocumentLevelSecurityRequestInterceptor.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FFieldAndDocumentLevelSecurityRequestInterceptor.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FFieldAndDocumentLevelSecurityRequestInterceptor.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FFieldAndDocumentLevelSecurityRequestInterceptor.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -40,7 +40,7 @@ public void intercept(Request request, Authentication authentication, Role userP\n                 IndicesAccessControl.IndexAccessControl indexAccessControl = indicesAccessControl.getIndexPermissions(index);\n                 if (indexAccessControl != null) {\n                     boolean fieldLevelSecurityEnabled = indexAccessControl.getFieldPermissions().hasFieldLevelSecurity();\n-                    boolean documentLevelSecurityEnabled = indexAccessControl.getQueries() != null;\n+                    boolean documentLevelSecurityEnabled = indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions();\n                     if (fieldLevelSecurityEnabled || documentLevelSecurityEnabled) {\n                         if (fieldLevelSecurityEnabled || documentLevelSecurityEnabled) {\n                             logger.trace(\"intercepted request for index [{}] with field level access controls [{}] document level access \" +"
        },
        {
            "sha": "10c9ab0365341fe02b6bf9aaee85f2fc172e9607",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/interceptor/IndicesAliasesRequestInterceptor.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptor.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptor.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptor.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -49,7 +49,7 @@ public void intercept(IndicesAliasesRequest request, Authentication authenticati\n                             IndicesAccessControl.IndexAccessControl indexAccessControl = indicesAccessControl.getIndexPermissions(index);\n                             if (indexAccessControl != null) {\n                                 final boolean fls = indexAccessControl.getFieldPermissions().hasFieldLevelSecurity();\n-                                final boolean dls = indexAccessControl.getQueries() != null;\n+                                final boolean dls = indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions();\n                                 if (fls || dls) {\n                                     throw new ElasticsearchSecurityException(\"Alias requests are not allowed for users who have \" +\n                                         \"field or document level security enabled on one of the indices\", RestStatus.BAD_REQUEST);"
        },
        {
            "sha": "8f2e99d7defde48b2394b2f8c92124d119d776ef",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/interceptor/ResizeRequestInterceptor.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptor.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptor.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptor.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -47,7 +47,7 @@ public void intercept(ResizeRequest request, Authentication authentication, Role\n                     indicesAccessControl.getIndexPermissions(request.getSourceIndex());\n                 if (indexAccessControl != null) {\n                     final boolean fls = indexAccessControl.getFieldPermissions().hasFieldLevelSecurity();\n-                    final boolean dls = indexAccessControl.getQueries() != null;\n+                    final boolean dls = indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions();\n                     if (fls || dls) {\n                         throw new ElasticsearchSecurityException(\"Resize requests are not allowed for users when \" +\n                             \"field or document level security is enabled on the source index\", RestStatus.BAD_REQUEST);"
        },
        {
            "sha": "15060570538aff0d78336dce71f5f454cb6f2101",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/user/TransportGetUserPrivilegesAction.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportGetUserPrivilegesAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportGetUserPrivilegesAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportGetUserPrivilegesAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -60,13 +60,14 @@ public TransportGetUserPrivilegesAction(ThreadPool threadPool, TransportService\n     protected void doExecute(Task task, GetUserPrivilegesRequest request, ActionListener<GetUserPrivilegesResponse> listener) {\n         final String username = request.username();\n \n-        final User user = Authentication.getAuthentication(threadPool.getThreadContext()).getUser();\n+        final Authentication authentication = Authentication.getAuthentication(threadPool.getThreadContext());\n+        final User user = authentication.getUser();\n         if (user.principal().equals(username) == false) {\n             listener.onFailure(new IllegalArgumentException(\"users may only list the privileges of their own account\"));\n             return;\n         }\n \n-        authorizationService.roles(user, ActionListener.wrap(\n+        authorizationService.roles(user, authentication, ActionListener.wrap(\n             role -> listener.onResponse(buildResponseObject(role)),\n             listener::onFailure));\n     }"
        },
        {
            "sha": "9164d9bb7df32f5104d090e70fb94e94f6d26ff3",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/action/user/TransportHasPrivilegesAction.java",
            "status": "modified",
            "additions": 25,
            "deletions": 99,
            "changes": 124,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -5,9 +5,9 @@\n  */\n package org.elasticsearch.xpack.security.action.user;\n \n+import com.google.common.collect.Sets;\n+\n import org.apache.logging.log4j.message.ParameterizedMessage;\n-import org.apache.lucene.util.automaton.Automaton;\n-import org.apache.lucene.util.automaton.Operations;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.ActionFilters;\n import org.elasticsearch.action.support.HandledTransportAction;\n@@ -21,25 +21,19 @@\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n-import org.elasticsearch.xpack.core.security.authz.permission.IndicesPermission;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivilegesMap;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n-import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n-import org.elasticsearch.xpack.core.security.authz.privilege.IndexPrivilege;\n-import org.elasticsearch.xpack.core.security.authz.privilege.Privilege;\n-import org.elasticsearch.xpack.core.security.support.Automatons;\n import org.elasticsearch.xpack.core.security.user.User;\n import org.elasticsearch.xpack.security.authz.AuthorizationService;\n import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n \n-import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.HashMap;\n-import java.util.LinkedHashMap;\n-import java.util.List;\n import java.util.Map;\n import java.util.Set;\n import java.util.stream.Collectors;\n@@ -68,13 +62,14 @@ public TransportHasPrivilegesAction(ThreadPool threadPool, TransportService tran\n     protected void doExecute(Task task, HasPrivilegesRequest request, ActionListener<HasPrivilegesResponse> listener) {\n         final String username = request.username();\n \n-        final User user = Authentication.getAuthentication(threadPool.getThreadContext()).getUser();\n+        final Authentication authentication = Authentication.getAuthentication(threadPool.getThreadContext());\n+        final User user = authentication.getUser();\n         if (user.principal().equals(username) == false) {\n             listener.onFailure(new IllegalArgumentException(\"users may only check the privileges of their own account\"));\n             return;\n         }\n \n-        authorizationService.roles(user, ActionListener.wrap(\n+        authorizationService.roles(user, authentication, ActionListener.wrap(\n             role -> resolveApplicationPrivileges(request, ActionListener.wrap(\n                 applicationPrivilegeLookup -> checkPrivileges(request, role, applicationPrivilegeLookup, listener),\n                 listener::onFailure)),\n@@ -106,106 +101,37 @@ private void checkPrivileges(HasPrivilegesRequest request, Role userRole,\n         Map<String, Boolean> cluster = new HashMap<>();\n         for (String checkAction : request.clusterPrivileges()) {\n             final ClusterPrivilege checkPrivilege = ClusterPrivilege.get(Collections.singleton(checkAction));\n-            final ClusterPrivilege rolePrivilege = userRole.cluster().privilege();\n-            cluster.put(checkAction, testPrivilege(checkPrivilege, rolePrivilege.getAutomaton()));\n+            cluster.put(checkAction, userRole.grants(checkPrivilege));\n         }\n         boolean allMatch = cluster.values().stream().allMatch(Boolean::booleanValue);\n \n-        final Map<IndicesPermission.Group, Automaton> predicateCache = new HashMap<>();\n-\n-        final Map<String, HasPrivilegesResponse.ResourcePrivileges> indices = new LinkedHashMap<>();\n+        ResourcePrivilegesMap.Builder combineIndicesResourcePrivileges = ResourcePrivilegesMap.builder();\n         for (RoleDescriptor.IndicesPrivileges check : request.indexPrivileges()) {\n-            for (String index : check.getIndices()) {\n-                final Map<String, Boolean> privileges = new HashMap<>();\n-                final HasPrivilegesResponse.ResourcePrivileges existing = indices.get(index);\n-                if (existing != null) {\n-                    privileges.putAll(existing.getPrivileges());\n-                }\n-                for (String privilege : check.getPrivileges()) {\n-                    if (testIndexMatch(index, check.allowRestrictedIndices(), privilege, userRole, predicateCache)) {\n-                        logger.debug(() -> new ParameterizedMessage(\"Role [{}] has [{}] on index [{}]\",\n-                            Strings.arrayToCommaDelimitedString(userRole.names()), privilege, index));\n-                        privileges.put(privilege, true);\n-                    } else {\n-                        logger.debug(() -> new ParameterizedMessage(\"Role [{}] does not have [{}] on index [{}]\",\n-                            Strings.arrayToCommaDelimitedString(userRole.names()), privilege, index));\n-                        privileges.put(privilege, false);\n-                        allMatch = false;\n-                    }\n-                }\n-                indices.put(index, new HasPrivilegesResponse.ResourcePrivileges(index, privileges));\n-            }\n+            ResourcePrivilegesMap resourcePrivileges = userRole.checkIndicesPrivileges(Sets.newHashSet(check.getIndices()),\n+                    check.allowRestrictedIndices(), Sets.newHashSet(check.getPrivileges()));\n+            allMatch = allMatch && resourcePrivileges.allAllowed();\n+            combineIndicesResourcePrivileges.addResourcePrivilegesMap(resourcePrivileges);\n         }\n+        ResourcePrivilegesMap allIndices = combineIndicesResourcePrivileges.build();\n+        allMatch = allMatch && allIndices.allAllowed();\n \n-        final Map<String, Collection<HasPrivilegesResponse.ResourcePrivileges>> privilegesByApplication = new HashMap<>();\n+        final Map<String, Collection<ResourcePrivileges>> privilegesByApplication = new HashMap<>();\n         for (String applicationName : getApplicationNames(request)) {\n-            logger.debug(\"Checking privileges for application {}\", applicationName);\n-            final Map<String, HasPrivilegesResponse.ResourcePrivileges> appPrivilegesByResource = new LinkedHashMap<>();\n+            ResourcePrivilegesMap.Builder builder = ResourcePrivilegesMap.builder();\n             for (RoleDescriptor.ApplicationResourcePrivileges p : request.applicationPrivileges()) {\n                 if (applicationName.equals(p.getApplication())) {\n-                    for (String resource : p.getResources()) {\n-                        final Map<String, Boolean> privileges = new HashMap<>();\n-                        final HasPrivilegesResponse.ResourcePrivileges existing = appPrivilegesByResource.get(resource);\n-                        if (existing != null) {\n-                            privileges.putAll(existing.getPrivileges());\n-                        }\n-                        for (String privilege : p.getPrivileges()) {\n-                            if (testResourceMatch(applicationName, resource, privilege, userRole, applicationPrivileges)) {\n-                                logger.debug(() -> new ParameterizedMessage(\"Role [{}] has [{} {}] on resource [{}]\",\n-                                    Strings.arrayToCommaDelimitedString(userRole.names()), applicationName, privilege, resource));\n-                                privileges.put(privilege, true);\n-                            } else {\n-                                logger.debug(() -> new ParameterizedMessage(\"Role [{}] does not have [{} {}] on resource [{}]\",\n-                                    Strings.arrayToCommaDelimitedString(userRole.names()), applicationName, privilege, resource));\n-                                privileges.put(privilege, false);\n-                                allMatch = false;\n-                            }\n-                        }\n-                        appPrivilegesByResource.put(resource, new HasPrivilegesResponse.ResourcePrivileges(resource, privileges));\n-                    }\n+                    ResourcePrivilegesMap appPrivsByResourceMap = userRole.checkApplicationResourcePrivileges(applicationName,\n+                            Sets.newHashSet(p.getResources()), Sets.newHashSet(p.getPrivileges()), applicationPrivileges);\n+                    builder.addResourcePrivilegesMap(appPrivsByResourceMap);\n                 }\n             }\n-            privilegesByApplication.put(applicationName, appPrivilegesByResource.values());\n+            ResourcePrivilegesMap resourcePrivsForApplication = builder.build();\n+            allMatch = allMatch && resourcePrivsForApplication.allAllowed();\n+            privilegesByApplication.put(applicationName, resourcePrivsForApplication.getResourceToResourcePrivileges().values());\n         }\n \n-        listener.onResponse(new HasPrivilegesResponse(request.username(), allMatch, cluster, indices.values(), privilegesByApplication));\n-    }\n-\n-    private boolean testIndexMatch(String checkIndexPattern, boolean allowRestrictedIndices, String checkPrivilegeName, Role userRole,\n-            Map<IndicesPermission.Group, Automaton> predicateCache) {\n-        final IndexPrivilege checkPrivilege = IndexPrivilege.get(Collections.singleton(checkPrivilegeName));\n-\n-        final Automaton checkIndexAutomaton = IndicesPermission.Group.buildIndexMatcherAutomaton(allowRestrictedIndices, checkIndexPattern);\n-\n-        List<Automaton> privilegeAutomatons = new ArrayList<>();\n-        for (IndicesPermission.Group group : userRole.indices().groups()) {\n-            final Automaton groupIndexAutomaton = predicateCache.computeIfAbsent(group,\n-                    g -> IndicesPermission.Group.buildIndexMatcherAutomaton(g.allowRestrictedIndices(), g.indices()));\n-            if (Operations.subsetOf(checkIndexAutomaton, groupIndexAutomaton)) {\n-                final IndexPrivilege rolePrivilege = group.privilege();\n-                if (rolePrivilege.name().contains(checkPrivilegeName)) {\n-                    return true;\n-                }\n-                privilegeAutomatons.add(rolePrivilege.getAutomaton());\n-            }\n-        }\n-        return testPrivilege(checkPrivilege, Automatons.unionAndMinimize(privilegeAutomatons));\n-    }\n-\n-    private static boolean testPrivilege(Privilege checkPrivilege, Automaton roleAutomaton) {\n-        return Operations.subsetOf(checkPrivilege.getAutomaton(), roleAutomaton);\n-    }\n-\n-    private boolean testResourceMatch(String application, String checkResource, String checkPrivilegeName, Role userRole,\n-                                      Collection<ApplicationPrivilegeDescriptor> privileges) {\n-        final Set<String> nameSet = Collections.singleton(checkPrivilegeName);\n-        final ApplicationPrivilege checkPrivilege = ApplicationPrivilege.get(application, nameSet, privileges);\n-        assert checkPrivilege.getApplication().equals(application)\n-            : \"Privilege \" + checkPrivilege + \" should have application \" + application;\n-        assert checkPrivilege.name().equals(nameSet)\n-            : \"Privilege \" + checkPrivilege + \" should have name \" + nameSet;\n-\n-        return userRole.application().grants(checkPrivilege, checkResource);\n+        listener.onResponse(new HasPrivilegesResponse(request.username(), allMatch, cluster,\n+                allIndices.getResourceToResourcePrivileges().values(), privilegesByApplication));\n     }\n \n }"
        },
        {
            "sha": "c2972b013ff056133da8d749dec2ac107fd0f329",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ApiKeyService.java",
            "status": "added",
            "additions": 844,
            "deletions": 0,
            "changes": 844,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyService.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyService.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyService.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,844 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc;\n+\n+import com.google.common.collect.Sets;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchException;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.ExceptionsHelper;\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.DocWriteResponse;\n+import org.elasticsearch.action.bulk.BulkItemResponse;\n+import org.elasticsearch.action.bulk.BulkRequestBuilder;\n+import org.elasticsearch.action.bulk.BulkResponse;\n+import org.elasticsearch.action.get.GetRequest;\n+import org.elasticsearch.action.get.GetResponse;\n+import org.elasticsearch.action.index.IndexAction;\n+import org.elasticsearch.action.index.IndexRequest;\n+import org.elasticsearch.action.search.SearchRequest;\n+import org.elasticsearch.action.support.WriteRequest.RefreshPolicy;\n+import org.elasticsearch.action.update.UpdateRequest;\n+import org.elasticsearch.action.update.UpdateResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.cluster.service.ClusterService;\n+import org.elasticsearch.common.CharArrays;\n+import org.elasticsearch.common.Nullable;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.logging.DeprecationLogger;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Setting;\n+import org.elasticsearch.common.settings.Setting.Property;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.DeprecationHandler;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentFactory;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.index.query.BoolQueryBuilder;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.search.SearchHit;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.security.ScrollHelper;\n+import org.elasticsearch.xpack.core.security.action.ApiKey;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationResult;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.Role;\n+import org.elasticsearch.xpack.core.security.authz.permission.LimitedRole;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+\n+import java.io.Closeable;\n+import java.io.IOException;\n+import java.io.UncheckedIOException;\n+import java.security.NoSuchAlgorithmException;\n+import java.time.Clock;\n+import java.time.Instant;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.function.Function;\n+import java.util.stream.Collectors;\n+\n+import javax.crypto.SecretKeyFactory;\n+\n+import static org.elasticsearch.search.SearchService.DEFAULT_KEEPALIVE_SETTING;\n+import static org.elasticsearch.xpack.core.ClientHelper.SECURITY_ORIGIN;\n+import static org.elasticsearch.xpack.core.ClientHelper.executeAsyncWithOrigin;\n+\n+public class ApiKeyService {\n+\n+    private static final Logger logger = LogManager.getLogger(ApiKeyService.class);\n+    private static final DeprecationLogger deprecationLogger = new DeprecationLogger(logger);\n+    private static final String TYPE = \"doc\";\n+    static final String API_KEY_ID_KEY = \"_security_api_key_id\";\n+    static final String API_KEY_ROLE_DESCRIPTORS_KEY = \"_security_api_key_role_descriptors\";\n+    static final String API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY = \"_security_api_key_limited_by_role_descriptors\";\n+    static final String API_KEY_ROLE_KEY = \"_security_api_key_role\";\n+\n+    public static final Setting<String> PASSWORD_HASHING_ALGORITHM = new Setting<>(\n+        \"xpack.security.authc.api_key_hashing.algorithm\", \"pbkdf2\", Function.identity(), v -> {\n+        if (Hasher.getAvailableAlgoStoredHash().contains(v.toLowerCase(Locale.ROOT)) == false) {\n+            throw new IllegalArgumentException(\"Invalid algorithm: \" + v + \". Valid values for password hashing are \" +\n+                Hasher.getAvailableAlgoStoredHash().toString());\n+        } else if (v.regionMatches(true, 0, \"pbkdf2\", 0, \"pbkdf2\".length())) {\n+            try {\n+                SecretKeyFactory.getInstance(\"PBKDF2withHMACSHA512\");\n+            } catch (NoSuchAlgorithmException e) {\n+                throw new IllegalArgumentException(\n+                    \"Support for PBKDF2WithHMACSHA512 must be available in order to use any of the \" +\n+                        \"PBKDF2 algorithms for the [xpack.security.authc.api_key.hashing.algorithm] setting.\", e);\n+            }\n+        }\n+    }, Setting.Property.NodeScope);\n+    public static final Setting<TimeValue> DELETE_TIMEOUT = Setting.timeSetting(\"xpack.security.authc.api_key.delete.timeout\",\n+            TimeValue.MINUS_ONE, Property.NodeScope);\n+    public static final Setting<TimeValue> DELETE_INTERVAL = Setting.timeSetting(\"xpack.security.authc.api_key.delete.interval\",\n+            TimeValue.timeValueHours(24L), Property.NodeScope);\n+\n+    private final Clock clock;\n+    private final Client client;\n+    private final SecurityIndexManager securityIndex;\n+    private final ClusterService clusterService;\n+    private final Hasher hasher;\n+    private final boolean enabled;\n+    private final Settings settings;\n+    private final ExpiredApiKeysRemover expiredApiKeysRemover;\n+    private final TimeValue deleteInterval;\n+    private final CompositeRolesStore compositeRolesStore;\n+\n+    private volatile long lastExpirationRunMs;\n+\n+    public ApiKeyService(Settings settings, Clock clock, Client client, SecurityIndexManager securityIndex, ClusterService clusterService,\n+            CompositeRolesStore compositeRolesStore) {\n+        this.clock = clock;\n+        this.client = client;\n+        this.securityIndex = securityIndex;\n+        this.clusterService = clusterService;\n+        this.enabled = XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.get(settings);\n+        this.hasher = Hasher.resolve(PASSWORD_HASHING_ALGORITHM.get(settings));\n+        this.settings = settings;\n+        this.deleteInterval = DELETE_INTERVAL.get(settings);\n+        this.expiredApiKeysRemover = new ExpiredApiKeysRemover(settings, client);\n+        this.compositeRolesStore = compositeRolesStore;\n+    }\n+\n+    /**\n+     * Asynchronously creates a new API key based off of the request and authentication\n+     * @param authentication the authentication that this api key should be based off of\n+     * @param request the request to create the api key included any permission restrictions\n+     * @param listener the listener that will be used to notify of completion\n+     */\n+    public void createApiKey(Authentication authentication, CreateApiKeyRequest request, ActionListener<CreateApiKeyResponse> listener) {\n+        ensureEnabled();\n+        if (authentication == null) {\n+            listener.onFailure(new IllegalArgumentException(\"authentication must be provided\"));\n+        } else {\n+            /*\n+             * Check if requested API key name already exists to avoid duplicate key names,\n+             * this check is best effort as there could be two nodes executing search and\n+             * then index concurrently allowing a duplicate name.\n+             */\n+            findApiKeyForApiKeyName(request.getName(), true, true, ActionListener.wrap(apiKeyIds -> {\n+                if (apiKeyIds.isEmpty()) {\n+                    final Instant created = clock.instant();\n+                    final Instant expiration = getApiKeyExpiration(created, request);\n+                    final SecureString apiKey = UUIDs.randomBase64UUIDSecureString();\n+                    final Version version = clusterService.state().nodes().getMinNodeVersion();\n+                    if (version.before(Version.V_7_0_0)) { // TODO(jaymode) change to V6_6_0 on backport!\n+                        logger.warn(\n+                                \"nodes prior to the minimum supported version for api keys {} exist in the cluster;\"\n+                                        + \" these nodes will not be able to use api keys\",\n+                                Version.V_7_0_0);\n+                    }\n+\n+                    final char[] keyHash = hasher.hash(apiKey);\n+                    try (XContentBuilder builder = XContentFactory.jsonBuilder()) {\n+                        builder.startObject()\n+                            .field(\"doc_type\", \"api_key\")\n+                            .field(\"creation_time\", created.toEpochMilli())\n+                            .field(\"expiration_time\", expiration == null ? null : expiration.toEpochMilli())\n+                            .field(\"api_key_invalidated\", false);\n+\n+                        byte[] utf8Bytes = null;\n+                        try {\n+                            utf8Bytes = CharArrays.toUtf8Bytes(keyHash);\n+                            builder.field(\"api_key_hash\").utf8Value(utf8Bytes, 0, utf8Bytes.length);\n+                        } finally {\n+                            if (utf8Bytes != null) {\n+                                Arrays.fill(utf8Bytes, (byte) 0);\n+                            }\n+                        }\n+\n+                        // Save role_descriptors\n+                        builder.startObject(\"role_descriptors\");\n+                        if (request.getRoleDescriptors() != null && request.getRoleDescriptors().isEmpty() == false) {\n+                            for (RoleDescriptor descriptor : request.getRoleDescriptors()) {\n+                                builder.field(descriptor.getName(),\n+                                        (contentBuilder, params) -> descriptor.toXContent(contentBuilder, params, true));\n+                            }\n+                        }\n+                        builder.endObject();\n+\n+                        // Save limited_by_role_descriptors\n+                        builder.startObject(\"limited_by_role_descriptors\");\n+                        compositeRolesStore.getRoleDescriptors(Sets.newHashSet(authentication.getUser().roles()),\n+                                ActionListener.wrap(rdSet -> {\n+                                    for (RoleDescriptor descriptor : rdSet) {\n+                                        builder.field(descriptor.getName(),\n+                                                (contentBuilder, params) -> descriptor.toXContent(contentBuilder, params, true));\n+                                    }\n+                                }, listener::onFailure));\n+                        builder.endObject();\n+\n+                        builder.field(\"name\", request.getName())\n+                            .field(\"version\", version.id)\n+                            .startObject(\"creator\")\n+                            .field(\"principal\", authentication.getUser().principal())\n+                            .field(\"metadata\", authentication.getUser().metadata())\n+                            .field(\"realm\", authentication.getLookedUpBy() == null ?\n+                                authentication.getAuthenticatedBy().getName() : authentication.getLookedUpBy().getName())\n+                            .endObject()\n+                            .endObject();\n+                        final IndexRequest indexRequest =\n+                            client.prepareIndex(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE)\n+                                .setSource(builder)\n+                                .setRefreshPolicy(request.getRefreshPolicy())\n+                                .request();\n+                        securityIndex.prepareIndexIfNeededThenExecute(listener::onFailure, () ->\n+                        executeAsyncWithOrigin(client, SECURITY_ORIGIN, IndexAction.INSTANCE, indexRequest,\n+                                ActionListener.wrap(\n+                                        indexResponse -> listener.onResponse(\n+                                                new CreateApiKeyResponse(request.getName(), indexResponse.getId(), apiKey, expiration)),\n+                                        listener::onFailure)));\n+                    } catch (IOException e) {\n+                        listener.onFailure(e);\n+                    } finally {\n+                        Arrays.fill(keyHash, (char) 0);\n+                    }\n+                } else {\n+                    listener.onFailure(traceLog(\"create api key\", new ElasticsearchSecurityException(\n+                            \"Error creating api key as api key with name [{}] already exists\", request.getName())));\n+                }\n+            }, listener::onFailure));\n+        }\n+    }\n+\n+    /**\n+     * Checks for the presence of a {@code Authorization} header with a value that starts with\n+     * {@code ApiKey }. If found this will attempt to authenticate the key.\n+     */\n+    void authenticateWithApiKeyIfPresent(ThreadContext ctx, ActionListener<AuthenticationResult> listener) {\n+        if (enabled) {\n+            final ApiKeyCredentials credentials;\n+            try {\n+                credentials = getCredentialsFromHeader(ctx);\n+            } catch (IllegalArgumentException iae) {\n+                listener.onResponse(AuthenticationResult.unsuccessful(iae.getMessage(), iae));\n+                return;\n+            }\n+\n+            if (credentials != null) {\n+                final GetRequest getRequest = client.prepareGet(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, credentials.getId())\n+                    .setFetchSource(true).request();\n+                executeAsyncWithOrigin(ctx, SECURITY_ORIGIN, getRequest, ActionListener.<GetResponse>wrap(response -> {\n+                    if (response.isExists()) {\n+                        try (ApiKeyCredentials ignore = credentials) {\n+                            final Map<String, Object> source = response.getSource();\n+                            validateApiKeyCredentials(source, credentials, clock, listener);\n+                        }\n+                    } else {\n+                        credentials.close();\n+                        listener.onResponse(\n+                            AuthenticationResult.unsuccessful(\"unable to find apikey with id \" + credentials.getId(), null));\n+                    }\n+                }, e -> {\n+                    credentials.close();\n+                    listener.onResponse(AuthenticationResult.unsuccessful(\"apikey authentication for id \" + credentials.getId() +\n+                        \" encountered a failure\", e));\n+                }), client::get);\n+            } else {\n+                listener.onResponse(AuthenticationResult.notHandled());\n+            }\n+        } else {\n+            listener.onResponse(AuthenticationResult.notHandled());\n+        }\n+    }\n+\n+    /**\n+     * The current request has been authenticated by an API key and this method enables the\n+     * retrieval of role descriptors that are associated with the api key and triggers the building\n+     * of the {@link Role} to authorize the request.\n+     */\n+    public void getRoleForApiKey(Authentication authentication, CompositeRolesStore rolesStore, ActionListener<Role> listener) {\n+        if (authentication.getAuthenticationType() != Authentication.AuthenticationType.API_KEY) {\n+            throw new IllegalStateException(\"authentication type must be api key but is \" + authentication.getAuthenticationType());\n+        }\n+\n+        final Map<String, Object> metadata = authentication.getMetadata();\n+        final String apiKeyId = (String) metadata.get(API_KEY_ID_KEY);\n+\n+        final Map<String, Object> roleDescriptors = (Map<String, Object>) metadata.get(API_KEY_ROLE_DESCRIPTORS_KEY);\n+        final Map<String, Object> authnRoleDescriptors = (Map<String, Object>) metadata.get(API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY);\n+\n+        if (roleDescriptors == null && authnRoleDescriptors == null) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"no role descriptors found for API key\"));\n+        } else if (roleDescriptors == null || roleDescriptors.isEmpty()) {\n+            final List<RoleDescriptor> authnRoleDescriptorsList = parseRoleDescriptors(apiKeyId, authnRoleDescriptors);\n+            rolesStore.buildAndCacheRoleFromDescriptors(authnRoleDescriptorsList, apiKeyId, listener);\n+        } else {\n+            final List<RoleDescriptor> roleDescriptorList = parseRoleDescriptors(apiKeyId, roleDescriptors);\n+            final List<RoleDescriptor> authnRoleDescriptorsList = parseRoleDescriptors(apiKeyId, authnRoleDescriptors);\n+            rolesStore.buildAndCacheRoleFromDescriptors(roleDescriptorList, apiKeyId, ActionListener.wrap(role -> {\n+                rolesStore.buildAndCacheRoleFromDescriptors(authnRoleDescriptorsList, apiKeyId, ActionListener.wrap(limitedByRole -> {\n+                    Role finalRole = LimitedRole.createLimitedRole(role, limitedByRole);\n+                    listener.onResponse(finalRole);\n+                }, listener::onFailure));\n+            }, listener::onFailure));\n+        }\n+\n+    }\n+\n+    private List<RoleDescriptor> parseRoleDescriptors(final String apiKeyId, final Map<String, Object> roleDescriptors) {\n+        if (roleDescriptors == null) {\n+            return null;\n+        }\n+        return roleDescriptors.entrySet().stream()\n+            .map(entry -> {\n+                final String name = entry.getKey();\n+                final Map<String, Object> rdMap = (Map<String, Object>) entry.getValue();\n+                try (XContentBuilder builder = XContentBuilder.builder(XContentType.JSON.xContent())) {\n+                    builder.map(rdMap);\n+                    try (XContentParser parser = XContentType.JSON.xContent().createParser(NamedXContentRegistry.EMPTY,\n+                        new ApiKeyLoggingDeprecationHandler(deprecationLogger, apiKeyId),\n+                        BytesReference.bytes(builder).streamInput())) {\n+                        return RoleDescriptor.parse(name, parser, false);\n+                    }\n+                } catch (IOException e) {\n+                    throw new UncheckedIOException(e);\n+                }\n+            }).collect(Collectors.toList());\n+    }\n+\n+    /**\n+     * Validates the ApiKey using the source map\n+     * @param source the source map from a get of the ApiKey document\n+     * @param credentials the credentials provided by the user\n+     * @param listener the listener to notify after verification\n+     */\n+    static void validateApiKeyCredentials(Map<String, Object> source, ApiKeyCredentials credentials, Clock clock,\n+                                          ActionListener<AuthenticationResult> listener) {\n+        final Boolean invalidated = (Boolean) source.get(\"api_key_invalidated\");\n+        if (invalidated == null) {\n+            listener.onResponse(AuthenticationResult.terminate(\"api key document is missing invalidated field\", null));\n+        } else if (invalidated) {\n+            listener.onResponse(AuthenticationResult.terminate(\"api key has been invalidated\", null));\n+        } else {\n+            final String apiKeyHash = (String) source.get(\"api_key_hash\");\n+            if (apiKeyHash == null) {\n+                throw new IllegalStateException(\"api key hash is missing\");\n+            }\n+            final boolean verified = verifyKeyAgainstHash(apiKeyHash, credentials);\n+\n+            if (verified) {\n+                final Long expirationEpochMilli = (Long) source.get(\"expiration_time\");\n+                if (expirationEpochMilli == null || Instant.ofEpochMilli(expirationEpochMilli).isAfter(clock.instant())) {\n+                    final Map<String, Object> creator = Objects.requireNonNull((Map<String, Object>) source.get(\"creator\"));\n+                    final String principal = Objects.requireNonNull((String) creator.get(\"principal\"));\n+                    final Map<String, Object> metadata = (Map<String, Object>) creator.get(\"metadata\");\n+                    final Map<String, Object> roleDescriptors = (Map<String, Object>) source.get(\"role_descriptors\");\n+                    final Map<String, Object> limitedByRoleDescriptors = (Map<String, Object>) source.get(\"limited_by_role_descriptors\");\n+                    final String[] roleNames = (roleDescriptors != null) ? roleDescriptors.keySet().toArray(Strings.EMPTY_ARRAY)\n+                            : limitedByRoleDescriptors.keySet().toArray(Strings.EMPTY_ARRAY);\n+                    final User apiKeyUser = new User(principal, roleNames, null, null, metadata, true);\n+                    final Map<String, Object> authResultMetadata = new HashMap<>();\n+                    authResultMetadata.put(API_KEY_ROLE_DESCRIPTORS_KEY, roleDescriptors);\n+                    authResultMetadata.put(API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY, limitedByRoleDescriptors);\n+                    authResultMetadata.put(API_KEY_ID_KEY, credentials.getId());\n+                    listener.onResponse(AuthenticationResult.success(apiKeyUser, authResultMetadata));\n+                } else {\n+                    listener.onResponse(AuthenticationResult.terminate(\"api key is expired\", null));\n+                }\n+            } else {\n+                listener.onResponse(AuthenticationResult.unsuccessful(\"invalid credentials\", null));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the API Key from the <code>Authorization</code> header if the header begins with\n+     * <code>ApiKey </code>\n+     */\n+    static ApiKeyCredentials getCredentialsFromHeader(ThreadContext threadContext) {\n+        String header = threadContext.getHeader(\"Authorization\");\n+        if (Strings.hasText(header) && header.regionMatches(true, 0, \"ApiKey \", 0, \"ApiKey \".length())\n+            && header.length() > \"ApiKey \".length()) {\n+            final byte[] decodedApiKeyCredBytes = Base64.getDecoder().decode(header.substring(\"ApiKey \".length()));\n+            char[] apiKeyCredChars = null;\n+            try {\n+                apiKeyCredChars = CharArrays.utf8BytesToChars(decodedApiKeyCredBytes);\n+                int colonIndex = -1;\n+                for (int i = 0; i < apiKeyCredChars.length; i++) {\n+                    if (apiKeyCredChars[i] == ':') {\n+                        colonIndex = i;\n+                        break;\n+                    }\n+                }\n+\n+                if (colonIndex < 1) {\n+                    throw new IllegalArgumentException(\"invalid ApiKey value\");\n+                }\n+                return new ApiKeyCredentials(new String(Arrays.copyOfRange(apiKeyCredChars, 0, colonIndex)),\n+                    new SecureString(Arrays.copyOfRange(apiKeyCredChars, colonIndex + 1, apiKeyCredChars.length)));\n+            } finally {\n+                if (apiKeyCredChars != null) {\n+                    Arrays.fill(apiKeyCredChars, (char) 0);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    private static boolean verifyKeyAgainstHash(String apiKeyHash, ApiKeyCredentials credentials) {\n+        final char[] apiKeyHashChars = apiKeyHash.toCharArray();\n+        try {\n+            Hasher hasher = Hasher.resolveFromHash(apiKeyHash.toCharArray());\n+            return hasher.verify(credentials.getKey(), apiKeyHashChars);\n+        } finally {\n+            Arrays.fill(apiKeyHashChars, (char) 0);\n+        }\n+    }\n+\n+    private Instant getApiKeyExpiration(Instant now, CreateApiKeyRequest request) {\n+        if (request.getExpiration() != null) {\n+            return now.plusSeconds(request.getExpiration().getSeconds());\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private void ensureEnabled() {\n+        if (enabled == false) {\n+            throw new IllegalStateException(\"api keys are not enabled\");\n+        }\n+    }\n+\n+    // package private class for testing\n+    static final class ApiKeyCredentials implements Closeable {\n+        private final String id;\n+        private final SecureString key;\n+\n+        ApiKeyCredentials(String id, SecureString key) {\n+            this.id = id;\n+            this.key = key;\n+        }\n+\n+        String getId() {\n+            return id;\n+        }\n+\n+        SecureString getKey() {\n+            return key;\n+        }\n+\n+        @Override\n+        public void close() {\n+            key.close();\n+        }\n+    }\n+\n+    private static class ApiKeyLoggingDeprecationHandler implements DeprecationHandler {\n+\n+        private final DeprecationLogger deprecationLogger;\n+        private final String apiKeyId;\n+\n+        private ApiKeyLoggingDeprecationHandler(DeprecationLogger logger, String apiKeyId) {\n+            this.deprecationLogger = logger;\n+            this.apiKeyId = apiKeyId;\n+        }\n+\n+        @Override\n+        public void usedDeprecatedName(String usedName, String modernName) {\n+            deprecationLogger.deprecated(\"Deprecated field [{}] used in api key [{}], expected [{}] instead\",\n+                usedName, apiKeyId, modernName);\n+        }\n+\n+        @Override\n+        public void usedDeprecatedField(String usedName, String replacedWith) {\n+            deprecationLogger.deprecated(\"Deprecated field [{}] used in api key [{}], replaced by [{}]\",\n+                usedName, apiKeyId, replacedWith);\n+        }\n+    }\n+\n+    /**\n+     * Invalidate API keys for given realm and user name.\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @param invalidateListener listener for {@link InvalidateApiKeyResponse}\n+     */\n+    public void invalidateApiKeysForRealmAndUser(String realmName, String userName,\n+                                                 ActionListener<InvalidateApiKeyResponse> invalidateListener) {\n+        ensureEnabled();\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false) {\n+            logger.trace(\"No realm name or username provided\");\n+            invalidateListener.onFailure(new IllegalArgumentException(\"realm name or username must be provided\"));\n+        } else {\n+            findApiKeysForUserAndRealm(userName, realmName, true, false, ActionListener.wrap(apiKeyIds -> {\n+                if (apiKeyIds.isEmpty()) {\n+                    logger.warn(\"No active api keys to invalidate for realm [{}] and username [{}]\", realmName, userName);\n+                    invalidateListener.onResponse(InvalidateApiKeyResponse.emptyResponse());\n+                } else {\n+                    invalidateAllApiKeys(apiKeyIds.stream().map(apiKey -> apiKey.getId()).collect(Collectors.toSet()), invalidateListener);\n+                }\n+            }, invalidateListener::onFailure));\n+        }\n+    }\n+\n+    private void invalidateAllApiKeys(Collection<String> apiKeyIds, ActionListener<InvalidateApiKeyResponse> invalidateListener) {\n+        indexInvalidation(apiKeyIds, invalidateListener, null);\n+    }\n+\n+    /**\n+     * Invalidate API key for given API key id\n+     * @param apiKeyId API key id\n+     * @param invalidateListener listener for {@link InvalidateApiKeyResponse}\n+     */\n+    public void invalidateApiKeyForApiKeyId(String apiKeyId, ActionListener<InvalidateApiKeyResponse> invalidateListener) {\n+        ensureEnabled();\n+        if (Strings.hasText(apiKeyId) == false) {\n+            logger.trace(\"No api key id provided\");\n+            invalidateListener.onFailure(new IllegalArgumentException(\"api key id must be provided\"));\n+        } else {\n+            findApiKeysForApiKeyId(apiKeyId, true, false, ActionListener.wrap(apiKeyIds -> {\n+                if (apiKeyIds.isEmpty()) {\n+                    logger.warn(\"No api key to invalidate for api key id [{}]\", apiKeyId);\n+                    invalidateListener.onResponse(InvalidateApiKeyResponse.emptyResponse());\n+                } else {\n+                    invalidateAllApiKeys(apiKeyIds.stream().map(apiKey -> apiKey.getId()).collect(Collectors.toSet()), invalidateListener);\n+                }\n+            }, invalidateListener::onFailure));\n+        }\n+    }\n+\n+    /**\n+     * Invalidate API key for given API key name\n+     * @param apiKeyName API key name\n+     * @param invalidateListener listener for {@link InvalidateApiKeyResponse}\n+     */\n+    public void invalidateApiKeyForApiKeyName(String apiKeyName, ActionListener<InvalidateApiKeyResponse> invalidateListener) {\n+        ensureEnabled();\n+        if (Strings.hasText(apiKeyName) == false) {\n+            logger.trace(\"No api key name provided\");\n+            invalidateListener.onFailure(new IllegalArgumentException(\"api key name must be provided\"));\n+        } else {\n+            findApiKeyForApiKeyName(apiKeyName, true, false, ActionListener.wrap(apiKeyIds -> {\n+                if (apiKeyIds.isEmpty()) {\n+                    logger.warn(\"No api key to invalidate for api key name [{}]\", apiKeyName);\n+                    invalidateListener.onResponse(InvalidateApiKeyResponse.emptyResponse());\n+                } else {\n+                    invalidateAllApiKeys(apiKeyIds.stream().map(apiKey -> apiKey.getId()).collect(Collectors.toSet()), invalidateListener);\n+                }\n+            }, invalidateListener::onFailure));\n+        }\n+    }\n+\n+    private void findApiKeysForUserAndRealm(String userName, String realmName, boolean filterOutInvalidatedKeys,\n+                                            boolean filterOutExpiredKeys, ActionListener<Collection<ApiKey>> listener) {\n+        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();\n+        if (frozenSecurityIndex.indexExists() == false) {\n+            listener.onResponse(Collections.emptyList());\n+        } else if (frozenSecurityIndex.isAvailable() == false) {\n+            listener.onFailure(frozenSecurityIndex.getUnavailableReason());\n+        } else {\n+            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()\n+                .filter(QueryBuilders.termQuery(\"doc_type\", \"api_key\"));\n+            if (Strings.hasText(userName)) {\n+                boolQuery.filter(QueryBuilders.termQuery(\"creator.principal\", userName));\n+            }\n+            if (Strings.hasText(realmName)) {\n+                boolQuery.filter(QueryBuilders.termQuery(\"creator.realm\", realmName));\n+            }\n+\n+            findApiKeys(boolQuery, filterOutInvalidatedKeys, filterOutExpiredKeys, listener);\n+        }\n+    }\n+\n+    private void findApiKeys(final BoolQueryBuilder boolQuery, boolean filterOutInvalidatedKeys, boolean filterOutExpiredKeys,\n+                             ActionListener<Collection<ApiKey>> listener) {\n+        if (filterOutInvalidatedKeys) {\n+            boolQuery.filter(QueryBuilders.termQuery(\"api_key_invalidated\", false));\n+        }\n+        if (filterOutExpiredKeys) {\n+            final BoolQueryBuilder expiredQuery = QueryBuilders.boolQuery();\n+            expiredQuery.should(QueryBuilders.rangeQuery(\"expiration_time\").lte(Instant.now().toEpochMilli()));\n+            expiredQuery.should(QueryBuilders.boolQuery().mustNot(QueryBuilders.existsQuery(\"expiration_time\")));\n+            boolQuery.filter(expiredQuery);\n+        }\n+\n+        final SearchRequest request = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+            .setScroll(DEFAULT_KEEPALIVE_SETTING.get(settings))\n+            .setQuery(boolQuery)\n+            .setVersion(false)\n+            .setSize(1000)\n+            .setFetchSource(true)\n+            .request();\n+        securityIndex.checkIndexVersionThenExecute(listener::onFailure,\n+            () -> ScrollHelper.fetchAllByEntity(client, request, listener,\n+                        (SearchHit hit) -> {\n+                            Map<String, Object> source = hit.getSourceAsMap();\n+                            String name = (String) source.get(\"name\");\n+                            String id = hit.getId();\n+                            Long creation = (Long) source.get(\"creation_time\");\n+                            Long expiration = (Long) source.get(\"expiration_time\");\n+                            Boolean invalidated = (Boolean) source.get(\"api_key_invalidated\");\n+                            String username = (String) ((Map<String, Object>) source.get(\"creator\")).get(\"principal\");\n+                            String realm = (String) ((Map<String, Object>) source.get(\"creator\")).get(\"realm\");\n+                            return new ApiKey(name, id, Instant.ofEpochMilli(creation),\n+                                    (expiration != null) ? Instant.ofEpochMilli(expiration) : null, invalidated, username, realm);\n+                        }));\n+    }\n+\n+    private void findApiKeyForApiKeyName(String apiKeyName, boolean filterOutInvalidatedKeys, boolean filterOutExpiredKeys,\n+                                         ActionListener<Collection<ApiKey>> listener) {\n+        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();\n+        if (frozenSecurityIndex.indexExists() == false) {\n+            listener.onResponse(Collections.emptyList());\n+        } else if (frozenSecurityIndex.isAvailable() == false) {\n+            listener.onFailure(frozenSecurityIndex.getUnavailableReason());\n+        } else {\n+            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()\n+                .filter(QueryBuilders.termQuery(\"doc_type\", \"api_key\"));\n+            if (Strings.hasText(apiKeyName)) {\n+                boolQuery.filter(QueryBuilders.termQuery(\"name\", apiKeyName));\n+            }\n+\n+            findApiKeys(boolQuery, filterOutInvalidatedKeys, filterOutExpiredKeys, listener);\n+        }\n+    }\n+\n+    private void findApiKeysForApiKeyId(String apiKeyId, boolean filterOutInvalidatedKeys, boolean filterOutExpiredKeys,\n+                                        ActionListener<Collection<ApiKey>> listener) {\n+        final SecurityIndexManager frozenSecurityIndex = securityIndex.freeze();\n+        if (frozenSecurityIndex.indexExists() == false) {\n+            listener.onResponse(Collections.emptyList());\n+        } else if (frozenSecurityIndex.isAvailable() == false) {\n+            listener.onFailure(frozenSecurityIndex.getUnavailableReason());\n+        } else {\n+            final BoolQueryBuilder boolQuery = QueryBuilders.boolQuery()\n+                .filter(QueryBuilders.termQuery(\"doc_type\", \"api_key\"))\n+                .filter(QueryBuilders.termQuery(\"_id\", apiKeyId));\n+\n+            findApiKeys(boolQuery, filterOutInvalidatedKeys, filterOutExpiredKeys, listener);\n+        }\n+    }\n+\n+    /**\n+     * Performs the actual invalidation of a collection of api keys\n+     *\n+     * @param apiKeyIds       the api keys to invalidate\n+     * @param listener        the listener to notify upon completion\n+     * @param previousResult  if this not the initial attempt for invalidation, it contains the result of invalidating\n+     *                        api keys up to the point of the retry. This result is added to the result of the current attempt\n+     */\n+    private void indexInvalidation(Collection<String> apiKeyIds, ActionListener<InvalidateApiKeyResponse> listener,\n+                                   @Nullable InvalidateApiKeyResponse previousResult) {\n+        maybeStartApiKeyRemover();\n+        if (apiKeyIds.isEmpty()) {\n+            listener.onFailure(new ElasticsearchSecurityException(\"No api key ids provided for invalidation\"));\n+        } else {\n+            BulkRequestBuilder bulkRequestBuilder = client.prepareBulk();\n+            for (String apiKeyId : apiKeyIds) {\n+                UpdateRequest request = client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, TYPE, apiKeyId)\n+                    .setDoc(Collections.singletonMap(\"api_key_invalidated\", true))\n+                    .request();\n+                bulkRequestBuilder.add(request);\n+            }\n+            bulkRequestBuilder.setRefreshPolicy(RefreshPolicy.WAIT_UNTIL);\n+            securityIndex.prepareIndexIfNeededThenExecute(ex -> listener.onFailure(traceLog(\"prepare security index\", ex)),\n+                () -> executeAsyncWithOrigin(client.threadPool().getThreadContext(), SECURITY_ORIGIN, bulkRequestBuilder.request(),\n+                    ActionListener.<BulkResponse>wrap(bulkResponse -> {\n+                        ArrayList<ElasticsearchException> failedRequestResponses = new ArrayList<>();\n+                        ArrayList<String> previouslyInvalidated = new ArrayList<>();\n+                        ArrayList<String> invalidated = new ArrayList<>();\n+                        if (null != previousResult) {\n+                            failedRequestResponses.addAll((previousResult.getErrors()));\n+                            previouslyInvalidated.addAll(previousResult.getPreviouslyInvalidatedApiKeys());\n+                            invalidated.addAll(previousResult.getInvalidatedApiKeys());\n+                        }\n+                        for (BulkItemResponse bulkItemResponse : bulkResponse.getItems()) {\n+                            if (bulkItemResponse.isFailed()) {\n+                                Throwable cause = bulkItemResponse.getFailure().getCause();\n+                                final String failedApiKeyId = bulkItemResponse.getFailure().getId();\n+                                traceLog(\"invalidate api key\", failedApiKeyId, cause);\n+                                failedRequestResponses.add(new ElasticsearchException(\"Error invalidating api key\", cause));\n+                            } else {\n+                                UpdateResponse updateResponse = bulkItemResponse.getResponse();\n+                                if (updateResponse.getResult() == DocWriteResponse.Result.UPDATED) {\n+                                    logger.debug(\"Invalidated api key for doc [{}]\", updateResponse.getId());\n+                                    invalidated.add(updateResponse.getId());\n+                                } else if (updateResponse.getResult() == DocWriteResponse.Result.NOOP) {\n+                                    previouslyInvalidated.add(updateResponse.getId());\n+                                }\n+                            }\n+                        }\n+                        InvalidateApiKeyResponse result = new InvalidateApiKeyResponse(invalidated, previouslyInvalidated,\n+                            failedRequestResponses);\n+                        listener.onResponse(result);\n+                    }, e -> {\n+                        Throwable cause = ExceptionsHelper.unwrapCause(e);\n+                        traceLog(\"invalidate api keys\", cause);\n+                        listener.onFailure(e);\n+                    }), client::bulk));\n+        }\n+    }\n+\n+    /**\n+     * Logs an exception concerning a specific api key at TRACE level (if enabled)\n+     */\n+    private <E extends Throwable> E traceLog(String action, String identifier, E exception) {\n+        if (logger.isTraceEnabled()) {\n+            if (exception instanceof ElasticsearchException) {\n+                final ElasticsearchException esEx = (ElasticsearchException) exception;\n+                final Object detail = esEx.getHeader(\"error_description\");\n+                if (detail != null) {\n+                    logger.trace(() -> new ParameterizedMessage(\"Failure in [{}] for id [{}] - [{}]\", action, identifier, detail),\n+                        esEx);\n+                } else {\n+                    logger.trace(() -> new ParameterizedMessage(\"Failure in [{}] for id [{}]\", action, identifier),\n+                        esEx);\n+                }\n+            } else {\n+                logger.trace(() -> new ParameterizedMessage(\"Failure in [{}] for id [{}]\", action, identifier), exception);\n+            }\n+        }\n+        return exception;\n+    }\n+\n+    /**\n+     * Logs an exception at TRACE level (if enabled)\n+     */\n+    private <E extends Throwable> E traceLog(String action, E exception) {\n+        if (logger.isTraceEnabled()) {\n+            if (exception instanceof ElasticsearchException) {\n+                final ElasticsearchException esEx = (ElasticsearchException) exception;\n+                final Object detail = esEx.getHeader(\"error_description\");\n+                if (detail != null) {\n+                    logger.trace(() -> new ParameterizedMessage(\"Failure in [{}] - [{}]\", action, detail), esEx);\n+                } else {\n+                    logger.trace(() -> new ParameterizedMessage(\"Failure in [{}]\", action), esEx);\n+                }\n+            } else {\n+                logger.trace(() -> new ParameterizedMessage(\"Failure in [{}]\", action), exception);\n+            }\n+        }\n+        return exception;\n+    }\n+\n+    boolean isExpirationInProgress() {\n+        return expiredApiKeysRemover.isExpirationInProgress();\n+    }\n+\n+    private void maybeStartApiKeyRemover() {\n+        if (securityIndex.isAvailable()) {\n+            if (client.threadPool().relativeTimeInMillis() - lastExpirationRunMs > deleteInterval.getMillis()) {\n+                expiredApiKeysRemover.submit(client.threadPool());\n+                lastExpirationRunMs = client.threadPool().relativeTimeInMillis();\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Get API keys for given realm and user name.\n+     * @param realmName realm name\n+     * @param userName user name\n+     * @param listener listener for {@link GetApiKeyResponse}\n+     */\n+    public void getApiKeysForRealmAndUser(String realmName, String userName, ActionListener<GetApiKeyResponse> listener) {\n+        ensureEnabled();\n+        if (Strings.hasText(realmName) == false && Strings.hasText(userName) == false) {\n+            logger.trace(\"No realm name or username provided\");\n+            listener.onFailure(new IllegalArgumentException(\"realm name or username must be provided\"));\n+        } else {\n+            findApiKeysForUserAndRealm(userName, realmName, false, false, ActionListener.wrap(apiKeyInfos -> {\n+                    if (apiKeyInfos.isEmpty()) {\n+                        logger.warn(\"No active api keys found for realm [{}] and username [{}]\", realmName, userName);\n+                        listener.onResponse(GetApiKeyResponse.emptyResponse());\n+                    } else {\n+                        listener.onResponse(new GetApiKeyResponse(apiKeyInfos));\n+                    }\n+                }, listener::onFailure));\n+        }\n+    }\n+\n+    /**\n+     * Get API key for given API key id\n+     * @param apiKeyId API key id\n+     * @param listener listener for {@link GetApiKeyResponse}\n+     */\n+    public void getApiKeyForApiKeyId(String apiKeyId, ActionListener<GetApiKeyResponse> listener) {\n+        ensureEnabled();\n+        if (Strings.hasText(apiKeyId) == false) {\n+            logger.trace(\"No api key id provided\");\n+            listener.onFailure(new IllegalArgumentException(\"api key id must be provided\"));\n+        } else {\n+            findApiKeysForApiKeyId(apiKeyId, false, false, ActionListener.wrap(apiKeyInfos -> {\n+                    if (apiKeyInfos.isEmpty()) {\n+                        logger.warn(\"No api key found for api key id [{}]\", apiKeyId);\n+                        listener.onResponse(GetApiKeyResponse.emptyResponse());\n+                    } else {\n+                        listener.onResponse(new GetApiKeyResponse(apiKeyInfos));\n+                    }\n+                }, listener::onFailure));\n+        }\n+    }\n+\n+    /**\n+     * Get API key for given API key name\n+     * @param apiKeyName API key name\n+     * @param listener listener for {@link GetApiKeyResponse}\n+     */\n+    public void getApiKeyForApiKeyName(String apiKeyName, ActionListener<GetApiKeyResponse> listener) {\n+        ensureEnabled();\n+        if (Strings.hasText(apiKeyName) == false) {\n+            logger.trace(\"No api key name provided\");\n+            listener.onFailure(new IllegalArgumentException(\"api key name must be provided\"));\n+        } else {\n+            findApiKeyForApiKeyName(apiKeyName, false, false, ActionListener.wrap(apiKeyInfos -> {\n+                    if (apiKeyInfos.isEmpty()) {\n+                        logger.warn(\"No api key found for api key name [{}]\", apiKeyName);\n+                        listener.onResponse(GetApiKeyResponse.emptyResponse());\n+                    } else {\n+                        listener.onResponse(new GetApiKeyResponse(apiKeyInfos));\n+                    }\n+                }, listener::onFailure));\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "365b2e43188a9efffa2d9f24e3ce22dc82b540c7",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/AuthenticationService.java",
            "status": "modified",
            "additions": 36,
            "deletions": 4,
            "changes": 40,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationService.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationService.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationService.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -10,6 +10,7 @@\n import org.apache.logging.log4j.message.ParameterizedMessage;\n import org.apache.logging.log4j.util.Supplier;\n import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.Version;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.ContextPreservingActionListener;\n import org.elasticsearch.common.Nullable;\n@@ -27,6 +28,7 @@\n import org.elasticsearch.transport.TransportMessage;\n import org.elasticsearch.xpack.core.common.IteratingActionListener;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authc.AuthenticationFailureHandler;\n import org.elasticsearch.xpack.core.security.authc.AuthenticationResult;\n@@ -81,12 +83,13 @@ public class AuthenticationService {\n     private final TokenService tokenService;\n     private final Cache<String, Realm> lastSuccessfulAuthCache;\n     private final AtomicLong numInvalidation = new AtomicLong();\n+    private final ApiKeyService apiKeyService;\n     private final boolean runAsEnabled;\n     private final boolean isAnonymousUserEnabled;\n \n     public AuthenticationService(Settings settings, Realms realms, AuditTrailService auditTrail,\n                                  AuthenticationFailureHandler failureHandler, ThreadPool threadPool,\n-                                 AnonymousUser anonymousUser, TokenService tokenService) {\n+                                 AnonymousUser anonymousUser, TokenService tokenService, ApiKeyService apiKeyService) {\n         this.nodeName = Node.NODE_NAME_SETTING.get(settings);\n         this.realms = realms;\n         this.auditTrail = auditTrail;\n@@ -104,6 +107,7 @@ public AuthenticationService(Settings settings, Realms realms, AuditTrailService\n         } else {\n             this.lastSuccessfulAuthCache = null;\n         }\n+        this.apiKeyService = apiKeyService;\n     }\n \n     /**\n@@ -237,7 +241,7 @@ private void authenticateAsync() {\n                         if (userToken != null) {\n                             writeAuthToContext(userToken.getAuthentication());\n                         } else {\n-                            extractToken(this::consumeToken);\n+                            checkForApiKey();\n                         }\n                     }, e -> {\n                         if (e instanceof ElasticsearchSecurityException &&\n@@ -252,6 +256,32 @@ private void authenticateAsync() {\n             });\n         }\n \n+        private void checkForApiKey() {\n+            apiKeyService.authenticateWithApiKeyIfPresent(threadContext, ActionListener.wrap(authResult -> {\n+                    if (authResult.isAuthenticated()) {\n+                        final User user = authResult.getUser();\n+                        authenticatedBy = new RealmRef(\"_es_api_key\", \"_es_api_key\", nodeName);\n+                        writeAuthToContext(new Authentication(user, authenticatedBy, null, Version.CURRENT,\n+                            Authentication.AuthenticationType.API_KEY, authResult.getMetadata()));\n+                    } else if (authResult.getStatus() == AuthenticationResult.Status.TERMINATE) {\n+                        Exception e = (authResult.getException() != null) ? authResult.getException()\n+                            : Exceptions.authenticationError(authResult.getMessage());\n+                        listener.onFailure(e);\n+                    } else {\n+                        if (authResult.getMessage() != null) {\n+                            if (authResult.getException() != null) {\n+                                logger.warn(new ParameterizedMessage(\"Authentication using apikey failed - {}\", authResult.getMessage()),\n+                                    authResult.getException());\n+                            } else {\n+                                logger.warn(\"Authentication using apikey failed - {}\", authResult.getMessage());\n+                            }\n+                        }\n+                        extractToken(this::consumeToken);\n+                    }\n+                },\n+                e -> listener.onFailure(request.exceptionProcessingRequest(e, null))));\n+        }\n+\n         /**\n          * Looks to see if the request contains an existing {@link Authentication} and if so, that authentication will be used. The\n          * consumer is called if no exception was thrown while trying to read the authentication and may be called with a {@code null}\n@@ -410,10 +440,12 @@ void handleNullToken() {\n             final Authentication authentication;\n             if (fallbackUser != null) {\n                 RealmRef authenticatedBy = new RealmRef(\"__fallback\", \"__fallback\", nodeName);\n-                authentication = new Authentication(fallbackUser, authenticatedBy, null);\n+                authentication = new Authentication(fallbackUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.INTERNAL,\n+                    Collections.emptyMap());\n             } else if (isAnonymousUserEnabled) {\n                 RealmRef authenticatedBy = new RealmRef(\"__anonymous\", \"__anonymous\", nodeName);\n-                authentication = new Authentication(anonymousUser, authenticatedBy, null);\n+                authentication = new Authentication(anonymousUser, authenticatedBy, null, Version.CURRENT, AuthenticationType.ANONYMOUS,\n+                    Collections.emptyMap());\n             } else {\n                 authentication = null;\n             }"
        },
        {
            "sha": "b9430681d7f43ddf2071f43b99d9260915d3bd32",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/ExpiredApiKeysRemover.java",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FExpiredApiKeysRemover.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FExpiredApiKeysRemover.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FExpiredApiKeysRemover.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,116 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc;\n+\n+import org.apache.logging.log4j.LogManager;\n+import org.apache.logging.log4j.Logger;\n+import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.bulk.BulkItemResponse;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.common.util.concurrent.AbstractRunnable;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.index.reindex.BulkByScrollResponse;\n+import org.elasticsearch.index.reindex.DeleteByQueryAction;\n+import org.elasticsearch.index.reindex.DeleteByQueryRequest;\n+import org.elasticsearch.index.reindex.ScrollableHitSource;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool.Names;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+\n+import static org.elasticsearch.action.support.TransportActions.isShardNotAvailableException;\n+import static org.elasticsearch.xpack.core.ClientHelper.SECURITY_ORIGIN;\n+import static org.elasticsearch.xpack.core.ClientHelper.executeAsyncWithOrigin;\n+\n+/**\n+ * Responsible for cleaning the invalidated and expired API keys from the security index.\n+ */\n+public final class ExpiredApiKeysRemover extends AbstractRunnable {\n+    private static final Logger logger = LogManager.getLogger(ExpiredApiKeysRemover.class);\n+\n+    private final Client client;\n+    private final AtomicBoolean inProgress = new AtomicBoolean(false);\n+    private final TimeValue timeout;\n+\n+    ExpiredApiKeysRemover(Settings settings, Client client) {\n+        this.client = client;\n+        this.timeout = ApiKeyService.DELETE_TIMEOUT.get(settings);\n+    }\n+\n+    @Override\n+    public void doRun() {\n+        DeleteByQueryRequest expiredDbq = new DeleteByQueryRequest(SecurityIndexManager.SECURITY_INDEX_NAME);\n+        if (timeout != TimeValue.MINUS_ONE) {\n+            expiredDbq.setTimeout(timeout);\n+            expiredDbq.getSearchRequest().source().timeout(timeout);\n+        }\n+        final Instant now = Instant.now();\n+        expiredDbq\n+            .setQuery(QueryBuilders.boolQuery()\n+                .filter(QueryBuilders.termsQuery(\"doc_type\", \"api_key\"))\n+                .should(QueryBuilders.termsQuery(\"api_key_invalidated\", true))\n+                .should(QueryBuilders.rangeQuery(\"expiration_time\").lte(now.minus(7L, ChronoUnit.DAYS).toEpochMilli()))\n+                .minimumShouldMatch(1)\n+                );\n+\n+        logger.trace(() -> new ParameterizedMessage(\"Removing old api keys: [{}]\", Strings.toString(expiredDbq)));\n+        executeAsyncWithOrigin(client, SECURITY_ORIGIN, DeleteByQueryAction.INSTANCE, expiredDbq,\n+                ActionListener.wrap(r -> {\n+                    debugDbqResponse(r);\n+                    markComplete();\n+                }, this::onFailure));\n+    }\n+\n+    void submit(ThreadPool threadPool) {\n+        if (inProgress.compareAndSet(false, true)) {\n+            threadPool.executor(Names.GENERIC).submit(this);\n+        }\n+    }\n+\n+    private void debugDbqResponse(BulkByScrollResponse response) {\n+        if (logger.isDebugEnabled()) {\n+            logger.debug(\"delete by query of api keys finished with [{}] deletions, [{}] bulk failures, [{}] search failures\",\n+                    response.getDeleted(), response.getBulkFailures().size(), response.getSearchFailures().size());\n+            for (BulkItemResponse.Failure failure : response.getBulkFailures()) {\n+                logger.debug(new ParameterizedMessage(\"deletion failed for index [{}], type [{}], id [{}]\",\n+                        failure.getIndex(), failure.getType(), failure.getId()), failure.getCause());\n+            }\n+            for (ScrollableHitSource.SearchFailure failure : response.getSearchFailures()) {\n+                logger.debug(new ParameterizedMessage(\"search failed for index [{}], shard [{}] on node [{}]\",\n+                        failure.getIndex(), failure.getShardId(), failure.getNodeId()), failure.getReason());\n+            }\n+        }\n+    }\n+\n+    boolean isExpirationInProgress() {\n+        return inProgress.get();\n+    }\n+\n+    @Override\n+    public void onFailure(Exception e) {\n+        if (isShardNotAvailableException(e)) {\n+            logger.debug(\"failed to delete expired or invalidated api keys\", e);\n+        } else {\n+            logger.error(\"failed to delete expired or invalidated api keys\", e);\n+        }\n+        markComplete();\n+    }\n+\n+    private void markComplete() {\n+        if (inProgress.compareAndSet(true, false) == false) {\n+            throw new IllegalStateException(\"in progress was set to false but should have been true!\");\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "522b1a6d4b97af646b71d5fe20edb31ee12089be",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authc/TokenService.java",
            "status": "modified",
            "additions": 6,
            "deletions": 5,
            "changes": 11,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenService.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenService.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenService.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -3,6 +3,7 @@\n  * or more contributor license agreements. Licensed under the Elastic License;\n  * you may not use this file except in compliance with the Elastic License.\n  */\n+\n package org.elasticsearch.xpack.security.authc;\n \n import org.apache.logging.log4j.LogManager;\n@@ -73,6 +74,7 @@\n import org.elasticsearch.xpack.core.XPackSettings;\n import org.elasticsearch.xpack.core.security.ScrollHelper;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.KeyAndTimestamp;\n import org.elasticsearch.xpack.core.security.authc.TokenMetaData;\n import org.elasticsearch.xpack.core.security.authc.support.TokensInvalidationResult;\n@@ -235,10 +237,9 @@ public void createUserToken(Authentication authentication, Authentication origin\n             final Instant created = clock.instant();\n             final Instant expiration = getExpirationTime(created);\n             final Version version = clusterService.state().nodes().getMinNodeVersion();\n-            final Authentication matchingVersionAuth = version.equals(authentication.getVersion()) ? authentication :\n-                    new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(), authentication.getLookedUpBy(),\n-                            version);\n-            final UserToken userToken = new UserToken(version, matchingVersionAuth, expiration, metadata);\n+            final Authentication tokenAuth = new Authentication(authentication.getUser(), authentication.getAuthenticatedBy(),\n+                authentication.getLookedUpBy(), version, AuthenticationType.TOKEN, authentication.getMetadata());\n+            final UserToken userToken = new UserToken(version, tokenAuth, expiration, metadata);\n             final String refreshToken = includeRefreshToken ? UUIDs.randomBase64UUID() : null;\n \n             try (XContentBuilder builder = XContentFactory.jsonBuilder()) {\n@@ -327,7 +328,7 @@ public void getAuthenticationAndMetaData(String token, ActionListener<Tuple<Auth\n         ));\n     }\n \n-    /*\n+    /**\n      * Asynchronously decodes the string representation of a {@link UserToken}. The process for\n      * this is asynchronous as we may need to compute a key, which can be computationally expensive\n      * so this should not block the current thread, which is typically a network thread. A second"
        },
        {
            "sha": "24df5b62c49807858d8e77f86aeb796cde567d3f",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationService.java",
            "status": "modified",
            "additions": 33,
            "deletions": 26,
            "changes": 59,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationService.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationService.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationService.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -50,7 +50,6 @@\n import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n-import org.elasticsearch.xpack.core.security.authz.permission.ClusterPermission;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsCache;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n@@ -64,6 +63,7 @@\n import org.elasticsearch.xpack.core.security.user.XPackUser;\n import org.elasticsearch.xpack.security.audit.AuditTrailService;\n import org.elasticsearch.xpack.security.audit.AuditUtil;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n import org.elasticsearch.xpack.security.authz.IndicesAndAliasesResolver.ResolvedIndices;\n import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n@@ -86,7 +86,7 @@ public class AuthorizationService {\n     public static final String ROLE_NAMES_KEY = \"_effective_role_names\";\n \n     private static final Predicate<String> SAME_USER_PRIVILEGE = Automatons.predicate(\n-        ChangePasswordAction.NAME, AuthenticateAction.NAME, HasPrivilegesAction.NAME, GetUserPrivilegesAction.NAME);\n+            ChangePasswordAction.NAME, AuthenticateAction.NAME, HasPrivilegesAction.NAME, GetUserPrivilegesAction.NAME);\n \n     private static final String INDEX_SUB_REQUEST_PRIMARY = IndexAction.NAME + \"[p]\";\n     private static final String INDEX_SUB_REQUEST_REPLICA = IndexAction.NAME + \"[r]\";\n@@ -102,12 +102,14 @@ public class AuthorizationService {\n     private final ThreadContext threadContext;\n     private final AnonymousUser anonymousUser;\n     private final FieldPermissionsCache fieldPermissionsCache;\n+    private final ApiKeyService apiKeyService;\n     private final boolean isAnonymousEnabled;\n     private final boolean anonymousAuthzExceptionEnabled;\n \n     public AuthorizationService(Settings settings, CompositeRolesStore rolesStore, ClusterService clusterService,\n                                 AuditTrailService auditTrail, AuthenticationFailureHandler authcFailureHandler,\n-                                ThreadPool threadPool, AnonymousUser anonymousUser) {\n+                                ThreadPool threadPool, AnonymousUser anonymousUser, ApiKeyService apiKeyService,\n+                                FieldPermissionsCache fieldPermissionsCache) {\n         this.rolesStore = rolesStore;\n         this.clusterService = clusterService;\n         this.auditTrail = auditTrail;\n@@ -117,7 +119,8 @@ public AuthorizationService(Settings settings, CompositeRolesStore rolesStore, C\n         this.anonymousUser = anonymousUser;\n         this.isAnonymousEnabled = AnonymousUser.isAnonymousEnabled(settings);\n         this.anonymousAuthzExceptionEnabled = ANONYMOUS_AUTHORIZATION_EXCEPTION_SETTING.get(settings);\n-        this.fieldPermissionsCache = new FieldPermissionsCache(settings);\n+        this.fieldPermissionsCache = fieldPermissionsCache;\n+        this.apiKeyService = apiKeyService;\n     }\n \n     /**\n@@ -194,8 +197,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n \n         // first, we'll check if the action is a cluster action. If it is, we'll only check it against the cluster permissions\n         if (ClusterPrivilege.ACTION_MATCHER.test(action)) {\n-            final ClusterPermission cluster = permission.cluster();\n-            if (cluster.check(action, request) || checkSameUserPermissions(action, request, authentication)) {\n+            if (permission.checkClusterAction(action, request) || checkSameUserPermissions(action, request, authentication)) {\n                 putTransientIfNonExisting(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, IndicesAccessControl.ALLOW_ALL);\n                 auditTrail.accessGranted(auditId, authentication, action, request, permission.names());\n                 return;\n@@ -215,7 +217,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n                     + \", \" + request.getClass().getSimpleName() + \" doesn't\");\n             }\n             // we check if the user can execute the action, without looking at indices, which will be authorized at the shard level\n-            if (permission.indices().check(action)) {\n+            if (permission.checkIndicesAction(action)) {\n                 auditTrail.accessGranted(auditId, authentication, action, request, permission.names());\n                 return;\n             }\n@@ -226,7 +228,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n                     + \", \" + request.getClass().getSimpleName() + \" doesn't\");\n             }\n             // we check if the user can execute the action, without looking at indices, which will be authorized at the shard level\n-            if (permission.indices().check(action)) {\n+            if (permission.checkIndicesAction(action)) {\n                 auditTrail.accessGranted(auditId, authentication, action, request, permission.names());\n                 return;\n             }\n@@ -237,7 +239,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n                 throw new IllegalStateException(\"originalRequest is not a proxy request: [\" + originalRequest + \"] but action: [\"\n                     + action + \"] is a proxy action\");\n             }\n-            if (permission.indices().check(action)) {\n+            if (permission.checkIndicesAction(action)) {\n                 auditTrail.accessGranted(auditId, authentication, action, request, permission.names());\n                 return;\n             } else {\n@@ -261,7 +263,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n                 // if the action is a search scroll action, we first authorize that the user can execute the action for some\n                 // index and if they cannot, we can fail the request early before we allow the execution of the action and in\n                 // turn the shard actions\n-                if (SearchScrollAction.NAME.equals(action) && permission.indices().check(action) == false) {\n+                if (SearchScrollAction.NAME.equals(action) && permission.checkIndicesAction(action) == false) {\n                     throw denial(auditId, authentication, action, request, permission.names());\n                 } else {\n                     // we store the request as a transient in the ThreadContext in case of a authorization failure at the shard\n@@ -282,7 +284,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n \n         // If this request does not allow remote indices\n         // then the user must have permission to perform this action on at least 1 local index\n-        if (allowsRemoteIndices == false && permission.indices().check(action) == false) {\n+        if (allowsRemoteIndices == false && permission.checkIndicesAction(action) == false) {\n             throw denial(auditId, authentication, action, request, permission.names());\n         }\n \n@@ -295,7 +297,7 @@ public void authorize(Authentication authentication, String action, TransportReq\n \n         // If this request does reference any remote indices\n         // then the user must have permission to perform this action on at least 1 local index\n-        if (resolvedIndices.getRemote().isEmpty() && permission.indices().check(action) == false) {\n+        if (resolvedIndices.getRemote().isEmpty() && permission.checkIndicesAction(action) == false) {\n             throw denial(auditId, authentication, action, request, permission.names());\n         }\n \n@@ -435,7 +437,7 @@ private void putTransientIfNonExisting(String key, Object value) {\n         }\n     }\n \n-    public void roles(User user, ActionListener<Role> roleActionListener) {\n+    public void roles(User user, Authentication authentication, ActionListener<Role> roleActionListener) {\n         // we need to special case the internal users in this method, if we apply the anonymous roles to every user including these system\n         // user accounts then we run into the chance of a deadlock because then we need to get a role that we may be trying to get as the\n         // internal user. The SystemUser is special cased as it has special privileges to execute internal actions and should never be\n@@ -454,21 +456,26 @@ public void roles(User user, ActionListener<Role> roleActionListener) {\n             return;\n         }\n \n-        Set<String> roleNames = new HashSet<>();\n-        Collections.addAll(roleNames, user.roles());\n-        if (isAnonymousEnabled && anonymousUser.equals(user) == false) {\n-            if (anonymousUser.roles().length == 0) {\n-                throw new IllegalStateException(\"anonymous is only enabled when the anonymous user has roles\");\n+        final Authentication.AuthenticationType authType = authentication.getAuthenticationType();\n+        if (authType == Authentication.AuthenticationType.API_KEY) {\n+            apiKeyService.getRoleForApiKey(authentication, rolesStore, roleActionListener);\n+        } else {\n+            Set<String> roleNames = new HashSet<>();\n+            Collections.addAll(roleNames, user.roles());\n+            if (isAnonymousEnabled && anonymousUser.equals(user) == false) {\n+                if (anonymousUser.roles().length == 0) {\n+                    throw new IllegalStateException(\"anonymous is only enabled when the anonymous user has roles\");\n+                }\n+                Collections.addAll(roleNames, anonymousUser.roles());\n             }\n-            Collections.addAll(roleNames, anonymousUser.roles());\n-        }\n \n-        if (roleNames.isEmpty()) {\n-            roleActionListener.onResponse(Role.EMPTY);\n-        } else if (roleNames.contains(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName())) {\n-            roleActionListener.onResponse(ReservedRolesStore.SUPERUSER_ROLE);\n-        } else {\n-            rolesStore.roles(roleNames, fieldPermissionsCache, roleActionListener);\n+            if (roleNames.isEmpty()) {\n+                roleActionListener.onResponse(Role.EMPTY);\n+            } else if (roleNames.contains(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName())) {\n+                roleActionListener.onResponse(ReservedRolesStore.SUPERUSER_ROLE);\n+            } else {\n+                rolesStore.roles(roleNames, roleActionListener);\n+            }\n         }\n     }\n "
        },
        {
            "sha": "3b141a43b4b80c72702b8c4721c8129fd0611e1d",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizationUtils.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationUtils.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationUtils.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationUtils.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -152,9 +152,10 @@ public void authorize(AuthorizationService service) {\n                 setUserRoles(null); // we can inform the listener immediately - nothing to fetch for us on system user\n                 setRunAsRoles(null);\n             } else {\n-                service.roles(authentication.getUser().authenticatedUser(), ActionListener.wrap(this::setUserRoles, listener::onFailure));\n+                service.roles(authentication.getUser().authenticatedUser(), authentication,\n+                    ActionListener.wrap(this::setUserRoles, listener::onFailure));\n                 if (authentication.getUser().isRunAs()) {\n-                    service.roles(authentication.getUser(), ActionListener.wrap(this::setRunAsRoles, listener::onFailure));\n+                    service.roles(authentication.getUser(), authentication, ActionListener.wrap(this::setRunAsRoles, listener::onFailure));\n                 } else {\n                     setRunAsRoles(null);\n                 }"
        },
        {
            "sha": "40fa0e2ff9938dfbc79ade47b0bcc135e59b8c06",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/AuthorizedIndices.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizedIndices.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizedIndices.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizedIndices.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -39,7 +39,7 @@ List<String> get() {\n     }\n \n     private List<String> load() {\n-        Predicate<String> predicate = userRoles.indices().allowedIndicesMatcher(action);\n+        Predicate<String> predicate = userRoles.allowedIndicesMatcher(action);\n \n         List<String> indicesAndAliases = new ArrayList<>();\n         // TODO: can this be done smarter? I think there are usually more indices/aliases in the cluster then indices defined a roles?"
        },
        {
            "sha": "622617e42201ead58a9ceaab4a8ecdb591f8683a",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStore.java",
            "status": "modified",
            "additions": 94,
            "deletions": 34,
            "changes": 128,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStore.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStore.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStore.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -8,6 +8,7 @@\n import org.apache.logging.log4j.LogManager;\n import org.apache.logging.log4j.Logger;\n import org.apache.logging.log4j.message.ParameterizedMessage;\n+import org.elasticsearch.ElasticsearchException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.support.ContextPreservingActionListener;\n import org.elasticsearch.common.Nullable;\n@@ -67,7 +68,7 @@\n  */\n public class CompositeRolesStore {\n \n-\n+    private static final String ROLES_STORE_SOURCE = \"roles_stores\";\n     private static final Setting<Integer> CACHE_SIZE_SETTING =\n         Setting.intSetting(\"xpack.security.authz.store.roles.cache.max_size\", 10000, Property.NodeScope);\n     private static final Setting<Integer> NEGATIVE_LOOKUP_CACHE_SIZE_SETTING =\n@@ -91,7 +92,8 @@ public class CompositeRolesStore {\n     private final NativeRolesStore nativeRolesStore;\n     private final NativePrivilegeStore privilegeStore;\n     private final XPackLicenseState licenseState;\n-    private final Cache<Set<String>, Role> roleCache;\n+    private final FieldPermissionsCache fieldPermissionsCache;\n+    private final Cache<RoleKey, Role> roleCache;\n     private final Cache<String, Boolean> negativeLookupCache;\n     private final ThreadContext threadContext;\n     private final AtomicLong numInvalidation = new AtomicLong();\n@@ -101,13 +103,14 @@ public class CompositeRolesStore {\n     public CompositeRolesStore(Settings settings, FileRolesStore fileRolesStore, NativeRolesStore nativeRolesStore,\n                                ReservedRolesStore reservedRolesStore, NativePrivilegeStore privilegeStore,\n                                List<BiConsumer<Set<String>, ActionListener<RoleRetrievalResult>>> rolesProviders,\n-                               ThreadContext threadContext, XPackLicenseState licenseState) {\n+                               ThreadContext threadContext, XPackLicenseState licenseState, FieldPermissionsCache fieldPermissionsCache) {\n         this.fileRolesStore = fileRolesStore;\n         fileRolesStore.addListener(this::invalidate);\n         this.nativeRolesStore = nativeRolesStore;\n         this.privilegeStore = privilegeStore;\n         this.licenseState = licenseState;\n-        CacheBuilder<Set<String>, Role> builder = CacheBuilder.builder();\n+        this.fieldPermissionsCache = fieldPermissionsCache;\n+        CacheBuilder<RoleKey, Role> builder = CacheBuilder.builder();\n         final int cacheSize = CACHE_SIZE_SETTING.get(settings);\n         if (cacheSize >= 0) {\n             builder.setMaximumWeight(cacheSize);\n@@ -132,8 +135,9 @@ public CompositeRolesStore(Settings settings, FileRolesStore fileRolesStore, Nat\n         }\n     }\n \n-    public void roles(Set<String> roleNames, FieldPermissionsCache fieldPermissionsCache, ActionListener<Role> roleActionListener) {\n-        Role existing = roleCache.get(roleNames);\n+    public void roles(Set<String> roleNames, ActionListener<Role> roleActionListener) {\n+        final RoleKey roleKey = new RoleKey(roleNames, ROLES_STORE_SOURCE);\n+        Role existing = roleCache.get(roleKey);\n         if (existing != null) {\n             roleActionListener.onResponse(existing);\n         } else {\n@@ -153,33 +157,64 @@ public void roles(Set<String> roleNames, FieldPermissionsCache fieldPermissionsC\n                                     .filter((rd) -> rd.isUsingDocumentOrFieldLevelSecurity() == false)\n                                     .collect(Collectors.toSet());\n                         }\n-                        logger.trace(\"Building role from descriptors [{}] for names [{}]\", effectiveDescriptors, roleNames);\n-                        buildRoleFromDescriptors(effectiveDescriptors, fieldPermissionsCache, privilegeStore, ActionListener.wrap(role -> {\n-                            if (role != null && rolesRetrievalResult.isSuccess()) {\n-                                try (ReleasableLock ignored = readLock.acquire()) {\n-                                    /* this is kinda spooky. We use a read/write lock to ensure we don't modify the cache if we hold\n-                                     * the write lock (fetching stats for instance - which is kinda overkill?) but since we fetching\n-                                     * stuff in an async fashion we need to make sure that if the cache got invalidated since we\n-                                     * started the request we don't put a potential stale result in the cache, hence the\n-                                     * numInvalidation.get() comparison to the number of invalidation when we started. we just try to\n-                                     * be on the safe side and don't cache potentially stale results\n-                                     */\n-                                    if (invalidationCounter == numInvalidation.get()) {\n-                                        roleCache.computeIfAbsent(roleNames, (s) -> role);\n-                                    }\n-                                }\n-\n-                                for (String missingRole : rolesRetrievalResult.getMissingRoles()) {\n-                                    negativeLookupCache.computeIfAbsent(missingRole, s -> Boolean.TRUE);\n-                                }\n-                            }\n-                            roleActionListener.onResponse(role);\n-                        }, roleActionListener::onFailure));\n+                        buildThenMaybeCacheRole(roleKey, effectiveDescriptors, rolesRetrievalResult.getMissingRoles(),\n+                            rolesRetrievalResult.isSuccess(), invalidationCounter, roleActionListener);\n                     },\n                     roleActionListener::onFailure));\n         }\n     }\n \n+    public void buildAndCacheRoleFromDescriptors(Collection<RoleDescriptor> roleDescriptors, String source,\n+                                                  ActionListener<Role> listener) {\n+        if (ROLES_STORE_SOURCE.equals(source)) {\n+            throw new IllegalArgumentException(\"source [\" + ROLES_STORE_SOURCE + \"] is reserved for internal use\");\n+        }\n+        RoleKey roleKey = new RoleKey(roleDescriptors.stream().map(RoleDescriptor::getName).collect(Collectors.toSet()), source);\n+        Role existing = roleCache.get(roleKey);\n+        if (existing != null) {\n+            listener.onResponse(existing);\n+        } else {\n+            final long invalidationCounter = numInvalidation.get();\n+            buildThenMaybeCacheRole(roleKey, roleDescriptors, Collections.emptySet(), true, invalidationCounter, listener);\n+        }\n+    }\n+\n+    private void buildThenMaybeCacheRole(RoleKey roleKey, Collection<RoleDescriptor> roleDescriptors, Set<String> missing,\n+                                         boolean tryCache, long invalidationCounter, ActionListener<Role> listener) {\n+        logger.trace(\"Building role from descriptors [{}] for names [{}] from source [{}]\", roleDescriptors, roleKey.names, roleKey.source);\n+        buildRoleFromDescriptors(roleDescriptors, fieldPermissionsCache, privilegeStore, ActionListener.wrap(role -> {\n+            if (role != null && tryCache) {\n+                try (ReleasableLock ignored = readLock.acquire()) {\n+                    /* this is kinda spooky. We use a read/write lock to ensure we don't modify the cache if we hold\n+                     * the write lock (fetching stats for instance - which is kinda overkill?) but since we fetching\n+                     * stuff in an async fashion we need to make sure that if the cache got invalidated since we\n+                     * started the request we don't put a potential stale result in the cache, hence the\n+                     * numInvalidation.get() comparison to the number of invalidation when we started. we just try to\n+                     * be on the safe side and don't cache potentially stale results\n+                     */\n+                    if (invalidationCounter == numInvalidation.get()) {\n+                        roleCache.computeIfAbsent(roleKey, (s) -> role);\n+                    }\n+                }\n+\n+                for (String missingRole : missing) {\n+                    negativeLookupCache.computeIfAbsent(missingRole, s -> Boolean.TRUE);\n+                }\n+            }\n+            listener.onResponse(role);\n+        }, listener::onFailure));\n+    }\n+\n+    public void getRoleDescriptors(Set<String> roleNames, ActionListener<Set<RoleDescriptor>> listener) {\n+        roleDescriptors(roleNames, ActionListener.wrap(rolesRetrievalResult -> {\n+            if (rolesRetrievalResult.isSuccess()) {\n+                listener.onResponse(rolesRetrievalResult.getRoleDescriptors());\n+            } else {\n+                listener.onFailure(new ElasticsearchException(\"role retrieval had one or more failures\"));\n+            }\n+        }, listener::onFailure));\n+    }\n+\n     private void roleDescriptors(Set<String> roleNames, ActionListener<RolesRetrievalResult> rolesResultListener) {\n         final Set<String> filteredRoleNames = roleNames.stream().filter((s) -> {\n             if (negativeLookupCache.get(s) != null) {\n@@ -318,10 +353,10 @@ public void invalidate(String role) {\n \n         // the cache cannot be modified while doing this operation per the terms of the cache iterator\n         try (ReleasableLock ignored = writeLock.acquire()) {\n-            Iterator<Set<String>> keyIter = roleCache.keys().iterator();\n+            Iterator<RoleKey> keyIter = roleCache.keys().iterator();\n             while (keyIter.hasNext()) {\n-                Set<String> key = keyIter.next();\n-                if (key.contains(role)) {\n+                RoleKey key = keyIter.next();\n+                if (key.names.contains(role)) {\n                     keyIter.remove();\n                 }\n             }\n@@ -334,10 +369,10 @@ public void invalidate(Set<String> roles) {\n \n         // the cache cannot be modified while doing this operation per the terms of the cache iterator\n         try (ReleasableLock ignored = writeLock.acquire()) {\n-            Iterator<Set<String>> keyIter = roleCache.keys().iterator();\n+            Iterator<RoleKey> keyIter = roleCache.keys().iterator();\n             while (keyIter.hasNext()) {\n-                Set<String> key = keyIter.next();\n-                if (Sets.haveEmptyIntersection(key, roles) == false) {\n+                RoleKey key = keyIter.next();\n+                if (Sets.haveEmptyIntersection(key.names, roles) == false) {\n                     keyIter.remove();\n                 }\n             }\n@@ -457,6 +492,31 @@ private Set<String> getMissingRoles() {\n         }\n     }\n \n+    private static final class RoleKey {\n+\n+        private final Set<String> names;\n+        private final String source;\n+\n+        private RoleKey(Set<String> names, String source) {\n+            this.names = Objects.requireNonNull(names);\n+            this.source = Objects.requireNonNull(source);\n+        }\n+\n+        @Override\n+        public boolean equals(Object o) {\n+            if (this == o) return true;\n+            if (o == null || getClass() != o.getClass()) return false;\n+            RoleKey roleKey = (RoleKey) o;\n+            return names.equals(roleKey.names) &&\n+                source.equals(roleKey.source);\n+        }\n+\n+        @Override\n+        public int hashCode() {\n+            return Objects.hash(names, source);\n+        }\n+    }\n+\n     public static List<Setting<?>> getSettings() {\n         return Arrays.asList(CACHE_SIZE_SETTING, NEGATIVE_LOOKUP_CACHE_SIZE_SETTING);\n     }"
        },
        {
            "sha": "2e3ced0d8933f48be81c9fb39f1eec85a3d890ad",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/RestCreateApiKeyAction.java",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,56 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequestBuilder;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.client.SecurityClient;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Rest action to create an API key\n+ */\n+public final class RestCreateApiKeyAction extends SecurityBaseRestHandler {\n+\n+    /**\n+     * @param settings the node's settings\n+     * @param licenseState the license state that will be used to determine if\n+     * security is licensed\n+     */\n+    public RestCreateApiKeyAction(Settings settings, RestController controller, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+        controller.registerHandler(RestRequest.Method.POST, \"/_security/api_key\", this);\n+        controller.registerHandler(RestRequest.Method.PUT, \"/_security/api_key\", this);\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_create_api_key\";\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(final RestRequest request, final NodeClient client) throws IOException {\n+        try (XContentParser parser = request.contentParser()) {\n+            String refresh = request.param(\"refresh\");\n+            CreateApiKeyRequestBuilder builder = new SecurityClient(client)\n+                    .prepareCreateApiKey(request.requiredContent(), request.getXContentType())\n+                    .setRefreshPolicy((refresh != null) ? WriteRequest.RefreshPolicy.parse(request.param(\"refresh\"))\n+                            : CreateApiKeyRequest.DEFAULT_REFRESH_POLICY);\n+            return channel -> builder.execute(new RestToXContentListener<CreateApiKeyResponse>(channel));\n+        }\n+    }\n+}"
        },
        {
            "sha": "ec0bd7bd9fd3153f21567c84b4e1a7c1c0998620",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/RestGetApiKeyAction.java",
            "status": "added",
            "additions": 63,
            "deletions": 0,
            "changes": 63,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,63 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Rest action to get one or more API keys information.\n+ */\n+public final class RestGetApiKeyAction extends SecurityBaseRestHandler {\n+\n+    public RestGetApiKeyAction(Settings settings, RestController controller, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+        controller.registerHandler(RestRequest.Method.GET, \"/_security/api_key\", this);\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        final String apiKeyId = request.param(\"id\");\n+        final String apiKeyName = request.param(\"name\");\n+        final String userName = request.param(\"username\");\n+        final String realmName = request.param(\"realm_name\");\n+        final GetApiKeyRequest getApiKeyRequest = new GetApiKeyRequest(realmName, userName, apiKeyId, apiKeyName);\n+        return channel -> client.execute(GetApiKeyAction.INSTANCE, getApiKeyRequest,\n+                new RestBuilderListener<GetApiKeyResponse>(channel) {\n+                    @Override\n+                    public RestResponse buildResponse(GetApiKeyResponse getApiKeyResponse, XContentBuilder builder) throws Exception {\n+                        getApiKeyResponse.toXContent(builder, channel.request());\n+\n+                        // return HTTP status 404 if no API key found for API key id\n+                        if (Strings.hasText(apiKeyId) && getApiKeyResponse.getApiKeyInfos().length == 0) {\n+                            return new BytesRestResponse(RestStatus.NOT_FOUND, builder);\n+                        }\n+                        return new BytesRestResponse(RestStatus.OK, builder);\n+                    }\n+                });\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_get_api_key\";\n+    }\n+\n+}"
        },
        {
            "sha": "eb10ec6669e32b4f2ec18f7fce0453ba6b6f8342",
            "filename": "x-pack/plugin/security/src/main/java/org/elasticsearch/xpack/security/rest/action/RestInvalidateApiKeyAction.java",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyAction.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyAction.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Fmain%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyAction.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.ParseField;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.ConstructingObjectParser;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentParser;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.BytesRestResponse;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestRequest;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.rest.action.RestBuilderListener;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyAction;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n+\n+import java.io.IOException;\n+\n+/**\n+ * Rest action to invalidate one or more API keys\n+ */\n+public final class RestInvalidateApiKeyAction extends SecurityBaseRestHandler {\n+    static final ConstructingObjectParser<InvalidateApiKeyRequest, Void> PARSER = new ConstructingObjectParser<>(\"invalidate_api_key\",\n+            a -> {\n+                return new InvalidateApiKeyRequest((String) a[0], (String) a[1], (String) a[2], (String) a[3]);\n+            });\n+\n+    static {\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), new ParseField(\"realm_name\"));\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), new ParseField(\"username\"));\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), new ParseField(\"id\"));\n+        PARSER.declareString(ConstructingObjectParser.optionalConstructorArg(), new ParseField(\"name\"));\n+    }\n+\n+    public RestInvalidateApiKeyAction(Settings settings, RestController controller, XPackLicenseState licenseState) {\n+        super(settings, licenseState);\n+        controller.registerHandler(RestRequest.Method.DELETE, \"/_security/api_key\", this);\n+    }\n+\n+    @Override\n+    protected RestChannelConsumer innerPrepareRequest(RestRequest request, NodeClient client) throws IOException {\n+        try (XContentParser parser = request.contentParser()) {\n+            final InvalidateApiKeyRequest invalidateApiKeyRequest = PARSER.parse(parser, null);\n+            return channel -> client.execute(InvalidateApiKeyAction.INSTANCE, invalidateApiKeyRequest,\n+                new RestBuilderListener<InvalidateApiKeyResponse>(channel) {\n+                    @Override\n+                    public RestResponse buildResponse(InvalidateApiKeyResponse invalidateResp,\n+                                                      XContentBuilder builder) throws Exception {\n+                        invalidateResp.toXContent(builder, channel.request());\n+                        return new BytesRestResponse(RestStatus.OK, builder);\n+                    }\n+                });\n+        }\n+    }\n+\n+    @Override\n+    public String getName() {\n+        return \"xpack_security_invalidate_api_key\";\n+    }\n+\n+}"
        },
        {
            "sha": "aa4f8d51980eb732a29f44780b71c9f283698f91",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/ApiKeySSLBootstrapCheckTests.java",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheckTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheckTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FApiKeySSLBootstrapCheckTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security;\n+\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.test.AbstractBootstrapCheckTestCase;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+\n+public class ApiKeySSLBootstrapCheckTests extends AbstractBootstrapCheckTestCase {\n+\n+    public void testApiKeySSLBootstrapCheck() {\n+        Settings settings = Settings.EMPTY;\n+\n+        assertTrue(new ApiKeySSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n+\n+        settings = Settings.builder().put(XPackSettings.HTTP_SSL_ENABLED.getKey(), true).build();\n+        assertTrue(new ApiKeySSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n+\n+        // XPackSettings.HTTP_SSL_ENABLED default false\n+        settings = Settings.builder().put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true).build();\n+        assertTrue(new ApiKeySSLBootstrapCheck().check(createTestContext(settings, null)).isFailure());\n+\n+        settings = Settings.builder()\n+                .put(XPackSettings.HTTP_SSL_ENABLED.getKey(), true)\n+                .put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true).build();\n+        assertTrue(new ApiKeySSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n+    }\n+}"
        },
        {
            "sha": "8fa280b68de37496dcfae6f7920e07c6860ec1f5",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/SecurityContextTests.java",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityContextTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityContextTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityContextTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -13,6 +13,7 @@\n import org.elasticsearch.test.VersionUtils;\n import org.elasticsearch.xpack.core.security.SecurityContext;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.user.SystemUser;\n import org.elasticsearch.xpack.core.security.user.User;\n@@ -56,6 +57,7 @@ public void testSetUser() {\n         assertNull(securityContext.getUser());\n         securityContext.setUser(user, Version.CURRENT);\n         assertEquals(user, securityContext.getUser());\n+        assertEquals(AuthenticationType.INTERNAL, securityContext.getAuthentication().getAuthenticationType());\n \n         IllegalStateException e = expectThrows(IllegalStateException.class,\n                 () -> securityContext.setUser(randomFrom(user, SystemUser.INSTANCE), Version.CURRENT));\n@@ -76,11 +78,15 @@ public void testExecuteAsUser() throws IOException {\n         final AtomicReference<StoredContext> contextAtomicReference = new AtomicReference<>();\n         securityContext.executeAsUser(executionUser, (originalCtx) -> {\n             assertEquals(executionUser, securityContext.getUser());\n+            assertEquals(AuthenticationType.INTERNAL, securityContext.getAuthentication().getAuthenticationType());\n             contextAtomicReference.set(originalCtx);\n         }, Version.CURRENT);\n \n         final User userAfterExecution = securityContext.getUser();\n         assertEquals(original, userAfterExecution);\n+        if (original != null) {\n+            assertEquals(AuthenticationType.REALM, securityContext.getAuthentication().getAuthenticationType());\n+        }\n         StoredContext originalContext = contextAtomicReference.get();\n         assertNotNull(originalContext);\n         originalContext.restore();\n@@ -100,6 +106,7 @@ public void testExecuteAfterRewritingAuthentication() throws IOException {\n             assertEquals(original.getAuthenticatedBy(), authentication.getAuthenticatedBy());\n             assertEquals(original.getLookedUpBy(), authentication.getLookedUpBy());\n             assertEquals(VersionUtils.getPreviousVersion(), authentication.getVersion());\n+            assertEquals(original.getAuthenticationType(), securityContext.getAuthentication().getAuthenticationType());\n             contextAtomicReference.set(originalCtx);\n         }, VersionUtils.getPreviousVersion());\n "
        },
        {
            "sha": "5b7ce8b1d03eb8511ee58db5ac3f64a56f5f5409",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/SecurityTests.java",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FSecurityTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -39,6 +39,7 @@\n import org.elasticsearch.xpack.core.security.authc.file.FileRealmSettings;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n import org.elasticsearch.xpack.core.ssl.SSLService;\n@@ -380,13 +381,13 @@ public void testGetFieldFilterSecurityEnabled() throws Exception {\n         FieldPermissions permissions = new FieldPermissions(\n             new FieldPermissionsDefinition(new String[] { \"field_granted\" }, Strings.EMPTY_ARRAY));\n         IndicesAccessControl.IndexAccessControl indexGrantedAccessControl = new IndicesAccessControl.IndexAccessControl(true, permissions,\n-            Collections.emptySet());\n+                DocumentPermissions.allowAll());\n         permissionsMap.put(\"index_granted\", indexGrantedAccessControl);\n         IndicesAccessControl.IndexAccessControl indexAccessControl = new IndicesAccessControl.IndexAccessControl(false,\n-            FieldPermissions.DEFAULT, Collections.emptySet());\n+                FieldPermissions.DEFAULT, DocumentPermissions.allowAll());\n         permissionsMap.put(\"index_not_granted\", indexAccessControl);\n         IndicesAccessControl.IndexAccessControl nullFieldPermissions =\n-            new IndicesAccessControl.IndexAccessControl(true, null, Collections.emptySet());\n+                new IndicesAccessControl.IndexAccessControl(true, null, DocumentPermissions.allowAll());\n         permissionsMap.put(\"index_null\", nullFieldPermissions);\n         IndicesAccessControl index = new IndicesAccessControl(true, permissionsMap);\n         threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, index);"
        },
        {
            "sha": "09c1315123c2c09245409136962201139574d8c5",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/TokenSSLBootsrapCheckTests.java",
            "status": "modified",
            "additions": 5,
            "deletions": 4,
            "changes": 9,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FTokenSSLBootsrapCheckTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FTokenSSLBootsrapCheckTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2FTokenSSLBootsrapCheckTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -14,18 +14,19 @@ public class TokenSSLBootsrapCheckTests extends AbstractBootstrapCheckTestCase {\n     public void testTokenSSLBootstrapCheck() {\n         Settings settings = Settings.EMPTY;\n \n-        assertFalse(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isFailure());\n+        assertTrue(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n \n         settings = Settings.builder().put(XPackSettings.HTTP_SSL_ENABLED.getKey(), true).build();\n-        assertFalse(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isFailure());\n+        assertTrue(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n \n         // XPackSettings.HTTP_SSL_ENABLED default false\n         settings = Settings.builder().put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).build();\n         assertTrue(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isFailure());\n \n         settings = Settings.builder()\n-                .put(XPackSettings.HTTP_SSL_ENABLED.getKey(), false)\n+                .put(XPackSettings.HTTP_SSL_ENABLED.getKey(), true)\n                 .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true).build();\n-        assertTrue(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isFailure());\n+        assertTrue(new TokenSSLBootstrapCheck().check(createTestContext(settings, null)).isSuccess());\n     }\n+\n }"
        },
        {
            "sha": "80d5e3f85281e954fb42a763d24a538880639d64",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/filter/SecurityActionFilterTests.java",
            "status": "modified",
            "additions": 8,
            "deletions": 8,
            "changes": 16,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Ffilter%2FSecurityActionFilterTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Ffilter%2FSecurityActionFilterTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Ffilter%2FSecurityActionFilterTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -103,10 +103,10 @@ public void testApply() throws Exception {\n         final Role empty = Role.EMPTY;\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             callback.onResponse(empty);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         filter.apply(task, \"_action\", request, listener, chain);\n         verify(authzService).authorize(authentication, \"_action\", request, empty, null);\n         verify(chain).proceed(eq(task), eq(\"_action\"), eq(request), isA(ContextPreservingActionListener.class));\n@@ -130,11 +130,11 @@ public void testApplyRestoresThreadContext() throws Exception {\n         final Role empty = Role.EMPTY;\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             assertEquals(authentication, threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY));\n             callback.onResponse(empty);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         assertNull(threadContext.getTransient(AuthenticationField.AUTHENTICATION_KEY));\n \n         filter.apply(task, \"_action\", request, listener, chain);\n@@ -201,10 +201,10 @@ public void testApplyDestructiveOperations() throws Exception {\n         final Role empty = Role.EMPTY;\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             callback.onResponse(empty);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         filter.apply(task, action, request, listener, chain);\n         if (failDestructiveOperations) {\n             verify(listener).onFailure(isA(IllegalArgumentException.class));\n@@ -231,10 +231,10 @@ public void testActionProcessException() throws Exception {\n         }).when(authcService).authenticate(eq(\"_action\"), eq(request), eq(SystemUser.INSTANCE), any(ActionListener.class));\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             callback.onResponse(Role.EMPTY);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         doThrow(exception).when(authzService).authorize(eq(authentication), eq(\"_action\"), eq(request), any(Role.class),\n                 any(Role.class));\n         filter.apply(task, \"_action\", request, listener, chain);"
        },
        {
            "sha": "5ca1112fa9b7220acd4354f6fd7e3215a5d892c5",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/interceptor/IndicesAliasesRequestInterceptorTests.java",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptorTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptorTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FIndicesAliasesRequestInterceptorTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -18,6 +18,7 @@\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n@@ -60,7 +61,8 @@ public void testInterceptorThrowsWhenFLSDLSEnabled() {\n         Role role = Role.builder().add(fieldPermissions, queries, IndexPrivilege.ALL, randomBoolean(), \"foo\").build();\n         final String action = IndicesAliasesAction.NAME;\n         IndicesAccessControl accessControl = new IndicesAccessControl(true, Collections.singletonMap(\"foo\",\n-                new IndicesAccessControl.IndexAccessControl(true, fieldPermissions, queries)));\n+                new IndicesAccessControl.IndexAccessControl(true, fieldPermissions,\n+                        (useDls) ? DocumentPermissions.filteredBy(queries) : DocumentPermissions.allowAll())));\n         threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, accessControl);\n \n         IndicesAliasesRequestInterceptor interceptor ="
        },
        {
            "sha": "9cf7c7ed14155592c1d5713da90400a504b7dc03",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/interceptor/ResizeRequestInterceptorTests.java",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptorTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptorTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Finterceptor%2FResizeRequestInterceptorTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -20,6 +20,7 @@\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n@@ -63,7 +64,8 @@ public void testResizeRequestInterceptorThrowsWhenFLSDLSEnabled() {\n         Role role = Role.builder().add(fieldPermissions, queries, IndexPrivilege.ALL, randomBoolean(), \"foo\").build();\n         final String action = randomFrom(ShrinkAction.NAME, ResizeAction.NAME);\n         IndicesAccessControl accessControl = new IndicesAccessControl(true, Collections.singletonMap(\"foo\",\n-                        new IndicesAccessControl.IndexAccessControl(true, fieldPermissions, queries)));\n+                new IndicesAccessControl.IndexAccessControl(true, fieldPermissions,\n+                        (useDls) ? DocumentPermissions.filteredBy(queries) : DocumentPermissions.allowAll())));\n         threadContext.putTransient(AuthorizationServiceField.INDICES_PERMISSIONS_KEY, accessControl);\n \n         ResizeRequestInterceptor resizeRequestInterceptor ="
        },
        {
            "sha": "670c2366d65bf6317eb693826a23d9b1da3f9c65",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/action/user/TransportHasPrivilegesActionTests.java",
            "status": "modified",
            "additions": 96,
            "deletions": 46,
            "changes": 142,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesActionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesActionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Faction%2Fuser%2FTransportHasPrivilegesActionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -25,10 +25,11 @@\n import org.elasticsearch.transport.TransportService;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesRequest;\n import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse;\n-import org.elasticsearch.xpack.core.security.action.user.HasPrivilegesResponse.ResourcePrivileges;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.LimitedRole;\n+import org.elasticsearch.xpack.core.security.authz.permission.ResourcePrivileges;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilegeDescriptor;\n@@ -88,10 +89,10 @@ public void setup() {\n \n         AuthorizationService authorizationService = mock(AuthorizationService.class);\n         Mockito.doAnswer(invocationOnMock -> {\n-            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[1];\n+            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[2];\n             listener.onResponse(role);\n             return null;\n-        }).when(authorizationService).roles(eq(user), any(ActionListener.class));\n+        }).when(authorizationService).roles(eq(user), any(Authentication.class), any(ActionListener.class));\n \n         applicationPrivileges = new ArrayList<>();\n         NativePrivilegeStore privilegeStore = mock(NativePrivilegeStore.class);\n@@ -126,7 +127,7 @@ public void testNamedIndexPrivilegesMatchApplicableActions() throws Exception {\n                 .privileges(DeleteAction.NAME, IndexAction.NAME)\n                 .build());\n         request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0]);\n-        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture();\n+        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture<>();\n         action.doExecute(mock(Task.class), request, future);\n \n         final HasPrivilegesResponse response = future.get();\n@@ -164,7 +165,7 @@ public void testMatchSubsetOfPrivileges() throws Exception {\n                 .privileges(\"delete\", \"index\", \"manage\")\n                 .build());\n         request.applicationPrivileges(new RoleDescriptor.ApplicationResourcePrivileges[0]);\n-        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture();\n+        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture<>();\n         action.doExecute(mock(Task.class), request, future);\n \n         final HasPrivilegesResponse response = future.get();\n@@ -293,32 +294,34 @@ public void testWildcardHandling() throws Exception {\n                         .build()\n         );\n \n-        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture();\n+        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture<>();\n         action.doExecute(mock(Task.class), request, future);\n \n         final HasPrivilegesResponse response = future.get();\n         assertThat(response, notNullValue());\n         assertThat(response.getUsername(), is(user.principal()));\n         assertThat(response.isCompleteMatch(), is(false));\n         assertThat(response.getIndexPrivileges(), Matchers.iterableWithSize(8));\n-        assertThat(response.getIndexPrivileges(), containsInAnyOrder(\n-                new ResourcePrivileges(\"logstash-2016-*\", Collections.singletonMap(\"write\", true)),\n-                new ResourcePrivileges(\"logstash-*\", Collections.singletonMap(\"read\", true)),\n-                new ResourcePrivileges(\"log*\", Collections.singletonMap(\"manage\", false)),\n-                new ResourcePrivileges(\"foo?\", Collections.singletonMap(\"read\", true)),\n-                new ResourcePrivileges(\"foo*\", Collections.singletonMap(\"read\", false)),\n-                new ResourcePrivileges(\"abcd*\", mapBuilder().put(\"read\", true).put(\"write\", false).map()),\n-                new ResourcePrivileges(\"abc*xyz\", mapBuilder().put(\"read\", true).put(\"write\", true).put(\"manage\", false).map()),\n-                new ResourcePrivileges(\"a*xyz\", mapBuilder().put(\"read\", false).put(\"write\", true).put(\"manage\", false).map())\n-        ));\n+        assertThat(response.getIndexPrivileges(),\n+                containsInAnyOrder(\n+                        ResourcePrivileges.builder(\"logstash-2016-*\").addPrivileges(Collections.singletonMap(\"write\", true)).build(),\n+                        ResourcePrivileges.builder(\"logstash-*\").addPrivileges(Collections.singletonMap(\"read\", true)).build(),\n+                        ResourcePrivileges.builder(\"log*\").addPrivileges(Collections.singletonMap(\"manage\", false)).build(),\n+                        ResourcePrivileges.builder(\"foo?\").addPrivileges(Collections.singletonMap(\"read\", true)).build(),\n+                        ResourcePrivileges.builder(\"foo*\").addPrivileges(Collections.singletonMap(\"read\", false)).build(),\n+                        ResourcePrivileges.builder(\"abcd*\").addPrivileges(mapBuilder().put(\"read\", true).put(\"write\", false).map()).build(),\n+                        ResourcePrivileges.builder(\"abc*xyz\")\n+                                .addPrivileges(mapBuilder().put(\"read\", true).put(\"write\", true).put(\"manage\", false).map()).build(),\n+                        ResourcePrivileges.builder(\"a*xyz\")\n+                                .addPrivileges(mapBuilder().put(\"read\", false).put(\"write\", true).put(\"manage\", false).map()).build()));\n         assertThat(response.getApplicationPrivileges().entrySet(), Matchers.iterableWithSize(1));\n         final Set<ResourcePrivileges> kibanaPrivileges = response.getApplicationPrivileges().get(\"kibana\");\n         assertThat(kibanaPrivileges, Matchers.iterableWithSize(3));\n         assertThat(Strings.collectionToCommaDelimitedString(kibanaPrivileges), kibanaPrivileges, containsInAnyOrder(\n-                new ResourcePrivileges(\"*\", mapBuilder().put(\"read\", true).put(\"write\", false).map()),\n-                new ResourcePrivileges(\"space/engineering/project-*\", Collections.singletonMap(\"space:view/dashboard\", true)),\n-                new ResourcePrivileges(\"space/*\", Collections.singletonMap(\"space:view/dashboard\", false))\n-        ));\n+                ResourcePrivileges.builder(\"*\").addPrivileges(mapBuilder().put(\"read\", true).put(\"write\", false).map()).build(),\n+                ResourcePrivileges.builder(\"space/engineering/project-*\")\n+                        .addPrivileges(Collections.singletonMap(\"space:view/dashboard\", true)).build(),\n+                ResourcePrivileges.builder(\"space/*\").addPrivileges(Collections.singletonMap(\"space:view/dashboard\", false)).build()));\n     }\n \n     private ApplicationPrivilege defineApplicationPrivilege(String app, String name, String ... actions) {\n@@ -339,13 +342,12 @@ public void testCheckingIndexPermissionsDefinedOnDifferentPatterns() throws Exce\n         assertThat(response.isCompleteMatch(), is(false));\n         assertThat(response.getIndexPrivileges(), Matchers.iterableWithSize(2));\n         assertThat(response.getIndexPrivileges(), containsInAnyOrder(\n-                new ResourcePrivileges(\"apache-2016-12\",\n+                ResourcePrivileges.builder(\"apache-2016-12\").addPrivileges(\n                         MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                                .put(\"index\", true).put(\"delete\", true).map()),\n-                new ResourcePrivileges(\"apache-2017-01\",\n+                                .put(\"index\", true).put(\"delete\", true).map()).build(),\n+                ResourcePrivileges.builder(\"apache-2017-01\").addPrivileges(\n                         MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                                .put(\"index\", true).put(\"delete\", false).map()\n-                )\n+                                .put(\"index\", true).put(\"delete\", false).map()).build()\n         ));\n     }\n \n@@ -384,26 +386,37 @@ public void testCheckingApplicationPrivilegesOnDifferentApplicationsAndResources\n         final Set<ResourcePrivileges> app1 = response.getApplicationPrivileges().get(\"app1\");\n         assertThat(app1, Matchers.iterableWithSize(4));\n         assertThat(Strings.collectionToCommaDelimitedString(app1), app1, containsInAnyOrder(\n-                new ResourcePrivileges(\"foo/1\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", true).put(\"write\", false).put(\"all\", false).map()),\n-                new ResourcePrivileges(\"foo/bar/2\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", true).put(\"write\", false).put(\"all\", false).map()),\n-                new ResourcePrivileges(\"foo/bar/baz\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", true).put(\"write\", true).put(\"all\", true).map()),\n-                new ResourcePrivileges(\"baz/bar/foo\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", false).put(\"write\", false).put(\"all\", false).map())\n-        ));\n+                ResourcePrivileges.builder(\"foo/1\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).put(\"write\", false)\n+                                .put(\"all\", false).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"foo/bar/2\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).put(\"write\", false)\n+                                .put(\"all\", false).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"foo/bar/baz\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).put(\"write\", true)\n+                                .put(\"all\", true).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"baz/bar/foo\").addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n+                        .put(\"read\", false).put(\"write\", false).put(\"all\", false).map()).build()));\n         final Set<ResourcePrivileges> app2 = response.getApplicationPrivileges().get(\"app2\");\n         assertThat(app2, Matchers.iterableWithSize(4));\n         assertThat(Strings.collectionToCommaDelimitedString(app2), app2, containsInAnyOrder(\n-                new ResourcePrivileges(\"foo/1\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", false).put(\"write\", false).put(\"all\", false).map()),\n-                new ResourcePrivileges(\"foo/bar/2\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", true).put(\"write\", true).put(\"all\", false).map()),\n-                new ResourcePrivileges(\"foo/bar/baz\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", true).put(\"write\", true).put(\"all\", false).map()),\n-                new ResourcePrivileges(\"baz/bar/foo\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n-                        .put(\"read\", false).put(\"write\", true).put(\"all\", false).map())\n+                ResourcePrivileges.builder(\"foo/1\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", false).put(\"write\", false)\n+                                .put(\"all\", false).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"foo/bar/2\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).put(\"write\", true)\n+                                .put(\"all\", false).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"foo/bar/baz\")\n+                        .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).put(\"write\", true)\n+                                .put(\"all\", false).map())\n+                        .build(),\n+                ResourcePrivileges.builder(\"baz/bar/foo\").addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n+                        .put(\"read\", false).put(\"write\", true).put(\"all\", false).map()).build()\n         ));\n     }\n \n@@ -413,7 +426,6 @@ public void testCheckingApplicationPrivilegesWithComplexNames() throws Exception\n         final String action2 = randomAlphaOfLength(1).toLowerCase(Locale.ROOT) + randomAlphaOfLengthBetween(6, 9);\n \n         final ApplicationPrivilege priv1 = defineApplicationPrivilege(appName, action1, \"DATA:read/*\", \"ACTION:\" + action1);\n-        final ApplicationPrivilege priv2 = defineApplicationPrivilege(appName, action2, \"DATA:read/*\", \"ACTION:\" + action2);\n \n         role = Role.builder(\"test-write\")\n             .addApplicationPrivilege(priv1, Collections.singleton(\"user/*/name\"))\n@@ -433,13 +445,13 @@ public void testCheckingApplicationPrivilegesWithComplexNames() throws Exception\n         assertThat(response.getApplicationPrivileges().keySet(), containsInAnyOrder(appName));\n         assertThat(response.getApplicationPrivileges().get(appName), iterableWithSize(1));\n         assertThat(response.getApplicationPrivileges().get(appName), containsInAnyOrder(\n-            new ResourcePrivileges(\"user/hawkeye/name\", MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n+            ResourcePrivileges.builder(\"user/hawkeye/name\").addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>())\n                 .put(\"DATA:read/user/*\", true)\n                 .put(\"ACTION:\" + action1, true)\n                 .put(\"ACTION:\" + action2, false)\n                 .put(action1, true)\n                 .put(action2, false)\n-                .map())\n+                .map()).build()\n         ));\n     }\n \n@@ -487,6 +499,44 @@ public void testIsCompleteMatch() throws Exception {\n                 \"monitor\").isCompleteMatch(), is(false));\n     }\n \n+    public void testLimitedRoleHasPrivilegesApi() throws Exception {\n+        final ApplicationPrivilege kibanaRead = defineApplicationPrivilege(\"kibana\", \"read\", \"data:read/*\");\n+        final ApplicationPrivilege kibanaWrite = defineApplicationPrivilege(\"kibana\", \"write\", \"data:write/*\");\n+        Role baseRole = Role.builder(\"base-role\").cluster(Sets.newHashSet(\"manage\", \"monitor\"), Collections.emptySet())\n+                .add(IndexPrivilege.ALL, \"all-*\").addApplicationPrivilege(kibanaRead, Collections.singleton(\"*\"))\n+                .addApplicationPrivilege(kibanaWrite, Collections.singleton(\"*\")).build();\n+\n+        Role limitedByRole = Role.builder(\"limited-by\").cluster(ClusterPrivilege.MONITOR).add(IndexPrivilege.READ, \"all-read-*\")\n+                .addApplicationPrivilege(kibanaRead, Collections.singleton(\"*\")).build();\n+\n+        role = LimitedRole.createLimitedRole(baseRole, limitedByRole);\n+\n+        assertThat(hasPrivileges(indexPrivileges(\"read\", \"all-read-1\", \"all-read-2\", \"all-read-*\"), \"monitor\").isCompleteMatch(), is(true));\n+        assertThat(hasPrivileges(indexPrivileges(\"read\", \"all-1\", \"all-999\"), \"monitor\").isCompleteMatch(), is(false));\n+        assertThat(hasPrivileges(indexPrivileges(\"read\", \"all-999\"), \"manage\").isCompleteMatch(), is(false));\n+        assertThat(hasPrivileges(indexPrivileges(\"write\", \"all-999\"), \"monitor\").isCompleteMatch(), is(false));\n+        assertThat(hasPrivileges(indexPrivileges(\"write\", \"all-*\"), \"manage\").isCompleteMatch(), is(false));\n+\n+        HasPrivilegesResponse response = hasPrivileges(indexPrivileges(\"read\", \"all-read-999\"), \"manage\", \"monitor\");\n+        assertThat(response.getClusterPrivileges().get(\"manage\"), is(false));\n+        assertThat(response.getClusterPrivileges().get(\"monitor\"), is(true));\n+        assertThat(response.getIndexPrivileges(), Matchers.iterableWithSize(1));\n+        assertThat(response.getIndexPrivileges(), containsInAnyOrder(ResourcePrivileges.builder(\"all-read-999\")\n+                .addPrivileges(MapBuilder.newMapBuilder(new LinkedHashMap<String, Boolean>()).put(\"read\", true).map()).build()));\n+\n+        response = hasPrivileges(new RoleDescriptor.IndicesPrivileges[] { indexPrivileges(\"read\", \"all-read-*\") },\n+                new RoleDescriptor.ApplicationResourcePrivileges[] {\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder().application(\"kibana\").resources(\"*\").privileges(\"read\")\n+                                .build(),\n+                        RoleDescriptor.ApplicationResourcePrivileges.builder().application(\"kibana\").resources(\"*\").privileges(\"write\")\n+                                .build() },\n+                \"monitor\");\n+        assertThat(response.isCompleteMatch(), is(false));\n+        final Set<ResourcePrivileges> kibanaPrivileges = response.getApplicationPrivileges().get(\"kibana\");\n+        assertThat(kibanaPrivileges, containsInAnyOrder(\n+                ResourcePrivileges.builder(\"*\").addPrivileges(mapBuilder().put(\"write\", false).put(\"read\", true).map()).build()));\n+    }\n+\n     private RoleDescriptor.IndicesPrivileges indexPrivileges(String priv, String... indices) {\n         return RoleDescriptor.IndicesPrivileges.builder()\n                 .indices(indices)\n@@ -511,7 +561,7 @@ private HasPrivilegesResponse hasPrivileges(RoleDescriptor.IndicesPrivileges[] i\n         request.clusterPrivileges(clusterPrivileges);\n         request.indexPrivileges(indicesPrivileges);\n         request.applicationPrivileges(appPrivileges);\n-        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture();\n+        final PlainActionFuture<HasPrivilegesResponse> future = new PlainActionFuture<>();\n         action.doExecute(mock(Task.class), request, future);\n         final HasPrivilegesResponse response = future.get();\n         assertThat(response, notNullValue());"
        },
        {
            "sha": "3450b713781c634e6bd78cac02617538b012a0d2",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyIntegTests.java",
            "status": "added",
            "additions": 494,
            "deletions": 0,
            "changes": 494,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyIntegTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyIntegTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyIntegTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,494 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc;\n+\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.admin.cluster.health.ClusterHealthResponse;\n+import org.elasticsearch.action.search.SearchResponse;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.action.support.WriteRequest;\n+import org.elasticsearch.client.Client;\n+import org.elasticsearch.common.Strings;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.unit.TimeValue;\n+import org.elasticsearch.index.query.QueryBuilders;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.search.builder.SearchSourceBuilder;\n+import org.elasticsearch.test.SecurityIntegTestCase;\n+import org.elasticsearch.test.SecuritySettingsSource;\n+import org.elasticsearch.test.SecuritySettingsSourceField;\n+import org.elasticsearch.xpack.core.XPackSettings;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n+import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.client.SecurityClient;\n+import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n+import org.elasticsearch.xpack.security.transport.filter.IPFilter;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.ExecutionException;\n+import java.util.concurrent.TimeUnit;\n+import java.util.concurrent.atomic.AtomicBoolean;\n+import java.util.concurrent.atomic.AtomicReference;\n+import java.util.stream.Collectors;\n+\n+import static org.hamcrest.Matchers.containsInAnyOrder;\n+import static org.hamcrest.Matchers.containsString;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.not;\n+\n+public class ApiKeyIntegTests extends SecurityIntegTestCase {\n+\n+    @Override\n+    public Settings nodeSettings(int nodeOrdinal) {\n+        return Settings.builder()\n+            .put(super.nodeSettings(nodeOrdinal))\n+            .put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true)\n+            .put(ApiKeyService.DELETE_INTERVAL.getKey(), TimeValue.timeValueMillis(200L))\n+            .put(ApiKeyService.DELETE_TIMEOUT.getKey(), TimeValue.timeValueSeconds(5L))\n+            .build();\n+    }\n+\n+    @Before\n+    public void waitForSecurityIndexWritable() throws Exception {\n+        assertSecurityIndexActive();\n+    }\n+\n+    @After\n+    public void wipeSecurityIndex() throws InterruptedException {\n+        // get the api key service and wait until api key expiration is not in progress!\n+        for (ApiKeyService apiKeyService : internalCluster().getInstances(ApiKeyService.class)) {\n+            final boolean done = awaitBusy(() -> apiKeyService.isExpirationInProgress() == false);\n+            assertTrue(done);\n+        }\n+        deleteSecurityIndex();\n+    }\n+\n+    public void testCreateApiKey() {\n+        final Instant start = Instant.now();\n+        final RoleDescriptor descriptor = new RoleDescriptor(\"role\", new String[] { \"monitor\" }, null, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        final CreateApiKeyResponse response = securityClient.prepareCreateApiKey()\n+            .setName(\"test key\")\n+            .setExpiration(TimeValue.timeValueHours(TimeUnit.DAYS.toHours(7L)))\n+            .setRoleDescriptors(Collections.singletonList(descriptor))\n+            .get();\n+\n+        assertEquals(\"test key\", response.getName());\n+        assertNotNull(response.getId());\n+        assertNotNull(response.getKey());\n+        Instant expiration = response.getExpiration();\n+        final long daysBetween = ChronoUnit.DAYS.between(start, expiration);\n+        assertThat(daysBetween, is(7L));\n+\n+        // create simple api key\n+        final CreateApiKeyResponse simple = securityClient.prepareCreateApiKey().setName(\"simple\").get();\n+        assertEquals(\"simple\", simple.getName());\n+        assertNotNull(simple.getId());\n+        assertNotNull(simple.getKey());\n+        assertThat(simple.getId(), not(containsString(new String(simple.getKey().getChars()))));\n+        assertNull(simple.getExpiration());\n+\n+        // use the first ApiKey for authorized action\n+        final String base64ApiKeyKeyValue = Base64.getEncoder().encodeToString(\n+            (response.getId() + \":\" + response.getKey().toString()).getBytes(StandardCharsets.UTF_8));\n+        ClusterHealthResponse healthResponse = client()\n+            .filterWithHeader(Collections.singletonMap(\"Authorization\", \"ApiKey \" + base64ApiKeyKeyValue))\n+            .admin()\n+            .cluster()\n+            .prepareHealth()\n+            .get();\n+        assertFalse(healthResponse.isTimedOut());\n+\n+        // use the first ApiKey for an unauthorized action\n+        ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () ->\n+            client().filterWithHeader(Collections.singletonMap(\"Authorization\", \"ApiKey \" + base64ApiKeyKeyValue))\n+                .admin()\n+                .cluster()\n+                .prepareUpdateSettings().setTransientSettings(Settings.builder().put(IPFilter.IP_FILTER_ENABLED_SETTING.getKey(), true))\n+                .get());\n+        assertThat(e.getMessage(), containsString(\"unauthorized\"));\n+        assertThat(e.status(), is(RestStatus.FORBIDDEN));\n+    }\n+\n+    public void testCreateApiKeyFailsWhenApiKeyWithSameNameAlreadyExists() throws InterruptedException, ExecutionException {\n+        String keyName = randomAlphaOfLength(5);\n+        List<CreateApiKeyResponse> responses = new ArrayList<>();\n+        {\n+            final RoleDescriptor descriptor = new RoleDescriptor(\"role\", new String[] { \"monitor\" }, null, null);\n+            Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                    .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+            SecurityClient securityClient = new SecurityClient(client);\n+            final CreateApiKeyResponse response = securityClient.prepareCreateApiKey().setName(keyName).setExpiration(null)\n+                    .setRoleDescriptors(Collections.singletonList(descriptor)).get();\n+            assertNotNull(response.getId());\n+            assertNotNull(response.getKey());\n+            responses.add(response);\n+        }\n+\n+        final RoleDescriptor descriptor = new RoleDescriptor(\"role\", new String[] { \"monitor\" }, null, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\",\n+            UsernamePasswordToken.basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER,\n+                SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class, () -> securityClient.prepareCreateApiKey()\n+            .setName(keyName)\n+            .setExpiration(TimeValue.timeValueHours(TimeUnit.DAYS.toHours(7L)))\n+            .setRoleDescriptors(Collections.singletonList(descriptor))\n+            .get());\n+        assertThat(e.getMessage(), equalTo(\"Error creating api key as api key with name [\"+keyName+\"] already exists\"));\n+\n+        // Now invalidate the API key\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyName(keyName), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(1, responses, invalidateResponse);\n+\n+        // try to create API key with same name, should succeed now\n+        CreateApiKeyResponse createResponse = securityClient.prepareCreateApiKey().setName(keyName)\n+                .setExpiration(TimeValue.timeValueHours(TimeUnit.DAYS.toHours(7L)))\n+                .setRoleDescriptors(Collections.singletonList(descriptor)).get();\n+        assertNotNull(createResponse.getId());\n+        assertNotNull(createResponse.getKey());\n+    }\n+\n+    public void testInvalidateApiKeysForRealm() throws InterruptedException, ExecutionException {\n+        int noOfApiKeys = randomIntBetween(3, 5);\n+        List<CreateApiKeyResponse> responses = createApiKeys(noOfApiKeys, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingRealmName(\"file\"), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(noOfApiKeys, responses, invalidateResponse);\n+    }\n+\n+    public void testInvalidateApiKeysForUser() throws Exception {\n+        int noOfApiKeys = randomIntBetween(3, 5);\n+        List<CreateApiKeyResponse> responses = createApiKeys(noOfApiKeys, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingUserName(SecuritySettingsSource.TEST_SUPERUSER), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(noOfApiKeys, responses, invalidateResponse);\n+    }\n+\n+    public void testInvalidateApiKeysForRealmAndUser() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingRealmAndUserName(\"file\", SecuritySettingsSource.TEST_SUPERUSER),\n+                listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(1, responses, invalidateResponse);\n+    }\n+\n+    public void testInvalidateApiKeysForApiKeyId() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(1, responses, invalidateResponse);\n+    }\n+\n+    public void testInvalidateApiKeysForApiKeyName() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyName(responses.get(0).getName()), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(1, responses, invalidateResponse);\n+    }\n+\n+    public void testGetAndInvalidateApiKeysWithExpiredAndInvalidatedApiKey() throws Exception {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Instant created = Instant.now();\n+\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+\n+        AtomicReference<String> docId = new AtomicReference<>();\n+        assertBusy(() -> {\n+            SearchResponse searchResponse = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+                    .setSource(SearchSourceBuilder.searchSource().query(QueryBuilders.termQuery(\"doc_type\", \"api_key\"))).setSize(10)\n+                    .setTerminateAfter(10).get();\n+            assertThat(searchResponse.getHits().getTotalHits().value, equalTo(1L));\n+            docId.set(searchResponse.getHits().getAt(0).getId());\n+        });\n+\n+        // hack doc to modify the expiration time to the week before\n+        Instant weekBefore = created.minus(8L, ChronoUnit.DAYS);\n+        assertTrue(Instant.now().isAfter(weekBefore));\n+        client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, \"doc\", docId.get())\n+                .setDoc(\"expiration_time\", weekBefore.toEpochMilli()).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).get();\n+\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        verifyInvalidateResponse(1, responses, invalidateResponse);\n+\n+        // try again\n+        listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+        invalidateResponse = listener.get();\n+        assertTrue(invalidateResponse.getInvalidatedApiKeys().isEmpty());\n+\n+        // Get API key though returns the API key information\n+        PlainActionFuture<GetApiKeyResponse> listener1 = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener1);\n+        GetApiKeyResponse response = listener1.get();\n+        verifyGetResponse(1, responses, response, Collections.emptySet(), Collections.singletonList(responses.get(0).getId()));\n+    }\n+\n+    private void verifyInvalidateResponse(int noOfApiKeys, List<CreateApiKeyResponse> responses,\n+                                          InvalidateApiKeyResponse invalidateResponse) {\n+        assertThat(invalidateResponse.getInvalidatedApiKeys().size(), equalTo(noOfApiKeys));\n+        assertThat(invalidateResponse.getInvalidatedApiKeys(),\n+                containsInAnyOrder(responses.stream().map(r -> r.getId()).collect(Collectors.toList()).toArray(Strings.EMPTY_ARRAY)));\n+        assertThat(invalidateResponse.getPreviouslyInvalidatedApiKeys().size(), equalTo(0));\n+        assertThat(invalidateResponse.getErrors().size(), equalTo(0));\n+    }\n+\n+    public void testInvalidatedApiKeysDeletedByRemover() throws Exception {\n+        List<CreateApiKeyResponse> responses = createApiKeys(2, null);\n+\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        assertThat(invalidateResponse.getInvalidatedApiKeys().size(), equalTo(1));\n+        assertThat(invalidateResponse.getPreviouslyInvalidatedApiKeys().size(), equalTo(0));\n+        assertThat(invalidateResponse.getErrors().size(), equalTo(0));\n+        AtomicReference<String> docId = new AtomicReference<>();\n+        assertBusy(() -> {\n+            SearchResponse searchResponse = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+                    .setSource(SearchSourceBuilder.searchSource().query(QueryBuilders.termQuery(\"doc_type\", \"api_key\"))).setSize(10)\n+                    .setTerminateAfter(10).get();\n+            assertThat(searchResponse.getHits().getTotalHits().value, equalTo(2L));\n+            docId.set(searchResponse.getHits().getAt(0).getId());\n+        });\n+\n+        AtomicBoolean deleteTriggered = new AtomicBoolean(false);\n+        assertBusy(() -> {\n+            if (deleteTriggered.compareAndSet(false, true)) {\n+                securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(1).getId()), new PlainActionFuture<>());\n+            }\n+            client.admin().indices().prepareRefresh(SecurityIndexManager.SECURITY_INDEX_NAME).get();\n+            SearchResponse searchResponse = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+                    .setSource(SearchSourceBuilder.searchSource().query(QueryBuilders.termQuery(\"doc_type\", \"api_key\")))\n+                    .setTerminateAfter(10).get();\n+            assertThat(searchResponse.getHits().getTotalHits().value, equalTo(1L));\n+        }, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public void testExpiredApiKeysDeletedAfter1Week() throws Exception {\n+        List<CreateApiKeyResponse> responses = createApiKeys(2, null);\n+        Instant created = Instant.now();\n+\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+\n+        AtomicReference<String> docId = new AtomicReference<>();\n+        assertBusy(() -> {\n+            SearchResponse searchResponse = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+                    .setSource(SearchSourceBuilder.searchSource().query(QueryBuilders.termQuery(\"doc_type\", \"api_key\"))).setSize(10)\n+                    .setTerminateAfter(10).get();\n+            assertThat(searchResponse.getHits().getTotalHits().value, equalTo(2L));\n+            docId.set(searchResponse.getHits().getAt(0).getId());\n+        });\n+\n+        // hack doc to modify the expiration time to the week before\n+        Instant weekBefore = created.minus(8L, ChronoUnit.DAYS);\n+        assertTrue(Instant.now().isAfter(weekBefore));\n+        client.prepareUpdate(SecurityIndexManager.SECURITY_INDEX_NAME, \"doc\", docId.get())\n+                .setDoc(\"expiration_time\", weekBefore.toEpochMilli()).setRefreshPolicy(WriteRequest.RefreshPolicy.IMMEDIATE).get();\n+\n+        AtomicBoolean deleteTriggered = new AtomicBoolean(false);\n+        assertBusy(() -> {\n+            if (deleteTriggered.compareAndSet(false, true)) {\n+                securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(1).getId()), new PlainActionFuture<>());\n+            }\n+            client.admin().indices().prepareRefresh(SecurityIndexManager.SECURITY_INDEX_NAME).get();\n+            SearchResponse searchResponse = client.prepareSearch(SecurityIndexManager.SECURITY_INDEX_NAME)\n+                    .setSource(SearchSourceBuilder.searchSource().query(QueryBuilders.termQuery(\"doc_type\", \"api_key\")))\n+                    .setTerminateAfter(10).get();\n+            assertThat(searchResponse.getHits().getTotalHits().value, equalTo(1L));\n+        }, 30, TimeUnit.SECONDS);\n+    }\n+\n+    public void testActiveApiKeysWithNoExpirationNeverGetDeletedByRemover() throws Exception {\n+        List<CreateApiKeyResponse> responses = createApiKeys(2, null);\n+\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+        // trigger expired keys remover\n+        securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(1).getId()), listener);\n+        InvalidateApiKeyResponse invalidateResponse = listener.get();\n+        assertThat(invalidateResponse.getInvalidatedApiKeys().size(), equalTo(1));\n+        assertThat(invalidateResponse.getPreviouslyInvalidatedApiKeys().size(), equalTo(0));\n+        assertThat(invalidateResponse.getErrors().size(), equalTo(0));\n+\n+        PlainActionFuture<GetApiKeyResponse> getApiKeyResponseListener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingRealmName(\"file\"), getApiKeyResponseListener);\n+        GetApiKeyResponse response = getApiKeyResponseListener.get();\n+        verifyGetResponse(2, responses, response, Collections.singleton(responses.get(0).getId()),\n+                Collections.singletonList(responses.get(1).getId()));\n+    }\n+\n+    public void testGetApiKeysForRealm() throws InterruptedException, ExecutionException {\n+        int noOfApiKeys = randomIntBetween(3, 5);\n+        List<CreateApiKeyResponse> responses = createApiKeys(noOfApiKeys, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        boolean invalidate= randomBoolean();\n+        List<String> invalidatedApiKeyIds = null;\n+        Set<String> expectedValidKeyIds = null;\n+        if (invalidate) {\n+            PlainActionFuture<InvalidateApiKeyResponse> listener = new PlainActionFuture<>();\n+            securityClient.invalidateApiKey(InvalidateApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+            InvalidateApiKeyResponse invalidateResponse = listener.get();\n+            invalidatedApiKeyIds = invalidateResponse.getInvalidatedApiKeys();\n+            expectedValidKeyIds = responses.stream().filter(o -> !o.getId().equals(responses.get(0).getId())).map(o -> o.getId())\n+                    .collect(Collectors.toSet());\n+        } else {\n+            invalidatedApiKeyIds = Collections.emptyList();\n+            expectedValidKeyIds = responses.stream().map(o -> o.getId()).collect(Collectors.toSet());\n+        }\n+\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingRealmName(\"file\"), listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(noOfApiKeys, responses, response,\n+                expectedValidKeyIds,\n+                invalidatedApiKeyIds);\n+    }\n+\n+    public void testGetApiKeysForUser() throws Exception {\n+        int noOfApiKeys = randomIntBetween(3, 5);\n+        List<CreateApiKeyResponse> responses = createApiKeys(noOfApiKeys, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingUserName(SecuritySettingsSource.TEST_SUPERUSER), listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(noOfApiKeys, responses, response, responses.stream().map(o -> o.getId()).collect(Collectors.toSet()), null);\n+    }\n+\n+    public void testGetApiKeysForRealmAndUser() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingRealmAndUserName(\"file\", SecuritySettingsSource.TEST_SUPERUSER),\n+                listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(1, responses, response, Collections.singleton(responses.get(0).getId()), null);\n+    }\n+\n+    public void testGetApiKeysForApiKeyId() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingApiKeyId(responses.get(0).getId()), listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(1, responses, response, Collections.singleton(responses.get(0).getId()), null);\n+    }\n+\n+    public void testGetApiKeysForApiKeyName() throws InterruptedException, ExecutionException {\n+        List<CreateApiKeyResponse> responses = createApiKeys(1, null);\n+        Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+        SecurityClient securityClient = new SecurityClient(client);\n+        PlainActionFuture<GetApiKeyResponse> listener = new PlainActionFuture<>();\n+        securityClient.getApiKey(GetApiKeyRequest.usingApiKeyName(responses.get(0).getName()), listener);\n+        GetApiKeyResponse response = listener.get();\n+        verifyGetResponse(1, responses, response, Collections.singleton(responses.get(0).getId()), null);\n+    }\n+\n+    private void verifyGetResponse(int noOfApiKeys, List<CreateApiKeyResponse> responses, GetApiKeyResponse response,\n+                                   Set<String> validApiKeyIds,\n+                                   List<String> invalidatedApiKeyIds) {\n+        assertThat(response.getApiKeyInfos().length, equalTo(noOfApiKeys));\n+        List<String> expectedIds = responses.stream().filter(o -> validApiKeyIds.contains(o.getId())).map(o -> o.getId())\n+                .collect(Collectors.toList());\n+        List<String> actualIds = Arrays.stream(response.getApiKeyInfos()).filter(o -> o.isInvalidated() == false).map(o -> o.getId())\n+                .collect(Collectors.toList());\n+        assertThat(actualIds, containsInAnyOrder(expectedIds.toArray(Strings.EMPTY_ARRAY)));\n+        List<String> expectedNames = responses.stream().filter(o -> validApiKeyIds.contains(o.getId())).map(o -> o.getName())\n+                .collect(Collectors.toList());\n+        List<String> actualNames = Arrays.stream(response.getApiKeyInfos()).filter(o -> o.isInvalidated() == false).map(o -> o.getName())\n+                .collect(Collectors.toList());\n+        assertThat(actualNames, containsInAnyOrder(expectedNames.toArray(Strings.EMPTY_ARRAY)));\n+        Set<String> expectedUsernames = (validApiKeyIds.isEmpty()) ? Collections.emptySet()\n+                : Collections.singleton(SecuritySettingsSource.TEST_SUPERUSER);\n+        Set<String> actualUsernames = Arrays.stream(response.getApiKeyInfos()).filter(o -> o.isInvalidated() == false)\n+                .map(o -> o.getUsername()).collect(Collectors.toSet());\n+        assertThat(actualUsernames, containsInAnyOrder(expectedUsernames.toArray(Strings.EMPTY_ARRAY)));\n+        if (invalidatedApiKeyIds != null) {\n+            List<String> actualInvalidatedApiKeyIds = Arrays.stream(response.getApiKeyInfos()).filter(o -> o.isInvalidated())\n+                    .map(o -> o.getId()).collect(Collectors.toList());\n+            assertThat(invalidatedApiKeyIds, containsInAnyOrder(actualInvalidatedApiKeyIds.toArray(Strings.EMPTY_ARRAY)));\n+        }\n+\n+    }\n+\n+    private List<CreateApiKeyResponse> createApiKeys(int noOfApiKeys, TimeValue expiration) {\n+        List<CreateApiKeyResponse> responses = new ArrayList<>();\n+        for (int i = 0; i < noOfApiKeys; i++) {\n+            final RoleDescriptor descriptor = new RoleDescriptor(\"role\", new String[] { \"monitor\" }, null, null);\n+            Client client = client().filterWithHeader(Collections.singletonMap(\"Authorization\", UsernamePasswordToken\n+                    .basicAuthHeaderValue(SecuritySettingsSource.TEST_SUPERUSER, SecuritySettingsSourceField.TEST_PASSWORD_SECURE_STRING)));\n+            SecurityClient securityClient = new SecurityClient(client);\n+            final CreateApiKeyResponse response = securityClient.prepareCreateApiKey()\n+                    .setName(\"test-key-\" + randomAlphaOfLengthBetween(5, 9) + i).setExpiration(expiration)\n+                    .setRoleDescriptors(Collections.singletonList(descriptor)).get();\n+            assertNotNull(response.getId());\n+            assertNotNull(response.getKey());\n+            responses.add(response);\n+        }\n+        return responses;\n+    }\n+}"
        },
        {
            "sha": "9b40f7dc0e68d801e554a9bf584a9553220330ee",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/ApiKeyServiceTests.java",
            "status": "added",
            "additions": 295,
            "deletions": 0,
            "changes": 295,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyServiceTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyServiceTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FApiKeyServiceTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,295 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.authc;\n+\n+import org.elasticsearch.Version;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.support.PlainActionFuture;\n+import org.elasticsearch.common.bytes.BytesReference;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.xcontent.ToXContent;\n+import org.elasticsearch.common.xcontent.XContentBuilder;\n+import org.elasticsearch.common.xcontent.XContentHelper;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n+import org.elasticsearch.test.ClusterServiceUtils;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.threadpool.TestThreadPool;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n+import org.elasticsearch.xpack.core.security.authc.AuthenticationResult;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n+import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n+import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsCache;\n+import org.elasticsearch.xpack.core.security.authz.permission.Role;\n+import org.elasticsearch.xpack.core.security.authz.permission.LimitedRole;\n+import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n+import org.elasticsearch.xpack.core.security.authz.store.ReservedRolesStore;\n+import org.elasticsearch.xpack.core.security.user.User;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n+import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n+import org.junit.After;\n+import org.junit.Before;\n+\n+import java.nio.charset.StandardCharsets;\n+import java.time.Clock;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Base64;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.instanceOf;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.mockito.Matchers.any;\n+import static org.mockito.Mockito.doAnswer;\n+import static org.mockito.Mockito.mock;\n+\n+public class ApiKeyServiceTests extends ESTestCase {\n+\n+    private ThreadPool threadPool;\n+\n+    @Before\n+    public void createThreadPool() {\n+        threadPool = new TestThreadPool(\"api key service tests\");\n+    }\n+\n+    @After\n+    public void stopThreadPool() {\n+        terminate(threadPool);\n+    }\n+\n+    public void testGetCredentialsFromThreadContext() {\n+        ThreadContext threadContext = new ThreadContext(Settings.EMPTY);\n+        assertNull(ApiKeyService.getCredentialsFromHeader(threadContext));\n+\n+        final String apiKeyAuthScheme = randomFrom(\"apikey\", \"apiKey\", \"ApiKey\", \"APikey\", \"APIKEY\");\n+        final String id = randomAlphaOfLength(12);\n+        final String key = randomAlphaOfLength(16);\n+        String headerValue = apiKeyAuthScheme + \" \" + Base64.getEncoder().encodeToString((id + \":\" + key).getBytes(StandardCharsets.UTF_8));\n+\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            threadContext.putHeader(\"Authorization\", headerValue);\n+            ApiKeyService.ApiKeyCredentials creds = ApiKeyService.getCredentialsFromHeader(threadContext);\n+            assertNotNull(creds);\n+            assertEquals(id, creds.getId());\n+            assertEquals(key, creds.getKey().toString());\n+        }\n+\n+        // missing space\n+        headerValue = apiKeyAuthScheme + Base64.getEncoder().encodeToString((id + \":\" + key).getBytes(StandardCharsets.UTF_8));\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            threadContext.putHeader(\"Authorization\", headerValue);\n+            ApiKeyService.ApiKeyCredentials creds = ApiKeyService.getCredentialsFromHeader(threadContext);\n+            assertNull(creds);\n+        }\n+\n+        // missing colon\n+        headerValue = apiKeyAuthScheme + \" \" + Base64.getEncoder().encodeToString((id + key).getBytes(StandardCharsets.UTF_8));\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            threadContext.putHeader(\"Authorization\", headerValue);\n+            IllegalArgumentException e =\n+                expectThrows(IllegalArgumentException.class, () -> ApiKeyService.getCredentialsFromHeader(threadContext));\n+            assertEquals(\"invalid ApiKey value\", e.getMessage());\n+        }\n+    }\n+\n+    public void testValidateApiKey() throws Exception {\n+        final String apiKey = randomAlphaOfLength(16);\n+        Hasher hasher = randomFrom(Hasher.PBKDF2, Hasher.BCRYPT4, Hasher.BCRYPT);\n+        final char[] hash = hasher.hash(new SecureString(apiKey.toCharArray()));\n+\n+        Map<String, Object> sourceMap = new HashMap<>();\n+        sourceMap.put(\"api_key_hash\", new String(hash));\n+        sourceMap.put(\"role_descriptors\", Collections.singletonMap(\"a role\", Collections.singletonMap(\"cluster\", \"all\")));\n+        sourceMap.put(\"limited_by_role_descriptors\", Collections.singletonMap(\"limited role\", Collections.singletonMap(\"cluster\", \"all\")));\n+        Map<String, Object> creatorMap = new HashMap<>();\n+        creatorMap.put(\"principal\", \"test_user\");\n+        creatorMap.put(\"metadata\", Collections.emptyMap());\n+        sourceMap.put(\"creator\", creatorMap);\n+        sourceMap.put(\"api_key_invalidated\", false);\n+\n+        ApiKeyService.ApiKeyCredentials creds =\n+            new ApiKeyService.ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(apiKey.toCharArray()));\n+        PlainActionFuture<AuthenticationResult> future = new PlainActionFuture<>();\n+        ApiKeyService.validateApiKeyCredentials(sourceMap, creds, Clock.systemUTC(), future);\n+        AuthenticationResult result = future.get();\n+        assertNotNull(result);\n+        assertTrue(result.isAuthenticated());\n+        assertThat(result.getUser().principal(), is(\"test_user\"));\n+        assertThat(result.getUser().roles(), arrayContaining(\"a role\"));\n+        assertThat(result.getUser().metadata(), is(Collections.emptyMap()));\n+        assertThat(result.getMetadata().get(ApiKeyService.API_KEY_ROLE_DESCRIPTORS_KEY), equalTo(sourceMap.get(\"role_descriptors\")));\n+        assertThat(result.getMetadata().get(ApiKeyService.API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY),\n+                equalTo(sourceMap.get(\"limited_by_role_descriptors\")));\n+\n+        sourceMap.put(\"expiration_time\", Clock.systemUTC().instant().plus(1L, ChronoUnit.HOURS).toEpochMilli());\n+        future = new PlainActionFuture<>();\n+        ApiKeyService.validateApiKeyCredentials(sourceMap, creds, Clock.systemUTC(), future);\n+        result = future.get();\n+        assertNotNull(result);\n+        assertTrue(result.isAuthenticated());\n+        assertThat(result.getUser().principal(), is(\"test_user\"));\n+        assertThat(result.getUser().roles(), arrayContaining(\"a role\"));\n+        assertThat(result.getUser().metadata(), is(Collections.emptyMap()));\n+        assertThat(result.getMetadata().get(ApiKeyService.API_KEY_ROLE_DESCRIPTORS_KEY), equalTo(sourceMap.get(\"role_descriptors\")));\n+        assertThat(result.getMetadata().get(ApiKeyService.API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY),\n+                equalTo(sourceMap.get(\"limited_by_role_descriptors\")));\n+\n+        sourceMap.put(\"expiration_time\", Clock.systemUTC().instant().minus(1L, ChronoUnit.HOURS).toEpochMilli());\n+        future = new PlainActionFuture<>();\n+        ApiKeyService.validateApiKeyCredentials(sourceMap, creds, Clock.systemUTC(), future);\n+        result = future.get();\n+        assertNotNull(result);\n+        assertFalse(result.isAuthenticated());\n+\n+        sourceMap.remove(\"expiration_time\");\n+        creds = new ApiKeyService.ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(randomAlphaOfLength(15).toCharArray()));\n+        future = new PlainActionFuture<>();\n+        ApiKeyService.validateApiKeyCredentials(sourceMap, creds, Clock.systemUTC(), future);\n+        result = future.get();\n+        assertNotNull(result);\n+        assertFalse(result.isAuthenticated());\n+        \n+        sourceMap.put(\"api_key_invalidated\", true);\n+        creds = new ApiKeyService.ApiKeyCredentials(randomAlphaOfLength(12), new SecureString(randomAlphaOfLength(15).toCharArray()));\n+        future = new PlainActionFuture<>();\n+        ApiKeyService.validateApiKeyCredentials(sourceMap, creds, Clock.systemUTC(), future);\n+        result = future.get();\n+        assertNotNull(result);\n+        assertFalse(result.isAuthenticated());\n+    }\n+\n+    public void testGetRolesForApiKeyNotInContext() throws Exception {\n+        Map<String, Object> superUserRdMap;\n+        try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n+            superUserRdMap = XContentHelper.convertToMap(XContentType.JSON.xContent(),\n+                BytesReference.bytes(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR\n+                    .toXContent(builder, ToXContent.EMPTY_PARAMS, true))\n+                    .streamInput(),\n+                false);\n+        }\n+        Map<String, Object> authMetadata = new HashMap<>();\n+        authMetadata.put(ApiKeyService.API_KEY_ID_KEY, randomAlphaOfLength(12));\n+        authMetadata.put(ApiKeyService.API_KEY_ROLE_DESCRIPTORS_KEY,\n+            Collections.singletonMap(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName(), superUserRdMap));\n+        authMetadata.put(ApiKeyService.API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY,\n+                Collections.singletonMap(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName(), superUserRdMap));\n+\n+        final Authentication authentication = new Authentication(new User(\"joe\"), new RealmRef(\"apikey\", \"apikey\", \"node\"), null,\n+            Version.CURRENT, AuthenticationType.API_KEY, authMetadata);\n+        CompositeRolesStore rolesStore = mock(CompositeRolesStore.class);\n+        doAnswer(invocationOnMock -> {\n+            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[2];\n+            Collection<RoleDescriptor> descriptors = (Collection<RoleDescriptor>) invocationOnMock.getArguments()[0];\n+            if (descriptors.size() != 1) {\n+                listener.onFailure(new IllegalStateException(\"descriptors was empty!\"));\n+            } else if (descriptors.iterator().next().getName().equals(\"superuser\")) {\n+                listener.onResponse(ReservedRolesStore.SUPERUSER_ROLE);\n+            } else {\n+                listener.onFailure(new IllegalStateException(\"unexpected role name \" + descriptors.iterator().next().getName()));\n+            }\n+            return Void.TYPE;\n+        }).when(rolesStore).buildAndCacheRoleFromDescriptors(any(Collection.class), any(String.class), any(ActionListener.class));\n+        ApiKeyService service = new ApiKeyService(Settings.EMPTY, Clock.systemUTC(), null, null,\n+                ClusterServiceUtils.createClusterService(threadPool), rolesStore);\n+\n+        PlainActionFuture<Role> roleFuture = new PlainActionFuture<>();\n+        service.getRoleForApiKey(authentication, rolesStore, roleFuture);\n+        Role role = roleFuture.get();\n+        assertThat(role.names(), arrayContaining(\"superuser\"));\n+    }\n+\n+    public void testGetRolesForApiKey() throws Exception {\n+        Map<String, Object> authMetadata = new HashMap<>();\n+        authMetadata.put(ApiKeyService.API_KEY_ID_KEY, randomAlphaOfLength(12));\n+        boolean emptyApiKeyRoleDescriptor = randomBoolean();\n+        final RoleDescriptor roleARoleDescriptor = new RoleDescriptor(\"a role\", new String[] { \"monitor\" },\n+                new RoleDescriptor.IndicesPrivileges[] {\n+                        RoleDescriptor.IndicesPrivileges.builder().indices(\"*\").privileges(\"monitor\").build() },\n+                null);\n+        Map<String, Object> roleARDMap;\n+        try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n+            roleARDMap = XContentHelper.convertToMap(XContentType.JSON.xContent(),\n+                    BytesReference.bytes(roleARoleDescriptor.toXContent(builder, ToXContent.EMPTY_PARAMS, true)).streamInput(), false);\n+        }\n+        authMetadata.put(ApiKeyService.API_KEY_ROLE_DESCRIPTORS_KEY,\n+                (emptyApiKeyRoleDescriptor) ? randomFrom(Arrays.asList(null, Collections.emptyMap()))\n+                        : Collections.singletonMap(\"a role\", roleARDMap));\n+\n+        final RoleDescriptor limitedRoleDescriptor = new RoleDescriptor(\"limited role\", new String[] { \"all\" },\n+                new RoleDescriptor.IndicesPrivileges[] {\n+                        RoleDescriptor.IndicesPrivileges.builder().indices(\"*\").privileges(\"all\").build() },\n+                null);\n+        Map<String, Object> limitedRdMap;\n+        try (XContentBuilder builder = JsonXContent.contentBuilder()) {\n+            limitedRdMap = XContentHelper.convertToMap(XContentType.JSON.xContent(),\n+                BytesReference.bytes(limitedRoleDescriptor\n+                    .toXContent(builder, ToXContent.EMPTY_PARAMS, true))\n+                    .streamInput(),\n+                false);\n+        }\n+        authMetadata.put(ApiKeyService.API_KEY_LIMITED_ROLE_DESCRIPTORS_KEY, Collections.singletonMap(\"limited role\", limitedRdMap));\n+\n+        final Authentication authentication = new Authentication(new User(\"joe\"), new RealmRef(\"apikey\", \"apikey\", \"node\"), null,\n+                Version.CURRENT, AuthenticationType.API_KEY, authMetadata);\n+\n+        final NativePrivilegeStore privilegesStore = mock(NativePrivilegeStore.class);\n+        doAnswer(i -> {\n+                assertThat(i.getArguments().length, equalTo(3));\n+                final Object arg2 = i.getArguments()[2];\n+                assertThat(arg2, instanceOf(ActionListener.class));\n+                ActionListener<Collection<ApplicationPrivilege>> listener = (ActionListener<Collection<ApplicationPrivilege>>) arg2;\n+                listener.onResponse(Collections.emptyList());\n+                return null;\n+            }\n+        ).when(privilegesStore).getPrivileges(any(Collection.class), any(Collection.class), any(ActionListener.class));\n+\n+        CompositeRolesStore rolesStore = mock(CompositeRolesStore.class);\n+        doAnswer(invocationOnMock -> {\n+            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[2];\n+            Collection<RoleDescriptor> descriptors = (Collection<RoleDescriptor>) invocationOnMock.getArguments()[0];\n+            if (descriptors.size() != 1) {\n+                listener.onFailure(new IllegalStateException(\"descriptors was empty!\"));\n+            } else if (descriptors.iterator().next().getName().equals(\"a role\")) {\n+                CompositeRolesStore.buildRoleFromDescriptors(descriptors, new FieldPermissionsCache(Settings.EMPTY),\n+                        privilegesStore, ActionListener.wrap(r -> listener.onResponse(r), listener::onFailure));\n+            } else if (descriptors.iterator().next().getName().equals(\"limited role\")) {\n+                CompositeRolesStore.buildRoleFromDescriptors(descriptors, new FieldPermissionsCache(Settings.EMPTY),\n+                        privilegesStore, ActionListener.wrap(r -> listener.onResponse(r), listener::onFailure));\n+            } else {\n+                listener.onFailure(new IllegalStateException(\"unexpected role name \" + descriptors.iterator().next().getName()));\n+            }\n+            return Void.TYPE;\n+        }).when(rolesStore).buildAndCacheRoleFromDescriptors(any(Collection.class), any(String.class), any(ActionListener.class));\n+        ApiKeyService service = new ApiKeyService(Settings.EMPTY, Clock.systemUTC(), null, null,\n+                ClusterServiceUtils.createClusterService(threadPool), rolesStore);\n+\n+        PlainActionFuture<Role> roleFuture = new PlainActionFuture<>();\n+        service.getRoleForApiKey(authentication, rolesStore, roleFuture);\n+        Role role = roleFuture.get();\n+        if (emptyApiKeyRoleDescriptor) {\n+            assertThat(role, instanceOf(Role.class));\n+            assertThat(role.names(), arrayContaining(\"limited role\"));\n+        } else {\n+            assertThat(role, instanceOf(LimitedRole.class));\n+            LimitedRole limitedRole = (LimitedRole) role;\n+            assertThat(limitedRole.names(), arrayContaining(\"a role\"));\n+            assertThat(limitedRole.limitedBy(), is(notNullValue()));\n+            assertThat(limitedRole.limitedBy().names(), arrayContaining(\"limited role\"));\n+        }\n+    }\n+}"
        },
        {
            "sha": "4c1b0737254ad9c770864f202beb388ced5e9b5c",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/AuthenticationServiceTests.java",
            "status": "modified",
            "additions": 137,
            "deletions": 16,
            "changes": 153,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationServiceTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationServiceTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FAuthenticationServiceTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -11,7 +11,9 @@\n import org.elasticsearch.ElasticsearchSecurityException;\n import org.elasticsearch.action.ActionListener;\n import org.elasticsearch.action.get.GetAction;\n+import org.elasticsearch.action.get.GetRequest;\n import org.elasticsearch.action.get.GetRequestBuilder;\n+import org.elasticsearch.action.get.GetResponse;\n import org.elasticsearch.action.get.MultiGetAction;\n import org.elasticsearch.action.get.MultiGetRequestBuilder;\n import org.elasticsearch.action.index.IndexAction;\n@@ -25,6 +27,8 @@\n import org.elasticsearch.cluster.health.ClusterHealthStatus;\n import org.elasticsearch.cluster.service.ClusterService;\n import org.elasticsearch.common.SuppressForbidden;\n+import org.elasticsearch.common.UUIDs;\n+import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.common.collect.Tuple;\n import org.elasticsearch.common.io.stream.BytesStreamOutput;\n import org.elasticsearch.common.io.stream.StreamInput;\n@@ -33,8 +37,11 @@\n import org.elasticsearch.common.transport.TransportAddress;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.json.JsonXContent;\n import org.elasticsearch.env.Environment;\n import org.elasticsearch.env.TestEnvironment;\n+import org.elasticsearch.index.get.GetResult;\n+import org.elasticsearch.index.seqno.SequenceNumbers;\n import org.elasticsearch.license.XPackLicenseState;\n import org.elasticsearch.rest.RestRequest;\n import org.elasticsearch.rest.RestStatus;\n@@ -48,6 +55,7 @@\n import org.elasticsearch.xpack.core.XPackField;\n import org.elasticsearch.xpack.core.XPackSettings;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authc.AuthenticationField;\n import org.elasticsearch.xpack.core.security.authc.AuthenticationResult;\n@@ -56,6 +64,7 @@\n import org.elasticsearch.xpack.core.security.authc.DefaultAuthenticationFailureHandler;\n import org.elasticsearch.xpack.core.security.authc.Realm;\n import org.elasticsearch.xpack.core.security.authc.Realm.Factory;\n+import org.elasticsearch.xpack.core.security.authc.support.Hasher;\n import org.elasticsearch.xpack.core.security.authc.support.UsernamePasswordToken;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n import org.elasticsearch.xpack.core.security.user.AnonymousUser;\n@@ -65,17 +74,22 @@\n import org.elasticsearch.xpack.security.audit.AuditUtil;\n import org.elasticsearch.xpack.security.authc.AuthenticationService.Authenticator;\n import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n+import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n import org.junit.After;\n import org.junit.Before;\n \n import java.io.IOException;\n import java.net.InetAddress;\n import java.net.InetSocketAddress;\n+import java.nio.charset.StandardCharsets;\n import java.time.Clock;\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n import java.util.Arrays;\n import java.util.Base64;\n import java.util.Collections;\n+import java.util.HashMap;\n import java.util.List;\n import java.util.Map;\n import java.util.concurrent.CountDownLatch;\n@@ -127,6 +141,7 @@ public class AuthenticationServiceTests extends ESTestCase {\n     private ThreadPool threadPool;\n     private ThreadContext threadContext;\n     private TokenService tokenService;\n+    private ApiKeyService apiKeyService;\n     private SecurityIndexManager securityIndex;\n     private Client client;\n     private InetSocketAddress remoteAddress;\n@@ -149,10 +164,11 @@ public void init() throws Exception {\n         when(secondRealm.type()).thenReturn(\"second\");\n         when(secondRealm.name()).thenReturn(\"second_realm\");\n         Settings settings = Settings.builder()\n-                .put(\"path.home\", createTempDir())\n-                .put(\"node.name\", \"authc_test\")\n-                .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true)\n-                .build();\n+            .put(\"path.home\", createTempDir())\n+            .put(\"node.name\", \"authc_test\")\n+            .put(XPackSettings.TOKEN_SERVICE_ENABLED_SETTING.getKey(), true)\n+            .put(XPackSettings.API_KEY_SERVICE_ENABLED_SETTING.getKey(), true)\n+            .build();\n         XPackLicenseState licenseState = mock(XPackLicenseState.class);\n         when(licenseState.allowedRealmType()).thenReturn(XPackLicenseState.AllowedRealmType.ALL);\n         when(licenseState.isAuthAllowed()).thenReturn(true);\n@@ -195,9 +211,11 @@ licenseState, threadContext, mock(ReservedRealm.class), Arrays.asList(firstRealm\n             return null;\n         }).when(securityIndex).checkIndexVersionThenExecute(any(Consumer.class), any(Runnable.class));\n         ClusterService clusterService = ClusterServiceUtils.createClusterService(threadPool);\n+        apiKeyService = new ApiKeyService(settings, Clock.systemUTC(), client, securityIndex, clusterService,\n+                mock(CompositeRolesStore.class));\n         tokenService = new TokenService(settings, Clock.systemUTC(), client, securityIndex, clusterService);\n-        service = new AuthenticationService(settings, realms, auditTrail,\n-                new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings), tokenService);\n+        service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()),\n+            threadPool, new AnonymousUser(settings), tokenService, apiKeyService);\n     }\n \n     @After\n@@ -254,6 +272,7 @@ public void testAuthenticateBothSupportSecondSucceeds() throws Exception {\n             assertThat(result.getUser(), is(user));\n             assertThat(result.getLookedUpBy(), is(nullValue()));\n             assertThat(result.getAuthenticatedBy(), is(notNullValue())); // TODO implement equals\n+            assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n             assertThreadContextContainsAuthentication(result);\n             setCompletedToTrue(completed);\n         }, this::logAndFail));\n@@ -346,7 +365,7 @@ public void testAuthenticateSmartRealmOrderingDisabled() {\n             .build();\n         service = new AuthenticationService(settings, realms, auditTrail,\n             new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(Settings.EMPTY),\n-            tokenService);\n+            tokenService, apiKeyService);\n         User user = new User(\"_username\", \"r1\");\n         when(firstRealm.supports(token)).thenReturn(true);\n         mockAuthenticate(firstRealm, token, null);\n@@ -401,6 +420,7 @@ public void testAuthenticateFirstNotSupportingSecondSucceeds() throws Exception\n         service.authenticate(\"_action\", message, (User)null, ActionListener.wrap(result -> {\n             assertThat(result, notNullValue());\n             assertThat(result.getUser(), is(user));\n+            assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n             assertThreadContextContainsAuthentication(result);\n             setCompletedToTrue(completed);\n         }, this::logAndFail));\n@@ -418,6 +438,7 @@ public void testAuthenticateCached() throws Exception {\n \n         assertThat(result, notNullValue());\n         assertThat(result, is(authentication));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n         verifyZeroInteractions(auditTrail);\n         verifyZeroInteractions(firstRealm);\n         verifyZeroInteractions(secondRealm);\n@@ -454,6 +475,7 @@ public void authenticationInContextAndHeader() throws Exception {\n \n         assertThat(result, notNullValue());\n         assertThat(result.getUser(), is(user));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n \n         String userStr = threadContext.getHeader(AuthenticationField.AUTHENTICATION_KEY);\n         assertThat(userStr, notNullValue());\n@@ -499,6 +521,7 @@ public void testAuthenticateTransportFallback() throws Exception {\n         Authentication result = authenticateBlocking(\"_action\", message, user1);\n         assertThat(result, notNullValue());\n         assertThat(result.getUser(), sameInstance(user1));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.INTERNAL));\n         assertThreadContextContainsAuthentication(result);\n     }\n \n@@ -544,6 +567,7 @@ public void testAuthenticateTransportSuccess() throws Exception {\n             assertThat(result, notNullValue());\n             assertThat(result.getUser(), sameInstance(user));\n             assertThreadContextContainsAuthentication(result);\n+            assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n             setCompletedToTrue(completed);\n         }, this::logAndFail));\n \n@@ -562,6 +586,7 @@ public void testAuthenticateRestSuccess() throws Exception {\n         service.authenticate(restRequest, ActionListener.wrap(authentication -> {\n             assertThat(authentication, notNullValue());\n             assertThat(authentication.getUser(), sameInstance(user1));\n+            assertThat(authentication.getAuthenticationType(), is(AuthenticationType.REALM));\n             assertThreadContextContainsAuthentication(authentication);\n             setCompletedToTrue(completed);\n         }, this::logAndFail));\n@@ -571,7 +596,7 @@ public void testAuthenticateRestSuccess() throws Exception {\n         assertTrue(completed.get());\n     }\n \n-    public void testAutheticateTransportContextAndHeader() throws Exception {\n+    public void testAuthenticateTransportContextAndHeader() throws Exception {\n         User user1 = new User(\"username\", \"r1\", \"r2\");\n         when(firstRealm.token(threadContext)).thenReturn(token);\n         when(firstRealm.supports(token)).thenReturn(true);\n@@ -581,9 +606,9 @@ public void testAutheticateTransportContextAndHeader() throws Exception {\n         final SetOnce<String> authHeaderRef = new SetOnce<>();\n         try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n             service.authenticate(\"_action\", message, SystemUser.INSTANCE, ActionListener.wrap(authentication -> {\n-\n                 assertThat(authentication, notNullValue());\n                 assertThat(authentication.getUser(), sameInstance(user1));\n+                assertThat(authentication.getAuthenticationType(), is(AuthenticationType.REALM));\n                 assertThreadContextContainsAuthentication(authentication);\n                 authRef.set(authentication);\n                 authHeaderRef.set(threadContext.getHeader(AuthenticationField.AUTHENTICATION_KEY));\n@@ -600,7 +625,7 @@ public void testAutheticateTransportContextAndHeader() throws Exception {\n             ThreadContext threadContext1 = threadPool1.getThreadContext();\n             service = new AuthenticationService(Settings.EMPTY, realms, auditTrail,\n                 new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool1, new AnonymousUser(Settings.EMPTY),\n-                tokenService);\n+                tokenService, apiKeyService);\n \n             threadContext1.putTransient(AuthenticationField.AUTHENTICATION_KEY, authRef.get());\n             threadContext1.putHeader(AuthenticationField.AUTHENTICATION_KEY, authHeaderRef.get());\n@@ -624,7 +649,7 @@ public void testAutheticateTransportContextAndHeader() throws Exception {\n             try (ThreadContext.StoredContext ignore = threadContext2.stashContext()) {\n                 service = new AuthenticationService(Settings.EMPTY, realms, auditTrail,\n                     new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool2, new AnonymousUser(Settings.EMPTY),\n-                    tokenService);\n+                    tokenService, apiKeyService);\n                 threadContext2.putHeader(AuthenticationField.AUTHENTICATION_KEY, authHeaderRef.get());\n \n                 BytesStreamOutput output = new BytesStreamOutput();\n@@ -638,10 +663,11 @@ public void testAutheticateTransportContextAndHeader() throws Exception {\n             threadPool2.getThreadContext().putHeader(AuthenticationField.AUTHENTICATION_KEY, header);\n             service = new AuthenticationService(Settings.EMPTY, realms, auditTrail,\n                 new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool2, new AnonymousUser(Settings.EMPTY),\n-                tokenService);\n+                tokenService, apiKeyService);\n             service.authenticate(\"_action\", new InternalMessage(), SystemUser.INSTANCE, ActionListener.wrap(result -> {\n                 assertThat(result, notNullValue());\n                 assertThat(result.getUser(), equalTo(user1));\n+                assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n                 setCompletedToTrue(completed);\n             }, this::logAndFail));\n             assertTrue(completed.get());\n@@ -675,13 +701,14 @@ public void testAnonymousUserRest() throws Exception {\n         Settings settings = builder.build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()),\n-            threadPool, anonymousUser, tokenService);\n+            threadPool, anonymousUser, tokenService, apiKeyService);\n         RestRequest request = new FakeRestRequest();\n \n         Authentication result = authenticateBlocking(request);\n \n         assertThat(result, notNullValue());\n         assertThat(result.getUser(), sameInstance((Object) anonymousUser));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.ANONYMOUS));\n         assertThreadContextContainsAuthentication(result);\n         String reqId = expectAuditRequestId();\n         verify(auditTrail).authenticationSuccess(reqId, \"__anonymous\", new AnonymousUser(settings), request);\n@@ -694,12 +721,13 @@ public void testAnonymousUserTransportNoDefaultUser() throws Exception {\n                 .build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()),\n-            threadPool, anonymousUser, tokenService);\n+            threadPool, anonymousUser, tokenService, apiKeyService);\n         InternalMessage message = new InternalMessage();\n \n         Authentication result = authenticateBlocking(\"_action\", message, null);\n         assertThat(result, notNullValue());\n         assertThat(result.getUser(), sameInstance(anonymousUser));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.ANONYMOUS));\n         assertThreadContextContainsAuthentication(result);\n     }\n \n@@ -709,13 +737,14 @@ public void testAnonymousUserTransportWithDefaultUser() throws Exception {\n                 .build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         service = new AuthenticationService(settings, realms, auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()),\n-            threadPool, anonymousUser, tokenService);\n+            threadPool, anonymousUser, tokenService, apiKeyService);\n \n         InternalMessage message = new InternalMessage();\n \n         Authentication result = authenticateBlocking(\"_action\", message, SystemUser.INSTANCE);\n         assertThat(result, notNullValue());\n         assertThat(result.getUser(), sameInstance(SystemUser.INSTANCE));\n+        assertThat(result.getAuthenticationType(), is(AuthenticationType.INTERNAL));\n         assertThreadContextContainsAuthentication(result);\n     }\n \n@@ -910,6 +939,7 @@ public void testRunAsLookupSameRealm() throws Exception {\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         ActionListener<Authentication> listener = ActionListener.wrap(result -> {\n             assertThat(result, notNullValue());\n+            assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n             User authenticated = result.getUser();\n \n             assertThat(authenticated.principal(), is(\"looked up user\"));\n@@ -956,6 +986,7 @@ public void testRunAsLookupDifferentRealm() throws Exception {\n         final AtomicBoolean completed = new AtomicBoolean(false);\n         ActionListener<Authentication> listener = ActionListener.wrap(result -> {\n             assertThat(result, notNullValue());\n+            assertThat(result.getAuthenticationType(), is(AuthenticationType.REALM));\n             User authenticated = result.getUser();\n \n             assertThat(SystemUser.is(authenticated), is(false));\n@@ -1082,7 +1113,7 @@ public void testAuthenticateWithToken() throws Exception {\n                 assertThat(result.getUser(), is(user));\n                 assertThat(result.getLookedUpBy(), is(nullValue()));\n                 assertThat(result.getAuthenticatedBy(), is(notNullValue()));\n-                assertEquals(expected, result);\n+                assertThat(result.getAuthenticationType(), is(AuthenticationType.TOKEN));\n                 setCompletedToTrue(completed);\n             }, this::logAndFail));\n         }\n@@ -1169,6 +1200,96 @@ public void testExpiredToken() throws Exception {\n         }\n     }\n \n+    public void testApiKeyAuthInvalidHeader() {\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            final String invalidHeader = randomFrom(\"apikey\", \"apikey \", \"apikey foo\");\n+            threadContext.putHeader(\"Authorization\", invalidHeader);\n+            ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+                () -> authenticateBlocking(\"_action\", message, null));\n+            assertEquals(RestStatus.UNAUTHORIZED, e.status());\n+            assertThat(e.getMessage(), containsString(\"missing authentication credentials\"));\n+        }\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public void testApiKeyAuth() {\n+        final String id = randomAlphaOfLength(12);\n+        final String key = UUIDs.randomBase64UUID(random());\n+        final String headerValue = \"ApiKey \" + Base64.getEncoder().encodeToString((id + \":\" + key).getBytes(StandardCharsets.UTF_8));\n+        doAnswer(invocationOnMock -> {\n+            final GetRequest request = (GetRequest) invocationOnMock.getArguments()[0];\n+            final ActionListener<GetResponse> listener = (ActionListener<GetResponse>) invocationOnMock.getArguments()[1];\n+            if (request.id().equals(id)) {\n+                final Map<String, Object> source = new HashMap<>();\n+                source.put(\"doc_type\", \"api_key\");\n+                source.put(\"creation_time\", Instant.now().minus(5, ChronoUnit.MINUTES).toEpochMilli());\n+                source.put(\"api_key_invalidated\", false);\n+                source.put(\"api_key_hash\", new String(Hasher.BCRYPT4.hash(new SecureString(key.toCharArray()))));\n+                source.put(\"role_descriptors\", Collections.singletonMap(\"api key role\", Collections.singletonMap(\"cluster\", \"all\")));\n+                source.put(\"name\", \"my api key for testApiKeyAuth\");\n+                Map<String, Object> creatorMap = new HashMap<>();\n+                creatorMap.put(\"principal\", \"johndoe\");\n+                creatorMap.put(\"metadata\", Collections.emptyMap());\n+                creatorMap.put(\"realm\", \"auth realm\");\n+                source.put(\"creator\", creatorMap);\n+                GetResponse getResponse = new GetResponse(new GetResult(request.index(), request.type(), request.id(), 0, 1, 1L, true,\n+                    BytesReference.bytes(JsonXContent.contentBuilder().map(source)), Collections.emptyMap()));\n+                listener.onResponse(getResponse);\n+            } else {\n+                listener.onResponse(new GetResponse(new GetResult(request.index(), request.type(), request.id(),\n+                        SequenceNumbers.UNASSIGNED_SEQ_NO, 1, -1L, false, null, Collections.emptyMap())));\n+            }\n+            return Void.TYPE;\n+        }).when(client).get(any(GetRequest.class), any(ActionListener.class));\n+\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            threadContext.putHeader(\"Authorization\", headerValue);\n+            final Authentication authentication = authenticateBlocking(\"_action\", message, null);\n+            assertThat(authentication.getUser().principal(), is(\"johndoe\"));\n+            assertThat(authentication.getAuthenticationType(), is(AuthenticationType.API_KEY));\n+        }\n+    }\n+\n+    public void testExpiredApiKey() {\n+        final String id = randomAlphaOfLength(12);\n+        final String key = UUIDs.randomBase64UUID(random());\n+        final String headerValue = \"ApiKey \" + Base64.getEncoder().encodeToString((id + \":\" + key).getBytes(StandardCharsets.UTF_8));\n+        doAnswer(invocationOnMock -> {\n+            final GetRequest request = (GetRequest) invocationOnMock.getArguments()[0];\n+            final ActionListener<GetResponse> listener = (ActionListener<GetResponse>) invocationOnMock.getArguments()[1];\n+            if (request.id().equals(id)) {\n+                final Map<String, Object> source = new HashMap<>();\n+                source.put(\"doc_type\", \"api_key\");\n+                source.put(\"creation_time\", Instant.now().minus(5L, ChronoUnit.HOURS).toEpochMilli());\n+                source.put(\"expiration_time\", Instant.now().minus(1L, ChronoUnit.HOURS).toEpochMilli());\n+                source.put(\"api_key_invalidated\", false);\n+                source.put(\"api_key_hash\", new String(Hasher.BCRYPT4.hash(new SecureString(key.toCharArray()))));\n+                source.put(\"role_descriptors\", Collections.singletonList(Collections.singletonMap(\"name\", \"a role\")));\n+                source.put(\"name\", \"my api key for testApiKeyAuth\");\n+                Map<String, Object> creatorMap = new HashMap<>();\n+                creatorMap.put(\"principal\", \"johndoe\");\n+                creatorMap.put(\"metadata\", Collections.emptyMap());\n+                creatorMap.put(\"realm\", \"auth realm\");\n+                source.put(\"creator\", creatorMap);\n+                GetResponse getResponse = new GetResponse(new GetResult(request.index(), request.type(), request.id(), 0, 1, 1L, true,\n+                        BytesReference.bytes(JsonXContent.contentBuilder().map(source)), Collections.emptyMap()));\n+                listener.onResponse(getResponse);\n+            } else {\n+                listener.onResponse(new GetResponse(new GetResult(request.index(), request.type(), request.id(),\n+                        SequenceNumbers.UNASSIGNED_SEQ_NO, 1, -1L, false, null, Collections.emptyMap())));\n+            }\n+            return Void.TYPE;\n+        }).when(client).get(any(GetRequest.class), any(ActionListener.class));\n+\n+        try (ThreadContext.StoredContext ignore = threadContext.stashContext()) {\n+            threadContext.putHeader(\"Authorization\", headerValue);\n+            ElasticsearchSecurityException e = expectThrows(ElasticsearchSecurityException.class,\n+                () -> authenticateBlocking(\"_action\", message, null));\n+            assertThat(e.getMessage(), containsString(\"api key is expired\"));\n+            assertEquals(RestStatus.UNAUTHORIZED, e.status());\n+        }\n+    }\n+\n     private static class InternalMessage extends TransportMessage {\n     }\n "
        },
        {
            "sha": "8caf82e8648cba7445710ae484c51f6438151f14",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authc/TokenServiceTests.java",
            "status": "modified",
            "additions": 28,
            "deletions": 13,
            "changes": 41,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenServiceTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenServiceTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthc%2FTokenServiceTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -40,6 +40,7 @@\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.xpack.core.XPackSettings;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authc.TokenMetaData;\n import org.elasticsearch.xpack.core.security.authc.support.TokensInvalidationResult;\n@@ -147,6 +148,7 @@ public void testAttachAndGetToken() throws Exception {\n         final UserToken token = tokenFuture.get().v1();\n         assertNotNull(token);\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", randomFrom(\"Bearer \", \"BEARER \", \"bearer \") + tokenService.getUserTokenString(token));\n@@ -155,7 +157,7 @@ public void testAttachAndGetToken() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n@@ -166,7 +168,7 @@ public void testAttachAndGetToken() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             anotherService.getAndValidateToken(requestContext, future);\n             UserToken fromOtherService = future.get();\n-            assertEquals(authentication, fromOtherService.getAuthentication());\n+            assertAuthentication(authentication, fromOtherService.getAuthentication());\n         }\n     }\n \n@@ -193,6 +195,7 @@ public void testRotateKey() throws Exception {\n         final UserToken token = tokenFuture.get().v1();\n         assertNotNull(token);\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", \"Bearer \" + tokenService.getUserTokenString(token));\n@@ -201,15 +204,15 @@ public void testRotateKey() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n         rotateKeys(tokenService);\n \n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n         PlainActionFuture<Tuple<UserToken, String>> newTokenFuture = new PlainActionFuture<>();\n@@ -226,7 +229,7 @@ public void testRotateKey() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n     }\n \n@@ -252,14 +255,15 @@ public void testKeyExchange() throws Exception {\n         final UserToken token = tokenFuture.get().v1();\n         assertNotNull(token);\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", \"Bearer \" + tokenService.getUserTokenString(token));\n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             otherTokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n         rotateKeys(tokenService);\n@@ -282,6 +286,7 @@ public void testPruneKeys() throws Exception {\n         final UserToken token = tokenFuture.get().v1();\n         assertNotNull(token);\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", \"Bearer \" + tokenService.getUserTokenString(token));\n@@ -290,7 +295,7 @@ public void testPruneKeys() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n         TokenMetaData metaData = tokenService.pruneKeys(randomIntBetween(0, 100));\n         tokenService.refreshMetaData(metaData);\n@@ -304,7 +309,7 @@ public void testPruneKeys() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n         PlainActionFuture<Tuple<UserToken, String>> newTokenFuture = new PlainActionFuture<>();\n@@ -330,7 +335,7 @@ public void testPruneKeys() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n     }\n@@ -343,6 +348,7 @@ public void testPassphraseWorks() throws Exception {\n         final UserToken token = tokenFuture.get().v1();\n         assertNotNull(token);\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", \"Bearer \" + tokenService.getUserTokenString(token));\n@@ -351,7 +357,7 @@ public void testPassphraseWorks() throws Exception {\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n             UserToken serialized = future.get();\n-            assertEquals(authentication, serialized.getAuthentication());\n+            assertAuthentication(authentication, serialized.getAuthentication());\n         }\n \n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n@@ -440,6 +446,7 @@ public void testTokenExpiry() throws Exception {\n         tokenService.createUserToken(authentication, authentication, tokenFuture, Collections.emptyMap(), true);\n         final UserToken token = tokenFuture.get().v1();\n         mockGetTokenFromId(token, false);\n+        authentication = token.getAuthentication();\n \n         ThreadContext requestContext = new ThreadContext(Settings.EMPTY);\n         requestContext.putHeader(\"Authorization\", \"Bearer \" + tokenService.getUserTokenString(token));\n@@ -448,7 +455,7 @@ public void testTokenExpiry() throws Exception {\n             // the clock is still frozen, so the cookie should be valid\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n-            assertEquals(authentication, future.get().getAuthentication());\n+            assertAuthentication(authentication, future.get().getAuthentication());\n         }\n \n         final TimeValue defaultExpiration = TokenService.TOKEN_EXPIRATION.get(Settings.EMPTY);\n@@ -458,7 +465,7 @@ public void testTokenExpiry() throws Exception {\n             clock.fastForwardSeconds(fastForwardAmount);\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n-            assertEquals(authentication, future.get().getAuthentication());\n+            assertAuthentication(authentication, future.get().getAuthentication());\n         }\n \n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n@@ -467,7 +474,7 @@ public void testTokenExpiry() throws Exception {\n             clock.rewind(TimeValue.timeValueNanos(clock.instant().getNano())); // trim off nanoseconds since don't store them in the index\n             PlainActionFuture<UserToken> future = new PlainActionFuture<>();\n             tokenService.getAndValidateToken(requestContext, future);\n-            assertEquals(authentication, future.get().getAuthentication());\n+            assertAuthentication(authentication, future.get().getAuthentication());\n         }\n \n         try (ThreadContext.StoredContext ignore = requestContext.newStoredContext(true)) {\n@@ -624,4 +631,12 @@ public static void mockGetTokenFromId(UserToken userToken, boolean isExpired, Cl\n             return Void.TYPE;\n         }).when(client).get(any(GetRequest.class), any(ActionListener.class));\n     }\n+\n+    public static void assertAuthentication(Authentication result, Authentication expected) {\n+        assertEquals(expected.getUser(), result.getUser());\n+        assertEquals(expected.getAuthenticatedBy(), result.getAuthenticatedBy());\n+        assertEquals(expected.getLookedUpBy(), result.getLookedUpBy());\n+        assertEquals(expected.getMetadata(), result.getMetadata());\n+        assertEquals(AuthenticationType.TOKEN, result.getAuthenticationType());\n+    }\n }"
        },
        {
            "sha": "b9181a43411856cc83b91281a2389c9a27cda6ed",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/AuthorizationServiceTests.java",
            "status": "modified",
            "additions": 159,
            "deletions": 79,
            "changes": 238,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationServiceTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationServiceTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FAuthorizationServiceTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -72,6 +72,7 @@\n import org.elasticsearch.action.update.UpdateAction;\n import org.elasticsearch.action.update.UpdateRequest;\n import org.elasticsearch.client.Client;\n+import org.elasticsearch.client.security.user.privileges.Role.ClusterPrivilegeName;\n import org.elasticsearch.cluster.ClusterState;\n import org.elasticsearch.cluster.metadata.AliasMetaData;\n import org.elasticsearch.cluster.metadata.IndexMetaData;\n@@ -84,6 +85,7 @@\n import org.elasticsearch.common.settings.ClusterSettings;\n import org.elasticsearch.common.settings.Settings;\n import org.elasticsearch.common.util.concurrent.ThreadContext;\n+import org.elasticsearch.common.util.concurrent.ThreadContext.StoredContext;\n import org.elasticsearch.index.IndexNotFoundException;\n import org.elasticsearch.index.shard.ShardId;\n import org.elasticsearch.license.GetLicenseAction;\n@@ -103,6 +105,7 @@\n import org.elasticsearch.xpack.core.security.action.user.PutUserAction;\n import org.elasticsearch.xpack.core.security.action.user.UserRequest;\n import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.AuthenticationType;\n import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authc.DefaultAuthenticationFailureHandler;\n import org.elasticsearch.xpack.core.security.authc.esnative.NativeRealmSettings;\n@@ -116,6 +119,7 @@\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsCache;\n import org.elasticsearch.xpack.core.security.authz.permission.Role;\n+import org.elasticsearch.xpack.core.security.authz.permission.LimitedRole;\n import org.elasticsearch.xpack.core.security.authz.privilege.ApplicationPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.ClusterPrivilege;\n import org.elasticsearch.xpack.core.security.authz.privilege.ConditionalClusterPrivilege;\n@@ -127,6 +131,7 @@\n import org.elasticsearch.xpack.core.security.user.XPackUser;\n import org.elasticsearch.xpack.security.audit.AuditTrailService;\n import org.elasticsearch.xpack.security.audit.AuditUtil;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n import org.elasticsearch.xpack.security.authc.esnative.ReservedRealm;\n import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n import org.elasticsearch.xpack.security.authz.store.NativePrivilegeStore;\n@@ -135,6 +140,7 @@\n import org.junit.Before;\n import org.mockito.Mockito;\n \n+import java.io.IOException;\n import java.util.ArrayList;\n import java.util.Arrays;\n import java.util.Collection;\n@@ -163,6 +169,7 @@\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.startsWith;\n import static org.mockito.Matchers.any;\n+import static org.mockito.Matchers.eq;\n import static org.mockito.Mockito.doAnswer;\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.times;\n@@ -179,6 +186,7 @@ public class AuthorizationServiceTests extends ESTestCase {\n     private ThreadPool threadPool;\n     private Map<String, RoleDescriptor> roleMap = new HashMap<>();\n     private CompositeRolesStore rolesStore;\n+    private ApiKeyService apiKeyService;\n \n     @SuppressWarnings(\"unchecked\")\n     @Before\n@@ -208,7 +216,7 @@ public void setup() {\n         ).when(privilegesStore).getPrivileges(any(Collection.class), any(Collection.class), any(ActionListener.class));\n \n         doAnswer((i) -> {\n-            ActionListener<Role> callback = (ActionListener<Role>) i.getArguments()[2];\n+            ActionListener<Role> callback = (ActionListener<Role>) i.getArguments()[1];\n             Set<String> names = (Set<String>) i.getArguments()[0];\n             assertNotNull(names);\n             Set<RoleDescriptor> roleDescriptors = new HashSet<>();\n@@ -227,9 +235,11 @@ public void setup() {\n                 );\n             }\n             return Void.TYPE;\n-        }).when(rolesStore).roles(any(Set.class), any(FieldPermissionsCache.class), any(ActionListener.class));\n-        authorizationService = new AuthorizationService(settings, rolesStore, clusterService,\n-            auditTrail, new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings));\n+        }).when(rolesStore).roles(any(Set.class), any(ActionListener.class));\n+        apiKeyService = mock(ApiKeyService.class);\n+        authorizationService = new AuthorizationService(settings, rolesStore, clusterService, auditTrail,\n+            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings),\n+            apiKeyService, new FieldPermissionsCache(Settings.EMPTY));\n     }\n \n     private void authorize(Authentication authentication, String action, TransportRequest request) {\n@@ -243,7 +253,7 @@ private void authorize(Authentication authentication, String action, TransportRe\n         future.actionGet();\n     }\n \n-    public void testActionsForSystemUserIsAuthorized() {\n+    public void testActionsForSystemUserIsAuthorized() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n \n@@ -268,7 +278,7 @@ public void testActionsForSystemUserIsAuthorized() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testIndicesActionsForSystemUserWhichAreNotAuthorized() {\n+    public void testIndicesActionsForSystemUserWhichAreNotAuthorized() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final Authentication authentication = createAuthentication(SystemUser.INSTANCE);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n@@ -279,7 +289,7 @@ public void testIndicesActionsForSystemUserWhichAreNotAuthorized() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testClusterAdminActionsForSystemUserWhichAreNotAuthorized() {\n+    public void testClusterAdminActionsForSystemUserWhichAreNotAuthorized() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final Authentication authentication = createAuthentication(SystemUser.INSTANCE);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n@@ -291,7 +301,7 @@ public void testClusterAdminActionsForSystemUserWhichAreNotAuthorized() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testClusterAdminSnapshotStatusActionForSystemUserWhichIsNotAuthorized() {\n+    public void testClusterAdminSnapshotStatusActionForSystemUserWhichIsNotAuthorized() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final Authentication authentication = createAuthentication(SystemUser.INSTANCE);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n@@ -303,7 +313,7 @@ public void testClusterAdminSnapshotStatusActionForSystemUserWhichIsNotAuthorize\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testAuthorizeUsingConditionalPrivileges() {\n+    public void testAuthorizeUsingConditionalPrivileges() throws IOException {\n         final DeletePrivilegesRequest request = new DeletePrivilegesRequest();\n         final Authentication authentication = createAuthentication(new User(\"user1\", \"role1\"));\n \n@@ -323,7 +333,7 @@ public void testAuthorizeUsingConditionalPrivileges() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testAuthorizationDeniedWhenConditionalPrivilegesDoNotMatch() {\n+    public void testAuthorizationDeniedWhenConditionalPrivilegesDoNotMatch() throws IOException {\n         final DeletePrivilegesRequest request = new DeletePrivilegesRequest();\n         final Authentication authentication = createAuthentication(new User(\"user1\", \"role1\"));\n \n@@ -345,7 +355,7 @@ public void testAuthorizationDeniedWhenConditionalPrivilegesDoNotMatch() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testNoRolesCausesDenial() {\n+    public void testNoRolesCausesDenial() throws IOException {\n         final TransportRequest request = new SearchRequest();\n         final Authentication authentication = createAuthentication(new User(\"test user\"));\n         mockEmptyMetaData();\n@@ -357,7 +367,7 @@ public void testNoRolesCausesDenial() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testUserWithNoRolesCanPerformRemoteSearch() {\n+    public void testUserWithNoRolesCanPerformRemoteSearch() throws IOException {\n         SearchRequest request = new SearchRequest();\n         request.indices(\"other_cluster:index1\", \"*_cluster:index2\", \"other_cluster:other_*\");\n         final Authentication authentication = createAuthentication(new User(\"test user\"));\n@@ -373,7 +383,7 @@ public void testUserWithNoRolesCanPerformRemoteSearch() {\n      * while the referenced index _looks_ like a remote index, the remote cluster name has not\n      * been defined, so it is actually a local index and access should be denied\n      */\n-    public void testUserWithNoRolesCannotPerformLocalSearch() {\n+    public void testUserWithNoRolesCannotPerformLocalSearch() throws IOException {\n         SearchRequest request = new SearchRequest();\n         request.indices(\"no_such_cluster:index\");\n         final Authentication authentication = createAuthentication(new User(\"test user\"));\n@@ -390,7 +400,7 @@ public void testUserWithNoRolesCannotPerformLocalSearch() {\n      * This test mimics {@link #testUserWithNoRolesCannotPerformLocalSearch()} but includes\n      * both local and remote indices, including wildcards\n      */\n-    public void testUserWithNoRolesCanPerformMultiClusterSearch() {\n+    public void testUserWithNoRolesCanPerformMultiClusterSearch() throws IOException {\n         SearchRequest request = new SearchRequest();\n         request.indices(\"local_index\", \"wildcard_*\", \"other_cluster:remote_index\", \"*:foo?\");\n         final Authentication authentication = createAuthentication(new User(\"test user\"));\n@@ -403,7 +413,7 @@ public void testUserWithNoRolesCanPerformMultiClusterSearch() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testUserWithNoRolesCannotSql() {\n+    public void testUserWithNoRolesCannotSql() throws IOException {\n         TransportRequest request = new SqlQueryRequest();\n         Authentication authentication = createAuthentication(new User(\"test user\"));\n         mockEmptyMetaData();\n@@ -418,7 +428,7 @@ public void testUserWithNoRolesCannotSql() {\n      * Verifies that the behaviour tested in {@link #testUserWithNoRolesCanPerformRemoteSearch}\n      * does not work for requests that are not remote-index-capable.\n      */\n-    public void testRemoteIndicesOnlyWorkWithApplicableRequestTypes() {\n+    public void testRemoteIndicesOnlyWorkWithApplicableRequestTypes() throws IOException {\n         DeleteIndexRequest request = new DeleteIndexRequest();\n         request.indices(\"other_cluster:index1\", \"other_cluster:index2\");\n         final Authentication authentication = createAuthentication(new User(\"test user\"));\n@@ -431,7 +441,7 @@ public void testRemoteIndicesOnlyWorkWithApplicableRequestTypes() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testUnknownRoleCausesDenial() {\n+    public void testUnknownRoleCausesDenial() throws IOException {\n         Tuple<String, TransportRequest> tuple = randomFrom(asList(\n             new Tuple<>(SearchAction.NAME, new SearchRequest()),\n             new Tuple<>(IndicesExistsAction.NAME, new IndicesExistsRequest()),\n@@ -448,7 +458,7 @@ public void testUnknownRoleCausesDenial() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testThatNonIndicesAndNonClusterActionIsDenied() {\n+    public void testThatNonIndicesAndNonClusterActionIsDenied() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n@@ -463,7 +473,7 @@ public void testThatNonIndicesAndNonClusterActionIsDenied() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testThatRoleWithNoIndicesIsDenied() {\n+    public void testThatRoleWithNoIndicesIsDenied() throws IOException {\n         @SuppressWarnings(\"unchecked\")\n         Tuple<String, TransportRequest> tuple = randomFrom(\n             new Tuple<>(SearchAction.NAME, new SearchRequest()),\n@@ -484,7 +494,7 @@ public void testThatRoleWithNoIndicesIsDenied() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testElasticUserAuthorizedForNonChangePasswordRequestsWhenNotInSetupMode() {\n+    public void testElasticUserAuthorizedForNonChangePasswordRequestsWhenNotInSetupMode() throws IOException {\n         final Authentication authentication = createAuthentication(new ElasticUser(true));\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n         final Tuple<String, TransportRequest> request = randomCompositeRequest();\n@@ -493,7 +503,7 @@ public void testElasticUserAuthorizedForNonChangePasswordRequestsWhenNotInSetupM\n         verify(auditTrail).accessGranted(requestId, authentication, request.v1(), request.v2(), new String[]{ElasticUser.ROLE_NAME});\n     }\n \n-    public void testSearchAgainstEmptyCluster() {\n+    public void testSearchAgainstEmptyCluster() throws IOException {\n         RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null);\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n@@ -524,11 +534,11 @@ public void testSearchAgainstEmptyCluster() {\n             final IndicesAccessControl.IndexAccessControl indexAccessControl =\n                 indicesAccessControl.getIndexPermissions(IndicesAndAliasesResolverField.NO_INDEX_PLACEHOLDER);\n             assertFalse(indexAccessControl.getFieldPermissions().hasFieldLevelSecurity());\n-            assertNull(indexAccessControl.getQueries());\n+            assertFalse(indexAccessControl.getDocumentPermissions().hasDocumentLevelPermissions());\n         }\n     }\n \n-    public void testScrollRelatedRequestsAllowed() {\n+    public void testScrollRelatedRequestsAllowed() throws IOException {\n         RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null);\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n@@ -570,7 +580,7 @@ public void testScrollRelatedRequestsAllowed() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testAuthorizeIndicesFailures() {\n+    public void testAuthorizeIndicesFailures() throws IOException {\n         TransportRequest request = new GetIndexRequest().indices(\"b\");\n         ClusterState state = mockEmptyMetaData();\n         RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n@@ -588,7 +598,7 @@ public void testAuthorizeIndicesFailures() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testCreateIndexWithAliasWithoutPermissions() {\n+    public void testCreateIndexWithAliasWithoutPermissions() throws IOException {\n         CreateIndexRequest request = new CreateIndexRequest(\"a\");\n         request.alias(new Alias(\"a2\"));\n         ClusterState state = mockEmptyMetaData();\n@@ -607,7 +617,7 @@ public void testCreateIndexWithAliasWithoutPermissions() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testCreateIndexWithAlias() {\n+    public void testCreateIndexWithAlias() throws IOException {\n         CreateIndexRequest request = new CreateIndexRequest(\"a\");\n         request.alias(new Alias(\"a2\"));\n         ClusterState state = mockEmptyMetaData();\n@@ -625,13 +635,14 @@ public void testCreateIndexWithAlias() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testDenialForAnonymousUser() {\n+    public void testDenialForAnonymousUser() throws IOException {\n         TransportRequest request = new GetIndexRequest().indices(\"b\");\n         ClusterState state = mockEmptyMetaData();\n         Settings settings = Settings.builder().put(AnonymousUser.ROLES_SETTING.getKey(), \"a_all\").build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         authorizationService = new AuthorizationService(settings, rolesStore, clusterService, auditTrail,\n-            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser);\n+            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, apiKeyService,\n+            new FieldPermissionsCache(settings));\n \n         RoleDescriptor role = new RoleDescriptor(\"a_all\", null,\n             new IndicesPrivileges[] { IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build() }, null);\n@@ -648,7 +659,7 @@ public void testDenialForAnonymousUser() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testDenialForAnonymousUserAuthorizationExceptionDisabled() {\n+    public void testDenialForAnonymousUserAuthorizationExceptionDisabled() throws IOException {\n         TransportRequest request = new GetIndexRequest().indices(\"b\");\n         ClusterState state = mockEmptyMetaData();\n         Settings settings = Settings.builder()\n@@ -657,7 +668,8 @@ public void testDenialForAnonymousUserAuthorizationExceptionDisabled() {\n             .build();\n         final Authentication authentication = createAuthentication(new AnonymousUser(settings));\n         authorizationService = new AuthorizationService(settings, rolesStore, clusterService, auditTrail,\n-            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings));\n+            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, new AnonymousUser(settings),\n+            apiKeyService, new FieldPermissionsCache(settings));\n \n         RoleDescriptor role = new RoleDescriptor(\"a_all\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null);\n@@ -673,7 +685,7 @@ public void testDenialForAnonymousUserAuthorizationExceptionDisabled() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testAuditTrailIsRecordedWhenIndexWildcardThrowsError() {\n+    public void testAuditTrailIsRecordedWhenIndexWildcardThrowsError() throws IOException {\n         IndicesOptions options = IndicesOptions.fromOptions(false, false, true, true);\n         TransportRequest request = new GetIndexRequest().indices(\"not-an-index-*\").indicesOptions(options);\n         ClusterState state = mockEmptyMetaData();\n@@ -694,7 +706,7 @@ public void testAuditTrailIsRecordedWhenIndexWildcardThrowsError() {\n         verify(state, times(1)).metaData();\n     }\n \n-    public void testRunAsRequestWithNoRolesUser() {\n+    public void testRunAsRequestWithNoRolesUser() throws IOException {\n         final TransportRequest request = mock(TransportRequest.class);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n         final Authentication authentication = createAuthentication(new User(\"run as me\", null, new User(\"test user\", \"admin\")));\n@@ -706,12 +718,13 @@ public void testRunAsRequestWithNoRolesUser() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testRunAsRequestWithoutLookedUpBy() {\n+    public void testRunAsRequestWithoutLookedUpBy() throws IOException {\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n         AuthenticateRequest request = new AuthenticateRequest(\"run as me\");\n         roleMap.put(\"can run as\", ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR);\n         User user = new User(\"run as me\", Strings.EMPTY_ARRAY, new User(\"test user\", new String[]{\"can run as\"}));\n         Authentication authentication = new Authentication(user, new RealmRef(\"foo\", \"bar\", \"baz\"), null);\n+        authentication.writeToContext(threadContext);\n         assertNotEquals(user.authenticatedUser(), user);\n         assertThrowsAuthorizationExceptionRunAs(\n             () -> authorize(authentication, AuthenticateAction.NAME, request),\n@@ -721,7 +734,7 @@ public void testRunAsRequestWithoutLookedUpBy() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testRunAsRequestRunningAsUnAllowedUser() {\n+    public void testRunAsRequestRunningAsUnAllowedUser() throws IOException {\n         TransportRequest request = mock(TransportRequest.class);\n         User user = new User(\"run as me\", new String[]{\"doesn't exist\"}, new User(\"test user\", \"can run as\"));\n         assertNotEquals(user.authenticatedUser(), user);\n@@ -739,7 +752,7 @@ public void testRunAsRequestRunningAsUnAllowedUser() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testRunAsRequestWithRunAsUserWithoutPermission() {\n+    public void testRunAsRequestWithRunAsUserWithoutPermission() throws IOException {\n         TransportRequest request = new GetIndexRequest().indices(\"a\");\n         User authenticatedUser = new User(\"test user\", \"can run as\");\n         User user = new User(\"run as me\", new String[]{\"b\"}, authenticatedUser);\n@@ -779,7 +792,7 @@ public void testRunAsRequestWithRunAsUserWithoutPermission() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testRunAsRequestWithValidPermissions() {\n+    public void testRunAsRequestWithValidPermissions() throws IOException {\n         TransportRequest request = new GetIndexRequest().indices(\"b\");\n         User authenticatedUser = new User(\"test user\", new String[]{\"can run as\"});\n         User user = new User(\"run as me\", new String[]{\"b\"}, authenticatedUser);\n@@ -807,7 +820,7 @@ public void testRunAsRequestWithValidPermissions() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testGrantAllRestrictedUserCannotExecuteOperationAgainstSecurityIndices() {\n+    public void testGrantAllRestrictedUserCannotExecuteOperationAgainstSecurityIndices() throws IOException {\n         RoleDescriptor role = new RoleDescriptor(\"all access\", new String[]{\"all\"},\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"*\").privileges(\"all\").build()}, null);\n         final Authentication authentication = createAuthentication(new User(\"all_access_user\", \"all_access\"));\n@@ -878,15 +891,13 @@ public void testGrantAllRestrictedUserCannotExecuteOperationAgainstSecurityIndic\n         assertEquals(IndicesAndAliasesResolver.NO_INDICES_OR_ALIASES_LIST, Arrays.asList(searchRequest.indices()));\n     }\n \n-    public void testMonitoringOperationsAgainstSecurityIndexRequireAllowRestricted() {\n+    public void testMonitoringOperationsAgainstSecurityIndexRequireAllowRestricted() throws IOException {\n         final RoleDescriptor restrictedMonitorRole = new RoleDescriptor(\"restricted_monitor\", null,\n                 new IndicesPrivileges[] { IndicesPrivileges.builder().indices(\"*\").privileges(\"monitor\").build() }, null);\n         final RoleDescriptor unrestrictedMonitorRole = new RoleDescriptor(\"unrestricted_monitor\", null, new IndicesPrivileges[] {\n                 IndicesPrivileges.builder().indices(\"*\").privileges(\"monitor\").allowRestrictedIndices(true).build() }, null);\n         roleMap.put(\"restricted_monitor\", restrictedMonitorRole);\n         roleMap.put(\"unrestricted_monitor\", unrestrictedMonitorRole);\n-        final Authentication restrictedUserAuthn = createAuthentication(new User(\"restricted_user\", \"restricted_monitor\"));\n-        final Authentication unrestrictedUserAuthn = createAuthentication(new User(\"unrestricted_user\", \"unrestricted_monitor\"));\n         ClusterState state = mock(ClusterState.class);\n         when(clusterService.state()).thenReturn(state);\n         when(state.metaData()).thenReturn(MetaData.builder()\n@@ -897,7 +908,6 @@ public void testMonitoringOperationsAgainstSecurityIndexRequireAllowRestricted()\n                     .numberOfReplicas(0)\n                     .build(), true)\n             .build());\n-        final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n \n         List<Tuple<String, ? extends TransportRequest>> requests = new ArrayList<>();\n         requests.add(new Tuple<>(IndicesStatsAction.NAME, new IndicesStatsRequest().indices(SECURITY_INDEX_NAME)));\n@@ -910,16 +920,25 @@ public void testMonitoringOperationsAgainstSecurityIndexRequireAllowRestricted()\n         for (final Tuple<String, ? extends TransportRequest> requestTuple : requests) {\n             final String action = requestTuple.v1();\n             final TransportRequest request = requestTuple.v2();\n-            assertThrowsAuthorizationException(() -> authorize(restrictedUserAuthn, action, request), action, \"restricted_user\");\n-            verify(auditTrail).accessDenied(requestId, restrictedUserAuthn, action, request, new String[] { \"restricted_monitor\" });\n-            verifyNoMoreInteractions(auditTrail);\n-            authorize(unrestrictedUserAuthn, action, request);\n-            verify(auditTrail).accessGranted(requestId, unrestrictedUserAuthn, action, request, new String[] { \"unrestricted_monitor\" });\n-            verifyNoMoreInteractions(auditTrail);\n+            try (StoredContext storedContext = threadContext.stashContext()) {\n+                final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n+                final Authentication restrictedUserAuthn = createAuthentication(new User(\"restricted_user\", \"restricted_monitor\"));\n+                assertThrowsAuthorizationException(() -> authorize(restrictedUserAuthn, action, request), action, \"restricted_user\");\n+                verify(auditTrail).accessDenied(requestId, restrictedUserAuthn, action, request, new String[] { \"restricted_monitor\" });\n+                verifyNoMoreInteractions(auditTrail);\n+            }\n+            try (StoredContext storedContext = threadContext.stashContext()) {\n+                final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n+                final Authentication unrestrictedUserAuthn = createAuthentication(new User(\"unrestricted_user\", \"unrestricted_monitor\"));\n+                authorize(unrestrictedUserAuthn, action, request);\n+                verify(auditTrail).accessGranted(requestId, unrestrictedUserAuthn, action, request,\n+                        new String[] { \"unrestricted_monitor\" });\n+                verifyNoMoreInteractions(auditTrail);\n+            }\n         }\n     }\n \n-    public void testSuperusersCanExecuteOperationAgainstSecurityIndex() {\n+    public void testSuperusersCanExecuteOperationAgainstSecurityIndex() throws IOException {\n         final User superuser = new User(\"custom_admin\", ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName());\n         roleMap.put(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName(), ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR);\n         ClusterState state = mock(ClusterState.class);\n@@ -958,13 +977,15 @@ public void testSuperusersCanExecuteOperationAgainstSecurityIndex() {\n         for (final Tuple<String, TransportRequest> requestTuple : requests) {\n             final String action = requestTuple.v1();\n             final TransportRequest request = requestTuple.v2();\n-            final Authentication authentication = createAuthentication(superuser);\n-            authorize(authentication, action, request);\n-            verify(auditTrail).accessGranted(requestId, authentication, action, request, superuser.roles());\n+            try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+                final Authentication authentication = createAuthentication(superuser);\n+                authorize(authentication, action, request);\n+                verify(auditTrail).accessGranted(requestId, authentication, action, request, superuser.roles());\n+            }\n         }\n     }\n \n-    public void testSuperusersCanExecuteOperationAgainstSecurityIndexWithWildcard() {\n+    public void testSuperusersCanExecuteOperationAgainstSecurityIndexWithWildcard() throws IOException {\n         final User superuser = new User(\"custom_admin\", ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName());\n         final Authentication authentication = createAuthentication(superuser);\n         roleMap.put(ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR.getName(), ReservedRolesStore.SUPERUSER_ROLE_DESCRIPTOR);\n@@ -982,54 +1003,66 @@ public void testSuperusersCanExecuteOperationAgainstSecurityIndexWithWildcard()\n \n         String action = SearchAction.NAME;\n         SearchRequest request = new SearchRequest(\"_all\");\n-        authorize(createAuthentication(superuser), action, request);\n+        authorize(authentication, action, request);\n         verify(auditTrail).accessGranted(requestId, authentication, action, request, superuser.roles());\n         assertThat(request.indices(), arrayContainingInAnyOrder(INTERNAL_SECURITY_INDEX, SECURITY_INDEX_NAME));\n     }\n \n-    public void testAnonymousRolesAreAppliedToOtherUsers() {\n+    public void testAnonymousRolesAreAppliedToOtherUsers() throws IOException {\n         TransportRequest request = new ClusterHealthRequest();\n         Settings settings = Settings.builder().put(AnonymousUser.ROLES_SETTING.getKey(), \"anonymous_user_role\").build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         authorizationService = new AuthorizationService(settings, rolesStore, clusterService, auditTrail,\n-            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser);\n+            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, apiKeyService,\n+            new FieldPermissionsCache(settings));\n         roleMap.put(\"anonymous_user_role\", new RoleDescriptor(\"anonymous_user_role\", new String[]{\"all\"},\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null));\n         mockEmptyMetaData();\n         AuditUtil.getOrGenerateRequestId(threadContext);\n \n         // sanity check the anonymous user\n-        authorize(createAuthentication(anonymousUser), ClusterHealthAction.NAME, request);\n-        authorize(createAuthentication(anonymousUser), IndicesExistsAction.NAME, new IndicesExistsRequest(\"a\"));\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+            authorize(createAuthentication(anonymousUser), ClusterHealthAction.NAME, request);\n+        }\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+            authorize(createAuthentication(anonymousUser), IndicesExistsAction.NAME, new IndicesExistsRequest(\"a\"));\n+        }\n \n         // test the no role user\n         final User userWithNoRoles = new User(\"no role user\");\n-        authorize(createAuthentication(userWithNoRoles), ClusterHealthAction.NAME, request);\n-        authorize(createAuthentication(userWithNoRoles), IndicesExistsAction.NAME, new IndicesExistsRequest(\"a\"));\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+            authorize(createAuthentication(userWithNoRoles), ClusterHealthAction.NAME, request);\n+        }\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+            authorize(createAuthentication(userWithNoRoles), IndicesExistsAction.NAME, new IndicesExistsRequest(\"a\"));\n+        }\n     }\n \n-    public void testDefaultRoleUserWithoutRoles() {\n+    public void testDefaultRoleUserWithoutRoles() throws IOException {\n         PlainActionFuture<Role> rolesFuture = new PlainActionFuture<>();\n-        authorizationService.roles(new User(\"no role user\"), rolesFuture);\n+        final User user = new User(\"no role user\");\n+        authorizationService.roles(user, createAuthentication(user), rolesFuture);\n         final Role roles = rolesFuture.actionGet();\n         assertEquals(Role.EMPTY, roles);\n     }\n \n-    public void testAnonymousUserEnabledRoleAdded() {\n+    public void testAnonymousUserEnabledRoleAdded() throws IOException {\n         Settings settings = Settings.builder().put(AnonymousUser.ROLES_SETTING.getKey(), \"anonymous_user_role\").build();\n         final AnonymousUser anonymousUser = new AnonymousUser(settings);\n         authorizationService = new AuthorizationService(settings, rolesStore, clusterService, auditTrail,\n-            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser);\n+            new DefaultAuthenticationFailureHandler(Collections.emptyMap()), threadPool, anonymousUser, apiKeyService,\n+            new FieldPermissionsCache(settings));\n         roleMap.put(\"anonymous_user_role\", new RoleDescriptor(\"anonymous_user_role\", new String[]{\"all\"},\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null));\n         mockEmptyMetaData();\n+        final User user = new User(\"no role user\");\n         PlainActionFuture<Role> rolesFuture = new PlainActionFuture<>();\n-        authorizationService.roles(new User(\"no role user\"), rolesFuture);\n+        authorizationService.roles(user, createAuthentication(user), rolesFuture);\n         final Role roles = rolesFuture.actionGet();\n         assertThat(Arrays.asList(roles.names()), hasItem(\"anonymous_user_role\"));\n     }\n \n-    public void testCompositeActionsAreImmediatelyRejected() {\n+    public void testCompositeActionsAreImmediatelyRejected() throws IOException {\n         //if the user has no permission for composite actions against any index, the request fails straight-away in the main action\n         final Tuple<String, TransportRequest> compositeRequest = randomCompositeRequest();\n         final String action = compositeRequest.v1();\n@@ -1045,7 +1078,7 @@ public void testCompositeActionsAreImmediatelyRejected() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testCompositeActionsIndicesAreNotChecked() {\n+    public void testCompositeActionsIndicesAreNotChecked() throws IOException {\n         //if the user has permission for some index, the request goes through without looking at the indices, they will be checked later\n         final Tuple<String, TransportRequest> compositeRequest = randomCompositeRequest();\n         final String action = compositeRequest.v1();\n@@ -1062,7 +1095,7 @@ public void testCompositeActionsIndicesAreNotChecked() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testCompositeActionsMustImplementCompositeIndicesRequest() {\n+    public void testCompositeActionsMustImplementCompositeIndicesRequest() throws IOException {\n         String action = randomCompositeRequest().v1();\n         TransportRequest request = mock(TransportRequest.class);\n         final String requestId = AuditUtil.getOrGenerateRequestId(threadContext);\n@@ -1075,7 +1108,7 @@ public void testCompositeActionsMustImplementCompositeIndicesRequest() {\n         assertThat(illegalStateException.getMessage(), containsString(\"Composite actions must implement CompositeIndicesRequest\"));\n     }\n \n-    public void testCompositeActionsIndicesAreCheckedAtTheShardLevel() {\n+    public void testCompositeActionsIndicesAreCheckedAtTheShardLevel() throws IOException {\n         final MockIndicesRequest mockRequest = new MockIndicesRequest(IndicesOptions.strictExpandOpen(), \"index\");\n         final TransportRequest request;\n         final String action;\n@@ -1114,12 +1147,14 @@ public void testCompositeActionsIndicesAreCheckedAtTheShardLevel() {\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null));\n         AuditUtil.getOrGenerateRequestId(threadContext);\n         mockEmptyMetaData();\n-        authorize(createAuthentication(userAllowed), action, request);\n+        try (ThreadContext.StoredContext ignore = threadContext.newStoredContext(false)) {\n+            authorize(createAuthentication(userAllowed), action, request);\n+        }\n         assertThrowsAuthorizationException(\n             () -> authorize(createAuthentication(userDenied), action, request), action, \"userDenied\");\n     }\n \n-    public void testAuthorizationOfIndividualBulkItems() {\n+    public void testAuthorizationOfIndividualBulkItems() throws IOException {\n         final String action = BulkAction.NAME + \"[s]\";\n         final BulkItemRequest[] items = {\n             new BulkItemRequest(1, new DeleteRequest(\"concrete-index\", \"doc\", \"c1\")),\n@@ -1153,7 +1188,7 @@ public void testAuthorizationOfIndividualBulkItems() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testAuthorizationOfIndividualBulkItemsWithDateMath() {\n+    public void testAuthorizationOfIndividualBulkItemsWithDateMath() throws IOException {\n         final String action = BulkAction.NAME + \"[s]\";\n         final BulkItemRequest[] items = {\n             new BulkItemRequest(1, new IndexRequest(\"<datemath-{now/M{YYYY}}>\", \"doc\", \"dy1\")),\n@@ -1359,21 +1394,31 @@ private static class MockCompositeIndicesRequest extends TransportRequest implem\n \n     public void testDoesNotUseRolesStoreForXPackUser() {\n         PlainActionFuture<Role> rolesFuture = new PlainActionFuture<>();\n-        authorizationService.roles(XPackUser.INSTANCE, rolesFuture);\n+        authorizationService.roles(XPackUser.INSTANCE, null, rolesFuture);\n         final Role roles = rolesFuture.actionGet();\n         assertThat(roles, equalTo(XPackUser.ROLE));\n         verifyZeroInteractions(rolesStore);\n     }\n \n     public void testGetRolesForSystemUserThrowsException() {\n         IllegalArgumentException iae = expectThrows(IllegalArgumentException.class, () -> authorizationService.roles(SystemUser.INSTANCE,\n-            null));\n+            null, null));\n         assertEquals(\"the user [_system] is the system user and we should never try to get its roles\", iae.getMessage());\n     }\n \n-    private static Authentication createAuthentication(User user) {\n+    private Authentication createAuthentication(User user) throws IOException {\n         RealmRef lookedUpBy = user.authenticatedUser() == user ? null : new RealmRef(\"looked\", \"up\", \"by\");\n-        return new Authentication(user, new RealmRef(\"test\", \"test\", \"foo\"), lookedUpBy);\n+        Authentication authentication = new Authentication(user, new RealmRef(\"test\", \"test\", \"foo\"), lookedUpBy);\n+        authentication.writeToContext(threadContext);\n+        return authentication;\n+    }\n+\n+    private Authentication createAuthentication(User user, AuthenticationType type) throws IOException {\n+        RealmRef lookedUpBy = user.authenticatedUser() == user ? null : new RealmRef(\"looked\", \"up\", \"by\");\n+        Authentication authentication =\n+            new Authentication(user, new RealmRef(\"test\", \"test\", \"foo\"), lookedUpBy, Version.CURRENT, type, Collections.emptyMap());\n+        authentication.writeToContext(threadContext);\n+        return authentication;\n     }\n \n     private ClusterState mockEmptyMetaData() {\n@@ -1408,7 +1453,7 @@ public void testProxyRequestFailsOnNonProxyRequest() {\n             endsWith(\"] but action: [internal:transport/proxy/indices:some/action] is a proxy action\"));\n     }\n \n-    public void testProxyRequestAuthenticationDenied() {\n+    public void testProxyRequestAuthenticationDenied() throws IOException {\n         final TransportRequest proxiedRequest = new SearchRequest();\n         final DiscoveryNode node = new DiscoveryNode(\"foo\", buildNewFakeTransportAddress(), Version.CURRENT);\n         final TransportRequest transportRequest = TransportActionProxy.wrapRequest(node, proxiedRequest);\n@@ -1424,7 +1469,7 @@ public void testProxyRequestAuthenticationDenied() {\n         verifyNoMoreInteractions(auditTrail);\n     }\n \n-    public void testProxyRequestAuthenticationGrantedWithAllPrivileges() {\n+    public void testProxyRequestAuthenticationGrantedWithAllPrivileges() throws IOException {\n         RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"all\").build()}, null);\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n@@ -1441,7 +1486,7 @@ public void testProxyRequestAuthenticationGrantedWithAllPrivileges() {\n         verify(auditTrail).accessGranted(requestId, authentication, action, clearScrollRequest, new String[]{role.getName()});\n     }\n \n-    public void testProxyRequestAuthenticationGranted() {\n+    public void testProxyRequestAuthenticationGranted() throws IOException {\n         RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"read_cross_cluster\").build()}, null);\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n@@ -1457,7 +1502,7 @@ public void testProxyRequestAuthenticationGranted() {\n         verify(auditTrail).accessGranted(requestId, authentication, action, clearScrollRequest, new String[]{role.getName()});\n     }\n \n-    public void testProxyRequestAuthenticationDeniedWithReadPrivileges() {\n+    public void testProxyRequestAuthenticationDeniedWithReadPrivileges() throws IOException {\n         final Authentication authentication = createAuthentication(new User(\"test user\", \"a_all\"));\n         final RoleDescriptor role = new RoleDescriptor(\"a_role\", null,\n             new IndicesPrivileges[]{IndicesPrivileges.builder().indices(\"a\").privileges(\"read\").build()}, null);\n@@ -1472,4 +1517,39 @@ public void testProxyRequestAuthenticationDeniedWithReadPrivileges() {\n             () -> authorize(authentication, action, transportRequest), action, \"test user\");\n         verify(auditTrail).accessDenied(requestId, authentication, action, clearScrollRequest, new String[]{role.getName()});\n     }\n+\n+    public void testApiKeyAuthUsesApiKeyService() throws IOException {\n+        AuditUtil.getOrGenerateRequestId(threadContext);\n+        final Authentication authentication = createAuthentication(new User(\"test api key user\", \"api_key\"), AuthenticationType.API_KEY);\n+        doAnswer(invocationOnMock -> {\n+            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[2];\n+            listener.onResponse(ReservedRolesStore.SUPERUSER_ROLE);\n+            return Void.TYPE;\n+        }).when(apiKeyService).getRoleForApiKey(eq(authentication), eq(rolesStore), any(ActionListener.class));\n+\n+        authorize(authentication, \"cluster:admin/foo\", new ClearScrollRequest());\n+        verify(apiKeyService).getRoleForApiKey(eq(authentication), eq(rolesStore), any(ActionListener.class));\n+        verifyZeroInteractions(rolesStore);\n+    }\n+\n+    public void testApiKeyAuthUsesApiKeyServiceWithScopedRole() throws IOException {\n+        final Role fromRole = Role.builder(\"a-role\").cluster(Collections.singleton(ClusterPrivilegeName.ALL), Collections.emptyList())\n+                .build();\n+        final Role scopedByRole = Role.builder(\"scoped-role\")\n+                .cluster(Collections.singleton(ClusterPrivilegeName.MANAGE_SECURITY), Collections.emptyList()).build();\n+        final Role role = LimitedRole.createLimitedRole(fromRole, scopedByRole);\n+\n+        AuditUtil.getOrGenerateRequestId(threadContext);\n+        final Authentication authentication = createAuthentication(new User(\"test api key user\", \"api_key\"), AuthenticationType.API_KEY);\n+        doAnswer(invocationOnMock -> {\n+            ActionListener<Role> listener = (ActionListener<Role>) invocationOnMock.getArguments()[2];\n+            listener.onResponse(role);\n+            return Void.TYPE;\n+        }).when(apiKeyService).getRoleForApiKey(eq(authentication), eq(rolesStore), any(ActionListener.class));\n+\n+        assertThrowsAuthorizationException(() -> authorize(authentication, \"cluster:admin/foo\", new ClearScrollRequest()),\n+                \"cluster:admin/foo\", \"test api key user\");\n+        verify(apiKeyService).getRoleForApiKey(eq(authentication), eq(rolesStore), any(ActionListener.class));\n+        verifyZeroInteractions(rolesStore);\n+    }\n }"
        },
        {
            "sha": "da6ff09737160c4fcc186d6f0951fd7cd16197cf",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/IndicesAndAliasesResolverTests.java",
            "status": "modified",
            "additions": 9,
            "deletions": 4,
            "changes": 13,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FIndicesAndAliasesResolverTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FIndicesAndAliasesResolverTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FIndicesAndAliasesResolverTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -52,6 +52,8 @@\n import org.elasticsearch.threadpool.ThreadPool;\n import org.elasticsearch.transport.TransportRequest;\n import org.elasticsearch.xpack.core.graph.action.GraphExploreAction;\n+import org.elasticsearch.xpack.core.security.authc.Authentication;\n+import org.elasticsearch.xpack.core.security.authc.Authentication.RealmRef;\n import org.elasticsearch.xpack.core.security.authc.DefaultAuthenticationFailureHandler;\n import org.elasticsearch.xpack.core.security.authz.IndicesAndAliasesResolverField;\n import org.elasticsearch.xpack.core.security.authz.RoleDescriptor;\n@@ -64,6 +66,7 @@\n import org.elasticsearch.xpack.core.security.user.XPackSecurityUser;\n import org.elasticsearch.xpack.core.security.user.XPackUser;\n import org.elasticsearch.xpack.security.audit.AuditTrailService;\n+import org.elasticsearch.xpack.security.authc.ApiKeyService;\n import org.elasticsearch.xpack.security.authz.IndicesAndAliasesResolver.ResolvedIndices;\n import org.elasticsearch.xpack.security.authz.store.CompositeRolesStore;\n import org.elasticsearch.xpack.security.support.SecurityIndexManager;\n@@ -166,7 +169,7 @@ public void setup() {\n         final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n         doAnswer((i) -> {\n                 ActionListener callback =\n-                        (ActionListener) i.getArguments()[2];\n+                        (ActionListener) i.getArguments()[1];\n                 Set<String> names = (Set<String>) i.getArguments()[0];\n                 assertNotNull(names);\n                 Set<RoleDescriptor> roleDescriptors = new HashSet<>();\n@@ -185,13 +188,13 @@ public void setup() {\n                     );\n                 }\n                 return Void.TYPE;\n-            }).when(rolesStore).roles(any(Set.class), any(FieldPermissionsCache.class), any(ActionListener.class));\n+            }).when(rolesStore).roles(any(Set.class), any(ActionListener.class));\n \n         ClusterService clusterService = mock(ClusterService.class);\n         when(clusterService.getClusterSettings()).thenReturn(new ClusterSettings(settings, ClusterSettings.BUILT_IN_CLUSTER_SETTINGS));\n         authzService = new AuthorizationService(settings, rolesStore, clusterService,\n                 mock(AuditTrailService.class), new DefaultAuthenticationFailureHandler(Collections.emptyMap()), mock(ThreadPool.class),\n-                new AnonymousUser(settings));\n+                new AnonymousUser(settings), mock(ApiKeyService.class), new FieldPermissionsCache(settings));\n         defaultIndicesResolver = new IndicesAndAliasesResolver(settings, clusterService);\n     }\n \n@@ -1365,7 +1368,9 @@ public void testDynamicPutMappingRequestFromAlias() {\n \n     private AuthorizedIndices buildAuthorizedIndices(User user, String action) {\n         PlainActionFuture<Role> rolesListener = new PlainActionFuture<>();\n-        authzService.roles(user, rolesListener);\n+        final Authentication authentication =\n+            new Authentication(user, new RealmRef(\"test\", \"indices-aliases-resolver-tests\", \"node\"), null);\n+        authzService.roles(user, authentication, rolesListener);\n         return new AuthorizedIndices(rolesListener.actionGet(), action, metaData);\n     }\n "
        },
        {
            "sha": "0f4b53e98418616982720bac402dd28841f15671",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/RoleDescriptorTests.java",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FRoleDescriptorTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FRoleDescriptorTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2FRoleDescriptorTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -55,7 +55,7 @@ public void testIndexGroup() throws Exception {\n         assertEquals(\"{\\\"names\\\":[\\\"idx\\\"],\\\"privileges\\\":[\\\"priv\\\"],\\\"allow_restricted_indices\\\":true}\", Strings.toString(b));\n     }\n \n-    public void testToString() throws Exception {\n+    public void testToString() {\n         RoleDescriptor.IndicesPrivileges[] groups = new RoleDescriptor.IndicesPrivileges[] {\n                 RoleDescriptor.IndicesPrivileges.builder()\n                         .indices(\"i1\", \"i2\")\n@@ -240,12 +240,12 @@ public void testSerialization() throws Exception {\n         Map<String, Object> metadata = randomBoolean() ? MetadataUtils.DEFAULT_RESERVED_METADATA : null;\n         final RoleDescriptor descriptor = new RoleDescriptor(\"test\", new String[]{\"all\", \"none\"}, groups, applicationPrivileges,\n             conditionalClusterPrivileges, new String[] { \"sudo\" }, metadata, null);\n-        RoleDescriptor.writeTo(descriptor, output);\n+        descriptor.writeTo(output);\n         final NamedWriteableRegistry registry = new NamedWriteableRegistry(new XPackClientPlugin(Settings.EMPTY).getNamedWriteables());\n         StreamInput streamInput = new NamedWriteableAwareStreamInput(ByteBufferStreamInput.wrap(BytesReference.toBytes(output.bytes())),\n             registry);\n         streamInput.setVersion(version);\n-        final RoleDescriptor serialized = RoleDescriptor.readFrom(streamInput);\n+        final RoleDescriptor serialized = new RoleDescriptor(streamInput);\n         assertEquals(descriptor, serialized);\n     }\n \n@@ -274,7 +274,7 @@ public void testParseEmptyQueryUsingDeprecatedIndicesField() throws Exception {\n     }\n \n     public void testParseIgnoresTransientMetadata() throws Exception {\n-        final RoleDescriptor descriptor = new RoleDescriptor(\"test\", new String[] { \"all\" }, null, null,\n+        final RoleDescriptor descriptor = new RoleDescriptor(\"test\", new String[] { \"all\" }, null, null, null, null,\n                 Collections.singletonMap(\"_unlicensed_feature\", true), Collections.singletonMap(\"foo\", \"bar\"));\n         XContentBuilder b = jsonBuilder();\n         descriptor.toXContent(b, ToXContent.EMPTY_PARAMS);"
        },
        {
            "sha": "71bc7035fc10ea6c1132807032afea24d0c7a403",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/IndicesAccessControlTests.java",
            "status": "modified",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControlTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControlTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesAccessControlTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -5,10 +5,22 @@\n  */\n package org.elasticsearch.xpack.security.authz.accesscontrol;\n \n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.bytes.BytesReference;\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl.IndexAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n+import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n+import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n \n import java.util.Collections;\n+import java.util.Set;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n+import static org.hamcrest.Matchers.notNullValue;\n+import static org.hamcrest.Matchers.nullValue;\n \n /**\n  * Unit tests for {@link IndicesAccessControl}\n@@ -20,4 +32,93 @@ public void testEmptyIndicesAccessControl() {\n         assertTrue(indicesAccessControl.isGranted());\n         assertNull(indicesAccessControl.getIndexPermissions(randomAlphaOfLengthBetween(3,20)));\n     }\n+\n+    public void testSLimitedIndicesAccessControl() {\n+        IndicesAccessControl indicesAccessControl = new IndicesAccessControl(true, Collections.emptyMap());\n+        IndicesAccessControl limitedByIndicesAccessControl = new IndicesAccessControl(true, Collections.emptyMap());\n+        IndicesAccessControl result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.isGranted(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(nullValue()));\n+\n+        indicesAccessControl = new IndicesAccessControl(true, Collections.emptyMap());\n+        limitedByIndicesAccessControl = new IndicesAccessControl(false, Collections.emptyMap());\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.isGranted(), is(false));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(nullValue()));\n+\n+        indicesAccessControl = new IndicesAccessControl(false, Collections.emptyMap());\n+        limitedByIndicesAccessControl = new IndicesAccessControl(true, Collections.emptyMap());\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.isGranted(), is(false));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(nullValue()));\n+\n+        indicesAccessControl = new IndicesAccessControl(false, Collections.emptyMap());\n+        limitedByIndicesAccessControl = new IndicesAccessControl(false, Collections.emptyMap());\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.isGranted(), is(false));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(nullValue()));\n+\n+        indicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.allowAll())));\n+        limitedByIndicesAccessControl = new IndicesAccessControl(true, Collections.emptyMap());\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(nullValue()));\n+\n+        indicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.allowAll())));\n+        limitedByIndicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.allowAll())));\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\").isGranted(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity(), is(false));\n+        assertThat(result.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(false));\n+\n+        final FieldPermissions fieldPermissions1 = new FieldPermissions(\n+                new FieldPermissionsDefinition(new String[] { \"f1\", \"f2\", \"f3*\" }, new String[] { \"f3\" }));\n+        final FieldPermissions fieldPermissions2 = new FieldPermissions(\n+                new FieldPermissionsDefinition(new String[] { \"f1\", \"f3*\", \"f4\" }, new String[] { \"f3\" }));\n+        indicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, fieldPermissions1, DocumentPermissions.allowAll())));\n+        limitedByIndicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, fieldPermissions2, DocumentPermissions.allowAll())));\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\").isGranted(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(false));\n+        FieldPermissions resultFieldPermissions = result.getIndexPermissions(\"_index\").getFieldPermissions();\n+        assertThat(resultFieldPermissions.grantsAccessTo(\"f1\"), is(true));\n+        assertThat(resultFieldPermissions.grantsAccessTo(\"f2\"), is(false));\n+        assertThat(resultFieldPermissions.grantsAccessTo(\"f3\"), is(false));\n+        assertThat(resultFieldPermissions.grantsAccessTo(\"f31\"), is(true));\n+        assertThat(resultFieldPermissions.grantsAccessTo(\"f4\"), is(false));\n+\n+        Set<BytesReference> queries = Collections.singleton(new BytesArray(\"{\\\"match_all\\\" : {}}\"));\n+        final DocumentPermissions documentPermissions = DocumentPermissions\n+                .filteredBy(queries);\n+        assertThat(documentPermissions, is(notNullValue()));\n+        assertThat(documentPermissions.hasDocumentLevelPermissions(), is(true));\n+        assertThat(documentPermissions.getQueries(), equalTo(queries));\n+\n+        indicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, new FieldPermissions(), DocumentPermissions.allowAll())));\n+        limitedByIndicesAccessControl = new IndicesAccessControl(true,\n+                Collections.singletonMap(\"_index\", new IndexAccessControl(true, new FieldPermissions(), documentPermissions)));\n+        result = indicesAccessControl.limitIndicesAccessControl(limitedByIndicesAccessControl);\n+        assertThat(result, is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\"), is(notNullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\").isGranted(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity(), is(false));\n+        assertThat(result.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(result.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), is(nullValue()));\n+        assertThat(result.getIndexPermissions(\"_index\").getDocumentPermissions().getLimitedByQueries(), equalTo(queries));\n+    }\n }"
        },
        {
            "sha": "f4b63942fbb9b156f5a1b7d2edc414c91cfee9cc",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/IndicesPermissionTests.java",
            "status": "modified",
            "additions": 31,
            "deletions": 22,
            "changes": 53,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesPermissionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesPermissionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FIndicesPermissionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -38,6 +38,7 @@\n \n import static org.hamcrest.Matchers.containsString;\n import static org.hamcrest.Matchers.equalTo;\n+import static org.hamcrest.Matchers.is;\n import static org.hamcrest.Matchers.notNullValue;\n import static org.hamcrest.Matchers.nullValue;\n import static org.hamcrest.Matchers.is;\n@@ -65,8 +66,9 @@ public void testAuthorize() {\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().grantsAccessTo(\"_field\"));\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         // no document level security:\n         role = Role.builder(\"_role\")\n@@ -76,15 +78,17 @@ public void testAuthorize() {\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().grantsAccessTo(\"_field\"));\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), nullValue());\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(false));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), nullValue());\n \n         // no field level security:\n         role = Role.builder(\"_role\").add(new FieldPermissions(), query, IndexPrivilege.ALL, randomBoolean(), \"_index\").build();\n         permissions = role.authorize(SearchAction.NAME, Sets.newHashSet(\"_index\"), md, fieldPermissionsCache);\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         // index group associated with an alias:\n         role = Role.builder(\"_role\")\n@@ -94,14 +98,16 @@ public void testAuthorize() {\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().grantsAccessTo(\"_field\"));\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         assertThat(permissions.getIndexPermissions(\"_alias\"), notNullValue());\n         assertTrue(permissions.getIndexPermissions(\"_alias\").getFieldPermissions().grantsAccessTo(\"_field\"));\n         assertTrue(permissions.getIndexPermissions(\"_alias\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         // match all fields\n         String[] allFields = randomFrom(new String[]{\"*\"}, new String[]{\"foo\", \"*\"},\n@@ -112,13 +118,15 @@ public void testAuthorize() {\n         permissions = role.authorize(SearchAction.NAME, Sets.newHashSet(\"_alias\"), md, fieldPermissionsCache);\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         assertThat(permissions.getIndexPermissions(\"_alias\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_alias\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries().size(), equalTo(1));\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries(), equalTo(query));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries().size(), equalTo(1));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries(), equalTo(query));\n \n         IndexMetaData.Builder imbBuilder1 = IndexMetaData.builder(\"_index_1\")\n                 .settings(Settings.builder()\n@@ -142,18 +150,21 @@ public void testAuthorize() {\n         Set<BytesReference> bothQueries = Sets.union(fooQuery, query);\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries().size(), equalTo(2));\n-        assertThat(permissions.getIndexPermissions(\"_index\").getQueries(), equalTo(bothQueries));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries().size(), equalTo(2));\n+        assertThat(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().getQueries(), equalTo(bothQueries));\n \n         assertThat(permissions.getIndexPermissions(\"_index_1\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_index_1\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_index_1\").getQueries().size(), equalTo(2));\n-        assertThat(permissions.getIndexPermissions(\"_index_1\").getQueries(), equalTo(bothQueries));\n+        assertThat(permissions.getIndexPermissions(\"_index_1\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_index_1\").getDocumentPermissions().getQueries().size(), equalTo(2));\n+        assertThat(permissions.getIndexPermissions(\"_index_1\").getDocumentPermissions().getQueries(), equalTo(bothQueries));\n \n         assertThat(permissions.getIndexPermissions(\"_alias\"), notNullValue());\n         assertFalse(permissions.getIndexPermissions(\"_alias\").getFieldPermissions().hasFieldLevelSecurity());\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries().size(), equalTo(2));\n-        assertThat(permissions.getIndexPermissions(\"_alias\").getQueries(), equalTo(bothQueries));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().hasDocumentLevelPermissions(), is(true));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries().size(), equalTo(2));\n+        assertThat(permissions.getIndexPermissions(\"_alias\").getDocumentPermissions().getQueries(), equalTo(bothQueries));\n \n     }\n \n@@ -178,9 +189,7 @@ public void testAuthorizeMultipleGroupsMixedDls() {\n         assertThat(permissions.getIndexPermissions(\"_index\"), notNullValue());\n         assertTrue(permissions.getIndexPermissions(\"_index\").getFieldPermissions().grantsAccessTo(\"_field\"));\n         assertFalse(permissions.getIndexPermissions(\"_index\").getFieldPermissions().hasFieldLevelSecurity());\n-        // null implies that there is no DLS. Currently a index permissions only has queries defined\n-        // on it and not a true document level permission object like fields\n-        assertNull(permissions.getIndexPermissions(\"_index\").getQueries());\n+        assertFalse(permissions.getIndexPermissions(\"_index\").getDocumentPermissions().hasDocumentLevelPermissions());\n     }\n \n     public void testIndicesPrivilegesStreaming() throws IOException {"
        },
        {
            "sha": "54dbdc3d33d729c3ece8f1ec2407cc02ac004069",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/accesscontrol/OptOutQueryCacheTests.java",
            "status": "modified",
            "additions": 14,
            "deletions": 14,
            "changes": 28,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FOptOutQueryCacheTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FOptOutQueryCacheTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Faccesscontrol%2FOptOutQueryCacheTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -26,13 +26,13 @@\n import org.elasticsearch.test.ESTestCase;\n import org.elasticsearch.xpack.core.security.authz.AuthorizationServiceField;\n import org.elasticsearch.xpack.core.security.authz.accesscontrol.IndicesAccessControl;\n+import org.elasticsearch.xpack.core.security.authz.permission.DocumentPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissions;\n import org.elasticsearch.xpack.core.security.authz.permission.FieldPermissionsDefinition;\n import org.junit.After;\n import org.junit.Before;\n \n import java.io.IOException;\n-import java.util.HashSet;\n \n import static org.mockito.Matchers.same;\n import static org.mockito.Mockito.mock;\n@@ -71,56 +71,56 @@ public void testOptOutQueryCacheSafetyCheck() throws IOException {\n \n         // whenever the allowed fields match the fields in the query and we do not deny access to any fields we allow caching.\n         IndicesAccessControl.IndexAccessControl permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, null)), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, null)), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, new String[]{})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, new String[]{})), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, new String[]{})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, new String[]{})), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, null)), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, null)), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, new String[]{\"oof\"})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"*\"}, new String[]{\"oof\"})), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"f*\", \"n*\"}, new String[]{})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"f*\", \"n*\"}, new String[]{})), DocumentPermissions.allowAll());\n         assertTrue(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         // check we don't cache if a field is not allowed\n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\"}, null)), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\"}, null)), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"a*\"}, new String[]{\"aa\"})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"a*\"}, new String[]{\"aa\"})), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(null, new String[]{\"no\"})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(null, new String[]{\"no\"})), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(null, new String[]{\"*\"})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(null, new String[]{\"*\"})), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, new String[]{\"no\"})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{\"foo\", \"no\"}, new String[]{\"no\"})), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{}, new String[]{})), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{}, new String[]{})), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n \n         permissions = new IndicesAccessControl.IndexAccessControl(true,\n-                new FieldPermissions(fieldPermissionDef(new String[]{}, null)), new HashSet<>());\n+                new FieldPermissions(fieldPermissionDef(new String[]{}, null)), DocumentPermissions.allowAll());\n         assertFalse(OptOutQueryCache.cachingIsSafe(weight, permissions));\n     }\n "
        },
        {
            "sha": "ecd4a37ae42759c6b0189a694d7fa57f91c15b52",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/authz/store/CompositeRolesStoreTests.java",
            "status": "modified",
            "additions": 33,
            "deletions": 41,
            "changes": 74,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStoreTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStoreTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Fauthz%2Fstore%2FCompositeRolesStoreTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -79,6 +79,8 @@ public class CompositeRolesStoreTests extends ESTestCase {\n             .put(XPackSettings.SECURITY_ENABLED.getKey(), true)\n             .build();\n \n+    private final FieldPermissionsCache cache = new FieldPermissionsCache(Settings.EMPTY);\n+\n     public void testRolesWhenDlsFlsUnlicensed() throws IOException {\n         XPackLicenseState licenseState = mock(XPackLicenseState.class);\n         when(licenseState.isDocumentAndFieldLevelSecurityAllowed()).thenReturn(false);\n@@ -126,23 +128,22 @@ public void testRolesWhenDlsFlsUnlicensed() throws IOException {\n         when(fileRolesStore.roleDescriptors(Collections.singleton(\"no_fls_dls\"))).thenReturn(Collections.singleton(noFlsDlsRole));\n         CompositeRolesStore compositeRolesStore = new CompositeRolesStore(Settings.EMPTY, fileRolesStore, nativeRolesStore,\n                 reservedRolesStore, mock(NativePrivilegeStore.class), Collections.emptyList(),\n-                new ThreadContext(Settings.EMPTY), licenseState);\n+                new ThreadContext(Settings.EMPTY), licenseState, cache);\n \n-        FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n         PlainActionFuture<Role> roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"fls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"fls\"), roleFuture);\n         assertEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"dls\"), roleFuture);\n         assertEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"fls_dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"fls_dls\"), roleFuture);\n         assertEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"no_fls_dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"no_fls_dls\"), roleFuture);\n         assertNotEquals(Role.EMPTY, roleFuture.actionGet());\n     }\n \n@@ -192,23 +193,22 @@ public void testRolesWhenDlsFlsLicensed() throws IOException {\n         when(fileRolesStore.roleDescriptors(Collections.singleton(\"no_fls_dls\"))).thenReturn(Collections.singleton(noFlsDlsRole));\n         CompositeRolesStore compositeRolesStore = new CompositeRolesStore(Settings.EMPTY, fileRolesStore, nativeRolesStore,\n                 reservedRolesStore, mock(NativePrivilegeStore.class), Collections.emptyList(),\n-                new ThreadContext(Settings.EMPTY), licenseState);\n+                new ThreadContext(Settings.EMPTY), licenseState, cache);\n \n-        FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n         PlainActionFuture<Role> roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"fls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"fls\"), roleFuture);\n         assertNotEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"dls\"), roleFuture);\n         assertNotEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"fls_dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"fls_dls\"), roleFuture);\n         assertNotEquals(Role.EMPTY, roleFuture.actionGet());\n \n         roleFuture = new PlainActionFuture<>();\n-        compositeRolesStore.roles(Collections.singleton(\"no_fls_dls\"), fieldPermissionsCache, roleFuture);\n+        compositeRolesStore.roles(Collections.singleton(\"no_fls_dls\"), roleFuture);\n         assertNotEquals(Role.EMPTY, roleFuture.actionGet());\n     }\n \n@@ -235,13 +235,12 @@ public void testNegativeLookupsAreCached() {\n         final CompositeRolesStore compositeRolesStore =\n                 new CompositeRolesStore(SECURITY_ENABLED_SETTINGS, fileRolesStore, nativeRolesStore, reservedRolesStore,\n                         nativePrivilegeStore, Collections.emptyList(), new ThreadContext(SECURITY_ENABLED_SETTINGS),\n-                        new XPackLicenseState(SECURITY_ENABLED_SETTINGS));\n+                        new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache);\n         verify(fileRolesStore).addListener(any(Consumer.class)); // adds a listener in ctor\n \n         final String roleName = randomAlphaOfLengthBetween(1, 10);\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(Collections.singleton(roleName), fieldPermissionsCache, future);\n+        compositeRolesStore.roles(Collections.singleton(roleName), future);\n         final Role role = future.actionGet();\n         assertEquals(Role.EMPTY, role);\n         verify(reservedRolesStore).accept(anySetOf(String.class), any(ActionListener.class));\n@@ -257,7 +256,7 @@ public void testNegativeLookupsAreCached() {\n                 : Collections.singleton(roleName);\n         for (int i = 0; i < numberOfTimesToCall; i++) {\n             future = new PlainActionFuture<>();\n-            compositeRolesStore.roles(names, fieldPermissionsCache, future);\n+            compositeRolesStore.roles(names, future);\n             future.actionGet();\n         }\n \n@@ -287,13 +286,12 @@ public void testNegativeLookupsCacheDisabled() {\n             .build();\n         final CompositeRolesStore compositeRolesStore = new CompositeRolesStore(settings, fileRolesStore, nativeRolesStore,\n             reservedRolesStore, mock(NativePrivilegeStore.class), Collections.emptyList(), new ThreadContext(settings),\n-            new XPackLicenseState(settings));\n+            new XPackLicenseState(settings), cache);\n         verify(fileRolesStore).addListener(any(Consumer.class)); // adds a listener in ctor\n \n         final String roleName = randomAlphaOfLengthBetween(1, 10);\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(Collections.singleton(roleName), fieldPermissionsCache, future);\n+        compositeRolesStore.roles(Collections.singleton(roleName), future);\n         final Role role = future.actionGet();\n         assertEquals(Role.EMPTY, role);\n         verify(reservedRolesStore).accept(anySetOf(String.class), any(ActionListener.class));\n@@ -322,13 +320,12 @@ public void testNegativeLookupsAreNotCachedWithFailures() {\n         final CompositeRolesStore compositeRolesStore =\n             new CompositeRolesStore(SECURITY_ENABLED_SETTINGS, fileRolesStore, nativeRolesStore, reservedRolesStore,\n                 mock(NativePrivilegeStore.class), Collections.emptyList(), new ThreadContext(SECURITY_ENABLED_SETTINGS),\n-                new XPackLicenseState(SECURITY_ENABLED_SETTINGS));\n+                new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache);\n         verify(fileRolesStore).addListener(any(Consumer.class)); // adds a listener in ctor\n \n         final String roleName = randomAlphaOfLengthBetween(1, 10);\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(Collections.singleton(roleName), fieldPermissionsCache, future);\n+        compositeRolesStore.roles(Collections.singleton(roleName), future);\n         final Role role = future.actionGet();\n         assertEquals(Role.EMPTY, role);\n         verify(reservedRolesStore).accept(anySetOf(String.class), any(ActionListener.class));\n@@ -341,7 +338,7 @@ public void testNegativeLookupsAreNotCachedWithFailures() {\n         final Set<String> names = Collections.singleton(roleName);\n         for (int i = 0; i < numberOfTimesToCall; i++) {\n             future = new PlainActionFuture<>();\n-            compositeRolesStore.roles(names, fieldPermissionsCache, future);\n+            compositeRolesStore.roles(names, future);\n             future.actionGet();\n         }\n \n@@ -400,12 +397,11 @@ public void testCustomRolesProviders() {\n         final CompositeRolesStore compositeRolesStore =\n                 new CompositeRolesStore(SECURITY_ENABLED_SETTINGS, fileRolesStore, nativeRolesStore, reservedRolesStore,\n                                 mock(NativePrivilegeStore.class), Arrays.asList(inMemoryProvider1, inMemoryProvider2),\n-                                new ThreadContext(SECURITY_ENABLED_SETTINGS), new XPackLicenseState(SECURITY_ENABLED_SETTINGS));\n+                                new ThreadContext(SECURITY_ENABLED_SETTINGS), new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache);\n \n         final Set<String> roleNames = Sets.newHashSet(\"roleA\", \"roleB\", \"unknown\");\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(roleNames, fieldPermissionsCache, future);\n+        compositeRolesStore.roles(roleNames, future);\n         final Role role = future.actionGet();\n \n         // make sure custom roles providers populate roles correctly\n@@ -422,7 +418,7 @@ public void testCustomRolesProviders() {\n         final int numberOfTimesToCall = scaledRandomIntBetween(1, 8);\n         for (int i = 0; i < numberOfTimesToCall; i++) {\n             future = new PlainActionFuture<>();\n-            compositeRolesStore.roles(Collections.singleton(\"unknown\"), fieldPermissionsCache, future);\n+            compositeRolesStore.roles(Collections.singleton(\"unknown\"), future);\n             future.actionGet();\n         }\n \n@@ -605,12 +601,11 @@ public void testCustomRolesProviderFailures() throws Exception {\n         final CompositeRolesStore compositeRolesStore =\n             new CompositeRolesStore(SECURITY_ENABLED_SETTINGS, fileRolesStore, nativeRolesStore, reservedRolesStore,\n                                     mock(NativePrivilegeStore.class), Arrays.asList(inMemoryProvider1, failingProvider),\n-                                    new ThreadContext(SECURITY_ENABLED_SETTINGS), new XPackLicenseState(SECURITY_ENABLED_SETTINGS));\n+                                    new ThreadContext(SECURITY_ENABLED_SETTINGS), new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache);\n \n         final Set<String> roleNames = Sets.newHashSet(\"roleA\", \"roleB\", \"unknown\");\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        final FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(roleNames, fieldPermissionsCache, future);\n+        compositeRolesStore.roles(roleNames, future);\n         try {\n             future.get();\n             fail(\"provider should have thrown a failure\");\n@@ -648,26 +643,24 @@ public void testCustomRolesProvidersLicensing() {\n         xPackLicenseState.update(randomFrom(OperationMode.BASIC, OperationMode.GOLD, OperationMode.STANDARD), true, null);\n         CompositeRolesStore compositeRolesStore = new CompositeRolesStore(\n             Settings.EMPTY, fileRolesStore, nativeRolesStore, reservedRolesStore, mock(NativePrivilegeStore.class),\n-            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState);\n+            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState, cache);\n \n         Set<String> roleNames = Sets.newHashSet(\"roleA\");\n         PlainActionFuture<Role> future = new PlainActionFuture<>();\n-        FieldPermissionsCache fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(roleNames, fieldPermissionsCache, future);\n+        compositeRolesStore.roles(roleNames, future);\n         Role role = future.actionGet();\n \n         // no roles should've been populated, as the license doesn't permit custom role providers\n         assertEquals(0, role.indices().groups().length);\n \n         compositeRolesStore = new CompositeRolesStore(\n             Settings.EMPTY, fileRolesStore, nativeRolesStore, reservedRolesStore, mock(NativePrivilegeStore.class),\n-            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState);\n+            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState, cache);\n         // these licenses allow custom role providers\n         xPackLicenseState.update(randomFrom(OperationMode.PLATINUM, OperationMode.TRIAL), true, null);\n         roleNames = Sets.newHashSet(\"roleA\");\n         future = new PlainActionFuture<>();\n-        fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(roleNames, fieldPermissionsCache, future);\n+        compositeRolesStore.roles(roleNames, future);\n         role = future.actionGet();\n \n         // roleA should've been populated by the custom role provider, because the license allows it\n@@ -676,12 +669,11 @@ Settings.EMPTY, fileRolesStore, nativeRolesStore, reservedRolesStore, mock(Nativ\n         // license expired, don't allow custom role providers\n         compositeRolesStore = new CompositeRolesStore(\n             Settings.EMPTY, fileRolesStore, nativeRolesStore, reservedRolesStore, mock(NativePrivilegeStore.class),\n-            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState);\n+            Arrays.asList(inMemoryProvider), new ThreadContext(Settings.EMPTY), xPackLicenseState, cache);\n         xPackLicenseState.update(randomFrom(OperationMode.PLATINUM, OperationMode.TRIAL), false, null);\n         roleNames = Sets.newHashSet(\"roleA\");\n         future = new PlainActionFuture<>();\n-        fieldPermissionsCache = new FieldPermissionsCache(Settings.EMPTY);\n-        compositeRolesStore.roles(roleNames, fieldPermissionsCache, future);\n+        compositeRolesStore.roles(roleNames, future);\n         role = future.actionGet();\n         assertEquals(0, role.indices().groups().length);\n     }\n@@ -702,7 +694,7 @@ public void testCacheClearOnIndexHealthChange() {\n         CompositeRolesStore compositeRolesStore = new CompositeRolesStore(\n                 Settings.EMPTY, fileRolesStore, nativeRolesStore, reservedRolesStore,\n                 mock(NativePrivilegeStore.class), Collections.emptyList(), new ThreadContext(Settings.EMPTY),\n-                new XPackLicenseState(SECURITY_ENABLED_SETTINGS)) {\n+                new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache) {\n             @Override\n             public void invalidateAll() {\n                 numInvalidation.incrementAndGet();\n@@ -754,7 +746,7 @@ public void testCacheClearOnIndexOutOfDateChange() {\n         CompositeRolesStore compositeRolesStore = new CompositeRolesStore(SECURITY_ENABLED_SETTINGS,\n                 fileRolesStore, nativeRolesStore, reservedRolesStore,\n                 mock(NativePrivilegeStore.class), Collections.emptyList(), new ThreadContext(SECURITY_ENABLED_SETTINGS),\n-                new XPackLicenseState(SECURITY_ENABLED_SETTINGS)) {\n+                new XPackLicenseState(SECURITY_ENABLED_SETTINGS), cache) {\n             @Override\n             public void invalidateAll() {\n                 numInvalidation.incrementAndGet();"
        },
        {
            "sha": "1b1b0fe8f0f1ad96b84b77a5b1b0793c1dd22e5c",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/rest/action/RestCreateApiKeyActionTests.java",
            "status": "added",
            "additions": 111,
            "deletions": 0,
            "changes": 111,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyActionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyActionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestCreateApiKeyActionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,111 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.settings.SecureString;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.AbstractRestChannel;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.action.RestToXContentListener;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.rest.FakeRestRequest;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.CreateApiKeyResponse;\n+\n+import java.time.Duration;\n+import java.time.Instant;\n+import java.util.Collections;\n+import java.util.UUID;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class RestCreateApiKeyActionTests extends ESTestCase {\n+    private final XPackLicenseState mockLicenseState = mock(XPackLicenseState.class);\n+    private final RestController mockRestController = mock(RestController.class);\n+    private Settings settings = null;\n+    private ThreadPool threadPool = null;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        settings = Settings.builder()\n+                .put(\"path.home\", createTempDir().toString())\n+                .put(\"node.name\", \"test-\" + getTestName())\n+                .put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString())\n+                .build();\n+        threadPool = new ThreadPool(settings);\n+        when(mockLicenseState.isSecurityAvailable()).thenReturn(true);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        terminate(threadPool);\n+    }\n+\n+    @SuppressWarnings({ \"unchecked\"})\n+    public void testCreateApiKeyApi() throws Exception {\n+        final String json = \"{ \\\"name\\\" : \\\"my-api-key\\\", \\\"role_descriptors\\\": { \\\"role-a\\\": {\\\"cluster\\\":[\\\"a-1\\\", \\\"a-2\\\"]} } }\";\n+        final FakeRestRequest restRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+                .withContent(new BytesArray(json), XContentType.JSON)\n+                .withParams(Collections.singletonMap(\"refresh\", randomFrom(\"false\", \"true\", \"wait_for\")))\n+                .build();\n+\n+        final SetOnce<RestResponse> responseSetOnce = new SetOnce<>();\n+        final RestChannel restChannel = new AbstractRestChannel(restRequest, randomBoolean()) {\n+            @Override\n+            public void sendResponse(RestResponse restResponse) {\n+                responseSetOnce.set(restResponse);\n+            }\n+        };\n+\n+        final CreateApiKeyResponse expected = new CreateApiKeyResponse(\"my-api-key\", UUID.randomUUID().toString(),\n+                new SecureString(randomAlphaOfLength(5)), Instant.now().plus(Duration.ofHours(5)));\n+\n+        try (NodeClient client = new NodeClient(Settings.EMPTY, threadPool) {\n+            @Override\n+            public <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request,\n+                    ActionListener<Response> listener) {\n+                CreateApiKeyRequest createApiKeyRequest = (CreateApiKeyRequest) request;\n+                @SuppressWarnings(\"unchecked\")\n+                RestToXContentListener<CreateApiKeyResponse> actionListener = (RestToXContentListener<CreateApiKeyResponse>) listener;\n+                if (createApiKeyRequest.getName().equals(\"my-api-key\")) {\n+                    actionListener.onResponse(expected);\n+                } else {\n+                    listener.onFailure(new ElasticsearchSecurityException(\"encountered an error while creating API key\"));\n+                }\n+            }\n+        }) {\n+            final RestCreateApiKeyAction restCreateApiKeyAction = new RestCreateApiKeyAction(Settings.EMPTY, mockRestController,\n+                    mockLicenseState);\n+            restCreateApiKeyAction.handleRequest(restRequest, restChannel, client);\n+\n+            final RestResponse restResponse = responseSetOnce.get();\n+            assertNotNull(restResponse);\n+            assertThat(CreateApiKeyResponse.fromXContent(createParser(XContentType.JSON.xContent(), restResponse.content())),\n+                    equalTo(expected));\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "533fa6195edc23425e667f912bde5a3f8a033d1c",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/rest/action/RestGetApiKeyActionTests.java",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyActionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyActionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestGetApiKeyActionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,138 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.collect.MapBuilder;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.AbstractRestChannel;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.rest.RestStatus;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.rest.FakeRestRequest;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.security.action.ApiKey;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.GetApiKeyResponse;\n+\n+import java.time.Instant;\n+import java.time.temporal.ChronoUnit;\n+import java.util.Arrays;\n+import java.util.Collections;\n+import java.util.Map;\n+\n+import static org.hamcrest.Matchers.arrayContaining;\n+import static org.hamcrest.Matchers.is;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class RestGetApiKeyActionTests extends ESTestCase {\n+    private final XPackLicenseState mockLicenseState = mock(XPackLicenseState.class);\n+    private final RestController mockRestController = mock(RestController.class);\n+    private Settings settings = null;\n+    private ThreadPool threadPool = null;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        settings = Settings.builder().put(\"path.home\", createTempDir().toString()).put(\"node.name\", \"test-\" + getTestName())\n+                .put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString()).build();\n+        threadPool = new ThreadPool(settings);\n+        when(mockLicenseState.isSecurityAvailable()).thenReturn(true);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        terminate(threadPool);\n+    }\n+\n+    public void testGetApiKey() throws Exception {\n+        final Map<String, String> param1 = mapBuilder().put(\"realm_name\", \"realm-1\").put(\"username\",\"user-x\").map();\n+        final Map<String, String> param2 = mapBuilder().put(\"realm_name\", \"realm-1\").map();\n+        final Map<String, String> param3 = mapBuilder().put(\"username\", \"user-x\").map();\n+        final Map<String, String> param4 = mapBuilder().put(\"id\", \"api-key-id-1\").map();\n+        final Map<String, String> param5 = mapBuilder().put(\"name\", \"api-key-name-1\").map();\n+        final Map<String, String> params = randomFrom(param1, param2, param3, param4, param5);\n+        final boolean replyEmptyResponse = rarely();\n+        final FakeRestRequest restRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+                .withParams(params).build();\n+\n+        final SetOnce<RestResponse> responseSetOnce = new SetOnce<>();\n+        final RestChannel restChannel = new AbstractRestChannel(restRequest, randomBoolean()) {\n+            @Override\n+            public void sendResponse(RestResponse restResponse) {\n+                responseSetOnce.set(restResponse);\n+            }\n+        };\n+        final Instant creation = Instant.now();\n+        final Instant expiration = randomFrom(Arrays.asList(null, Instant.now().plus(10, ChronoUnit.DAYS)));\n+        final GetApiKeyResponse getApiKeyResponseExpected = new GetApiKeyResponse(\n+                Collections.singletonList(new ApiKey(\"api-key-name-1\", \"api-key-id-1\", creation, expiration, false, \"user-x\", \"realm-1\")));\n+\n+        try (NodeClient client = new NodeClient(Settings.EMPTY, threadPool) {\n+            @SuppressWarnings(\"unchecked\")\n+            @Override\n+            public <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request,\n+                                                                                                   ActionListener<Response> listener) {\n+                GetApiKeyRequest getApiKeyRequest = (GetApiKeyRequest) request;\n+                ActionRequestValidationException validationException = getApiKeyRequest.validate();\n+                if (validationException != null) {\n+                    listener.onFailure(validationException);\n+                    return;\n+                }\n+                if (getApiKeyRequest.getApiKeyName() != null && getApiKeyRequest.getApiKeyName().equals(\"api-key-name-1\")\n+                        || getApiKeyRequest.getApiKeyId() != null && getApiKeyRequest.getApiKeyId().equals(\"api-key-id-1\")\n+                        || getApiKeyRequest.getRealmName() != null && getApiKeyRequest.getRealmName().equals(\"realm-1\")\n+                        || getApiKeyRequest.getUserName() != null && getApiKeyRequest.getUserName().equals(\"user-x\")) {\n+                    if (replyEmptyResponse) {\n+                        listener.onResponse((Response) GetApiKeyResponse.emptyResponse());\n+                    } else {\n+                        listener.onResponse((Response) getApiKeyResponseExpected);\n+                    }\n+                } else {\n+                    listener.onFailure(new ElasticsearchSecurityException(\"encountered an error while creating API key\"));\n+                }\n+            }\n+        }) {\n+            final RestGetApiKeyAction restGetApiKeyAction = new RestGetApiKeyAction(Settings.EMPTY, mockRestController, mockLicenseState);\n+\n+            restGetApiKeyAction.handleRequest(restRequest, restChannel, client);\n+\n+            final RestResponse restResponse = responseSetOnce.get();\n+            assertNotNull(restResponse);\n+            assertThat(restResponse.status(),\n+                    (replyEmptyResponse && params.get(\"id\") != null) ? is(RestStatus.NOT_FOUND) : is(RestStatus.OK));\n+            final GetApiKeyResponse actual = GetApiKeyResponse\n+                    .fromXContent(createParser(XContentType.JSON.xContent(), restResponse.content()));\n+            if (replyEmptyResponse) {\n+                assertThat(actual.getApiKeyInfos().length, is(0));\n+            } else {\n+                assertThat(actual.getApiKeyInfos(),\n+                        arrayContaining(new ApiKey(\"api-key-name-1\", \"api-key-id-1\", creation, expiration, false, \"user-x\", \"realm-1\")));\n+            }\n+        }\n+\n+    }\n+\n+    private static MapBuilder<String, String> mapBuilder() {\n+        return MapBuilder.newMapBuilder();\n+    }\n+}"
        },
        {
            "sha": "6a8a60ae2a9999506b33f07625ad6f5f681cc24c",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/rest/action/RestInvalidateApiKeyActionTests.java",
            "status": "added",
            "additions": 121,
            "deletions": 0,
            "changes": 121,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyActionTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyActionTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Frest%2Faction%2FRestInvalidateApiKeyActionTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,121 @@\n+/*\n+ * Copyright Elasticsearch B.V. and/or licensed to Elasticsearch B.V. under one\n+ * or more contributor license agreements. Licensed under the Elastic License;\n+ * you may not use this file except in compliance with the Elastic License.\n+ */\n+\n+package org.elasticsearch.xpack.security.rest.action;\n+\n+import org.apache.lucene.util.SetOnce;\n+import org.elasticsearch.ElasticsearchSecurityException;\n+import org.elasticsearch.action.Action;\n+import org.elasticsearch.action.ActionListener;\n+import org.elasticsearch.action.ActionRequest;\n+import org.elasticsearch.action.ActionRequestValidationException;\n+import org.elasticsearch.action.ActionResponse;\n+import org.elasticsearch.client.node.NodeClient;\n+import org.elasticsearch.common.bytes.BytesArray;\n+import org.elasticsearch.common.settings.Settings;\n+import org.elasticsearch.common.xcontent.NamedXContentRegistry;\n+import org.elasticsearch.common.xcontent.XContentType;\n+import org.elasticsearch.env.Environment;\n+import org.elasticsearch.license.XPackLicenseState;\n+import org.elasticsearch.rest.AbstractRestChannel;\n+import org.elasticsearch.rest.RestChannel;\n+import org.elasticsearch.rest.RestController;\n+import org.elasticsearch.rest.RestResponse;\n+import org.elasticsearch.test.ESTestCase;\n+import org.elasticsearch.test.rest.FakeRestRequest;\n+import org.elasticsearch.threadpool.ThreadPool;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyRequest;\n+import org.elasticsearch.xpack.core.security.action.InvalidateApiKeyResponse;\n+\n+import java.util.Collections;\n+\n+import static org.hamcrest.Matchers.equalTo;\n+import static org.mockito.Mockito.mock;\n+import static org.mockito.Mockito.when;\n+\n+public class RestInvalidateApiKeyActionTests extends ESTestCase {\n+    private final XPackLicenseState mockLicenseState = mock(XPackLicenseState.class);\n+    private final RestController mockRestController = mock(RestController.class);\n+    private Settings settings = null;\n+    private ThreadPool threadPool = null;\n+\n+    @Override\n+    public void setUp() throws Exception {\n+        super.setUp();\n+        settings = Settings.builder()\n+                .put(\"path.home\", createTempDir().toString())\n+                .put(\"node.name\", \"test-\" + getTestName())\n+                .put(Environment.PATH_HOME_SETTING.getKey(), createTempDir().toString())\n+                .build();\n+        threadPool = new ThreadPool(settings);\n+        when(mockLicenseState.isSecurityAvailable()).thenReturn(true);\n+    }\n+\n+    @Override\n+    public void tearDown() throws Exception {\n+        super.tearDown();\n+        terminate(threadPool);\n+    }\n+\n+    public void testInvalidateApiKey() throws Exception {\n+        final String json1 = \"{ \\\"realm_name\\\" : \\\"realm-1\\\", \\\"username\\\": \\\"user-x\\\" }\";\n+        final String json2 = \"{ \\\"realm_name\\\" : \\\"realm-1\\\" }\";\n+        final String json3 = \"{ \\\"username\\\": \\\"user-x\\\" }\";\n+        final String json4 = \"{ \\\"id\\\" : \\\"api-key-id-1\\\" }\";\n+        final String json5 = \"{ \\\"name\\\" : \\\"api-key-name-1\\\" }\";\n+        final String json = randomFrom(json1, json2, json3, json4, json5);\n+        final FakeRestRequest restRequest = new FakeRestRequest.Builder(NamedXContentRegistry.EMPTY)\n+                .withContent(new BytesArray(json), XContentType.JSON).build();\n+\n+        final SetOnce<RestResponse> responseSetOnce = new SetOnce<>();\n+        final RestChannel restChannel = new AbstractRestChannel(restRequest, randomBoolean()) {\n+            @Override\n+            public void sendResponse(RestResponse restResponse) {\n+                responseSetOnce.set(restResponse);\n+            }\n+        };\n+\n+        final InvalidateApiKeyResponse invalidateApiKeyResponseExpected = new InvalidateApiKeyResponse(\n+                Collections.singletonList(\"api-key-id-1\"), Collections.emptyList(), null);\n+\n+        try (NodeClient client = new NodeClient(Settings.EMPTY, threadPool) {\n+            @Override\n+            public <Request extends ActionRequest, Response extends ActionResponse> void doExecute(Action<Response> action, Request request,\n+                                                                                                   ActionListener<Response> listener) {\n+                InvalidateApiKeyRequest invalidateApiKeyRequest = (InvalidateApiKeyRequest) request;\n+                ActionRequestValidationException validationException = invalidateApiKeyRequest.validate();\n+                if (validationException != null) {\n+                    listener.onFailure(validationException);\n+                    return;\n+                }\n+                if (invalidateApiKeyRequest.getName() != null && invalidateApiKeyRequest.getName().equals(\"api-key-name-1\")\n+                        || invalidateApiKeyRequest.getId() != null && invalidateApiKeyRequest.getId().equals(\"api-key-id-1\")\n+                        || invalidateApiKeyRequest.getRealmName() != null && invalidateApiKeyRequest.getRealmName().equals(\"realm-1\")\n+                        || invalidateApiKeyRequest.getUserName() != null && invalidateApiKeyRequest.getUserName().equals(\"user-x\")) {\n+                    listener.onResponse((Response) invalidateApiKeyResponseExpected);\n+                } else {\n+                    listener.onFailure(new ElasticsearchSecurityException(\"encountered an error while creating API key\"));\n+                }\n+            }\n+        }) {\n+            final RestInvalidateApiKeyAction restInvalidateApiKeyAction = new RestInvalidateApiKeyAction(Settings.EMPTY, mockRestController,\n+                    mockLicenseState);\n+\n+            restInvalidateApiKeyAction.handleRequest(restRequest, restChannel, client);\n+\n+            final RestResponse restResponse = responseSetOnce.get();\n+            assertNotNull(restResponse);\n+            final InvalidateApiKeyResponse actual = InvalidateApiKeyResponse\n+                    .fromXContent(createParser(XContentType.JSON.xContent(), restResponse.content()));\n+            assertThat(actual.getInvalidatedApiKeys(), equalTo(invalidateApiKeyResponseExpected.getInvalidatedApiKeys()));\n+            assertThat(actual.getPreviouslyInvalidatedApiKeys(),\n+                    equalTo(invalidateApiKeyResponseExpected.getPreviouslyInvalidatedApiKeys()));\n+            assertThat(actual.getErrors(), equalTo(invalidateApiKeyResponseExpected.getErrors()));\n+\n+        }\n+\n+    }\n+}"
        },
        {
            "sha": "9f35e996186f1dae6acbf8119135a9ba94bb8744",
            "filename": "x-pack/plugin/security/src/test/java/org/elasticsearch/xpack/security/transport/ServerTransportFilterTests.java",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Ftransport%2FServerTransportFilterTests.java",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Ftransport%2FServerTransportFilterTests.java",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsecurity%2Fsrc%2Ftest%2Fjava%2Forg%2Felasticsearch%2Fxpack%2Fsecurity%2Ftransport%2FServerTransportFilterTests.java?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -151,10 +151,10 @@ public void testInboundAuthorizationException() throws Exception {\n         final Role empty = Role.EMPTY;\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             callback.onResponse(empty);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         when(authentication.getVersion()).thenReturn(Version.CURRENT);\n         when(authentication.getUser()).thenReturn(XPackUser.INSTANCE);\n         PlainActionFuture<Void> future = new PlainActionFuture<>();\n@@ -188,10 +188,10 @@ public void testNodeProfileAllowsNodeActions() throws Exception {\n         Authentication authentication = new Authentication(new User(\"test\", \"superuser\"), new RealmRef(\"test\", \"test\", \"node1\"), null);\n         doAnswer((i) -> {\n             ActionListener callback =\n-                    (ActionListener) i.getArguments()[1];\n+                    (ActionListener) i.getArguments()[2];\n             callback.onResponse(authentication.getUser().equals(i.getArguments()[0]) ? ReservedRolesStore.SUPERUSER_ROLE : null);\n             return Void.TYPE;\n-        }).when(authzService).roles(any(User.class), any(ActionListener.class));\n+        }).when(authzService).roles(any(User.class), any(Authentication.class), any(ActionListener.class));\n         doAnswer((i) -> {\n             ActionListener callback =\n                     (ActionListener) i.getArguments()[3];\n@@ -207,12 +207,12 @@ public void testNodeProfileAllowsNodeActions() throws Exception {\n \n         filter.inbound(internalAction, request, channel, new PlainActionFuture<>());\n         verify(authcService).authenticate(eq(internalAction), eq(request), eq((User)null), any(ActionListener.class));\n-        verify(authzService).roles(eq(authentication.getUser()), any(ActionListener.class));\n+        verify(authzService).roles(eq(authentication.getUser()), any(Authentication.class), any(ActionListener.class));\n         verify(authzService).authorize(authentication, internalAction, request, ReservedRolesStore.SUPERUSER_ROLE, null);\n \n         filter.inbound(nodeOrShardAction, request, channel, new PlainActionFuture<>());\n         verify(authcService).authenticate(eq(nodeOrShardAction), eq(request), eq((User)null), any(ActionListener.class));\n-        verify(authzService, times(2)).roles(eq(authentication.getUser()), any(ActionListener.class));\n+        verify(authzService, times(2)).roles(eq(authentication.getUser()), any(Authentication.class), any(ActionListener.class));\n         verify(authzService).authorize(authentication, nodeOrShardAction, request, ReservedRolesStore.SUPERUSER_ROLE, null);\n         verifyNoMoreInteractions(authcService, authzService);\n     }"
        },
        {
            "sha": "30b5b30a52b61236e77f4791f09fc66c1bfbfbf7",
            "filename": "x-pack/plugin/src/test/resources/rest-api-spec/api/security.create_api_key.json",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.create_api_key.json",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.create_api_key.json",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.create_api_key.json?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,22 @@\n+{\n+  \"security.create_api_key\": {\n+    \"documentation\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-create-api-key.html\",\n+    \"methods\": [ \"PUT\", \"POST\" ],\n+    \"url\": {\n+      \"path\": \"/_security/api_key\",\n+      \"paths\": [ \"/_security/api_key\" ],\n+      \"parts\": {},\n+      \"params\": {\n+        \"refresh\": {\n+          \"type\" : \"enum\",\n+          \"options\": [\"true\", \"false\", \"wait_for\"],\n+          \"description\" : \"If `true` (the default) then refresh the affected shards to make this operation visible to search, if `wait_for` then wait for a refresh to make this operation visible to search, if `false` then do nothing with refreshes.\"\n+        }\n+      }\n+    },\n+    \"body\": {\n+      \"description\" : \"The api key request to create an API key\",\n+      \"required\" : true\n+    }\n+  }\n+}"
        },
        {
            "sha": "f534d2a220e843f23f851100a32f40c5c59a6905",
            "filename": "x-pack/plugin/src/test/resources/rest-api-spec/api/security.get_api_key.json",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.get_api_key.json",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.get_api_key.json",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.get_api_key.json?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,30 @@\n+{\n+  \"security.get_api_key\": {\n+    \"documentation\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-get-api-key.html\",\n+    \"methods\": [ \"GET\" ],\n+    \"url\": {\n+      \"path\": \"/_security/api_key\",\n+      \"paths\": [ \"/_security/api_key\" ],\n+      \"parts\": {},\n+      \"params\": {\n+        \"id\": {\n+          \"type\": \"string\",\n+          \"description\": \"API key id of the API key to be retrieved\"\n+        },\n+        \"name\": {\n+          \"type\": \"string\",\n+          \"description\": \"API key name of the API key to be retrieved\"\n+        },\n+        \"username\": {\n+          \"type\": \"string\",\n+          \"description\": \"user name of the user who created this API key to be retrieved\"\n+        },\n+        \"realm_name\": {\n+          \"type\": \"string\",\n+          \"description\": \"realm name of the user who created this API key to be retrieved\"\n+        }\n+      }\n+    },\n+    \"body\": null\n+  }\n+}"
        },
        {
            "sha": "fa0639704aa9a4c1e005ffba4e7e35c12005ec2a",
            "filename": "x-pack/plugin/src/test/resources/rest-api-spec/api/security.invalidate_api_key.json",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.invalidate_api_key.json",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.invalidate_api_key.json",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Fapi%2Fsecurity.invalidate_api_key.json?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,15 @@\n+{\n+  \"security.invalidate_api_key\": {\n+    \"documentation\": \"https://www.elastic.co/guide/en/elasticsearch/reference/current/security-api-invalidate-api-key.html\",\n+    \"methods\": [ \"DELETE\" ],\n+    \"url\": {\n+      \"path\": \"/_security/api_key\",\n+      \"paths\": [ \"/_security/api_key\" ],\n+      \"parts\": {}\n+    },\n+    \"body\": {\n+      \"description\" : \"The api key request to invalidate API key(s)\",\n+      \"required\" : true\n+    }\n+  }\n+}"
        },
        {
            "sha": "def779cc7024efe78a5a6648a78314c43006f3be",
            "filename": "x-pack/plugin/src/test/resources/rest-api-spec/test/api_key/10_basic.yml",
            "status": "added",
            "additions": 290,
            "deletions": 0,
            "changes": 290,
            "blob_url": "https://github.com/elastic/elasticsearch/blob/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Ftest%2Fapi_key%2F10_basic.yml",
            "raw_url": "https://github.com/elastic/elasticsearch/raw/fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Ftest%2Fapi_key%2F10_basic.yml",
            "contents_url": "https://api.github.com/repos/elastic/elasticsearch/contents/x-pack%2Fplugin%2Fsrc%2Ftest%2Fresources%2Frest-api-spec%2Ftest%2Fapi_key%2F10_basic.yml?ref=fe36861ada3e75259ff601a9f6b0e1cd5fbb8afe",
            "patch": "@@ -0,0 +1,290 @@\n+---\n+setup:\n+  - skip:\n+      features: headers\n+\n+  - do:\n+      cluster.health:\n+          wait_for_status: yellow\n+\n+  - do:\n+      security.put_user:\n+        username: \"api_key_user\"\n+        body:  >\n+          {\n+            \"password\" : \"x-pack-test-password\",\n+            \"roles\" : [ \"superuser\" ],\n+            \"full_name\" : \"API key user\"\n+          }\n+\n+  # Create app privileges\n+  - do:\n+      security.put_privileges:\n+        body: >\n+          {\n+            \"myapp\": {\n+              \"read\": {\n+                \"application\": \"myapp\",\n+                \"name\": \"read\",\n+                \"actions\": [ \"data:read/*\" ]\n+              },\n+              \"write\": {\n+                \"application\": \"myapp\",\n+                \"name\": \"write\",\n+                \"actions\": [ \"data:write/*\" ]\n+              }\n+            }\n+          }\n+\n+---\n+teardown:\n+  - do:\n+      security.delete_user:\n+        username: \"api_key_user\"\n+        ignore: 404\n+\n+  - do:\n+      security.delete_privileges:\n+        application: myapp\n+        name: \"read,write\"\n+        ignore: 404\n+\n+---\n+\"Test create api key\":\n+\n+  - do:\n+      headers:\n+        Authorization: \"Basic YXBpX2tleV91c2VyOngtcGFjay10ZXN0LXBhc3N3b3Jk\"\n+      security.create_api_key:\n+        body:  >\n+            {\n+              \"name\": \"my-api-key\",\n+              \"expiration\": \"1d\",\n+              \"role_descriptors\": {\n+                \"role-a\": {\n+                  \"cluster\": [\"all\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-a\"],\n+                      \"privileges\": [\"read\"]\n+                    }\n+                  ]\n+                },\n+                \"role-b\": {\n+                  \"cluster\": [\"manage\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-b\"],\n+                      \"privileges\": [\"all\"]\n+                    }\n+                  ]\n+                }\n+              }\n+            }\n+  - match: { name: \"my-api-key\" }\n+  - is_true: id\n+  - is_true: api_key\n+  - is_true: expiration\n+  - transform_and_set: { login_creds: \"#base64EncodeCredentials(id,api_key)\" }\n+\n+  - do:\n+      headers:\n+        Authorization: ApiKey ${login_creds}\n+      security.authenticate: {}\n+\n+  - match: { username: \"api_key_user\" }\n+  - match: { roles.0:  \"role-b\" }\n+  - match: { roles.1:  \"role-a\" }\n+  - match: { authentication_realm.name: \"_es_api_key\" }\n+  - match: { authentication_realm.type: \"_es_api_key\" }\n+\n+---\n+\"Test get api key\":\n+  - skip:\n+      features: transform_and_set\n+\n+  - do:\n+      headers:\n+        Authorization: \"Basic YXBpX2tleV91c2VyOngtcGFjay10ZXN0LXBhc3N3b3Jk\"\n+      security.create_api_key:\n+        body:  >\n+            {\n+              \"name\": \"my-api-key\",\n+              \"expiration\": \"1d\",\n+              \"role_descriptors\": {\n+                \"role-a\": {\n+                  \"cluster\": [\"all\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-a\"],\n+                      \"privileges\": [\"read\"]\n+                    }\n+                  ]\n+                },\n+                \"role-b\": {\n+                  \"cluster\": [\"manage\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-b\"],\n+                      \"privileges\": [\"all\"]\n+                    }\n+                  ]\n+                }\n+              }\n+            }\n+  - match: { name: \"my-api-key\" }\n+  - is_true: id\n+  - is_true: api_key\n+  - is_true: expiration\n+  - set: { id: api_key_id }\n+  - set: { name: api_key_name }\n+\n+  - do:\n+      headers:\n+        Authorization: \"Basic YXBpX2tleV91c2VyOngtcGFjay10ZXN0LXBhc3N3b3Jk\"\n+      security.get_api_key:\n+        id: \"$api_key_id\"\n+  - match: { \"api_keys.0.id\": \"$api_key_id\" }\n+  - match: { \"api_keys.0.name\": \"$api_key_name\" }\n+  - match: { \"api_keys.0.username\": \"api_key_user\" }\n+  - match: { \"api_keys.0.invalidated\": false }\n+  - is_true: \"api_keys.0.creation\"\n+\n+---\n+\"Test invalidate api key\":\n+  - skip:\n+      features: transform_and_set\n+\n+  - do:\n+      headers:\n+        Authorization: \"Basic YXBpX2tleV91c2VyOngtcGFjay10ZXN0LXBhc3N3b3Jk\"\n+      security.create_api_key:\n+        body:  >\n+            {\n+              \"name\": \"my-api-key-1\",\n+              \"expiration\": \"1d\",\n+              \"role_descriptors\": {\n+              }\n+            }\n+  - match: { name: \"my-api-key-1\" }\n+  - is_true: id\n+  - is_true: api_key\n+  - is_true: expiration\n+  - set: { id: api_key_id }\n+  - transform_and_set: { login_creds: \"#base64EncodeCredentials(id,api_key)\" }\n+\n+  - do:\n+      headers:\n+        Authorization: Apikey ${login_creds}\n+      security.invalidate_api_key:\n+        body:  >\n+            {\n+              \"id\": \"${api_key_id}\"\n+            }\n+  - length: { \"invalidated_api_keys\" : 1 }\n+  - match: { \"invalidated_api_keys.0\" : \"${api_key_id}\" }\n+  - length: { \"previously_invalidated_api_keys\" : 0 }\n+  - match: { \"error_count\" : 0 }\n+\n+---\n+\"Test has privileges API for api key\":\n+  - skip:\n+      features: transform_and_set\n+\n+  - do:\n+      headers:\n+        Authorization: \"Basic YXBpX2tleV91c2VyOngtcGFjay10ZXN0LXBhc3N3b3Jk\"\n+      security.create_api_key:\n+        body:  >\n+            {\n+              \"name\": \"my-api-key\",\n+              \"expiration\": \"1d\",\n+              \"role_descriptors\": {\n+                \"role-a\": {\n+                  \"cluster\": [\"all\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-a\"],\n+                      \"privileges\": [\"read\"]\n+                    }\n+                  ],\n+                  \"applications\": [\n+                    {\n+                      \"application\": \"myapp\",\n+                      \"privileges\": [\"read\"],\n+                      \"resources\": [\"*\"]\n+                    }\n+                  ]\n+                },\n+                \"role-b\": {\n+                  \"cluster\": [\"manage\"],\n+                  \"index\": [\n+                    {\n+                      \"names\": [\"index-b\"],\n+                      \"privileges\": [\"all\"]\n+                    }\n+                  ]\n+                }\n+              }\n+            }\n+  - match: { name: \"my-api-key\" }\n+  - is_true: id\n+  - is_true: api_key\n+  - is_true: expiration\n+  - transform_and_set: { login_creds: \"#base64EncodeCredentials(id,api_key)\" }\n+\n+  - do:\n+      headers:\n+        Authorization: ApiKey ${login_creds}\n+      security.has_privileges:\n+        user: null\n+        body: >\n+          {\n+            \"index\": [\n+              {\n+                \"names\" :[ \"*\", \"index-a\" ],\n+                \"privileges\" : [ \"read\", \"index\", \"write\" ]\n+              },\n+              {\n+                \"names\" :[ \"index-a\", \"index-b\" ],\n+                \"privileges\" : [ \"read\", \"write\" ]\n+              }\n+            ],\n+            \"application\": [\n+              {\n+                \"application\" : \"myapp\",\n+                \"resources\" : [ \"*\", \"some-other-res\" ],\n+                \"privileges\" : [ \"data:read/me\", \"data:write/me\" ]\n+              }\n+            ]\n+          }\n+  - match: { \"username\" : \"api_key_user\" }\n+  - match: { \"has_all_requested\" : false }\n+  - match: { \"index\" : {\n+      \"*\" : {\n+        \"read\": false,\n+        \"index\": false,\n+        \"write\": false\n+      },\n+      \"index-a\" : {\n+        \"read\": true,\n+        \"index\": false,\n+        \"write\": false\n+      },\n+      \"index-b\" : {\n+        \"read\": true,\n+        \"write\": true\n+      }\n+    } }\n+  - match: { \"application\" : {\n+      \"myapp\" : {\n+        \"*\" : {\n+          \"data:read/me\" : true,\n+          \"data:write/me\" : false\n+        },\n+        \"some-other-res\" : {\n+          \"data:read/me\" : true,\n+          \"data:write/me\" : false\n+        }\n+      }\n+    } }"
        }
    ]
}
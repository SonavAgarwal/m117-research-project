{
    "sha": "d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
    "node_id": "MDY6Q29tbWl0MjkxNTcwOmQyZjA1MzczM2VhYmY1YzE1ODdhOWU1ZTlmYjY0MmQ1NTRmYjVmZWQ=",
    "commit": {
        "author": {
            "name": "Les Hazlewood",
            "email": "lhazlewood@apache.org",
            "date": "2010-04-17T02:00:40Z"
        },
        "committer": {
            "name": "Les Hazlewood",
            "email": "lhazlewood@apache.org",
            "date": "2010-04-17T02:00:40Z"
        },
        "message": "Refactoring of cryptograhy support.  Converted Cipher name and implementations to 'CipherService' and relative implementations to reflect their stateful nature.  Did more JavadDoc than I ever care to remember...\n\ngit-svn-id: https://svn.apache.org/repos/asf/incubator/shiro/trunk@935106 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "73b19a9cdb6f6bb87bbf350ff2c1492451a300b8",
            "url": "https://api.github.com/repos/apache/shiro/git/trees/73b19a9cdb6f6bb87bbf350ff2c1492451a300b8"
        },
        "url": "https://api.github.com/repos/apache/shiro/git/commits/d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/shiro/commits/d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
    "html_url": "https://github.com/apache/shiro/commit/d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
    "comments_url": "https://api.github.com/repos/apache/shiro/commits/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b",
            "url": "https://api.github.com/repos/apache/shiro/commits/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b",
            "html_url": "https://github.com/apache/shiro/commit/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b"
        }
    ],
    "stats": {
        "total": 2798,
        "additions": 2324,
        "deletions": 474
    },
    "files": [
        {
            "sha": "3f27bac96b7ff396fb87c164f0661f6684b32a7a",
            "filename": "core/src/main/java/org/apache/shiro/crypto/AbstractSymmetricCipherService.java",
            "status": "added",
            "additions": 66,
            "deletions": 0,
            "changes": 66,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAbstractSymmetricCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAbstractSymmetricCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAbstractSymmetricCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,66 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import javax.crypto.KeyGenerator;\n+import java.security.Key;\n+import java.security.NoSuchAlgorithmException;\n+\n+/**\n+ * Base abstract class for supporting symmetric key cipher algorithms.\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public abstract class AbstractSymmetricCipherService extends JcaCipherService {\n+\n+    protected AbstractSymmetricCipherService(String algorithmName) {\n+        super(algorithmName);\n+    }\n+\n+    /**\n+     * Generates a new {@link java.security.Key Key} suitable for this CipherService's {@link #getAlgorithmName() algorithm}\n+     * by calling {@link #generateNewKey(int) generateNewKey(128)} (uses a 128 bit size by default).\n+     *\n+     * @return a new {@link java.security.Key Key}, 128 bits in length.\n+     */\n+    public Key generateNewKey() {\n+        return generateNewKey(getKeySize());\n+    }\n+\n+    /**\n+     * Generates a new {@link Key Key} of the specified size suitable for this CipherService\n+     * (based on the {@link #getAlgorithmName() algorithmName} using the JDK {@link javax.crypto.KeyGenerator KeyGenerator}.\n+     *\n+     * @param keyBitSize the bit size of the key to create\n+     * @return the created key suitable for use with this CipherService\n+     */\n+    public Key generateNewKey(int keyBitSize) {\n+        KeyGenerator kg;\n+        try {\n+            kg = KeyGenerator.getInstance(getAlgorithmName());\n+        } catch (NoSuchAlgorithmException e) {\n+            String msg = \"Unable to acquire \" + getAlgorithmName() + \" algorithm.  This is required to function.\";\n+            throw new IllegalStateException(msg, e);\n+        }\n+        kg.init(keyBitSize);\n+        return kg.generateKey();\n+    }\n+\n+}"
        },
        {
            "sha": "10aab0ba6265cc4ff0c6ae3188c2f59c4bcb2275",
            "filename": "core/src/main/java/org/apache/shiro/crypto/AesCipherService.java",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+/**\n+ * {@code CipherService} using the {@code AES} cipher algorithm for all encryption, decryption, and key operations.\n+ * <p/>\n+ * The AES algorithm can support key sizes of {@code 128}, {@code 192} and {@code 256} bits<b>*</b>.  This implementation\n+ * defaults to 128 bits.\n+ * <p/>\n+ * Note that this class retains the parent class's default {@link OperationMode#CFB CFB} mode of operation\n+ * instead of the typical JDK default of {@link OperationMode#ECB ECB}.  {@code ECB} should not be used in\n+ * security-sensitive environments because {@code ECB} does not allow for initialization vectors, which are\n+ * considered necessary for strong encryption.  See the {@link DefaultBlockCipherService parent class}'s JavaDoc and the\n+ * {@link JcaCipherService JcaCipherService} JavaDoc for more on why the JDK default should not be used and is not\n+ * used in this implementation.\n+ * <p/>\n+ * <b>*</b> Generating and using AES key sizes greater than 128 require installation of the\n+ * <a href=\"http://java.sun.com/javase/downloads/index.jsp\">Java Cryptography Extension (JCE) Unlimited Strength\n+ * Jurisdiction Policy files</a>.\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public class AesCipherService extends DefaultBlockCipherService {\n+\n+    private static final String ALGORITHM_NAME = \"AES\";\n+\n+    /**\n+     * Creates a new {@link CipherService} instance using the {@code AES} cipher algorithm with the following\n+     * important cipher default attributes:\n+     * <table>\n+     * <tr>\n+     * <th>Attribute</th>\n+     * <th>Value</th>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setKeySize keySize}</td>\n+     * <td>{@code 128} bits</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setBlockSize blockSize}</td>\n+     * <td>{@code 128} bits (required for {@code AES}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setMode mode}</td>\n+     * <td>{@link OperationMode#CFB CFB}<b>*</b></td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setPaddingScheme paddingScheme}</td>\n+     * <td>{@link PaddingScheme#PKCS5 PKCS5}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setInitializationVectorSize(int) initializationVectorSize}</td>\n+     * <td>{@code 128} bits</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setGenerateInitializationVectors(boolean) generateInitializationVectors}</td>\n+     * <td>{@code true}<b>**</b></td>\n+     * </tr>\n+     * </table>\n+     * <p/>\n+     * <b>*</b> The {@link OperationMode#CFB CFB} operation mode is used instead of the JDK default {@code ECB} to\n+     * ensure strong encryption.  {@code ECB} should not be used in security-sensitive environments - see the\n+     * {@link DefaultBlockCipherService DefaultBlockCipherService} class JavaDoc's &quot;Operation Mode&quot; section\n+     * for more.\n+     * <p/>\n+     * <b>**</b>In conjunction with the default {@code CFB} operation mode, initialization vectors are generated by\n+     * default to ensure strong encryption.  See the {@link JcaCipherService JcaCipherService} class JavaDoc for more.\n+     */\n+    public AesCipherService() {\n+        super(ALGORITHM_NAME);\n+    }\n+\n+}"
        },
        {
            "sha": "413aab21c3fce23ec7bf86a867925ddc0f8f1e96",
            "filename": "core/src/main/java/org/apache/shiro/crypto/BlowfishCipher.java",
            "status": "removed",
            "additions": 0,
            "deletions": 286,
            "changes": 286,
            "blob_url": "https://github.com/apache/shiro/blob/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipher.java",
            "raw_url": "https://github.com/apache/shiro/raw/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipher.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipher.java?ref=22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b",
            "patch": "@@ -1,286 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.shiro.crypto;\n-\n-import java.security.InvalidKeyException;\n-import java.security.Key;\n-import java.security.NoSuchAlgorithmException;\n-import java.util.Arrays;\n-import javax.crypto.KeyGenerator;\n-import javax.crypto.spec.SecretKeySpec;\n-\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n-\n-import org.apache.shiro.codec.Base64;\n-import org.apache.shiro.codec.CodecSupport;\n-\n-\n-/**\n- * Shiro's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n- * same <tt>Key</tt> to both encrypt and decrypt data.  If one is not provided via the {@link #setKey setKey} method,\n- * a default one will be used, BUT NOTE:\n- *\n- * <p>Because Shiro is an open-source project, if anyone knew that you were using Shiro's default\n- * <code>Key</code>, they could download/view the source, and with enough effort, reconstruct the <code>Key</code>\n- * and decode encrypted data at will.\n- *\n- * <p>Shiro only really uses Ciphers to encrypt user ids and session ids, so if that information is not critical\n- * to you and you think the default key still makes things 'sufficiently difficult', then you can ignore this issue.\n- *\n- * <p>However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n- * <tt>Key</tt> via the {@link #setKey setKey} method to a Key known only to your application,\n- * guaranteeing that no third party can decrypt your data.  If you want to know how to do this, you can browse this\n- * class's source code for the {@link #generateNewKey()} method to see how we created our default.  Then you can\n- * duplicate the same in your environment and set the result on an instance of this class via the\n- * <code>setKey</code> method.\n- *\n- * @author Les Hazlewood\n- * @author Jeremy Haile\n- * @since 0.9\n- */\n-public class BlowfishCipher implements Cipher {\n-\n-    /**\n-     * The JDK Crypto Cipher algorithm to use for this class, equal to &quot;Blowfish&quot;.\n-     */\n-    private static final String ALGORITHM = \"Blowfish\";\n-\n-    /**\n-     * The JDK Crypto Transformation string to use for this class, equal to {@link #ALGORITHM ALGORITHM} + &quot;/ECB/PKCS5Padding&quot;;\n-     */\n-    private static final String TRANSFORMATION_STRING = ALGORITHM + \"/ECB/PKCS5Padding\";\n-\n-    //The following KEY_BYTES String was created by running\n-    //System.out.println( Base64.encode( generateNewKey().getEncoded() ) ); and copying-n-pasting the output here.\n-    //You should run the same and set the resulting output as a property of this class instead of using\n-    //Shiro's default Key for proper security.\n-    private static final byte[] KEY_BYTES = Base64.decode(\"jJ9Kg1BAevbvhSg3vBfwfQ==\");\n-    private static final Key DEFAULT_CIPHER_KEY = new SecretKeySpec(KEY_BYTES, ALGORITHM);\n-\n-    /**\n-     * Internal private log instance.\n-     */\n-    private static final Logger log = LoggerFactory.getLogger(BlowfishCipher.class);\n-\n-    /**\n-     * The key to use by default, can be overridden by calling {@link #setKey(java.security.Key)}.\n-     */\n-    private Key key = DEFAULT_CIPHER_KEY;\n-\n-    /**\n-     * Default no argument constructor that uses an internal default {@link #getKey() key} to use during\n-     * encryption and decryption.  For propery security, you should definitely supply your own key by using the\n-     * {@link #setKey(java.security.Key) setKey(Key)} method.\n-     */\n-    public BlowfishCipher() {\n-    }\n-\n-    /**\n-     * Returns the default {@link Key Key} to use for symmetric encryption and decryption if one is not specified during\n-     * encryption/decryption.  For truly secure applications,\n-     * you should always specify your own key via the {@link #setKey(java.security.Key) setKey} method.\n-     *\n-     * @return the {@link Key Key} to use for symmetric encryption and decryption.\n-     * @see #encrypt(byte[], byte[])\n-     * @see #decrypt(byte[], byte[])\n-     */\n-    public Key getKey() {\n-        return key;\n-    }\n-\n-    /**\n-     * Sets the internal default {@link Key Key} to use for symmetric encryption and decryption if one is not\n-     * specified during encryption/decryption.   For truly secure applications, you should always specify your own\n-     * key via this method.\n-     *\n-     * @param key the key to use for symmetric encryption and decryption.\n-     * @see #encrypt(byte[], byte[])\n-     * @see #decrypt(byte[], byte[])\n-     */\n-    public void setKey(Key key) {\n-        this.key = key;\n-    }\n-\n-    /**\n-     * Encrypts the specified raw byte array.  If the <code>key</code> argument is null, the internal default\n-     * {@link #getKey() key} will be used to encrypt the byte array.\n-     */\n-    public byte[] encrypt(byte[] raw, byte[] key) {\n-        byte[] encrypted = crypt(raw, javax.crypto.Cipher.ENCRYPT_MODE, key);\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"Incoming byte array of size \" + (raw != null ? raw.length : 0) + \".  Encrypted \" +\n-                    \"byte array is size \" + (encrypted != null ? encrypted.length : 0));\n-        }\n-        return encrypted;\n-    }\n-\n-    /**\n-     * Decrypts the specified already-encrypted byte array.  If the <code>key</code> argument is null, the internal default\n-     * {@link #getKey() key} will be used to encrypt the byte array.\n-     */\n-    public byte[] decrypt(byte[] encrypted, byte[] key) {\n-        if (log.isTraceEnabled()) {\n-            log.trace(\"Attempting to decrypt incoming byte array of length \" +\n-                    (encrypted != null ? encrypted.length : 0));\n-        }\n-        return crypt(encrypted, javax.crypto.Cipher.DECRYPT_MODE, key);\n-    }\n-\n-    /**\n-     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations, based on\n-     * the {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n-     *\n-     * @return a new Cipher instance.\n-     * @throws IllegalStateException if a new Cipher instance cannot be constructed based on the\n-     *                               {@link #TRANSFORMATION_STRING TRANSFORMATION_STRING} constant.\n-     */\n-    protected javax.crypto.Cipher newCipherInstance() throws IllegalStateException {\n-        try {\n-            return javax.crypto.Cipher.getInstance(TRANSFORMATION_STRING);\n-        } catch (Exception e) {\n-            String msg = \"Unable to acquire a Java JCE Cipher instance using \" +\n-                    javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + TRANSFORMATION_STRING + \"\\\" ). \" +\n-                    \"Blowfish under this configuration is required for the \" +\n-                    getClass().getName() + \" instance to function.\";\n-            throw new IllegalStateException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n-     * potential {@link InvalidKeyException InvalidKeyException} that might arise.\n-     *\n-     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n-     * @param mode   the Cipher mode\n-     * @param key    the Cipher's Key\n-     */\n-    protected void init(javax.crypto.Cipher cipher, int mode, java.security.Key key) {\n-        try {\n-            cipher.init(mode, key);\n-        } catch (InvalidKeyException e) {\n-            String msg = \"Unable to init cipher.\";\n-            throw new IllegalStateException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n-     * might arise in an {@link IllegalStateException IllegalStateException}\n-     *\n-     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n-     * @param bytes  the bytes to crypt\n-     * @return the resulting crypted byte array.\n-     */\n-    protected byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) {\n-        try {\n-            return cipher.doFinal(bytes);\n-        } catch (Exception e) {\n-            String msg = \"Unable to crypt bytes with cipher [\" + cipher + \"].\";\n-            throw new IllegalStateException(msg, e);\n-        }\n-    }\n-\n-    /**\n-     * Calls the {@link #init(javax.crypto.Cipher, int, java.security.Key)} and then\n-     * {@link #crypt(javax.crypto.Cipher, byte[])}.  Ensures that the key is never null by using the\n-     * {@link #getKey() default key} if the method argument key is <code>null</code>.\n-     *\n-     * @param bytes the bytes to crypt\n-     * @param mode  the JDK Cipher mode\n-     * @param key   the key to use to do the cryption.  If <code>null</code> the {@link #getKey() default key} will be used.\n-     * @return the resulting crypted byte array\n-     */\n-    protected byte[] crypt(byte[] bytes, int mode, byte[] key) {\n-        javax.crypto.Cipher cipher = newCipherInstance();\n-\n-        java.security.Key jdkKey;\n-        if (key == null) {\n-            jdkKey = getKey();\n-        } else {\n-            jdkKey = new SecretKeySpec(key, ALGORITHM);\n-        }\n-\n-        init(cipher, mode, jdkKey);\n-        return crypt(cipher, bytes);\n-    }\n-\n-    /**\n-     * Generates a new {@link Key Key} suitable for this Cipher by calling\n-     * {@link #generateNewKey(int) generateNewKey(128)} (uses a 128 bit size by default).\n-     *\n-     * @return a new {@link Key Key}, 128 bits in length.\n-     */\n-    public static Key generateNewKey() {\n-        return generateNewKey(128);\n-    }\n-\n-    /**\n-     * Generates a new {@link Key Key} of the specified size suitable for this Cipher\n-     * (based on the {@link #ALGORITHM ALGORITHM} using the JDK {@link KeyGenerator KeyGenerator}.\n-     *\n-     * @param keyBitSize the bit size of the key to create\n-     * @return the created key suitable for use with this Cipher.\n-     */\n-    public static Key generateNewKey(int keyBitSize) {\n-        KeyGenerator kg;\n-        try {\n-            kg = KeyGenerator.getInstance(ALGORITHM);\n-        } catch (NoSuchAlgorithmException e) {\n-            String msg = \"Unable to acquire \" + ALGORITHM + \" algorithm.  This is required to function.\";\n-            throw new IllegalStateException(msg, e);\n-        }\n-        kg.init(keyBitSize);\n-        return kg.generateKey();\n-    }\n-\n-    /**\n-     * Simple test main method to ensure functionality is correct.  Should really be moved to a proper test case.\n-     *\n-     * @param unused ignored\n-     * @throws Exception if anything unexpected happens.\n-     */\n-    public static void main(String[] unused) throws Exception {\n-\n-        Cipher cipher = new BlowfishCipher();\n-\n-        String[] cleartext = new String[]{\n-                \"Hello, this is a test.\",\n-                \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n-        };\n-\n-        for (String clear : cleartext) {\n-            byte[] cleartextBytes = CodecSupport.toBytes(clear);\n-            System.out.println(\"Clear text: [\" + clear + \"]\");\n-            System.out.println(\"Clear text base64: [\" + Base64.encodeToString(cleartextBytes) + \"]\");\n-\n-            byte[] encrypted = cipher.encrypt(cleartextBytes, null);\n-            String encryptedBase64 = Base64.encodeToString(encrypted);\n-            System.out.println(\"Encrypted base64: [\" + encryptedBase64 + \"]\");\n-\n-            byte[] decrypted = cipher.decrypt(Base64.decode(encryptedBase64), null);\n-            String decryptedString = CodecSupport.toString(decrypted);\n-\n-            System.out.println(\"Arrays equal? \" + Arrays.equals(cleartextBytes, decrypted));\n-\n-            System.out.println(\"Decrypted text: [\" + decryptedString + \"]\");\n-            System.out.println(\"Decrypted text base64: [\" + Base64.encodeToString(decrypted) + \"]\");\n-        }\n-    }\n-}"
        },
        {
            "sha": "1165a5dffeb15de697455cdd11c030736d7a35ca",
            "filename": "core/src/main/java/org/apache/shiro/crypto/BlowfishCipherService.java",
            "status": "added",
            "additions": 93,
            "deletions": 0,
            "changes": 93,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,93 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+/**\n+ * {@code CipherService} using the {@code Blowfish} cipher algorithm for all encryption, decryption, and key operations.\n+ * <p/>\n+ * The Blowfish algorithm can support key sizes between {@code 32} and {@code 448} bits<b>*</b>, inclusive.  However,\n+ * modern cryptanalysis techniques render keys of 80 bits or less mostly worthless - use {@code 128} or more whenever\n+ * possible.\n+ * <p/>\n+ * Note that this class retains the parent class's default {@link OperationMode#CFB CFB} mode of operation\n+ * instead of the typical JDK default of {@link OperationMode#ECB ECB}.  {@code ECB} should not be used in\n+ * security-sensitive environments because {@code ECB} does not allow for initialization vectors, which are\n+ * considered necessary for strong encryption.  See the {@link DefaultBlockCipherService parent class}'s JavaDoc and the\n+ * {@link JcaCipherService JcaCipherService} JavaDoc for more on why the JDK default should not be used and is not\n+ * used in this implementation.\n+ * <p/>\n+ * <b>*</b> Generating and using Blowfish key sizes greater than 128 require installation of the\n+ * <a href=\"http://java.sun.com/javase/downloads/index.jsp\">Java Cryptography Extension (JCE) Unlimited Strength\n+ * Jurisdiction Policy files</a>.\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public class BlowfishCipherService extends DefaultBlockCipherService {\n+\n+    private static final String ALGORITHM_NAME = \"Blowfish\";\n+    private static final int BLOCK_SIZE = 64;\n+\n+    /**\n+     * Creates a new {@link CipherService} instance using the {@code Blowfish} cipher algorithm with the following\n+     * important cipher default attributes:\n+     * <table>\n+     * <tr>\n+     * <th>Attribute</th>\n+     * <th>Value</th>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setKeySize keySize}</td>\n+     * <td>{@code 128} bits</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setBlockSize blockSize}</td>\n+     * <td>{@code 64} bits (required for {@code Blowfish})</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setMode mode}</td>\n+     * <td>{@link OperationMode#CFB CFB}<b>*</b></td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setPaddingScheme paddingScheme}</td>\n+     * <td>{@link PaddingScheme#PKCS5 PKCS5}</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setInitializationVectorSize(int) initializationVectorSize}</td>\n+     * <td>{@code 64} bits</td>\n+     * </tr>\n+     * <tr>\n+     * <td>{@link #setGenerateInitializationVectors(boolean) generateInitializationVectors}</td>\n+     * <td>{@code true}<b>**</b></td>\n+     * </tr>\n+     * </table>\n+     * <p/>\n+     * <b>*</b> The {@link OperationMode#CFB CFB} operation mode is used instead of the JDK default {@code ECB} to\n+     * ensure strong encryption.  {@code ECB} should not be used in security-sensitive environments - see the\n+     * {@link DefaultBlockCipherService DefaultBlockCipherService} class JavaDoc's &quot;Operation Mode&quot; section\n+     * for more.\n+     * <p/>\n+     * <b>**</b>In conjunction with the default {@code CFB} operation mode, initialization vectors are generated by\n+     * default to ensure strong encryption.  See the {@link JcaCipherService JcaCipherService} class JavaDoc for more.\n+     */\n+    public BlowfishCipherService() {\n+        super(ALGORITHM_NAME);\n+        setInitializationVectorSize(BLOCK_SIZE); //like most block ciphers, the IV size is the same as the block size\n+    }\n+}"
        },
        {
            "sha": "f897cb810840e1df477c140e4d8f7b2aca01af31",
            "filename": "core/src/main/java/org/apache/shiro/crypto/Cipher.java",
            "status": "removed",
            "additions": 0,
            "deletions": 75,
            "changes": 75,
            "blob_url": "https://github.com/apache/shiro/blob/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipher.java",
            "raw_url": "https://github.com/apache/shiro/raw/22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipher.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipher.java?ref=22c32ffddeec36ee05d1b3a4cf08bd45bc71cc6b",
            "patch": "@@ -1,75 +0,0 @@\n-/*\n- * Licensed to the Apache Software Foundation (ASF) under one\n- * or more contributor license agreements.  See the NOTICE file\n- * distributed with this work for additional information\n- * regarding copyright ownership.  The ASF licenses this file\n- * to you under the Apache License, Version 2.0 (the\n- * \"License\"); you may not use this file except in compliance\n- * with the License.  You may obtain a copy of the License at\n- *\n- *     http://www.apache.org/licenses/LICENSE-2.0\n- *\n- * Unless required by applicable law or agreed to in writing,\n- * software distributed under the License is distributed on an\n- * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n- * KIND, either express or implied.  See the License for the\n- * specific language governing permissions and limitations\n- * under the License.\n- */\n-package org.apache.shiro.crypto;\n-\n-/**\n- * A <tt>Cipher</tt> is an algorithm used in cryptography that converts an original input source using a <tt>Key</tt> to\n- * an uninterpretable format.  The resulting encrypted output is only able to be converted back to original form with\n- * a <tt>Key</tt> as well.\n- *\n- * <p>For what is known as <em>Symmetric</em> <tt>Cipher</tt>s, the <tt>Key</tt> used to encrypt the source is the same\n- * as (or trivially similar to) the <tt>Key</tt> used to decrypt it.\n- *\n- * <p>For <em>Assymetric</em> <tt>Cipher</tt>s, the encryption <tt>Key</tt> is not the same as the decryption <tt>Key</tt>.\n- * The most common type of Assymetric Ciphers are based on what is called public/private key pairs:\n- *\n- * <p>A <em>private</em> key is known only to a single party, and as its name implies, is supposed be kept very private\n- * and secure.  A <em>public</em> key that is associated with the private key can be disseminated freely to anyone.\n- * Then data encrypted by the public key can only be decrypted by the private key and vice versa, but neither party\n- * need share their private key with anyone else.  By not sharing a private key, you can guarantee no 3rd party can\n- * intercept the key and therefore use it to decrypt a message.\n- *\n- * <p>This assymetric key technology was created as a\n- * more secure alternative to symmetric ciphers that sometimes suffer from man-in-the-middle attacks since, for\n- * data shared between two parties, the same Key must also be shared and may be compromised.\n- *\n- * <p>Note that a symmetric cipher is perfectly fine to use if you just want to encode data in a format no one else\n- * can understand and you never give away the key.  Shiro uses a symmetric cipher when using certain\n- * HTTP Cookies for example - because it is often undesireable to have user's identity stored in a plain-text cookie,\n- * that identity can be converted via a symmetric cipher.  Since the the same exact Shiro application will receive\n- * the cookie, it can decrypt it via the same <tt>Key</tt> and there is no potential for discovery since that Key\n- * is never shared with anyone.\n- *\n- * @author Les Hazlewood\n- * @see BlowfishCipher\n- * @since 0.9\n- */\n-public interface Cipher {\n-\n-    /**\n-     * Encrypts data via the specified Cipher key.  Note that the key must be in a format understood by\n-     * the Cipher implementation.\n-     *\n-     * @param raw           the data to encrypt\n-     * @param encryptionKey the Cipher key used during encryption.\n-     * @return an encrypted representation of the specified raw data.\n-     */\n-    byte[] encrypt(byte[] raw, byte[] encryptionKey);\n-\n-    /**\n-     * Decrypts encrypted data via the specified Cipher key and returns the original (pre-encrypted) data.\n-     * Note that the key must be in a format understood by the Cipher implementation.\n-     *\n-     * @param encrypted     the previously encrypted data to decrypt\n-     * @param decryptionKey the Cipher key used during decryption.\n-     * @return the original form of the specified encrypted data.\n-     */\n-    byte[] decrypt(byte[] encrypted, byte[] decryptionKey);\n-\n-}"
        },
        {
            "sha": "729f215fe7a32b2ac0ffe189d522523572ffe279",
            "filename": "core/src/main/java/org/apache/shiro/crypto/CipherService.java",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,176 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.util.ByteSource;\n+\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+\n+/**\n+ * A {@code CipherService} uses a cryptographic algorithm called a\n+ * <a href=\"http://en.wikipedia.org/wiki/Cipher\">Cipher</a> to convert an original input source using a {@code key} to\n+ * an uninterpretable format.  The resulting encrypted output is only able to be converted back to original form with\n+ * a {@code key} as well.  {@code CipherService}s can perform both encryption and decryption.\n+ * <h2>Cipher Basics</h2>\n+ * For what is known as <em>Symmetric</em> {@code Cipher}s, the {@code Key} used to encrypt the source is the same\n+ * as (or trivially similar to) the {@code Key} used to decrypt it.\n+ * <p/>\n+ * For <em>Asymmetric</em> {@code Cipher}s, the encryption {@code Key} is not the same as the decryption {@code Key}.\n+ * The most common type of Asymmetric Ciphers are based on what is called public/private key pairs:\n+ * <p/>\n+ * A <em>private</em> key is known only to a single party, and as its name implies, is supposed be kept very private\n+ * and secure.  A <em>public</em> key that is associated with the private key can be disseminated freely to anyone.\n+ * Then data encrypted by the public key can only be decrypted by the private key and vice versa, but neither party\n+ * need share their private key with anyone else.  By not sharing a private key, you can guarantee no 3rd party can\n+ * intercept the key and therefore use it to decrypt a message.\n+ * <p/>\n+ * This asymmetric key technology was created as a\n+ * more secure alternative to symmetric ciphers that sometimes suffer from man-in-the-middle attacks since, for\n+ * data shared between two parties, the same Key must also be shared and may be compromised.\n+ * <p/>\n+ * Note that a symmetric cipher is perfectly fine to use if you just want to encode data in a format no one else\n+ * can understand and you never give away the key.  Shiro uses a symmetric cipher when creating certain\n+ * HTTP Cookies for example - because it is often undesirable to have user's identity stored in a plain-text cookie,\n+ * that identity can be converted via a symmetric cipher.  Since the the same exact Shiro application will receive\n+ * the cookie, it can decrypt it via the same {@code Key} and there is no potential for discovery since that Key\n+ * is never shared with anyone.\n+ * <h2>{@code CipherService}s vs JDK {@link javax.crypto.Cipher Cipher}s</h2>\n+ * Shiro {@code CipherService}s essentially do the same things as JDK {@link javax.crypto.Cipher Cipher}s, but in\n+ * simpler and easier-to-use ways for most application developers.  When thinking about encrypting and decrypting data\n+ * in an application, most app developers want what a {@code CipherService} provides, rather than having to manage the\n+ * lower-level intricacies of the JDK's {@code Cipher} API.  Here are a few reasons why most people prefer\n+ * {@code CipherService}s:\n+ * <ul>\n+ * <li><b>Stateless Methods</b> - {@code CipherService} method calls do not retain state between method invocations.\n+ * JDK {@code Cipher} instances do retain state across invocations, requiring its end-users to manage the instance\n+ * and its state themselves.</li>\n+ * <li><b>Thread Safety</b> - {@code CipherService} instances are thread-safe inherently because no state is\n+ * retained across method invocations.  JDK {@code Cipher} instances retain state and cannot be used by multiple\n+ * threads concurrently.</li>\n+ * <li><b>Single Operation</b> - {@code CipherService} method calls are single operation methods: encryption or\n+ * decryption in their entirety are done as a single method call.  This is ideal for the large majority of developer\n+ * needs where you have something unencrypted and just want it decrypted (or vice versa) in a single method call.  In\n+ * contrast, JDK {@code Cipher} instances can support encrypting/decrypting data in chunks over time (because it\n+ * retains state), but this often introduces API clutter and confusion for most application developers.</li>\n+ * <li><b>Type Safe</b> - There are {@code CipherService} implementations for different Cipher algorithms\n+ * ({@code AesCipherService}, {@code BlowfishCipherService}, etc).  There is only one JDK {@code Cipher} class to\n+ * represent all cipher algorithms/instances.\n+ * <li><b>Simple Construction</b> - Because {@code CipherService} instances are type-safe, instantiating and using\n+ * one is often as simple as calling the default constructor, for example, <code>new AesCipherService();</code>.  The\n+ * JDK {@code Cipher} class however requires using a procedural factory method with String arguments to indicate how\n+ * the instance should be created.  The String arguments themselves are somewhat cryptic and hard to\n+ * understand unless you're a security expert.  Shiro hides these details from you, but allows you to configure them\n+ * if you want.</li>\n+ * </ul>\n+ *\n+ * @author Les Hazlewood\n+ * @see BlowfishCipherService\n+ * @see AesCipherService\n+ * @since 1.0\n+ */\n+public interface CipherService {\n+\n+    /**\n+     * Decrypts encrypted data via the specified cipher key and returns the original (pre-encrypted) data.\n+     * Note that the key must be in a format understood by the CipherService implementation.\n+     *\n+     * @param encrypted     the previously encrypted data to decrypt\n+     * @param decryptionKey the cipher key used during decryption.\n+     * @return a byte source representing the original form of the specified encrypted data.\n+     * @throws CryptoException if there is an error during decryption\n+     */\n+    ByteSource decrypt(byte[] encrypted, byte[] decryptionKey) throws CryptoException;\n+\n+    /**\n+     * Receives encrypted data from the given {@code InputStream}, decrypts it, and sends the resulting decrypted data\n+     * to the given {@code OutputStream}.\n+     * <p/>\n+     * <b>NOTE:</b> This method <em>does NOT</em> flush or close either stream prior to returning - the caller must\n+     * do so when they are finished with the streams.  For example:\n+     * <pre>\n+     * try {\n+     *     InputStream in = ...\n+     *     OutputStream out = ...\n+     *     cipherService.decrypt(in, out, decryptionKey);\n+     * } finally {\n+     *     if (in != null) {\n+     *         try {\n+     *             in.close();\n+     *         } catch (IOException ioe1) { ... log, trigger event, etc }\n+     *     }\n+     *     if (out != null) {\n+     *         try {\n+     *             out.close();\n+     *         } catch (IOException ioe2) { ... log, trigger event, etc }\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param in            the stream supplying the data to decrypt\n+     * @param out           the stream to send the decrypted data\n+     * @param decryptionKey the cipher key to use for decryption\n+     * @throws CryptoException if there is any problem during decryption.\n+     */\n+    void decrypt(InputStream in, OutputStream out, byte[] decryptionKey) throws CryptoException;\n+\n+    /**\n+     * Encrypts data via the specified cipher key.  Note that the key must be in a format understood by\n+     * the {@code CipherService} implementation.\n+     *\n+     * @param raw           the data to encrypt\n+     * @param encryptionKey the cipher key used during encryption.\n+     * @return a byte source with the encrypted representation of the specified raw data.\n+     * @throws CryptoException if there is an error during encryption\n+     */\n+    ByteSource encrypt(byte[] raw, byte[] encryptionKey) throws CryptoException;\n+\n+    /**\n+     * Receives the data from the given {@code InputStream}, encrypts it, and sends the resulting encrypted data to the\n+     * given {@code OutputStream}.\n+     * <p/>\n+     * <b>NOTE:</b> This method <em>does NOT</em> flush or close either stream prior to returning - the caller must\n+     * do so when they are finished with the streams.  For example:\n+     * <pre>\n+     * try {\n+     *     InputStream in = ...\n+     *     OutputStream out = ...\n+     *     cipherService.encrypt(in, out, encryptionKey);\n+     * } finally {\n+     *     if (in != null) {\n+     *         try {\n+     *             in.close();\n+     *         } catch (IOException ioe1) { ... log, trigger event, etc }\n+     *     }\n+     *     if (out != null) {\n+     *         try {\n+     *             out.close();\n+     *         } catch (IOException ioe2) { ... log, trigger event, etc }\n+     *     }\n+     * }\n+     * </pre>\n+     *\n+     * @param in            the stream supplying the data to encrypt\n+     * @param out           the stream to send the encrypted data\n+     * @param encryptionKey the cipher key to use for encryption\n+     * @throws CryptoException if there is any problem during encryption.\n+     */\n+    void encrypt(InputStream in, OutputStream out, byte[] encryptionKey) throws CryptoException;\n+\n+}"
        },
        {
            "sha": "69ada0aab66e834d5ea968c9b1e5cdb532950203",
            "filename": "core/src/main/java/org/apache/shiro/crypto/CryptoException.java",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCryptoException.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCryptoException.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FCryptoException.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.ShiroException;\n+\n+/**\n+ * Base Shiro exception for problems encountered during cryptographic operations.\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public class CryptoException extends ShiroException {\n+\n+    public CryptoException(String message) {\n+        super(message);\n+    }\n+\n+    public CryptoException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    public CryptoException(String message, Throwable cause) {\n+        super(message, cause);\n+    }\n+}"
        },
        {
            "sha": "11778820b0ca5418bf74f069cf37c4bbf9674d58",
            "filename": "core/src/main/java/org/apache/shiro/crypto/DefaultBlockCipherService.java",
            "status": "added",
            "additions": 533,
            "deletions": 0,
            "changes": 533,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FDefaultBlockCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FDefaultBlockCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FDefaultBlockCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,533 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.util.StringUtils;\n+\n+/**\n+ * Base abstract class for block cipher algorithms.\n+ *\n+ * <h2>Usage</h2>\n+ * Note that this class exists mostly to simplify algorithm-specific subclasses.  Unless you understand the concepts of\n+ * cipher modes of operations, block sizes, and padding schemes, and you want direct control of these things, you should\n+ * typically not uses instances of this class directly.  Instead, algorithm-specific subclasses, such as\n+ * {@link AesCipherService}, {@link BlowfishCipherService}, and others are usually better suited for regular use.\n+ * <p/>\n+ * However, if you have the need to create a custom block cipher service where no sufficient algorithm-specific subclass\n+ * exists in Shiro, this class would be very useful.\n+ *\n+ * <h2>Configuration</h2>\n+ * Block ciphers can accept configuration parameters that direct how they operate.  These parameters concatenated\n+ * together in a single String comprise what the JDK JCA documentation calls a\n+ * <a href=\"http://java.sun.com/javase/6/docs/technotes/guides/security/crypto/CryptoSpec.html#trans\">transformation\n+ * string</a>.  We think that it is better for Shiro to construct this transformation string automatically based on its\n+ * constituent parts instead of having the end-user construct the string manually, which may be error prone or\n+ * confusing.  To that end, Shiro {@link DefaultBlockCipherService}s have attributes that can be set individually in\n+ * a type-safe manner based on your configuration needs, and Shiro will build the transformation string for you.\n+ * <p/>\n+ * The following sections typically document the configuration options for block (byte array)\n+ * {@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])} method invocations.  Streaming configuration\n+ * for those same attributes are done via mirrored {@code streaming}* attributes, and their purpose is identical, but\n+ * they're only used during streaming {@link #encrypt(java.io.InputStream, java.io.OutputStream, byte[])} and\n+ * {@link #decrypt(java.io.InputStream, java.io.OutputStream, byte[])} methods.  See the &quot;Streaming&quot;\n+ * section below for more.\n+ *\n+ * <h3>Block Size</h3>\n+ * The block size specifies the number of bits (not bytes) that the cipher operates on when performing an operation.\n+ * It can be specified explicitly via the {@link #setBlockSize blockSize} attribute.  If not set, the JCA Provider\n+ * default will be used based on the cipher algorithm.  Block sizes are usually very algorithm specific, so set this\n+ * value only if you know you don't want the JCA Provider's default for the desired algorithm.  For example, the\n+ * AES algorithm's Rijndael implementation <em>only</em> supports a 128 bit block size and will not work with any other\n+ * size.\n+ * <p/>\n+ * Also note that the {@link #setInitializationVectorSize initializationVectorSize} is usually the same as the\n+ * {@link #setBlockSize blockSize} in block ciphers.  If you change either attribute, you should ensure that the other\n+ * attribute is correct for the target cipher algorithm.\n+ *\n+ * <h3>Operation Mode</h3>\n+ * You may set the block cipher's<a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation\">mode of\n+ * operation</a> via the {@link #setMode(OperationMode) mode} attribute, which accepts a type-safe\n+ * {@link OperationMode OperationMode} enum instance.  This type safety helps avoid typos when specifying the mode and\n+ * guarantees that the mode name will be recognized by the underlying JCA Provider.\n+ * <p/>\n+ * <b>*</b>If no operation mode is specified, Shiro defaults all of its block {@code CipherService} instances to the\n+ * {@link OperationMode#CFB CFB} mode, specifically to support auto-generation of initialization vectors during\n+ * encryption.  This is different than the JDK's default {@link OperationMode#ECB ECB} mode because {@code ECB} does\n+ * not support initialization vectors, which are necessary for strong encryption.  See  the\n+ * {@link org.apache.shiro.crypto.JcaCipherService JcaCipherService parent class} class JavaDoc for an extensive\n+ * explanation on why we do this and why we do not use the Sun {@code ECB} default.  You also might also want read\n+ * the <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29\">Wikipedia\n+ * section on ECB<a/> and look at the encrypted image to see an example of why {@code ECB} should not be used in\n+ * security-sensitive environments.\n+ * <p/>\n+ * In the rare case that you need to override the default with a mode not represented\n+ * by the {@link OperationMode} enum, you may specify the raw mode name string that will be recognized by your JCA\n+ * provider via the {@link #setModeName modeName} attribute.  Because this is not type-safe, it is recommended only to\n+ * use this attribute if the {@link OperationMode} enum does not represent your desired mode.\n+ * <p/>\n+ * <b>NOTE:</b> If you change the mode to one that does not support initialization vectors (such as\n+ * {@link OperationMode#ECB ECB} or {@link OperationMode#NONE NONE}), you <em>must</em> turn off auto-generated\n+ * initialization vectors by setting {@link #setGenerateInitializationVectors(boolean) generateInitializationVectors}\n+ * to {@code false}.  Abandoning initialization vectors significantly weakens encryption, so think twice before\n+ * disabling this feature.\n+ *\n+ * <h3>Padding Scheme</h3>\n+ * Because block ciphers process messages in fixed-length blocks, if the final block in a message is not equal to the\n+ * block length, <a href=\"http://en.wikipedia.org/wiki/Padding_(cryptography)\">padding</a> is applied to match that\n+ * size to maintain the total length of the message.  This is good because it protects data patterns from being\n+ * identified  - when all chunks look the same length, it is much harder to infer what that data might be.\n+ * <p/>\n+ * You may set a padding scheme via the {@link #setPaddingScheme(PaddingScheme) paddingScheme} attribute, which\n+ * accepts a type-safe {@link PaddingScheme PaddingScheme} enum instance.  Like the {@link OperationMode} enum,\n+ * this enum offers type safety to help avoid typos and guarantees that the mode will be recongized by the underlying\n+ * JCA provider.\n+ * <p/>\n+ * <b>*</b>If no padding scheme is specified, this class defaults to the {@link PaddingScheme#PKCS5} scheme, specifically\n+ * to be compliant with the default behavior of auto-generating initialization vectors during encryption (see the\n+ * {@link org.apache.shiro.crypto.JcaCipherService JcaCipherService parent class} class JavaDoc for why).\n+ * <p/>\n+ * In the rare case that you need to override the default with a scheme not represented by the {@link PaddingScheme}\n+ * enum, you may specify the raw padding scheme name string that will be recognized by your JCA provider via the\n+ * {@link #setPaddingScheme paddingSchemeName} attribute.  Because this is not type-safe, it is recommended only to\n+ * use this attribute if the {@link PaddingScheme} enum does not represent your desired scheme.\n+ *\n+ * <h2>Streaming</h2>\n+ * Most people don't think of using block ciphers as stream ciphers, since their name implies working\n+ * with block data (i.e. byte arrays) only.  However, block ciphers can be turned into byte-oriented stream ciphers by\n+ * using an appropriate {@link OperationMode operation mode} with a {@link #getStreamingBlockSize() streaming block size}\n+ * of 8 bits.  This is why the {@link CipherService} interface provides both block and streaming operations.\n+ * <p/>\n+ * Because this streaming 8-bit block size rarely changes across block-cipher algorithms, default values have been set\n+ * for all three streaming configuration parameters.  The defaults are:\n+ * <ul>\n+ * <li>{@link #setStreamingBlockSize(int) streamingBlockSize} = {@code 8} (bits)</li>\n+ * <li>{@link #setStreamingMode streamingMode} = {@link OperationMode#CFB CFB}</li>\n+ * <li>{@link #setStreamingPaddingScheme(PaddingScheme) streamingPaddingScheme} = {@link PaddingScheme#NONE none} (since\n+ * the block size is already the most atomic size of a single byte)</li>\n+ * </ul>\n+ * <p/>\n+ * These attributes have the same meaning as the {@code mode}, {@code blockSize}, and {@code paddingScheme} attributes\n+ * described above, but they are applied during streaming method invocations only ({@link #encrypt(java.io.InputStream, java.io.OutputStream, byte[])}\n+ * and {@link #decrypt(java.io.InputStream, java.io.OutputStream, byte[])}).\n+ *\n+ * @author Les Hazlewood\n+ * @see BlowfishCipherService\n+ * @see AesCipherService\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation\">Wikipedia: Block Cipher Modes of Operation</a>\n+ * @since 1.0\n+ */\n+public class DefaultBlockCipherService extends AbstractSymmetricCipherService {\n+\n+    private static final int DEFAULT_BLOCK_SIZE = 0;\n+\n+    private static final String TRANSFORMATION_STRING_DELIMITER = \"/\";\n+    private static final int DEFAULT_STREAMING_BLOCK_SIZE = 8; //8 bits (1 byte)\n+\n+    private String modeName;\n+    private int blockSize; //size in bits (not bytes) - i.e. a blockSize of 8 equals 1 byte. negative or zero value = use system default\n+    private String paddingSchemeName;\n+\n+    private String streamingModeName;\n+    private int streamingBlockSize;\n+    private String streamingPaddingSchemeName;\n+\n+    private String transformationString; //cached value - rebuilt whenever any of its constituent parts change\n+    private String streamingTransformationString; //cached value - rebuilt whenever any of its constituent parts change\n+\n+\n+    /**\n+     * Creates a new {@link DefaultBlockCipherService} using the specified block cipher {@code algorithmName}.  Per this\n+     * class's JavaDoc, this constructor also sets the following defaults:\n+     * <ul>\n+     * <li>{@code streamingMode} = {@link OperationMode#CFB CFB}</li>\n+     * <li>{@code streamingPaddingScheme} = {@link PaddingScheme#NONE none}</li>\n+     * <li>{@code streamingBlockSize} = 8</li>\n+     * </ul>\n+     * All other attributes are null/unset, indicating the JCA Provider defaults will be used.\n+     *\n+     * @param algorithmName the block cipher algorithm to use when encrypting and decrypting\n+     */\n+    public DefaultBlockCipherService(String algorithmName) {\n+        super(algorithmName);\n+\n+        this.modeName = OperationMode.CFB.name();\n+        this.paddingSchemeName = PaddingScheme.PKCS5.getTransformationName();\n+        this.blockSize = DEFAULT_BLOCK_SIZE; //0 = use the JCA provider's default\n+\n+        this.streamingModeName = OperationMode.CFB.name();\n+        this.streamingPaddingSchemeName = PaddingScheme.NONE.getTransformationName();\n+        this.streamingBlockSize = DEFAULT_STREAMING_BLOCK_SIZE;\n+    }\n+\n+    /**\n+     * Returns the cipher operation mode name (as a String) to be used when constructing\n+     * {@link javax.crypto.Cipher Cipher} transformation string or {@code null} if the JCA Provider default mode for\n+     * the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingModeName() streamingModeName} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * The default value is {@code null} to retain the JCA Provider default.\n+     *\n+     * @return the cipher operation mode name (as a String) to be used when constructing the\n+     *         {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider default\n+     *         mode for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public String getModeName() {\n+        return modeName;\n+    }\n+\n+    /**\n+     * Sets the cipher operation mode name to be used when constructing the\n+     * {@link javax.crypto.Cipher Cipher} transformation string.  A {@code null} value indicates that the JCA Provider\n+     * default mode for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingModeName() streamingModeName} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * The default value is {@code null} to retain the JCA Provider default.\n+     * <p/>\n+     * <b>NOTE:</b> most standard mode names are represented by the {@link OperationMode OperationMode} enum.  That enum\n+     * should be used with the {@link #setMode mode} attribute when possible to retain type-safety and reduce the\n+     * possibility of errors.  This method is better used if the {@link OperationMode} enum does not represent the\n+     * necessary mode.\n+     *\n+     * @param modeName the cipher operation mode name to be used when constructing\n+     *                 {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider\n+     *                 default mode for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * @see #setMode\n+     */\n+    public void setModeName(String modeName) {\n+        this.modeName = modeName;\n+        //clear out the transformation string so the next invocation will rebuild it with the new mode:\n+        this.transformationString = null;\n+    }\n+\n+    /**\n+     * Sets the cipher operation mode of operation to be used when constructing the\n+     * {@link javax.crypto.Cipher Cipher} transformation string.  A {@code null} value indicates that the JCA Provider\n+     * default mode for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #setStreamingMode streamingMode} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * If the {@link OperationMode} enum cannot represent your desired mode, you can set the name explicitly\n+     * via the {@link #setModeName modeName} attribute directly.  However, because {@link OperationMode} represents all\n+     * standard JDK mode names already, ensure that your underlying JCA Provider supports the non-standard name first.\n+     *\n+     * @param mode the cipher operation mode to be used when constructing\n+     *             {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider\n+     *             default mode for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public void setMode(OperationMode mode) {\n+        setModeName(mode.name());\n+    }\n+\n+    /**\n+     * Returns the cipher algorithm padding scheme name (as a String) to be used when constructing\n+     * {@link javax.crypto.Cipher Cipher} transformation string or {@code null} if the JCA Provider default mode for\n+     * the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingPaddingSchemeName() streamingPaddingSchemeName} attribute is used when the block cipher is\n+     * used for streaming operations.\n+     * <p/>\n+     * The default value is {@code null} to retain the JCA Provider default.\n+     *\n+     * @return the padding scheme name (as a String) to be used when constructing the\n+     *         {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider default\n+     *         padding scheme for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public String getPaddingSchemeName() {\n+        return paddingSchemeName;\n+    }\n+\n+    /**\n+     * Sets the padding scheme name to be used when constructing the\n+     * {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider default mode for\n+     * the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingPaddingSchemeName() streamingPaddingSchemeName} attribute is used when the block cipher is\n+     * used for streaming operations.\n+     * <p/>\n+     * The default value is {@code null} to retain the JCA Provider default.\n+     * <p/>\n+     * <b>NOTE:</b> most standard padding schemes are represented by the {@link PaddingScheme PaddingScheme} enum.\n+     * That enum should be used with the {@link #setPaddingScheme paddingScheme} attribute when possible to retain\n+     * type-safety and reduce the possibility of errors.  Calling this method however is suitable if the\n+     * {@code PaddingScheme} enum does not represent the desired scheme.\n+     *\n+     * @param paddingSchemeName the padding scheme name to be used when constructing\n+     *                          {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA\n+     *                          Provider default padding scheme for the specified {@link #getAlgorithmName() algorithm}\n+     *                          should be used.\n+     * @see #setPaddingScheme\n+     */\n+    public void setPaddingSchemeName(String paddingSchemeName) {\n+        this.paddingSchemeName = paddingSchemeName;\n+        //clear out the transformation string so the next invocation will rebuild it with the new padding scheme:\n+        this.transformationString = null;\n+    }\n+\n+    /**\n+     * Sets the padding scheme to be used when constructing the\n+     * {@link javax.crypto.Cipher Cipher} transformation string. A {@code null} value indicates that the JCA Provider\n+     * default padding scheme for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #setStreamingPaddingScheme streamingPaddingScheme} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * If the {@link PaddingScheme PaddingScheme} enum does represent your desired scheme, you can set the name explicitly\n+     * via the {@link #setPaddingSchemeName paddingSchemeName} attribute directly.  However, because\n+     * {@code PaddingScheme} represents all standard JDK scheme names already, ensure that your underlying JCA Provider\n+     * supports the non-standard name first.\n+     *\n+     * @param paddingScheme the padding scheme to be used when constructing\n+     *                      {@link javax.crypto.Cipher Cipher} transformation string, or {@code null} if the JCA Provider\n+     *                      default padding scheme for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public void setPaddingScheme(PaddingScheme paddingScheme) {\n+        setPaddingSchemeName(paddingScheme.getTransformationName());\n+    }\n+\n+    /**\n+     * Returns the block cipher's block size to be used when constructing\n+     * {@link javax.crypto.Cipher Cipher} transformation string or {@code -1} if the JCA Provider default block size\n+     * the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingBlockSize() streamingBlockSize} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * The default value is {@code -1} to retain the JCA Provider default.\n+     *\n+     * @return the block cipher block size to be used when constructing the\n+     *         {@link javax.crypto.Cipher Cipher} transformation string, or {@code -1} if the JCA Provider default\n+     *         block size for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public int getBlockSize() {\n+        return blockSize;\n+    }\n+\n+    /**\n+     * Sets the block cipher's block size to be used when constructing\n+     * {@link javax.crypto.Cipher Cipher} transformation string.  {@code -1} indicates that the JCA Provider default\n+     * block size for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     * <p/>\n+     * This attribute is used <em>only</em> when constructing the transformation string for block (byte array)\n+     * operations ({@link #encrypt(byte[], byte[])} and {@link #decrypt(byte[], byte[])}).  The\n+     * {@link #getStreamingBlockSize() streamingBlockSize} attribute is used when the block cipher is used for\n+     * streaming operations.\n+     * <p/>\n+     * The default value is {@code -1} to retain the JCA Provider default.\n+     * <p/>\n+     * <b>NOTE:</b> block cipher block sizes are very algorithm-specific.  If you change this value, ensure that it\n+     * will work with the specified {@link #getAlgorithmName() algorithm}.\n+     *\n+     * @param blockSize the block cipher block size to be used when constructing the\n+     *                  {@link javax.crypto.Cipher Cipher} transformation string, or {@code -1} if the JCA Provider\n+     *                  default block size for the specified {@link #getAlgorithmName() algorithm} should be used.\n+     */\n+    public void setBlockSize(int blockSize) {\n+        this.blockSize = Math.max(DEFAULT_BLOCK_SIZE, blockSize);\n+        //clear out the transformation string so the next invocation will rebuild it with the new block size:\n+        this.transformationString = null;\n+    }\n+\n+    /**\n+     * Same purpose as the {@link #getModeName modeName} attribute, but is used instead only for for streaming\n+     * operations ({@link #encrypt(java.io.InputStream, java.io.OutputStream, byte[])} and\n+     * {@link #decrypt(java.io.InputStream, java.io.OutputStream, byte[])}).\n+     * <p/>\n+     * Note that unlike the {@link #getModeName modeName} attribute, the default value of this attribute is not\n+     * {@code null} - it is {@link OperationMode#CFB CFB} for reasons described in the class-level JavaDoc in the\n+     * {@code Streaming} section.\n+     *\n+     * @return the transformation string mode name to be used for streaming operations only.\n+     */\n+    public String getStreamingModeName() {\n+        return streamingModeName;\n+    }\n+\n+    private boolean isModeStreamingCompatible(String modeName) {\n+        return modeName != null &&\n+                !modeName.equalsIgnoreCase(OperationMode.ECB.name()) &&\n+                !modeName.equalsIgnoreCase(OperationMode.NONE.name());\n+    }\n+\n+    /**\n+     * Sets the transformation string mode name to be used for streaming operations only.  The default value is\n+     * {@link OperationMode#CFB CFB} for reasons described in the class-level JavaDoc in the {@code Streaming} section.\n+     *\n+     * @param streamingModeName transformation string mode name to be used for streaming operations only\n+     */\n+    public void setStreamingModeName(String streamingModeName) {\n+        if (!isModeStreamingCompatible(streamingModeName)) {\n+            String msg = \"mode [\" + streamingModeName + \"] is not a valid operation mode for block cipher streaming.\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+        this.streamingModeName = streamingModeName;\n+        //clear out the streaming transformation string so the next invocation will rebuild it with the new mode:\n+        this.streamingTransformationString = null;\n+    }\n+\n+    /**\n+     * Sets the transformation string mode to be used for streaming operations only.  The default value is\n+     * {@link OperationMode#CFB CFB} for reasons described in the class-level JavaDoc in the {@code Streaming} section.\n+     *\n+     * @param mode the transformation string mode to be used for streaming operations only\n+     */\n+    public void setStreamingMode(OperationMode mode) {\n+        setStreamingModeName(mode.name());\n+    }\n+\n+    public String getStreamingPaddingSchemeName() {\n+        return streamingPaddingSchemeName;\n+    }\n+\n+    public void setStreamingPaddingSchemeName(String streamingPaddingSchemeName) {\n+        this.streamingPaddingSchemeName = streamingPaddingSchemeName;\n+        //clear out the streaming transformation string so the next invocation will rebuild it with the new scheme:\n+        this.streamingTransformationString = null;\n+    }\n+\n+    public void setStreamingPaddingScheme(PaddingScheme scheme) {\n+        setStreamingPaddingSchemeName(scheme.getTransformationName());\n+    }\n+\n+    public int getStreamingBlockSize() {\n+        return streamingBlockSize;\n+    }\n+\n+    public void setStreamingBlockSize(int streamingBlockSize) {\n+        this.streamingBlockSize = Math.max(DEFAULT_BLOCK_SIZE, streamingBlockSize);\n+        //clear out the streaming transformation string so the next invocation will rebuild it with the new block size:\n+        this.streamingTransformationString = null;\n+    }\n+\n+    /**\n+     * Returns the transformation string to use with the {@link javax.crypto.Cipher#getInstance} call.  If\n+     * {@code streaming} is {@code true}, a block-cipher transformation string compatible with streaming operations will\n+     * be constructed and cached for re-use later (see the class-level JavaDoc for more on using block ciphers\n+     * for streaming).  If {@code streaming} is {@code false} a normal block-cipher transformation string will\n+     * be constructed and cached for later re-use.\n+     *\n+     * @param streaming if the transformation string is going to be used for a Cipher performing stream-based encryption or not.\n+     * @return the transformation string\n+     */\n+    protected String getTransformationString(boolean streaming) {\n+        if (streaming) {\n+            if (this.streamingTransformationString == null) {\n+                this.streamingTransformationString = buildStreamingTransformationString();\n+            }\n+            return this.streamingTransformationString;\n+        } else {\n+            if (this.transformationString == null) {\n+                this.transformationString = buildTransformationString();\n+            }\n+            return this.transformationString;\n+        }\n+    }\n+\n+    private String buildTransformationString() {\n+        return buildTransformationString(getModeName(), getPaddingSchemeName(), getBlockSize());\n+    }\n+\n+    private String buildStreamingTransformationString() {\n+        return buildTransformationString(getStreamingModeName(), getStreamingPaddingSchemeName(), getStreamingBlockSize());\n+    }\n+\n+    private String buildTransformationString(String modeName, String paddingSchemeName, int blockSize) {\n+        StringBuilder sb = new StringBuilder(getAlgorithmName());\n+        if (StringUtils.hasText(modeName)) {\n+            sb.append(TRANSFORMATION_STRING_DELIMITER).append(modeName);\n+        }\n+        if (blockSize > 0) {\n+            sb.append(blockSize);\n+        }\n+        if (StringUtils.hasText(paddingSchemeName)) {\n+            sb.append(TRANSFORMATION_STRING_DELIMITER).append(paddingSchemeName);\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Returns {@code true} if the specified cipher operation mode name supports initialization vectors,\n+     * {@code false} otherwise.\n+     *\n+     * @param modeName the raw text name of the mode of operation\n+     * @return {@code true} if the specified cipher operation mode name supports initialization vectors,\n+     *         {@code false} otherwise.\n+     */\n+    private boolean isModeInitializationVectorCompatible(String modeName) {\n+        return modeName != null &&\n+                !modeName.equalsIgnoreCase(OperationMode.ECB.name()) &&\n+                !modeName.equalsIgnoreCase(OperationMode.NONE.name());\n+    }\n+\n+    /**\n+     * Overrides the parent implementation to ensure initialization vectors are always generated if streaming is\n+     * enabled (block ciphers <em>must</em> use initialization vectors if they are to be used as a stream cipher).  If\n+     * not being used as a stream cipher, then the value is computed based on whether or not the currently configured\n+     * {@link #getModeName modeName} is compatible with initialization vectors as well as the result of the configured\n+     * {@link #setGenerateInitializationVectors(boolean) generateInitializationVectors} value.\n+     *\n+     * @param streaming whether or not streaming is being performed\n+     * @return {@code true} if streaming or a value computed based on if the currently configured mode is compatible\n+     *         with initialization vectors.\n+     */\n+    @Override\n+    protected boolean isGenerateInitializationVectors(boolean streaming) {\n+        return streaming || super.isGenerateInitializationVectors() && isModeInitializationVectorCompatible(getModeName());\n+    }\n+\n+    @Override\n+    protected byte[] generateInitializationVector(boolean streaming) {\n+        if (streaming) {\n+            String streamingModeName = getStreamingModeName();\n+            if (!isModeInitializationVectorCompatible(streamingModeName)) {\n+                String msg = \"streamingMode attribute value [\" + streamingModeName + \"] does not support \" +\n+                        \"Initialization Vectors.  Ensure the streamingMode value represents an operation mode \" +\n+                        \"that is compatible with initialization vectors.\";\n+                throw new IllegalStateException(msg);\n+            }\n+        } else {\n+            String modeName = getModeName();\n+            if (!isModeInitializationVectorCompatible(modeName)) {\n+                String msg = \"mode attribute value [\" + modeName + \"] does not support \" +\n+                        \"Initialization Vectors.  Ensure the mode value represents an operation mode \" +\n+                        \"that is compatible with initialization vectors.\";\n+                throw new IllegalStateException(msg);\n+            }\n+        }\n+        return super.generateInitializationVector(streaming);\n+    }\n+}"
        },
        {
            "sha": "67437c11a2a8f52678242846b58f3c221f8b4241",
            "filename": "core/src/main/java/org/apache/shiro/crypto/JcaCipherService.java",
            "status": "added",
            "additions": 605,
            "deletions": 0,
            "changes": 605,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FJcaCipherService.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FJcaCipherService.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FJcaCipherService.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,605 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.util.ByteSource;\n+import org.apache.shiro.util.SimpleByteSource;\n+import org.apache.shiro.util.StringUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import javax.crypto.CipherInputStream;\n+import javax.crypto.spec.IvParameterSpec;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.OutputStream;\n+import java.security.Key;\n+import java.security.SecureRandom;\n+import java.security.spec.AlgorithmParameterSpec;\n+\n+/**\n+ * Abstract {@code CipherService} implementation utilizing Java's JCA APIs.\n+ * <h2>Auto-generated Initialization Vectors</h2>\n+ * Shiro does something by default for all of its {@code CipherService} implementations that the JCA\n+ * {@link javax.crypto.Cipher Cipher} does not do:  by default,\n+ * <a href=\"http://en.wikipedia.org/wiki/Initialization_vector\">initialization vector</a>s are automatically randomly\n+ * generated and prepended to encrypted data before returning from the {@code encrypt} methods.  That is, the returned\n+ * byte array or {@code OutputStream} is actually a concatenation of an initialization vector byte array plus the actual\n+ * encrypted data byte array.  The {@code decrypt} methods in turn know to read this prepended initialization vector\n+ * before decrypting the real data that follows.\n+ * <p/>\n+ * This is highly desirable because initialization vectors guarantee that, for a key and any plaintext, the encrypted\n+ * output will always be different <em>even if you call {@code encrypt} multiple times with the exact same arguments</em>.\n+ * This is essential in cryptography to ensure that data patterns cannot be identified across multiple input sources\n+ * that are the same or similar.\n+ * <p/>\n+ * You can turn off this behavior by setting the\n+ * {@link #setGenerateInitializationVectors(boolean) generateInitializationVectors} property to {@code false}, but it\n+ * is highly recommended that you do not do this unless you have a very good reason to do so, since you would be losing\n+ * a critical security feature.\n+ * <h3>Initialization Vector Size</h3>\n+ * This implementation defaults the {@link #setInitializationVectorSize(int) initializationVectorSize} attribute to\n+ * {@code 128} bits, a fairly common size.  Initialization vector sizes are very algorithm specific however, so subclass\n+ * implementations will often override this value in their constructor if necessary.\n+ * <p/>\n+ * Also note that {@code initializationVectorSize} values are specified in the number of\n+ * bits (not bytes!) to match common references in most cryptography documentation.  In practice though, initialization\n+ * vectors are always specified as a byte array, so ensure that if you set this property, that the value is a multiple\n+ * of {@code 8} to ensure that the IV can be correctly represented as a byte array (the\n+ * {@link #setInitializationVectorSize(int) setInitializationVectorSize} mutator method enforces this).\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public abstract class JcaCipherService implements CipherService {\n+\n+    /**\n+     * Internal private log instance.\n+     */\n+    private static final Logger log = LoggerFactory.getLogger(JcaCipherService.class);\n+\n+    /**\n+     * Default key size (in bits) for generated keys.\n+     */\n+    private static final int DEFAULT_KEY_SIZE = 128;\n+\n+    /**\n+     * Default size of the internal buffer (in bytes) used to transfer data between streams during stream operations\n+     */\n+    private static final int DEFAULT_STREAMING_BUFFER_SIZE = 512;\n+\n+    private static final int BITS_PER_BYTE = 8;\n+\n+    /**\n+     * Default SecureRandom algorithm name to use when acquiring the SecureRandom instance.\n+     */\n+    private static final String RANDOM_NUM_GENERATOR_ALGORITHM_NAME = \"SHA1PRNG\";\n+\n+    /**\n+     * The name of the cipher algorithm to use for all encryption, decryption, and key operations\n+     */\n+    private String algorithmName;\n+\n+    /**\n+     * The size in bits (not bytes) of generated cipher keys\n+     */\n+    private int keySize;\n+\n+    /**\n+     * The size of the internal buffer (in bytes) used to transfer data from one stream to another during stream operations\n+     */\n+    private int streamingBufferSize;\n+\n+    private boolean generateInitializationVectors;\n+    private int initializationVectorSize;\n+\n+\n+    private SecureRandom secureRandom;\n+\n+    /**\n+     * Creates a new {@code JcaCipherService} instance which will use the specified cipher {@code algorithmName}\n+     * for all encryption, decryption, and key operations.  Also, the following defaults are set:\n+     * <ul>\n+     * <li>{@link #setKeySize keySize} = 128 bits</li>\n+     * <li>{@link #setInitializationVectorSize(int) initializationVectorSize} = 128 bits</li>\n+     * <li>{@link #setStreamingBufferSize(int) streamingBufferSize} = 512 bytes</li>\n+     * </ul>\n+     *\n+     * @param algorithmName the name of the cipher algorithm to use for all encryption, decryption, and key operations\n+     */\n+    protected JcaCipherService(String algorithmName) {\n+        if (!StringUtils.hasText(algorithmName)) {\n+            throw new IllegalArgumentException(\"algorithmName argument cannot be null or empty.\");\n+        }\n+        this.algorithmName = algorithmName;\n+        this.keySize = DEFAULT_KEY_SIZE;\n+        this.initializationVectorSize = DEFAULT_KEY_SIZE; //default to same size as the key size (a common algorithm practice)\n+        this.streamingBufferSize = DEFAULT_STREAMING_BUFFER_SIZE;\n+        this.generateInitializationVectors = true;\n+    }\n+\n+    /**\n+     * Returns the cipher algorithm name that will be used for all encryption, decryption, and key operations (for\n+     * example, 'AES', 'Blowfish', 'RSA', 'DSA', 'TripleDES', etc).\n+     *\n+     * @return the cipher algorithm name that will be used for all encryption, decryption, and key operations\n+     */\n+    public String getAlgorithmName() {\n+        return algorithmName;\n+    }\n+\n+    /**\n+     * Returns the size in bits (not bytes) of generated cipher keys.\n+     *\n+     * @return the size in bits (not bytes) of generated cipher keys.\n+     */\n+    public int getKeySize() {\n+        return keySize;\n+    }\n+\n+    /**\n+     * Sets the size in bits (not bytes) of generated cipher keys.\n+     *\n+     * @param keySize the size in bits (not bytes) of generated cipher keys.\n+     */\n+    public void setKeySize(int keySize) {\n+        this.keySize = keySize;\n+    }\n+\n+    public boolean isGenerateInitializationVectors() {\n+        return generateInitializationVectors;\n+    }\n+\n+    public void setGenerateInitializationVectors(boolean generateInitializationVectors) {\n+        this.generateInitializationVectors = generateInitializationVectors;\n+    }\n+\n+    /**\n+     * Returns the algorithm-specific size in bits of generated initialization vectors.\n+     *\n+     * @return the algorithm-specific size in bits of generated initialization vectors.\n+     */\n+    public int getInitializationVectorSize() {\n+        return initializationVectorSize;\n+    }\n+\n+    /**\n+     * Sets the algorithm-specific initialization vector size in bits (not bytes!) to be used when generating\n+     * initialization vectors.  The  value must be a multiple of {@code 8} to ensure that the IV can be represented\n+     * as a byte array.\n+     *\n+     * @param initializationVectorSize the size in bits (not bytes) of generated initialization vectors.\n+     * @throws IllegalArgumentException if the size is not a multiple of {@code 8}.\n+     */\n+    public void setInitializationVectorSize(int initializationVectorSize) throws IllegalArgumentException {\n+        if (initializationVectorSize % BITS_PER_BYTE != 0) {\n+            String msg = \"Initialization vector sizes are specified in bits, but must be a multiple of 8 so they \" +\n+                    \"can be easily represented as a byte array.\";\n+            throw new IllegalArgumentException(msg);\n+        }\n+        this.initializationVectorSize = initializationVectorSize;\n+    }\n+\n+    protected boolean isGenerateInitializationVectors(boolean streaming) {\n+        return isGenerateInitializationVectors();\n+    }\n+\n+    /**\n+     * Returns the size in bytes of the internal buffer used to transfer data from one stream to another during stream\n+     * operations ({@link #encrypt(java.io.InputStream, java.io.OutputStream, byte[])} and\n+     * {@link #decrypt(java.io.InputStream, java.io.OutputStream, byte[])}).\n+     * <p/>\n+     * Default size is {@code 512} bytes.\n+     *\n+     * @return the size of the internal buffer used to transfer data from one stream to another during stream\n+     *         operations\n+     */\n+    public int getStreamingBufferSize() {\n+        return streamingBufferSize;\n+    }\n+\n+    /**\n+     * Sets the size in bytes of the internal buffer used to transfer data from one stream to another during stream\n+     * operations ({@link #encrypt(java.io.InputStream, java.io.OutputStream, byte[])} and\n+     * {@link #decrypt(java.io.InputStream, java.io.OutputStream, byte[])}).\n+     * <p/>\n+     * Default size is {@code 512} bytes.\n+     *\n+     * @param streamingBufferSize the size of the internal buffer used to transfer data from one stream to another\n+     *                            during stream operations\n+     */\n+    public void setStreamingBufferSize(int streamingBufferSize) {\n+        this.streamingBufferSize = streamingBufferSize;\n+    }\n+\n+    /**\n+     * Returns a source of randomness for encryption operations.  If one is not configured, and the underlying\n+     * algorithm needs one, the JDK {@code SHA1PRNG} instance will be used by default.\n+     *\n+     * @return a source of randomness for encryption operations.  If one is not configured, and the underlying\n+     *         algorithm needs one, the JDK {@code SHA1PRNG} instance will be used by default.\n+     */\n+    public SecureRandom getSecureRandom() {\n+        return secureRandom;\n+    }\n+\n+    /**\n+     * Sets a source of randomness for encryption operations.  If one is not configured, and the underlying\n+     * algorithm needs one, the JDK {@code SHA1PRNG} instance will be used by default.\n+     *\n+     * @param secureRandom a source of randomness for encryption operations.  If one is not configured, and the\n+     *                     underlying algorithm needs one, the JDK {@code SHA1PRNG} instance will be used by default.\n+     */\n+    public void setSecureRandom(SecureRandom secureRandom) {\n+        this.secureRandom = secureRandom;\n+    }\n+\n+    protected static SecureRandom getDefaultSecureRandom() {\n+        try {\n+            return java.security.SecureRandom.getInstance(RANDOM_NUM_GENERATOR_ALGORITHM_NAME);\n+        } catch (java.security.NoSuchAlgorithmException e) {\n+            log.debug(\"The SecureRandom SHA1PRNG algorithm is not available on the current platform.  Using the \" +\n+                    \"platform's default SecureRandom algorithm.\", e);\n+            return new java.security.SecureRandom();\n+        }\n+    }\n+\n+    protected SecureRandom ensureSecureRandom() {\n+        SecureRandom random = getSecureRandom();\n+        if (random == null) {\n+            random = getDefaultSecureRandom();\n+        }\n+        return random;\n+    }\n+\n+    /**\n+     * Returns the transformation string to use with the {@link javax.crypto.Cipher#getInstance} invocation when\n+     * creating a new {@code Cipher} instance.  This default implementation always returns\n+     * {@link #getAlgorithmName() getAlgorithmName()}.  Block cipher implementations will want to override this method\n+     * to support appending cipher operation modes and padding schemes.\n+     *\n+     * @param streaming if the transformation string is going to be used for a Cipher for stream-based encryption or not.\n+     * @return the transformation string to use with the {@link javax.crypto.Cipher#getInstance} invocation when\n+     *         creating a new {@code Cipher} instance.\n+     */\n+    protected String getTransformationString(boolean streaming) {\n+        return getAlgorithmName();\n+    }\n+\n+    protected byte[] generateInitializationVector(boolean streaming) {\n+        int size = getInitializationVectorSize();\n+        if (size <= 0) {\n+            String msg = \"initializationVectorSize property must be greater than zero.  This number is \" +\n+                    \"typically set in the \" + CipherService.class.getSimpleName() + \" subclass constructor.  \" +\n+                    \"Also check your configuration to ensure that if you are setting a value, it is positive.\";\n+            throw new IllegalStateException(msg);\n+        }\n+        if (size % BITS_PER_BYTE != 0) {\n+            String msg = \"initializationVectorSize property must be a multiple of 8 to represent as a byte array.\";\n+            throw new IllegalStateException(msg);\n+        }\n+        int sizeInBytes = size / BITS_PER_BYTE;\n+        byte[] ivBytes = new byte[sizeInBytes];\n+        SecureRandom random = ensureSecureRandom();\n+        random.nextBytes(ivBytes);\n+        return ivBytes;\n+    }\n+\n+    public ByteSource encrypt(byte[] plaintext, byte[] key) {\n+        byte[] ivBytes = null;\n+        boolean generate = isGenerateInitializationVectors(false);\n+        if (generate) {\n+            ivBytes = generateInitializationVector(false);\n+            if (ivBytes == null || ivBytes.length == 0) {\n+                throw new IllegalStateException(\"Initialization vector generation is enabled - generated vector\" +\n+                        \"cannot be null or empty.\");\n+            }\n+        }\n+        return encrypt(plaintext, key, ivBytes, generate);\n+    }\n+\n+    private ByteSource encrypt(byte[] plaintext, byte[] key, byte[] iv, boolean prependIv) throws CryptoException {\n+\n+        final int MODE = javax.crypto.Cipher.ENCRYPT_MODE;\n+\n+        byte[] output;\n+\n+        if (prependIv && iv != null && iv.length > 0) {\n+\n+            byte[] encrypted = crypt(plaintext, key, iv, MODE);\n+\n+            output = new byte[iv.length + encrypted.length];\n+\n+            //now copy the iv bytes + encrypted bytes into one output array:\n+\n+            // iv bytes:\n+            System.arraycopy(iv, 0, output, 0, iv.length);\n+\n+            // + encrypted bytes:\n+            System.arraycopy(encrypted, 0, output, iv.length, encrypted.length);\n+        } else {\n+            output = crypt(plaintext, key, iv, MODE);\n+        }\n+\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Incoming plaintext of size \" + (plaintext != null ? plaintext.length : 0) + \".  Ciphertext \" +\n+                    \"byte array is size \" + (output != null ? output.length : 0));\n+        }\n+\n+        return new SimpleByteSource(output);\n+\n+    }\n+\n+    public ByteSource decrypt(byte[] ciphertext, byte[] key) throws CryptoException {\n+\n+        byte[] encrypted = ciphertext;\n+\n+        //No IV, check if we need to read the IV from the stream:\n+        byte[] iv = null;\n+\n+        if (isGenerateInitializationVectors(false)) {\n+            try {\n+                //We are generating IVs, so the ciphertext argument array is not actually 100% cipher text.  Instead, it\n+                //is:\n+                // - the first N bytes is the initialization vector, where N equals the value of the\n+                // 'initializationVectorSize' attribute.\n+                // - the remaining bytes in the method argument (arg.length - N) is the real cipher text.\n+\n+                //So we need to chunk the method argument into its constituent parts to find the IV and then use\n+                //the IV to decrypt the real ciphertext:\n+\n+                int ivSize = getInitializationVectorSize();\n+                int ivByteSize = ivSize / BITS_PER_BYTE;\n+\n+                //now we know how large the iv is, so extract the iv bytes:\n+                iv = new byte[ivByteSize];\n+                System.arraycopy(ciphertext, 0, iv, 0, ivByteSize);\n+\n+                //remaining data is the actual encrypted ciphertext.  Isolate it:\n+                int encryptedSize = ciphertext.length - ivByteSize;\n+                encrypted = new byte[encryptedSize];\n+                System.arraycopy(ciphertext, ivByteSize, encrypted, 0, encryptedSize);\n+            } catch (Exception e) {\n+                String msg = \"Unable to correctly extract the Initialization Vector or ciphertext.\";\n+                throw new CryptoException(msg, e);\n+            }\n+        }\n+\n+        return decrypt(encrypted, key, iv);\n+    }\n+\n+    private ByteSource decrypt(byte[] ciphertext, byte[] key, byte[] iv) throws CryptoException {\n+        if (log.isTraceEnabled()) {\n+            log.trace(\"Attempting to decrypt incoming byte array of length \" +\n+                    (ciphertext != null ? ciphertext.length : 0));\n+        }\n+        byte[] decrypted = crypt(ciphertext, key, iv, javax.crypto.Cipher.DECRYPT_MODE);\n+        return decrypted == null ? null : new SimpleByteSource(decrypted);\n+    }\n+\n+    /**\n+     * Returns a new {@link javax.crypto.Cipher Cipher} instance to use for encryption/decryption operations.  The\n+     * Cipher's {@code transformationString} for the {@code Cipher}.{@link javax.crypto.Cipher#getInstance getInstance}\n+     * call is obtaind via the {@link #getTransformationString(boolean) getTransformationString} method.\n+     *\n+     * @param streaming {@code true} if the cipher instance will be used as a stream cipher, {@code false} if it will be\n+     *                  used as a block cipher.\n+     * @return a new JDK {@code Cipher} instance.\n+     * @throws CryptoException if a new Cipher instance cannot be constructed based on the\n+     *                         {@link #getTransformationString(boolean) getTransformationString} value.\n+     */\n+    private javax.crypto.Cipher newCipherInstance(boolean streaming) throws CryptoException {\n+        String transformationString = getTransformationString(streaming);\n+        try {\n+            return javax.crypto.Cipher.getInstance(transformationString);\n+        } catch (Exception e) {\n+            String msg = \"Unable to acquire a Java JCA Cipher instance using \" +\n+                    javax.crypto.Cipher.class.getName() + \".getInstance( \\\"\" + transformationString + \"\\\" ). \" +\n+                    getAlgorithmName() + \" under this configuration is required for the \" +\n+                    getClass().getName() + \" instance to function.\";\n+            throw new CryptoException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * Functions as follows:\n+     * <ol>\n+     * <li>Creates a {@link #newCipherInstance(boolean) new JDK cipher instance}</li>\n+     * <li>Converts the specified key bytes into an {@link #getAlgorithmName() algorithm}-compatible JDK\n+     * {@link Key key} instance</li>\n+     * <li>{@link #init(javax.crypto.Cipher, int, java.security.Key, AlgorithmParameterSpec, SecureRandom) Initializes}\n+     * the JDK cipher instance with the JDK key</li>\n+     * <li>Calls the {@link #crypt(javax.crypto.Cipher, byte[]) crypt(cipher,bytes)} method to either encrypt or\n+     * decrypt the data based on the specified Cipher behavior mode\n+     * ({@link javax.crypto.Cipher#ENCRYPT_MODE Cipher.ENCRYPT_MODE} or\n+     * {@link javax.crypto.Cipher#DECRYPT_MODE Cipher.DECRYPT_MODE})</li>\n+     * </ol>\n+     *\n+     * @param bytes the bytes to crypt\n+     * @param key   the key to use to perform the encryption or decryption.\n+     * @param iv    the initialization vector to use for the crypt operation (optional, may be {@code null}).\n+     * @param mode  the JDK Cipher behavior mode (Cipher.ENCRYPT_MODE or Cipher.DECRYPT_MODE).\n+     * @return the resulting crypted byte array\n+     * @throws IllegalArgumentException if {@code bytes} are null or empty.\n+     * @throws CryptoException          if Cipher initialization or the crypt operation fails\n+     */\n+    private byte[] crypt(byte[] bytes, byte[] key, byte[] iv, int mode) throws IllegalArgumentException, CryptoException {\n+        if (key == null || key.length == 0) {\n+            throw new IllegalArgumentException(\"key argument cannot be null or empty.\");\n+        }\n+        javax.crypto.Cipher cipher = initNewCipher(mode, key, iv, false);\n+        return crypt(cipher, bytes);\n+    }\n+\n+    /**\n+     * Calls the {@link javax.crypto.Cipher#doFinal(byte[]) doFinal(bytes)} method, propagating any exception that\n+     * might arise in an {@link CryptoException}\n+     *\n+     * @param cipher the JDK Cipher to finalize (perform the actual cryption)\n+     * @param bytes  the bytes to crypt\n+     * @return the resulting crypted byte array.\n+     * @throws CryptoException if there is an illegal block size or bad padding\n+     */\n+    private byte[] crypt(javax.crypto.Cipher cipher, byte[] bytes) throws CryptoException {\n+        try {\n+            return cipher.doFinal(bytes);\n+        } catch (Exception e) {\n+            String msg = \"Unable to execute 'doFinal' with cipher instance [\" + cipher + \"].\";\n+            throw new CryptoException(msg, e);\n+        }\n+    }\n+\n+    /**\n+     * Initializes the JDK Cipher with the specified mode and key.  This is primarily a utility method to catch any\n+     * potential {@link java.security.InvalidKeyException InvalidKeyException} that might arise.\n+     *\n+     * @param cipher the JDK Cipher to {@link javax.crypto.Cipher#init(int, java.security.Key) init}.\n+     * @param mode   the Cipher mode\n+     * @param key    the Cipher's Key\n+     * @param spec   the JDK AlgorithmParameterSpec for cipher initialization (optional, may be null).\n+     * @param random the SecureRandom to use for cipher initialization (optional, may be null).\n+     * @throws CryptoException if the key is invalid\n+     */\n+    private void init(javax.crypto.Cipher cipher, int mode, java.security.Key key,\n+                      AlgorithmParameterSpec spec, SecureRandom random) throws CryptoException {\n+        try {\n+            if (random != null) {\n+                if (spec != null) {\n+                    cipher.init(mode, key, spec, random);\n+                } else {\n+                    cipher.init(mode, key, random);\n+                }\n+            } else {\n+                if (spec != null) {\n+                    cipher.init(mode, key, spec);\n+                } else {\n+                    cipher.init(mode, key);\n+                }\n+            }\n+        } catch (Exception e) {\n+            String msg = \"Unable to init cipher instance.\";\n+            throw new CryptoException(msg, e);\n+        }\n+    }\n+\n+\n+    public void encrypt(InputStream in, OutputStream out, byte[] key) throws CryptoException {\n+        byte[] iv = null;\n+        boolean generate = isGenerateInitializationVectors(true);\n+        if (generate) {\n+            iv = generateInitializationVector(true);\n+            if (iv == null || iv.length == 0) {\n+                throw new IllegalStateException(\"Initialization vector generation is enabled - generated vector\" +\n+                        \"cannot be null or empty.\");\n+            }\n+        }\n+        encrypt(in, out, key, iv, generate);\n+    }\n+\n+    private void encrypt(InputStream in, OutputStream out, byte[] key, byte[] iv, boolean prependIv) throws CryptoException {\n+        if (prependIv && iv != null && iv.length > 0) {\n+            try {\n+                //first write the IV:\n+                out.write(iv);\n+            } catch (IOException e) {\n+                throw new CryptoException(e);\n+            }\n+        }\n+\n+        crypt(in, out, key, iv, javax.crypto.Cipher.ENCRYPT_MODE);\n+    }\n+\n+    public void decrypt(InputStream in, OutputStream out, byte[] key) throws CryptoException {\n+        decrypt(in, out, key, isGenerateInitializationVectors(true));\n+    }\n+\n+    private void decrypt(InputStream in, OutputStream out, byte[] key, boolean ivPrepended) throws CryptoException {\n+\n+        byte[] iv = null;\n+        //No Initialization Vector provided as a method argument - check if we need to read the IV from the stream:\n+        if (ivPrepended) {\n+            //we are generating IVs, so we need to read the previously-generated IV from the stream before\n+            //we decrypt the rest of the stream (we need the IV to decrypt):\n+            int ivSize = getInitializationVectorSize();\n+            int ivByteSize = ivSize / BITS_PER_BYTE;\n+            iv = new byte[ivByteSize];\n+            int read;\n+\n+            try {\n+                read = in.read(iv);\n+            } catch (IOException e) {\n+                String msg = \"Unable to correctly read the Initialization Vector from the input stream.\";\n+                throw new CryptoException(msg, e);\n+            }\n+\n+            if (read != ivByteSize) {\n+                throw new CryptoException(\"Unable to read initialization vector bytes from the InputStream.  \" +\n+                        \"This is required when initialization vectors are autogenerated during an encryption \" +\n+                        \"operation.\");\n+            }\n+        }\n+\n+        decrypt(in, out, key, iv);\n+    }\n+\n+    private void decrypt(InputStream in, OutputStream out, byte[] decryptionKey, byte[] iv) throws CryptoException {\n+        crypt(in, out, decryptionKey, iv, javax.crypto.Cipher.DECRYPT_MODE);\n+    }\n+\n+    private void crypt(InputStream in, OutputStream out, byte[] keyBytes, byte[] iv, int cryptMode) throws CryptoException {\n+        if (in == null) {\n+            throw new NullPointerException(\"InputStream argument cannot be null.\");\n+        }\n+        if (out == null) {\n+            throw new NullPointerException(\"OutputStream argument cannot be null.\");\n+        }\n+\n+        javax.crypto.Cipher cipher = initNewCipher(cryptMode, keyBytes, iv, true);\n+\n+        CipherInputStream cis = new CipherInputStream(in, cipher);\n+\n+        int bufSize = getStreamingBufferSize();\n+        byte[] buffer = new byte[bufSize];\n+\n+        int bytesRead;\n+        try {\n+            while ((bytesRead = cis.read(buffer)) != -1) {\n+                out.write(buffer, 0, bytesRead);\n+            }\n+        } catch (IOException e) {\n+            throw new CryptoException(e);\n+        }\n+    }\n+\n+    private javax.crypto.Cipher initNewCipher(int jcaCipherMode, byte[] key, byte[] iv, boolean streaming)\n+            throws CryptoException {\n+\n+        javax.crypto.Cipher cipher = newCipherInstance(streaming);\n+        java.security.Key jdkKey = new SecretKeySpec(key, getAlgorithmName());\n+        IvParameterSpec ivSpec = null;\n+        if (iv != null && iv.length > 0) {\n+            ivSpec = new IvParameterSpec(iv);\n+        }\n+\n+        init(cipher, jcaCipherMode, jdkKey, ivSpec, getSecureRandom());\n+\n+        return cipher;\n+    }\n+}"
        },
        {
            "sha": "abaaeb433da14f809b6d8c953a18054f11b09b7e",
            "filename": "core/src/main/java/org/apache/shiro/crypto/OperationMode.java",
            "status": "added",
            "additions": 144,
            "deletions": 0,
            "changes": 144,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FOperationMode.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FOperationMode.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FOperationMode.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,144 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+/**\n+ * A cipher <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation\">mode of operation</a>\n+ * directs a cipher algorithm how to convert data during the encryption or decryption process.  This enum represents\n+ * all JDK-standard Cipher operation mode names as defined in\n+ * <a href=\"http://java.sun.com/javase/6/docs/technotes/guides/security/StandardNames.html\">JDK Security Standard\n+ * Names</a>, as well as a few more that are well-known and supported by other JCA Providers.\n+ * <p/>\n+ * This {@code enum} exists to provide Shiro end-users type-safety when declaring an operation mode.  This helps reduce\n+ * error by providing a compile-time mechanism to specify a mode and guarantees a valid name that will be\n+ * recognized by an underling JCA Provider.\n+ * <h2>Standard or Non-Standard?</h2>\n+ * All modes listed specify whether they are a JDK standard mode or a non-standard mode.  Standard modes are included\n+ * in all JDK distributions.  Non-standard modes can\n+ * sometimes result in better performance or more secure output, but may not be available on the target JDK\n+ * platform and rely on an external JCA Provider to be installed.  Some providers\n+ * (like <a href=\"http://www.bouncycastle.org\">Bouncy Castle</a>) may support these modes however.\n+ *\n+ * @author Les Hazlewood\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation\">Block Cipher Modes of Operation<a/>\n+ * @since 1.0\n+ */\n+public enum OperationMode {\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher-block_chaining_.28CBC.29\">\n+     * Cipher-block Chaining</a> mode, defined in <a href=\"http://csrc.nist.gov/publications/fips/index.html\">FIPS\n+     * PUB 81</a>.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    CBC,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/CCM_mode\">Counter with CBC-MAC</a> mode<b>*</b> - for block ciphers with\n+     * 128 bit block-size only. See <a href=\"http://www.ietf.org/rfc/rfc3610.txt\">RFC 3610</a> for AES Ciphers.\n+     * This mode has essentially been replaced by the more-capable {@link #EAX EAX} mode.\n+     * <p/>\n+     * <b>*THIS IS A NON-STANDARD MODE</b>. It is not guaranteed to be supported across JDK installations.  You must\n+     * ensure you have a JCA Provider that can support this cipher operation mode.\n+     * <a href=\"http://www.bouncycastle.org\">Bouncy Castle</a> <em>may</em> be one such provider.\n+     */\n+    CCM,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Cipher_feedback_.28CFB.29\">Cipher\n+     * Feedback<a/> mode, defined in <a href=\"http://csrc.nist.gov/publications/fips/index.html\">FIPS PUB 81</a>.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    CFB,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Counter_.28CTR.29\">Counter Mode</a>, aka\n+     * Integer Counter Mode (ICM) and Segmented Integer Counter (SIC).  Counter is a simplification of {@link #OFB OFB}\n+     * and updates the input block as a counter.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    CTR,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/EAX_mode\">EAX Mode</a><b>*</b>.  This is a patent-free but less-effecient\n+     * alternative to {@link #OCB OCB} and has capabilities beyond what {@link #CCM CCM} can provide.\n+     * <p/>\n+     * <b>*THIS IS A NON-STANDARD MODE</b>. It is not guaranteed to be supported across JDK installations.  You must\n+     * ensure you have a JCA Provider that can support this cipher operation mode.\n+     * <a href=\"http://www.bouncycastle.org\">Bouncy Castle</a> <em>may</em> be one such provider.\n+     */\n+    EAX,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Electronic_codebook_.28ECB.29\">Electronic\n+     * Codebook</a> mode, defined in <a href=\"http://csrc.nist.gov/publications/fips/index.html\">FIPS PUB 81</a>.\n+     * ECB is the only mode that does <em>not</em> require an Initialization Vector, but because of this, can be seen\n+     * as less secure than operation modes that require an IV.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    ECB,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/GCM_mode\">Galois/Counter</a> mode<b>*</b> - for block ciphers with 128\n+     * bit block-size only.\n+     * <p/>\n+     * <b>*THIS IS A NON-STANDARD MODE</b>. It is not guaranteed to be supported across JDK installations.  You must\n+     * ensure you have a JCA Provider that can support this cipher operation mode.\n+     * <a href=\"http://www.bouncycastle.org\">Bouncy Castle</a> <em>may</em> be one such provider.\n+     */\n+    GCM,\n+\n+    /**\n+     * No mode.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    NONE,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/OCB_mode\">Offset Codebook</a> mode<b>*</b>.  Parallel mode that provides\n+     * both message privacy and authenticity in a single pass.  This is a very efficient mode, but is patent-encumbered.\n+     * A less-efficient (two pass) alternative is available by using {@link #EAX EAX} mode.\n+     * <p/>\n+     * <b>*THIS IS A NON-STANDARD MODE</b>. It is not guaranteed to be supported across JDK installations.  You must\n+     * ensure you have a JCA Provider that can support this cipher operation mode.\n+     * <a href=\"http://www.bouncycastle.org\">Bouncy Castle</a> <em>may</em> be one such provider.\n+     */\n+    OCB,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Output_feedback_.28OFB.29\">Output\n+     * Feedback</a> mode, defined in <a href=\"http://csrc.nist.gov/publications/fips/index.html\">FIPS PUB 81</a>.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    OFB,\n+\n+    /**\n+     * <a href=\"http://en.wikipedia.org/wiki/Block_cipher_modes_of_operation#Propagating_cipher-block_chaining_.28PCBC.29\">\n+     * Propagating Cipher Block Chaining</a> mode, defined in <a href=\"http://web.mit.edu/kerberos/\">Kerberos version 4<a/>.\n+     * <p/>\n+     * This is a standard JDK operation mode and should be supported by all JDK environments.\n+     */\n+    PCBC\n+}"
        },
        {
            "sha": "0bea636c1f3513697d8b18990839c3f01bc229fe",
            "filename": "core/src/main/java/org/apache/shiro/crypto/PaddingScheme.java",
            "status": "added",
            "additions": 166,
            "deletions": 0,
            "changes": 166,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FPaddingScheme.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FPaddingScheme.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FPaddingScheme.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,166 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+/**\n+ * A {@code CipherPaddingScheme} represents well-known\n+ * <a href=\"http://en.wikipedia.org/wiki/Padding_(cryptography)\">padding schemes</a> supported by JPA providers in a\n+ * type-safe manner.\n+ * <p/>\n+ * When encrypted data is transferred, it is usually desirable to ensure that all 'chunks' transferred are a fixed-length:\n+ * different length blocks might give cryptanalysts clues about what the data might be, among other reasons.  Of course\n+ * not all data will convert to neat fixed-length blocks, so padding schemes are used to 'fill in' (pad) any remaining\n+ * space with unintelligible data.\n+ * <p/>\n+ * Padding schemes can be used in both asymmetric key ciphers as well as symmetric key ciphers (e.g. block ciphers).\n+ * Block-ciphers especially regularly use padding schemes as they are based on the notion of fixed-length block sizes.\n+ *\n+ * @author Les Hazlewood\n+ * @see <a href=\"http://en.wikipedia.org/wiki/Padding_(cryptography)\">Wikipedia: Cryptographic Padding</a>\n+ * @since 1.0\n+ */\n+public enum PaddingScheme {\n+\n+    /**\n+     * No padding.  Useful when the block size is 8 bits for block cipher streaming operations. (Because\n+     * a byte is the most primitive block size, there is nothing to pad).\n+     */\n+    NONE(\"NoPadding\"),\n+\n+    /**\n+     * Padding scheme as defined in the W3C's &quot;XML Encryption Syntax and Processing&quot; document,\n+     * <a href=\"http://www.w3.org/TR/xmlenc-core/#sec-Alg-Block\">Section 5.2 - Block Encryption Algorithms</a>.\n+     */\n+    ISO10126(\"ISO10126Padding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding defined in RSA's <a href=\"http://en.wikipedia.org/wiki/PKCS1\">PKSC#1\n+     * standard</a> (aka <a href=\"http://tools.ietf.org/html/rfc3447\">RFC 3447</a>).\n+     * <p/>\n+     * <b>NOTE:</b> using this padding requires initializing {@link javax.crypto.Cipher Cipher} instances with a\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object which provides the 1) message digest and\n+     * 2) mask generation function to use for the scheme.\n+     * <h3>Convenient Alternatives</h3>\n+     * While using this scheme enables you full customization of the message digest + mask generation function\n+     * combination, it does require the extra burden of providing your own {@code OAEPParameterSpec} object.  This is\n+     * often unnecessary, because most combinations are fairly standard.  These common combinations are pre-defined\n+     * in this enum in the {@code OAEP}* variants.\n+     * <p/>\n+     * If you find that these common combinations still do not meet your needs, then you will need to\n+     * specify your own message digest and mask generation function, either as an {@code OAEPParameterSpec} object\n+     * during Cipher initialization or, maybe more easily, in the scheme name directly.  If you want to use scheme name\n+     * approach, the name format is specified in the\n+     * <a href=\"http://java.sun.com/javase/6/docs/technotes/guides/security/StandardNames.html\">Standard Names</a>\n+     * document in the <code>Cipher Algorithm Padding</code> section.\n+     *\n+     * @see #OAEPWithMd5AndMgf1\n+     * @see #OAEPWithSha1AndMgf1\n+     * @see #OAEPWithSha256AndMgf1\n+     * @see #OAEPWithSha384AndMgf1\n+     * @see #OAEPWithSha512AndMgf1\n+     */\n+    OAEP(\"OAEPPadding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding with {@code MD5} message digest and {@code MGF1} mask generation function.\n+     * <p/>\n+     * This is a convenient pre-defined OAEP padding scheme that embeds the message digest and mask generation function.\n+     * When using this padding scheme, there is no need to init the {@code Cipher} instance with an\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object, as it is already 'built in' to the scheme\n+     * name (unlike the {@link #OAEP OAEP} scheme, which requires a bit more work).\n+     */\n+    OAEPWithMd5AndMgf1(\"OAEPWithMD5AndMGF1Padding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding with {@code SHA-1} message digest and {@code MGF1} mask generation function.\n+     * <p/>\n+     * This is a convenient pre-defined OAEP padding scheme that embeds the message digest and mask generation function.\n+     * When using this padding scheme, there is no need to init the {@code Cipher} instance with an\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object, as it is already 'built in' to the scheme\n+     * name (unlike the {@link #OAEP OAEP} scheme, which requires a bit more work).\n+     */\n+    OAEPWithSha1AndMgf1(\"OAEPWithSHA-1AndMGF1Padding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding with {@code SHA-256} message digest and {@code MGF1} mask generation function.\n+     * <p/>\n+     * This is a convenient pre-defined OAEP padding scheme that embeds the message digest and mask generation function.\n+     * When using this padding scheme, there is no need to init the {@code Cipher} instance with an\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object, as it is already 'built in' to the scheme\n+     * name (unlike the {@link #OAEP OAEP} scheme, which requires a bit more work).\n+     */\n+    OAEPWithSha256AndMgf1(\"OAEPWithSHA-256AndMGF1Padding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding with {@code SHA-384} message digest and {@code MGF1} mask generation function.\n+     * <p/>\n+     * This is a convenient pre-defined OAEP padding scheme that embeds the message digest and mask generation function.\n+     * When using this padding scheme, there is no need to init the {@code Cipher} instance with an\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object, as it is already 'built in' to the scheme\n+     * name (unlike the {@link #OAEP OAEP} scheme, which requires a bit more work).\n+     */\n+    OAEPWithSha384AndMgf1(\"OAEPWithSHA-384AndMGF1Padding\"),\n+\n+    /**\n+     * Optimal Asymmetric Encryption Padding with {@code SHA-512} message digest and {@code MGF1} mask generation function.\n+     * <p/>\n+     * This is a convenient pre-defined OAEP padding scheme that embeds the message digest and mask generation function.\n+     * When using this padding scheme, there is no need to init the {@code Cipher} instance with an\n+     * {@link javax.crypto.spec.OAEPParameterSpec OAEPParameterSpec} object, as it is already 'built in' to the scheme\n+     * name (unlike the {@link #OAEP OAEP} scheme, which requires a bit more work).\n+     */\n+    OAEPWithSha512AndMgf1(\"OAEPWithSHA-512AndMGF1Padding\"),\n+\n+    /**\n+     * Padding scheme used with the {@code RSA} algorithm defined in RSA's\n+     * <a href=\"http://en.wikipedia.org/wiki/PKCS1\">PKSC#1 standard</a> (aka\n+     * <a href=\"http://tools.ietf.org/html/rfc3447\">RFC 3447</a>).\n+     */\n+    PKCS1(\"PKCS1Padding\"),\n+\n+    /**\n+     * Padding scheme defined in RSA's <a href=\"http://www.rsa.com/rsalabs/node.asp?id=2127\">Password-Based\n+     * Cryptography Standard</a>.\n+     */\n+    PKCS5(\"PKCS5Padding\"),\n+\n+    /**\n+     * Padding scheme defined in the <a href=\"http://www.mozilla.org/projects/security/pki/nss/ssl/draft302.txt\">SSL\n+     * 3.0 specification</a>, section <code>5.2.3.2 (CBC block cipher)</code>.\n+     */\n+    SSL3(\"SSL3Padding\");\n+\n+    private final String transformationName;\n+\n+    private PaddingScheme(String transformationName) {\n+        this.transformationName = transformationName;\n+    }\n+\n+    /**\n+     * Returns the actual string name to use when building the {@link javax.crypto.Cipher Cipher}\n+     * {@code transformation string}.\n+     *\n+     * @return the actual string name to use when building the {@link javax.crypto.Cipher Cipher}\n+     *         {@code transformation string}.\n+     * @see javax.crypto.Cipher#getInstance(String)\n+     */\n+    public String getTransformationName() {\n+        return this.transformationName;\n+    }\n+}"
        },
        {
            "sha": "90279c39d8d840927e1ce83086ae6a696381d6de",
            "filename": "core/src/main/java/org/apache/shiro/crypto/hash/AbstractHash.java",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FAbstractHash.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FAbstractHash.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FAbstractHash.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -110,7 +110,8 @@ public AbstractHash(Object source, Object salt) throws CodecException {\n      * {@code hashIterations} times.\n      * <p/>\n      * By default, this class only supports Object method arguments of\n-     * type {@code byte[]}, {@code char[]} and {@code String}.  If either argument is anything other than these\n+     * type {@code byte[]}, {@code char[]}, {@link String}, {@link java.io.File File}, or\n+     * {@link java.io.InputStream InputStream}.  If either argument is anything other than these\n      * types a {@link org.apache.shiro.codec.CodecException CodecException} will be thrown.\n      * <p/>\n      * If you want to be able to hash other object types, or use other salt types, you need to override the"
        },
        {
            "sha": "fbb84afc7cd931af2aa231b3b13f3f05341bb761",
            "filename": "core/src/main/java/org/apache/shiro/crypto/hash/Hash.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FHash.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FHash.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fhash%2FHash.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -19,8 +19,8 @@\n package org.apache.shiro.crypto.hash;\n \n /**\n- * A Cryptoraphic <tt>Hash</tt> represents a one-way conversion algorithm that transforms an input source to an underlying\n- * byte array.\n+ * A Cryptographic {@code Hash} represents a one-way conversion algorithm that transforms an input source to an\n+ * underlying byte array.\n  *\n  * @author Les Hazlewood\n  * @see AbstractHash"
        },
        {
            "sha": "f84853db724b64a9d5355f5eda98b96d69e2853e",
            "filename": "core/src/main/java/org/apache/shiro/crypto/package-info.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fpackage-info.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fpackage-info.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2Fpackage-info.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -20,7 +20,7 @@\n  * Cryptography Cipher and Hashing components that greatly simplify the JDK's cryptography concepts and\n  * add additional convenient behavior.\n  * <p/>\n- * The most important interface in this package is the {@link org.apache.shiro.crypto.Cipher Cipher} interface, which\n- * allows other Shiro components to encrypt and decrypt potentially sensitive data.\n+ * The most important interface in this package is the {@link org.apache.shiro.crypto.CipherService CipherService}\n+ * interface, which allows one to encrypt and decrypt sensitive data.\n  */\n package org.apache.shiro.crypto;"
        },
        {
            "sha": "120df54ce17edc017014ebf5e13bdff4bfdffe60",
            "filename": "core/src/main/java/org/apache/shiro/io/Serializer.java",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fio%2FSerializer.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fio%2FSerializer.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fio%2FSerializer.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -23,17 +23,19 @@\n  * of objects to files, HTTP cookies, or other mechanism.\n  * <p/>\n  * A <code>Serializer</code> should only do conversion, never change the data, such as encoding/decoding or\n- * encryption.  These orthoganal concerns are handled elsewhere by Shiro, for example, via\n- * {@link org.apache.shiro.codec.CodecSupport CodecSupport} and {@link org.apache.shiro.crypto.Cipher Cipher}s.\n- * @param <T> The type of the object being serialized and deserialized.\n+ * encryption.  These orthogonal concerns are handled elsewhere by Shiro, for example, via\n+ * {@link org.apache.shiro.codec.CodecSupport CodecSupport} and {@link org.apache.shiro.crypto.CipherService CipherService}s.\n+ *\n  * @author Les Hazlewood\n+ * @param <T> The type of the object being serialized and deserialized.\n  * @since 0.9\n  */\n public interface Serializer<T> {\n \n     /**\n      * Converts the specified Object into a byte[] array.  This byte[] array must be able to be reconstructed\n      * back into the original Object form via the {@link #deserialize(byte[]) deserialize} method.\n+     *\n      * @param o the Object to convert into a byte[] array.\n      * @return a byte[] array representing the Object's state that can be restored later.\n      * @throws SerializationException if an error occurrs converting the Object into a byte[] array.\n@@ -44,7 +46,7 @@ public interface Serializer<T> {\n      * Converts the specified raw byte[] array back into an original Object form.  This byte[] array is expected to\n      * be the output of a previous {@link #serialize(Object) serialize} method call.\n      *\n-     * @param serialized the raw data resulting from a previous {@link #serialize(Object) serialize} call. \n+     * @param serialized the raw data resulting from a previous {@link #serialize(Object) serialize} call.\n      * @return the Object that was previously serialized into the raw byte[] array.\n      * @throws SerializationException if an error occurrs converting the raw byte[] array back into an Object.\n      */"
        },
        {
            "sha": "9a272f33c4e6f4bfea9cbf8e6ca1ba950eee0102",
            "filename": "core/src/main/java/org/apache/shiro/mgt/AbstractRememberMeManager.java",
            "status": "modified",
            "additions": 114,
            "deletions": 82,
            "changes": 196,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FAbstractRememberMeManager.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FAbstractRememberMeManager.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FAbstractRememberMeManager.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -24,12 +24,13 @@\n import org.apache.shiro.authc.RememberMeAuthenticationToken;\n import org.apache.shiro.codec.Base64;\n import org.apache.shiro.codec.Hex;\n-import org.apache.shiro.crypto.BlowfishCipher;\n-import org.apache.shiro.crypto.Cipher;\n+import org.apache.shiro.crypto.AesCipherService;\n+import org.apache.shiro.crypto.CipherService;\n import org.apache.shiro.io.DefaultSerializer;\n import org.apache.shiro.io.Serializer;\n import org.apache.shiro.subject.PrincipalCollection;\n import org.apache.shiro.subject.Subject;\n+import org.apache.shiro.util.ByteSource;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -38,9 +39,27 @@\n /**\n  * Abstract implementation of the {@code RememberMeManager} interface that handles\n  * {@link #setSerializer(org.apache.shiro.io.Serializer) serialization} and\n- * {@link #setCipher(org.apache.shiro.crypto.Cipher) encryption} of the remembered user identity.\n+ * {@link #setCipherService encryption} of the remembered user identity.\n  * <p/>\n  * The remembered identity storage location and details are left to subclasses.\n+ * <h2>Default encryption key</h2>\n+ * This implementation uses an {@link AesCipherService AesCipherService} for strong encryption by default.  It also\n+ * uses a default generated symmetric key to both encrypt and decrypt data.Shiro's default symmetric block Cipher using the Blowfish algorithm.  As it is a symmetric Cipher, it uses the\n+ * same <tt>Key</tt> to both encrypt and decrypt data, BUT NOTE:\n+ * <p/>\n+ * Because Shiro is an open-source project, if anyone knew that you were using Shiro's default\n+ * {@code key}, they could download/view the source, and with enough effort, reconstruct the {@code key}\n+ * and decode encrypted data at will.\n+ * <p/>\n+ * Of course, this key is only really used to encrypt the remembered {@code PrincipalCollection} which is typically\n+ * a user id or username.  So if you do not consider that sensitive information, and you think the default key still\n+ * makes things 'sufficiently difficult', then you can ignore this issue.\n+ * <p/>\n+ * However, if you do feel this constitutes sensitive information, it is recommended that you provide your own\n+ * {@code key} via the {@link #setCipherKey setCipherKey} method to a key known only to your application,\n+ * guaranteeing that no third party can decrypt your data.  You can generate your own key by calling the\n+ * {@code CipherService}'s {@link org.apache.shiro.crypto.AesCipherService#generateNewKey() generateNewKey} method\n+ * and using that result as the {@link #setCipherKey cipherKey} configuration attribute.\n  *\n  * @author Les Hazlewood\n  * @author Jeremy Haile\n@@ -53,6 +72,17 @@ public abstract class AbstractRememberMeManager implements RememberMeManager {\n      */\n     private static final Logger log = LoggerFactory.getLogger(AbstractRememberMeManager.class);\n \n+    /**\n+     * The following Base64 string was generated by auto-generating an AES Key:\n+     * <pre>\n+     * AesCipherService aes = new AesCipherService();\n+     * byte[] key = aes.generateNewKey().getEncoded();\n+     * String base64 = Base64.encodeToString(key);\n+     * </pre>\n+     * The value of 'base64' was copied-n-pasted here:\n+     */\n+    private static final byte[] DEFAULT_CIPHER_KEY_BYTES = Base64.decode(\"kPH+bIxk5D2deZiIxcaaaA==\");\n+\n     /**\n      * Serializer to use for converting PrincipalCollection instances to/from byte arrays\n      */\n@@ -61,7 +91,7 @@ public abstract class AbstractRememberMeManager implements RememberMeManager {\n     /**\n      * Cipher to use for encrypting/decrypting serialized byte arrays for added security\n      */\n-    private Cipher cipher;\n+    private CipherService cipherService;\n \n     /**\n      * Cipher encryption key to use with the Cipher when encrypting data\n@@ -75,11 +105,12 @@ public abstract class AbstractRememberMeManager implements RememberMeManager {\n \n     /**\n      * Default constructor that initializes a {@link DefaultSerializer} as the {@link #getSerializer() serializer} and\n-     * a {@link BlowfishCipher BlowfishCipher} as the {@link #getCipher() cipher}.\n+     * an {@link AesCipherService} as the {@link #getCipherService() cipherService}.\n      */\n     public AbstractRememberMeManager() {\n         this.serializer = new DefaultSerializer<PrincipalCollection>();\n-        this.cipher = new BlowfishCipher();\n+        this.cipherService = new AesCipherService();\n+        setCipherKey(DEFAULT_CIPHER_KEY_BYTES);\n     }\n \n     /**\n@@ -110,32 +141,32 @@ public void setSerializer(Serializer<PrincipalCollection> serializer) {\n     }\n \n     /**\n-     * Returns the {@code Cipher} to use for encrypting and decrypting serialized identity data to prevent easy\n+     * Returns the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy\n      * inspection of Subject identity data.\n      * <p/>\n-     * Unless overridden by the {@link #setCipher} method, the default instance is a {@link BlowfishCipher}.\n+     * Unless overridden by the {@link #setCipherService} method, the default instance is an {@link AesCipherService}.\n      *\n      * @return the {@code Cipher} to use for encrypting and decrypting serialized identity data to prevent easy\n      *         inspection of Subject identity data\n      */\n-    public Cipher getCipher() {\n-        return cipher;\n+    public CipherService getCipherService() {\n+        return cipherService;\n     }\n \n     /**\n-     * Sets the {@code Cipher} to use for encrypting and decrypting serialized identity data to prevent easy\n+     * Sets the {@code CipherService} to use for encrypting and decrypting serialized identity data to prevent easy\n      * inspection of Subject identity data.\n      * <p/>\n-     * If the cipher is an symmetric cipher (using the same key for both encryption and decryption), you\n+     * If the CipherService is a symmetric CipherService (using the same key for both encryption and decryption), you\n      * should set your key via one of the three following methods:\n      * <ul>\n      * <li>{@link #setCipherKey(byte[])}</li>\n      * <li>{@link #setCipherKeyBase64(String)}, or</li>\n      * <li>{@link #setCipherKeyHex(String)}</li>\n      * </ul>\n      * <p/>\n-     * If the cipher is an asymmetric cipher (different keys for encryption and decryption, such as public/private key\n-     * pairs), you should set your encryption key via one of these methods:\n+     * If the CipherService is an asymmetric CipherService (different keys for encryption and decryption, such as\n+     * public/private key pairs), you should set your encryption key via one of these methods:\n      * <ul>\n      * <li>{@link #setEncryptionCipherKey(byte[])}</li>\n      * <li>{@link #setEncryptionCipherKeyHex(String)}, or</li>\n@@ -148,23 +179,23 @@ public Cipher getCipher() {\n      * <li>{@link #setDecryptionCipherKeyBase64(String)}</li>\n      * </ul>\n      * <p/>\n-     * <b>N.B.</b> Unless overridden by this method, the default Cipher instance is a\n-     * {@link BlowfishCipher}.  Shiro's {@code BlowfishCipher} already has a configured symmetric key to use for\n-     * encryption and decryption, but it is recommended to provide your own for added security.  See the\n-     * {@link BlowfishCipher} class-level JavaDoc for more information and why it might be good to provide your own.\n+     * <b>N.B.</b> Unless overridden by this method, the default CipherService instance is an\n+     * {@link AesCipherService}.  This {@code RememberMeManager} implementation already has a configured symmetric key\n+     * to use for encryption and decryption, but it is recommended to provide your own for added security.  See the\n+     * class-level JavaDoc for more information and why it might be good to provide your own.\n      *\n-     * @param cipher the {@code Cipher} to use for encrypting and decrypting serialized identity data to prevent easy\n-     *               inspection of Subject identity data.\n+     * @param cipherService the {@code CipherService} to use for encrypting and decrypting serialized identity data to\n+     *                      prevent easy inspection of Subject identity data.\n      */\n-    public void setCipher(Cipher cipher) {\n-        this.cipher = cipher;\n+    public void setCipherService(CipherService cipherService) {\n+        this.cipherService = cipherService;\n     }\n \n     /**\n      * Returns the cipher key to use for encryption operations.\n      *\n      * @return the cipher key to use for encryption operations.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public byte[] getEncryptionCipherKey() {\n         return encryptionCipherKey;\n@@ -176,31 +207,31 @@ public byte[] getEncryptionCipherKey() {\n      * {@link #setEncryptionCipherKeyBase64(String) encryptionCipherKeyBase64} methods are probably more convenient.\n      *\n      * @param encryptionCipherKey the encryption key to use for encryption operations.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setEncryptionCipherKey(byte[] encryptionCipherKey) {\n         this.encryptionCipherKey = encryptionCipherKey;\n     }\n \n     /**\n-     * Convenience method that allows configuration of the encryption {@link Cipher cipher} key by specifying a\n+     * Convenience method that allows configuration of the encryption cipher key by specifying a\n      * {@code hex}-encoded string.  The string is {@code hex}-decoded and the resulting byte array is used\n-     * as the {@link #setEncryptionCipherKey(byte[]) encryption cipher key}.\n+     * as the {@link #setEncryptionCipherKey(byte[]) encryptionCipherKey}.\n      *\n      * @param hex hex-encoded encryption cipher key to decode into the raw encryption cipher key bytes.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setEncryptionCipherKeyHex(String hex) {\n         setEncryptionCipherKey(Hex.decode(hex));\n     }\n \n     /**\n-     * Convenience method that allows configuration of the encryption {@link Cipher cipher} key by specifying a\n+     * Convenience method that allows configuration of the encryption cipher key by specifying a\n      * {@code BASE 64}-encoded string.  The string is {@code BASE 64}-decoded and the resulting byte array is used\n-     * as the {@link #setEncryptionCipherKey(byte[]) cipher key}.\n+     * as the {@link #setEncryptionCipherKey(byte[]) encryptionCipherKey}.\n      *\n      * @param base64 base64-encoded encryption cipher key to decode into the raw encryption cipher key bytes\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setEncryptionCipherKeyBase64(String base64) {\n         setEncryptionCipherKey(Base64.decode(base64));\n@@ -210,7 +241,7 @@ public void setEncryptionCipherKeyBase64(String base64) {\n      * Returns the decryption cipher key to use for decryption operations.\n      *\n      * @return the cipher key to use for decryption operations.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public byte[] getDecryptionCipherKey() {\n         return decryptionCipherKey;\n@@ -222,31 +253,31 @@ public byte[] getDecryptionCipherKey() {\n      * {@link #setDecryptionCipherKeyBase64(String) decryptionCipherKeyBase64} methods are probably more convenient.\n      *\n      * @param decryptionCipherKey the decryption key to use for decryption operations.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setDecryptionCipherKey(byte[] decryptionCipherKey) {\n         this.decryptionCipherKey = decryptionCipherKey;\n     }\n \n     /**\n-     * Convenience method that allows configuration of the decryption {@link Cipher cipher} key by specifying a\n+     * Convenience method that allows configuration of the decryption cipher key by specifying a\n      * {@code hex}-encoded string.  The string is {@code hex}-decoded and the resulting byte array is used\n-     * as the {@link #setDecryptionCipherKey(byte[]) decryption cipher key}.\n+     * as the {@link #setDecryptionCipherKey(byte[]) decryptionCipherKey}.\n      *\n      * @param hex hex-encoded decryption cipher key to decode into the raw decryption cipher key bytes.\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setDecryptionCipherKeyHex(String hex) {\n         setDecryptionCipherKey(Hex.decode(hex));\n     }\n \n     /**\n-     * Convenience method that allows configuration of the decryption {@link Cipher cipher} key by specifying a\n+     * Convenience method that allows configuration of the decryption cipher key by specifying a\n      * {@code BASE 64}-encoded string.  The string is {@code BASE 64}-decoded and the resulting byte array is used\n-     * as the {@link #setDecryptionCipherKey(byte[]) cipher key}.\n+     * as the {@link #setDecryptionCipherKey(byte[]) decryptionCipherKey}.\n      *\n      * @param base64 base64-encoded decryption cipher key to decode into the raw decryption cipher key bytes\n-     * @see #setCipher for a description of the various {@code get/set*Key} methods.\n+     * @see #setCipherService for a description of the various {@code get/set*Key} methods.\n      */\n     public void setDecryptionCipherKeyBase64(String base64) {\n         setDecryptionCipherKey(Base64.decode(base64));\n@@ -255,13 +286,13 @@ public void setDecryptionCipherKeyBase64(String base64) {\n     /**\n      * Convenience method that returns the cipher key to use for <em>both</em> encryption and decryption.\n      * <p/>\n-     * <b>N.B.</b> This method can only be called if the underlying {@link #getCipher() cipher} is a symmetric cipher\n-     * which by definition uses the same key for both encryption and decryption.  If using an asymmetric cipher\n-     * (such as a public/private key pair), you cannot use this method, and should instead use the\n+     * <b>N.B.</b> This method can only be called if the underlying {@link #getCipherService() cipherService} is a symmetric\n+     * CipherService which by definition uses the same key for both encryption and decryption.  If using an asymmetric\n+     * CipherService public/private key pair, you cannot use this method, and should instead use the\n      * {@link #getEncryptionCipherKey()} and {@link #getDecryptionCipherKey()} methods individually.\n      * <p/>\n-     * The default {@link BlowfishCipher} instance is a symmetric cipher, so this method can be used if you are using\n-     * the default.\n+     * The default {@link AesCipherService} instance is a symmetric cipher service, so this method can be used if you are\n+     * using the default.\n      *\n      * @return the symmetric cipher key used for both encryption and decryption.\n      */\n@@ -274,13 +305,13 @@ public byte[] getCipherKey() {\n     /**\n      * Convenience method that sets the cipher key to use for <em>both</em> encryption and decryption.\n      * <p/>\n-     * <b>N.B.</b> This method can only be called if the underlying {@link #getCipher() cipher} is a symmetric cipher\n-     * which by definition uses the same key for both encryption and decryption.  If using an asymmetric cipher\n-     * (such as a public/private key pair), you cannot use this method, and should instead use the\n-     * {@link #setEncryptionCipherKey(byte[])} and {@link #setDecryptionCipherKey(byte[])} methods individually.\n+     * <b>N.B.</b> This method can only be called if the underlying {@link #getCipherService() cipherService} is a\n+     * symmetric CipherService?which by definition uses the same key for both encryption and decryption.  If using an\n+     * asymmetric CipherService?(such as a public/private key pair), you cannot use this method, and should instead use\n+     * the {@link #setEncryptionCipherKey(byte[])} and {@link #setDecryptionCipherKey(byte[])} methods individually.\n      * <p/>\n-     * The default {@link BlowfishCipher} instance is a symmetric cipher, so this method can be used if you are using\n-     * the default.\n+     * The default {@link AesCipherService} instance is a symmetric CipherService, so this method can be used if you\n+     * are using the default.\n      *\n      * @param cipherKey the symmetric cipher key to use for both encryption and decryption.\n      */\n@@ -292,18 +323,17 @@ public void setCipherKey(byte[] cipherKey) {\n     }\n \n     /**\n-     * Convenience method that allows configuration of the (symmetric) {@link Cipher cipher} key by specifying a\n+     * Convenience method that allows configuration of the (symmetric) cipher key by specifying a\n      * {@code hex}-encoded string.  The string is {@code hex}-decoded and the resulting byte array is used\n-     * as the {@link #setCipherKey(byte[]) cipher key}.\n+     * as the {@link #setCipherKey(byte[]) cipherKey}.\n      * <p/>\n-     * <b>N.B.</b> This is a convenience method to set <em>both</em> the {@link Cipher} encryption key and the\n-     * decryption key and should only be called if using a symmetric cipher.  If using an asymmetric cipher (such\n-     * as a public/private key pair) you cannot\n-     * call this method and instead should use the {@link #setEncryptionCipherKeyHex(String)} and\n-     * {@link #setDecryptionCipherKeyHex(String)} methods instead.\n+     * <b>N.B.</b> This is a convenience method to set <em>both</em> the {@link CipherService} encryption key and the\n+     * decryption key and should only be called if using a symmetric CipherService.  If using an asymmetric CipherService\n+     * (such as a public/private key pair) you cannot call this method and instead should use the\n+     * {@link #setEncryptionCipherKeyHex(String)} and {@link #setDecryptionCipherKeyHex(String)} methods instead.\n      * <p/>\n-     * The default {@link BlowfishCipher} instance is a symmetric cipher, so this method can be used if you are using\n-     * the default.\n+     * The default {@link AesCipherService} instance is a symmetric CipherService, so this method can be used if you are\n+     * using the default.\n      *\n      * @param hex hex-encoded symmetric cipher key to decode into the raw cipher key bytes.\n      */\n@@ -312,17 +342,17 @@ public void setCipherKeyHex(String hex) {\n     }\n \n     /**\n-     * Convenience method that allows configuration of the (symmetric) {@link Cipher cipher} key by specifying a\n-     * {@code BASE 64}-encoded string.  The string is {@code BASE 64}-decoded and the resulting byte array is used\n-     * as the {@link #setCipherKey(byte[]) cipher key}.\n+     * Convenience method that allows configuration of the (symmetric) cipher key\n+     * by specifying a {@code BASE 64}-encoded string.  The string is {@code BASE 64}-decoded and the resulting byte\n+     * array is used as the {@link #setCipherKey(byte[]) cipherKey}.\n      * <p/>\n-     * <b>N.B.</b> This is a convenience method to set <em>both</em> the {@link Cipher} encryption key and the\n-     * decryption key and should only be called if using a symmetric cipher.  If using an asymmetric cipher, you cannot\n-     * call this method and instead should use the {@link #setEncryptionCipherKeyBase64(String)} and\n-     * {@link #setDecryptionCipherKeyBase64(String)} methods instead.\n+     * <b>N.B.</b> This is a convenience method to set <em>both</em> the {@link CipherService} encryption key and the\n+     * decryption key and should only be called if using a symmetric CipherService.  If using an asymmetric\n+     * CipherService, you cannot call this method and instead should use the {@link #setEncryptionCipherKeyBase64(String)}\n+     * and {@link #setDecryptionCipherKeyBase64(String)} methods instead.\n      * <p/>\n-     * The default {@link BlowfishCipher} instance is a symmetric cipher, so this method can be used if you are using\n-     * the default.\n+     * The default {@link AesCipherService} instance is a symmetric CipherService, so this method can be used if you are\n+     * using the default.\n      *\n      * @param base64 base64-encoded symmetric cipher key to decode into the raw cipher key bytes.\n      */\n@@ -447,7 +477,7 @@ protected void rememberIdentity(Subject subject, PrincipalCollection accountPrin\n      */\n     protected byte[] convertPrincipalsToBytes(PrincipalCollection principals) {\n         byte[] bytes = serialize(principals);\n-        if (getCipher() != null) {\n+        if (getCipherService() != null) {\n             bytes = encrypt(bytes);\n         }\n         return bytes;\n@@ -481,7 +511,7 @@ public PrincipalCollection getRememberedPrincipals(Map subjectContext) {\n         try {\n             byte[] bytes = getRememberedSerializedIdentity(subjectContext);\n             //SHIRO-138 - only call convertBytesToPrincipals if bytes exist:\n-            if ( bytes != null && bytes.length > 0 ) {\n+            if (bytes != null && bytes.length > 0) {\n                 principals = convertBytesToPrincipals(bytes, subjectContext);\n             }\n         } catch (RuntimeException re) {\n@@ -505,16 +535,16 @@ public PrincipalCollection getRememberedPrincipals(Map subjectContext) {\n     protected abstract byte[] getRememberedSerializedIdentity(Map subjectContext);\n \n     /**\n-     * If a {@link #getCipher() cipher} is available, it will be used to first decrypt the byte array.  Then the\n-     * bytes are then {@link #deserialize(byte[]) deserialized} and then returned.\n+     * If a {@link #getCipherService() cipherService} is available, it will be used to first decrypt the byte array.\n+     * Then the bytes are then {@link #deserialize(byte[]) deserialized} and then returned.\n      *\n      * @param bytes          the bytes to decrypt if necessary and then deserialize.\n      * @param subjectContext the contextual data, usually provided by a {@link Subject.Builder} implementation, that\n      *                       is being used to construct a {@link Subject} instance.\n      * @return the de-serialized and possibly decrypted principals\n      */\n     protected PrincipalCollection convertBytesToPrincipals(byte[] bytes, Map subjectContext) {\n-        if (getCipher() != null) {\n+        if (getCipherService() != null) {\n             bytes = decrypt(bytes);\n         }\n         return deserialize(bytes);\n@@ -550,31 +580,33 @@ protected PrincipalCollection onRememberedPrincipalFailure(RuntimeException e, M\n     }\n \n     /**\n-     * Encrypts the byte array by using the configured {@link #getCipher() cipher}.\n+     * Encrypts the byte array by using the configured {@link #getCipherService() cipherService}.\n      *\n      * @param serialized the serialized object byte array to be encrypted\n-     * @return an encrypted byte array returned by the configured {@link #getCipher() cipher}.\n+     * @return an encrypted byte array returned by the configured {@link #getCipherService () cipher}.\n      */\n     protected byte[] encrypt(byte[] serialized) {\n         byte[] value = serialized;\n-        Cipher cipher = getCipher();\n-        if (cipher != null) {\n-            value = cipher.encrypt(serialized, getEncryptionCipherKey());\n+        CipherService cipherService = getCipherService();\n+        if (cipherService != null) {\n+            ByteSource byteSource = cipherService.encrypt(serialized, getEncryptionCipherKey());\n+            value = byteSource.getBytes();\n         }\n         return value;\n     }\n \n     /**\n-     * Decrypts the byte array using the configured {@link #getCipher() cipher}.\n+     * Decrypts the byte array using the configured {@link #getCipherService() cipherService}.\n      *\n      * @param encrypted the encrypted byte array to decrypt\n-     * @return the decrypted byte array returned by the configured {@link #getCipher() cipher}.\n+     * @return the decrypted byte array returned by the configured {@link #getCipherService () cipher}.\n      */\n     protected byte[] decrypt(byte[] encrypted) {\n         byte[] serialized = encrypted;\n-        Cipher cipher = getCipher();\n-        if (cipher != null) {\n-            serialized = cipher.decrypt(encrypted, getDecryptionCipherKey());\n+        CipherService cipherService = getCipherService();\n+        if (cipherService != null) {\n+            ByteSource byteSource = cipherService.decrypt(encrypted, getDecryptionCipherKey());\n+            serialized = byteSource.getBytes();\n         }\n         return serialized;\n     }"
        },
        {
            "sha": "142ce620315bbc5428d193a15d3b804502f4a31a",
            "filename": "core/src/main/java/org/apache/shiro/mgt/DefaultSecurityManager.java",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FDefaultSecurityManager.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FDefaultSecurityManager.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Fmgt%2FDefaultSecurityManager.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -20,7 +20,7 @@\n \n import org.apache.shiro.authc.*;\n import org.apache.shiro.authz.Authorizer;\n-import org.apache.shiro.crypto.Cipher;\n+import org.apache.shiro.crypto.CipherService;\n import org.apache.shiro.realm.Realm;\n import org.apache.shiro.session.InvalidSessionException;\n import org.apache.shiro.session.Session;\n@@ -132,8 +132,8 @@ private AbstractRememberMeManager getRememberMeManagerForCipherAttributes() {\n         return (AbstractRememberMeManager) this.rememberMeManager;\n     }\n \n-    public void setRememberMeCipher(Cipher cipher) {\n-        getRememberMeManagerForCipherAttributes().setCipher(cipher);\n+    public void setRememberMeCipherService(CipherService cipherService) {\n+        getRememberMeManagerForCipherAttributes().setCipherService(cipherService);\n     }\n \n     public void setRememberMeCipherKey(byte[] bytes) {"
        },
        {
            "sha": "a22ae331027d4159f67733a471c2ef8d62322c8c",
            "filename": "core/src/main/java/org/apache/shiro/util/ByteSource.java",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FByteSource.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FByteSource.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FByteSource.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2008 Les Hazlewood\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.shiro.util;\n+\n+/**\n+ * A {@code ByteSource} wraps a byte array and provides additional encoding operations.\n+ *\n+ * @author Les Hazlewood\n+ * @since 1.0\n+ */\n+public interface ByteSource {\n+\n+    public byte[] getBytes();\n+\n+    public String toHex();\n+\n+    public String toBase64();\n+}"
        },
        {
            "sha": "cadd990ede8124ce76cc6e12bdb9eb1f65f6644d",
            "filename": "core/src/main/java/org/apache/shiro/util/SimpleByteSource.java",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FSimpleByteSource.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FSimpleByteSource.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fshiro%2Futil%2FSimpleByteSource.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,67 @@\n+/*\n+ * Copyright 2008 Les Hazlewood\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.shiro.util;\n+\n+import org.apache.shiro.codec.Base64;\n+import org.apache.shiro.codec.Hex;\n+\n+import java.util.Arrays;\n+\n+/**\n+ * TODO - Class JavaDoc\n+ *\n+ * @author Les Hazlewood\n+ * @since Apr 12, 2010 2:35:19 PM\n+ */\n+public class SimpleByteSource implements ByteSource {\n+\n+    private final byte[] bytes;\n+\n+    public SimpleByteSource(byte[] bytes) {\n+        this.bytes = bytes;\n+    }\n+\n+    public byte[] getBytes() {\n+        return this.bytes;\n+    }\n+\n+    public String toHex() {\n+        return Hex.encodeToString(getBytes());\n+    }\n+\n+    public String toBase64() {\n+        return Base64.encodeToString(getBytes());\n+    }\n+\n+    public String toString() {\n+        return toBase64();\n+    }\n+\n+    public int hashCode() {\n+        return toBase64().hashCode();\n+    }\n+\n+    public boolean equals(Object o) {\n+        if (o == this) {\n+            return true;\n+        }\n+        if (o instanceof SimpleByteSource) {\n+            SimpleByteSource bs = (SimpleByteSource) o;\n+            return Arrays.equals(getBytes(), bs.getBytes());\n+        }\n+        return false;\n+    }\n+}"
        },
        {
            "sha": "215b5c31251cb05a6a132d89672610edba0aa96e",
            "filename": "core/src/test/java/org/apache/shiro/crypto/AesCipherServiceTest.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherServiceTest.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherServiceTest.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FAesCipherServiceTest.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.codec.CodecSupport;\n+import org.apache.shiro.util.ByteSource;\n+import org.junit.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import static junit.framework.Assert.assertTrue;\n+\n+/**\n+ * Test class for the AesCipherService class.\n+ *\n+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)\n+ * @since 1.0\n+ */\n+public class AesCipherServiceTest {\n+\n+    private static final String[] PLAINTEXTS = new String[]{\n+            \"Hello, this is a test.\",\n+            \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n+    };\n+\n+    @Test\n+    public void testBlockOperations() {\n+        AesCipherService aes = new AesCipherService();\n+\n+        byte[] key = aes.generateNewKey().getEncoded();\n+\n+        for (String plain : PLAINTEXTS) {\n+            byte[] plaintext = CodecSupport.toBytes(plain);\n+            ByteSource ciphertext = aes.encrypt(plaintext, key);\n+            ByteSource decrypted = aes.decrypt(ciphertext.getBytes(), key);\n+            assertTrue(Arrays.equals(plaintext, decrypted.getBytes()));\n+        }\n+    }\n+\n+    @Test\n+    public void testStreamingOperations() {\n+\n+        AesCipherService cipher = new AesCipherService();\n+        byte[] key = cipher.generateNewKey().getEncoded();\n+\n+        for (String plain : PLAINTEXTS) {\n+            byte[] plaintext = CodecSupport.toBytes(plain);\n+            InputStream plainIn = new ByteArrayInputStream(plaintext);\n+            ByteArrayOutputStream cipherOut = new ByteArrayOutputStream();\n+            cipher.encrypt(plainIn, cipherOut, key);\n+\n+            byte[] ciphertext = cipherOut.toByteArray();\n+            InputStream cipherIn = new ByteArrayInputStream(ciphertext);\n+            ByteArrayOutputStream plainOut = new ByteArrayOutputStream();\n+            cipher.decrypt(cipherIn, plainOut, key);\n+\n+            byte[] decrypted = plainOut.toByteArray();\n+            assertTrue(Arrays.equals(plaintext, decrypted));\n+        }\n+    }\n+}"
        },
        {
            "sha": "6889846f83e93152c366d7107e00b232f462ef23",
            "filename": "core/src/test/java/org/apache/shiro/crypto/BlowfishCipherServiceTest.java",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherServiceTest.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherServiceTest.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fcrypto%2FBlowfishCipherServiceTest.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -0,0 +1,81 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing,\n+ * software distributed under the License is distributed on an\n+ * \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY\n+ * KIND, either express or implied.  See the License for the\n+ * specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package org.apache.shiro.crypto;\n+\n+import org.apache.shiro.codec.CodecSupport;\n+import org.apache.shiro.util.ByteSource;\n+import org.junit.Test;\n+\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.InputStream;\n+import java.util.Arrays;\n+\n+import static junit.framework.Assert.assertTrue;\n+\n+/**\n+ * Test cases for the {@link BlowfishCipherService} class.\n+ *\n+ * @author The Apache Shiro Project (shiro-dev@incubator.apache.org)\n+ * @since 1.0\n+ */\n+public class BlowfishCipherServiceTest {\n+\n+    private static final String[] PLAINTEXTS = new String[]{\n+            \"Hello, this is a test.\",\n+            \"Lorem ipsum dolor sit amet, consectetur adipisicing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.\"\n+    };\n+\n+    @Test\n+    public void testBlockOperations() {\n+        BlowfishCipherService blowfish = new BlowfishCipherService();\n+\n+        byte[] key = blowfish.generateNewKey().getEncoded();\n+\n+        for (String plain : PLAINTEXTS) {\n+            byte[] plaintext = CodecSupport.toBytes(plain);\n+            ByteSource ciphertext = blowfish.encrypt(plaintext, key);\n+            ByteSource decrypted = blowfish.decrypt(ciphertext.getBytes(), key);\n+            assertTrue(Arrays.equals(plaintext, decrypted.getBytes()));\n+        }\n+    }\n+\n+    @Test\n+    public void testStreamingOperations() {\n+\n+        BlowfishCipherService cipher = new BlowfishCipherService();\n+        byte[] key = cipher.generateNewKey().getEncoded();\n+\n+        for (String plain : PLAINTEXTS) {\n+            byte[] plaintext = CodecSupport.toBytes(plain);\n+            InputStream plainIn = new ByteArrayInputStream(plaintext);\n+            ByteArrayOutputStream cipherOut = new ByteArrayOutputStream();\n+            cipher.encrypt(plainIn, cipherOut, key);\n+\n+            byte[] ciphertext = cipherOut.toByteArray();\n+            InputStream cipherIn = new ByteArrayInputStream(ciphertext);\n+            ByteArrayOutputStream plainOut = new ByteArrayOutputStream();\n+            cipher.decrypt(cipherIn, plainOut, key);\n+\n+            byte[] decrypted = plainOut.toByteArray();\n+            assertTrue(Arrays.equals(plaintext, decrypted));\n+        }\n+\n+    }\n+}"
        },
        {
            "sha": "bbcb2911dee1897e3126cda1e60c5188242ddff9",
            "filename": "samples/web/src/main/webapp/logout.jsp",
            "status": "modified",
            "additions": 1,
            "deletions": 2,
            "changes": 3,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/samples%2Fweb%2Fsrc%2Fmain%2Fwebapp%2Flogout.jsp",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/samples%2Fweb%2Fsrc%2Fmain%2Fwebapp%2Flogout.jsp",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/samples%2Fweb%2Fsrc%2Fmain%2Fwebapp%2Flogout.jsp?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -1,4 +1,3 @@\n-<%@ page import=\"org.apache.shiro.SecurityUtils\" %>\n <%--\n ~ Licensed to the Apache Software Foundation (ASF) under one\n ~ or more contributor license agreements.  See the NOTICE file\n@@ -30,7 +29,7 @@\n \n       When a user logs out, any 'rememberMe' identity\n       should always be cleared.  In a web application,\n-      Shiro uses a Cipher-encrypted Cookie to\n+      Shiro uses a cipher-encrypted Cookie to\n       remember a user's identity by default, and it will\n       automatically delete the Cookie upon a logout.\n "
        },
        {
            "sha": "685ec19462af639dda6fc3df0ed7028ae8f85afa",
            "filename": "web/src/test/java/org/apache/shiro/web/WebRememberMeManagerTest.java",
            "status": "modified",
            "additions": 19,
            "deletions": 17,
            "changes": 36,
            "blob_url": "https://github.com/apache/shiro/blob/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fweb%2FWebRememberMeManagerTest.java",
            "raw_url": "https://github.com/apache/shiro/raw/d2f053733eabf5c1587a9e5e9fb642d554fb5fed/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fweb%2FWebRememberMeManagerTest.java",
            "contents_url": "https://api.github.com/repos/apache/shiro/contents/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fshiro%2Fweb%2FWebRememberMeManagerTest.java?ref=d2f053733eabf5c1587a9e5e9fb642d554fb5fed",
            "patch": "@@ -21,7 +21,7 @@\n import org.apache.shiro.authc.AuthenticationInfo;\n import org.apache.shiro.authc.SimpleAuthenticationInfo;\n import org.apache.shiro.authc.UsernamePasswordToken;\n-import org.apache.shiro.io.SerializationException;\n+import org.apache.shiro.crypto.CryptoException;\n import org.apache.shiro.mgt.SubjectFactory;\n import org.apache.shiro.subject.PrincipalCollection;\n import org.apache.shiro.subject.SimplePrincipalCollection;\n@@ -72,28 +72,29 @@ public void onSuccessfulLogin() {\n     }\n \n     // SHIRO-69\n+\n     @Test\n     public void getRememberedPrincipals() {\n         HttpServletRequest mockRequest = createMock(HttpServletRequest.class);\n         HttpServletResponse mockResponse = createMock(HttpServletResponse.class);\n-        Map<String,Object> context = new HashMap<String,Object>();\n+        Map<String, Object> context = new HashMap<String, Object>();\n         context.put(SubjectFactory.SERVLET_REQUEST, mockRequest);\n         context.put(SubjectFactory.SERVLET_RESPONSE, mockResponse);\n \n         expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n \n         //The following base64 string was determined from the log output of the above 'onSuccessfulLogin' test.\n         //This will have to change any time the PrincipalCollection implementation changes:\n-        final String userPCBlowfishBase64 = \"UwP13UzjVUceLBNWh+sYM01JWOSbBOwc1ZLySIws0Idnkc\" +\n-                \"WeD/yWeH0eIycwHaI8MRKPyenBr77dBdt3S7KTK/6qKqKiW5oLqOgU/ZQLdvIOxlZxmT9RlUvK\" +\n-                \"T6zopnQrSpdsCNaruG/Op/XEoJcdNLI9rJCCyMKN3em5wl8GrWTIzKS4hzHombGBEW4EPS9jv4\" +\n-                \"0HV4mIS2sUFXm5MlOptr99e1A6eKYxlLrldk2/yqw29nWohE0sIjO7tRF9mOAZUeC/Fem6K4S8\" +\n-                \"2LbXAJ6p0oNg3MP7dbFSkeeDF2CwFJvvi5xVrGyF0RnTzjwKZdTcvg4bx9ifQpKyPayQgsjCjd\" +\n-                \"3pucJfBq1kuw/IyiPdSREnzWAEXOQi9o9II4jNvOJik+VI3QkwWdBBekzEKCACn8uvjlLKSiR8\" +\n-                \"tCs9vbycs5N0FrODxMQ5FDvhV+rZLHtPkishP5cm/QEL01IUqqC4RA==\";\n+        final String userPCAesBase64 = \"qk7spFqO1zoNLgq3qArE7bc8+J+Zvm1jz8lDSUmRiRlDQQx7jxG4+\" +\n+                \"QImiRpR7zO0d9oHH+7C3VeN9OvGMdjxtpbInMsLcGz4Q0u3M1fmyErn5Mr61chmNzQ8cLegpIKE3M+xMY\" +\n+                \"5JB1PRw7aEJdRxtHh80kiXZ5jeALvDP3hmFM7OF2CDKLIIa83XuBQvyrKGI9GhsxGTLkmNFknbfRsmN7v\" +\n+                \"NIDorceeaMkAetYf6GxDOw1ZK7yEbsydIHnqVWNHLen6DHC8pLkqMNOoGwXLeBroD6mRpoFf76J0VKBcd\" +\n+                \"C54Mg73S2R7wx9ZzSNJJrCi1KAilmThzm3Rm97EidUnYlWI0TM+zvMzNsLynIK4PoIG6HYQQfEI35qVRI\" +\n+                \"bCdbTlTnjfM/fPf7RWO8s4Z7KzszSQMJE9LgBudcyzrld5ZrWb11cianskNZMI8kzOITezjjqvWn5U4jg\" +\n+                \"Mb9a6qcpaNJcgaxV6NZRmof8cnet54wwE=\";\n \n         Cookie[] cookies = new Cookie[]{\n-                new Cookie(WebRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCBlowfishBase64)\n+                new Cookie(WebRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n         };\n \n         expect(mockRequest.getCookies()).andReturn(cookies);\n@@ -110,21 +111,22 @@ public void getRememberedPrincipals() {\n     }\n \n     // SHIRO-69\n+\n     @Test\n     public void getRememberedPrincipalsDecryptionError() {\n         HttpServletRequest mockRequest = createNiceMock(HttpServletRequest.class);\n         HttpServletResponse mockResponse = createNiceMock(HttpServletResponse.class);\n \n-        Map<String,Object> context = new HashMap<String,Object>();\n+        Map<String, Object> context = new HashMap<String, Object>();\n         context.put(SubjectFactory.SERVLET_REQUEST, mockRequest);\n         context.put(SubjectFactory.SERVLET_RESPONSE, mockResponse);\n \n         expect(mockRequest.getAttribute(ShiroHttpServletRequest.IDENTITY_REMOVED_KEY)).andReturn(null);\n \n         // Simulate a bad return value here (for example if this was encrypted with a different key\n-        final String userPCBlowfishBase64 = \"DlJgEjFZVuRRN5lCpInkOsawSaKK4hLwegZK/QgR1Thk380v5wL9pA1NZo7QHr7erlnry1vt2AqIyM8Fj2HBCsl1lierxE9EJ1typI2GpgMeG+HmceNdrlN6KGh4AmjLG3zCUPo8E+QzGVs/EO3PIAGyYYtuYbW++oJDr5xfY9DwK4Omq5GijZSSmdpOHiYelPMa1XLwT0D/kNCUm6EVfG6TKwxViNtGdyzknY7abNU7ucw2UWfjFe24hH0SL0hZMXjPQYtMnPl5J5qfjU4EXX1a/Ijn0IKUEk5BmY+ipc6irMI/Rrmumr46XAIU3uwWMxlbPxDtzyABsmGLbmG1vvqCQ6+cX2PQJ37oNcKqr4mV7ObN2EvWZ1uVbJlUdXeEQgghL3/ayatTs3hWwFGdNhgef8c8iX9wM5bEvxqqY9TMXEyLYLZeA8H6gNvJc6hRd0TQFkzUhjs=\";\n+        final String userPCAesBase64 = \"garbage\";\n         Cookie[] cookies = new Cookie[]{\n-                new Cookie(WebRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCBlowfishBase64)\n+                new Cookie(WebRememberMeManager.DEFAULT_REMEMBER_ME_COOKIE_NAME, userPCAesBase64)\n         };\n \n         expect(mockRequest.getCookies()).andReturn(cookies).anyTimes();\n@@ -133,13 +135,13 @@ public void getRememberedPrincipalsDecryptionError() {\n         WebRememberMeManager mgr = new WebRememberMeManager();\n         PrincipalCollection collection = null;\n \n-        SerializationException se = null;\n+        CryptoException ce = null;\n         try {\n             collection = mgr.getRememberedPrincipals(context);\n-        } catch (SerializationException expected) {\n-            se = expected;\n+        } catch (CryptoException expected) {\n+            ce = expected;\n         }\n-        assertNotNull(se);\n+        assertNotNull(ce);\n \n         verify(mockRequest);\n "
        }
    ]
}
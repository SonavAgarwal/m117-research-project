{
    "sha": "7d97adc68789f4a191cee15de482530dd9d5c31d",
    "node_id": "MDY6Q29tbWl0MzE0ODk3OTo3ZDk3YWRjNjg3ODlmNGExOTFjZWUxNWRlNDgyNTMwZGQ5ZDVjMzFk",
    "commit": {
        "author": {
            "name": "Luke Taylor",
            "email": "luke.taylor@springsource.com",
            "date": "2010-10-03T00:04:26Z"
        },
        "committer": {
            "name": "Luke Taylor",
            "email": "luke.taylor@springsource.com",
            "date": "2010-10-27T12:25:39Z"
        },
        "message": "SEC-1584: Addition of HttpFirewall strategy to FilterChainProxy to reject un-normalized requests and wrap the incoming request object before processing by the security filter chain to provide a more consistent representation of paths than is guaranteed by the servlet spec. The wrapper strips path parameters from pathInfo and servletPath to provide consistency of URL matching across servlet containers and protect against bypassing security constraints by the malicious addition of such parameters to the URL. The paths are canonicalized further by replacing of multiple sequences of \"/\" characters with a single \"/\".",
        "tree": {
            "sha": "2622773982f5a130612d885438f5da0eb45cddc4",
            "url": "https://api.github.com/repos/spring-projects/spring-security/git/trees/2622773982f5a130612d885438f5da0eb45cddc4"
        },
        "url": "https://api.github.com/repos/spring-projects/spring-security/git/commits/7d97adc68789f4a191cee15de482530dd9d5c31d",
        "comment_count": 2,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/spring-projects/spring-security/commits/7d97adc68789f4a191cee15de482530dd9d5c31d",
    "html_url": "https://github.com/spring-projects/spring-security/commit/7d97adc68789f4a191cee15de482530dd9d5c31d",
    "comments_url": "https://api.github.com/repos/spring-projects/spring-security/commits/7d97adc68789f4a191cee15de482530dd9d5c31d/comments",
    "author": {
        "login": "tekul",
        "id": 191720,
        "node_id": "MDQ6VXNlcjE5MTcyMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/191720?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tekul",
        "html_url": "https://github.com/tekul",
        "followers_url": "https://api.github.com/users/tekul/followers",
        "following_url": "https://api.github.com/users/tekul/following{/other_user}",
        "gists_url": "https://api.github.com/users/tekul/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tekul/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tekul/subscriptions",
        "organizations_url": "https://api.github.com/users/tekul/orgs",
        "repos_url": "https://api.github.com/users/tekul/repos",
        "events_url": "https://api.github.com/users/tekul/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tekul/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "tekul",
        "id": 191720,
        "node_id": "MDQ6VXNlcjE5MTcyMA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/191720?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/tekul",
        "html_url": "https://github.com/tekul",
        "followers_url": "https://api.github.com/users/tekul/followers",
        "following_url": "https://api.github.com/users/tekul/following{/other_user}",
        "gists_url": "https://api.github.com/users/tekul/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/tekul/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/tekul/subscriptions",
        "organizations_url": "https://api.github.com/users/tekul/orgs",
        "repos_url": "https://api.github.com/users/tekul/repos",
        "events_url": "https://api.github.com/users/tekul/events{/privacy}",
        "received_events_url": "https://api.github.com/users/tekul/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "695c8f4ad6dbda40132cffc0032ba8f7cae9396a",
            "url": "https://api.github.com/repos/spring-projects/spring-security/commits/695c8f4ad6dbda40132cffc0032ba8f7cae9396a",
            "html_url": "https://github.com/spring-projects/spring-security/commit/695c8f4ad6dbda40132cffc0032ba8f7cae9396a"
        }
    ],
    "stats": {
        "total": 635,
        "additions": 583,
        "deletions": 52
    },
    "files": [
        {
            "sha": "9144c45efcd4a122b09340c65754deaa85a98d4d",
            "filename": ".gitignore",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/.gitignore",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/.gitignore",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/.gitignore?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -4,6 +4,7 @@ target/\n .project\n .DS_Store\n .settings/\n+.idea/\n out/\n intellij/\n build/"
        },
        {
            "sha": "33d83e460df750f7348f076d41ac950f540da972",
            "filename": "config/src/test/java/org/springframework/security/config/FilterChainProxyConfigTests.java",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/config%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fconfig%2FFilterChainProxyConfigTests.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/config%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fconfig%2FFilterChainProxyConfigTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/config%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fconfig%2FFilterChainProxyConfigTests.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -116,18 +116,18 @@ public void mixingPatternsAndPlaceholdersDoesntCauseOrderingIssues() throws Exce\n     }\n \n     private void checkPathAndFilterOrder(FilterChainProxy filterChainProxy) throws Exception {\n-        List<Filter> filters = filterChainProxy.getFilters(\"/foo/blah\");\n+        List<Filter> filters = filterChainProxy.getFilters(\"/foo/blah;x=1\");\n         assertEquals(1, filters.size());\n         assertTrue(filters.get(0) instanceof SecurityContextHolderAwareRequestFilter);\n \n-        filters = filterChainProxy.getFilters(\"/some/other/path/blah\");\n+        filters = filterChainProxy.getFilters(\"/some;x=2,y=3/other/path;z=4/blah\");\n         assertNotNull(filters);\n         assertEquals(3, filters.size());\n         assertTrue(filters.get(0) instanceof SecurityContextPersistenceFilter);\n         assertTrue(filters.get(1) instanceof SecurityContextHolderAwareRequestFilter);\n         assertTrue(filters.get(2) instanceof SecurityContextHolderAwareRequestFilter);\n \n-        filters = filterChainProxy.getFilters(\"/do/not/filter\");\n+        filters = filterChainProxy.getFilters(\"/do/not/filter;x=7\");\n         assertEquals(0, filters.size());\n \n         filters = filterChainProxy.getFilters(\"/another/nonspecificmatch\");"
        },
        {
            "sha": "5d184832269877385ef2fa8863c02012443ed6a8",
            "filename": "web/src/main/java/org/springframework/security/web/FilterChainProxy.java",
            "status": "modified",
            "additions": 111,
            "deletions": 49,
            "changes": 160,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxy.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxy.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxy.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -17,64 +17,100 @@\n \n import org.apache.commons.logging.Log;\n import org.apache.commons.logging.LogFactory;\n+import org.springframework.security.web.firewall.DefaultHttpFirewall;\n+import org.springframework.security.web.firewall.FirewalledRequest;\n+import org.springframework.security.web.firewall.HttpFirewall;\n import org.springframework.security.web.util.AnyRequestMatcher;\n import org.springframework.security.web.util.RequestMatcher;\n+import org.springframework.security.web.util.UrlUtils;\n import org.springframework.util.Assert;\n import org.springframework.web.filter.DelegatingFilterProxy;\n import org.springframework.web.filter.GenericFilterBean;\n \n-import javax.servlet.*;\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletRequestWrapper;\n+import javax.servlet.ServletResponse;\n import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n import java.io.IOException;\n import java.util.*;\n \n \n /**\n- * Delegates <code>Filter</code> requests to a list of Spring-managed beans.\n- * As of version 2.0, you shouldn't need to explicitly configure a <tt>FilterChainProxy</tt> bean in your application\n+ * Delegates {@code Filter} requests to a list of Spring-managed filter beans.\n+ * As of version 2.0, you shouldn't need to explicitly configure a {@code FilterChainProxy} bean in your application\n  * context unless you need very fine control over the filter chain contents. Most cases should be adequately covered\n- * by the default <tt>&lt;security:http /&gt;</tt> namespace configuration options.\n+ * by the default {@code &lt;security:http /&gt;} namespace configuration options.\n  * <p>\n- * The <code>FilterChainProxy</code> is loaded via a standard Spring {@link DelegatingFilterProxy} declaration in\n- * <code>web.xml</code>.\n+ * The {@code FilterChainProxy} is linked into the servlet container filter chain by adding a standard\n+ * Spring {@link DelegatingFilterProxy} declaration in the application {@code web.xml} file.\n+ *\n+ * <h2>Configuration</h2>\n  * <p>\n- * As of version 3.1, <tt>FilterChainProxy</tt> is configured using an ordered Map of {@link RequestMatcher} instances\n- * to <tt>List</tt>s of <tt>Filter</tt>s. The Map instance will normally be created while parsing the namespace\n- * configuration, so doesn't have to be set explicitly. Instead the &lt;filter-chain-map&gt; element should be used\n- * within the FilterChainProxy bean declaration.\n- * This in turn should have a list of child &lt;filter-chain&gt; elements which each define a URI pattern and the list\n- * of filters (as comma-separated bean names) which should be applied to requests which match the pattern.\n- * An example configuration might look like this:\n+ * As of version 3.1, {@code FilterChainProxy} is configured using an ordered Map of {@link RequestMatcher} instances\n+ * to {@code List}s of {@code Filter}s. The Map instance will normally be created while parsing the namespace\n+ * configuration, so doesn't have to be set explicitly. Instead the {@code &lt;filter-chain-map&gt;}\n+ * element should be used within the bean declaration.\n+ * This in turn should have a list of child {@code &lt;filter-chain&gt;} elements which each define a URI pattern and\n+ * the list of filters (as comma-separated bean names) which should be applied to requests which match the pattern.\n+ * The default pattern matching strategy is to use {@link org.springframework.security.web.util.AntPathRequestMatcher\n+ * Ant-style paths}. An example configuration might look like this:\n  *\n  * <pre>\n  &lt;bean id=\"myfilterChainProxy\" class=\"org.springframework.security.util.FilterChainProxy\">\n      &lt;security:filter-chain-map request-matcher=\"ant\">\n-         &lt;security:filter-chain pattern=\"/do/not/filter\" filters=\"none\"/>\n+         &lt;security:filter-chain pattern=\"/do/not/filter*\" filters=\"none\"/>\n          &lt;security:filter-chain pattern=\"/**\" filters=\"filter1,filter2,filter3\"/>\n      &lt;/security:filter-chain-map>\n  &lt;/bean>\n  * </pre>\n  *\n- * The names \"filter1\", \"filter2\", \"filter3\" should be the bean names of <tt>Filter</tt> instances defined in the\n+ * The names \"filter1\", \"filter2\", \"filter3\" should be the bean names of {@code Filter} instances defined in the\n  * application context. The order of the names defines the order in which the filters will be applied. As shown above,\n  * use of the value \"none\" for the \"filters\" can be used to exclude a request pattern from the security filter chain\n  * entirely. Please consult the security namespace schema file for a full list of available configuration options.\n+ *\n+ * <h2>Request Handling</h2>\n  * <p>\n- * Each possible pattern that <code>FilterChainProxy</code> should service must be entered.\n- * The first match for a given request will be used to define all of the <code>Filter</code>s that apply to that\n- * request. This means you must put most specific matches at the top of the list, and ensure all <code>Filter</code>s\n+ * Each possible pattern that the {@code FilterChainProxy} should service must be entered.\n+ * The first match for a given request will be used to define all of the {@code Filter}s that apply to that\n+ * request. This means you must put most specific matches at the top of the list, and ensure all {@code Filter}s\n  * that should apply for a given matcher are entered against the respective entry.\n- * The <code>FilterChainProxy</code> will not iterate through the remainder of the map entries to locate additional\n- * <code>Filter</code>s.\n+ * The {@code FilterChainProxy} will not iterate through the remainder of the map entries to locate additional\n+ * {@code Filter}s.\n  * <p>\n- * <code>FilterChainProxy</code> respects normal handling of <code>Filter</code>s that elect not to call {@link\n+ * {@code FilterChainProxy} respects normal handling of {@code Filter}s that elect not to call {@link\n  * javax.servlet.Filter#doFilter(javax.servlet.ServletRequest, javax.servlet.ServletResponse,\n- * javax.servlet.FilterChain)}, in that the remainder of the original or <code>FilterChainProxy</code>-declared filter\n+ * javax.servlet.FilterChain)}, in that the remainder of the original or {@code FilterChainProxy}-declared filter\n  * chain will not be called.\n+ *\n+ * <h3>Request Firewalling</h3>\n+ *\n+ * An {@link HttpFirewall} instance is used to validate incoming requests and create a wrapped request which provides\n+ * consistent path values for matching against. See {@link DefaultHttpFirewall}, for more information on the type of\n+ * attacks which the default implementation protects against. A custom implementation can be injected to provide\n+ * stricter control over the request contents or if an application needs to support certain types of request which\n+ * are rejected by default.\n+ * <p>\n+ * Note that this means that you must use the Spring Security filters in combination with a {@code FilterChainProxy}\n+ * if you want this protection. Don't define them explicitly in your {@code web.xml} file.\n  * <p>\n- * Note the <code>Filter</code> lifecycle mismatch between the servlet container and IoC\n- * container. As described in the {@link DelegatingFilterProxy} JavaDocs, we recommend you allow the IoC\n- * container to manage the lifecycle instead of the servlet container.\n+ * {@code FilterChainProxy} will use the firewall instance to obtain both request and response objects which will be\n+ * fed down the filter chain, so it is also possible to use this functionality to control the functionality of the\n+ * response. When the request has passed through the security filter chain, the {@code reset} method will be called.\n+ * With the default implementation this means that the original values of {@code servletPath} and {@code pathInfo} will\n+ * be returned thereafter, instead of the modified ones used for security pattern matching.\n+ *\n+ *\n+ * <h2>Filter Lifecycle</h2>\n+ * <p>\n+ * Note the {@code Filter} lifecycle mismatch between the servlet container and IoC\n+ * container. As described in the {@link DelegatingFilterProxy} Javadocs, we recommend you allow the IoC\n+ * container to manage the lifecycle instead of the servlet container. {@code FilterChainProxy} does not invoke the\n+ * standard filter lifecycle methods on any filter beans that you add to the application context.\n  *\n  * @author Carlos Sanchez\n  * @author Ben Alex\n@@ -92,6 +128,8 @@ public class FilterChainProxy extends GenericFilterBean {\n \n     private FilterChainValidator filterChainValidator = new NullFilterChainValidator();\n \n+    private HttpFirewall firewall = new DefaultHttpFirewall();\n+\n     //~ Methods ========================================================================================================\n \n     @Override\n@@ -103,25 +141,27 @@ public void afterPropertiesSet() {\n     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)\n             throws IOException, ServletException {\n \n-        FilterInvocation fi = new FilterInvocation(request, response, chain);\n-        List<Filter> filters = getFilters(fi.getRequest());\n+        FirewalledRequest fwRequest = firewall.getFirewalledRequest((HttpServletRequest) request);\n+        HttpServletResponse fwResponse = firewall.getFirewalledResponse((HttpServletResponse) response);\n+        String url = UrlUtils.buildRequestUrl(fwRequest);\n+\n+        List<Filter> filters = getFilters(fwRequest);\n \n         if (filters == null || filters.size() == 0) {\n             if (logger.isDebugEnabled()) {\n-                logger.debug(fi.getRequestUrl() +\n+                logger.debug(url +\n                         (filters == null ? \" has no matching filters\" : \" has an empty filter list\"));\n             }\n \n-            chain.doFilter(request, response);\n+            chain.doFilter(fwRequest, fwResponse);\n \n             return;\n         }\n \n-        VirtualFilterChain virtualFilterChain = new VirtualFilterChain(fi, filters);\n-        virtualFilterChain.doFilter(fi.getRequest(), fi.getResponse());\n+        VirtualFilterChain vfc = new VirtualFilterChain(url, chain, filters);\n+        vfc.doFilter(fwRequest, fwResponse);\n     }\n \n-\n     /**\n      * Returns the first filter chain matching the supplied URL.\n      *\n@@ -147,20 +187,20 @@ private List<Filter> getFilters(HttpServletRequest request)  {\n      * @return matching filter list\n      */\n     public List<Filter> getFilters(String url) {\n-        return getFilters(new FilterInvocation(url, null).getRequest());\n+        return getFilters(firewall.getFirewalledRequest((new FilterInvocation(url, null).getRequest())));\n     }\n \n     /**\n      * Sets the mapping of URL patterns to filter chains.\n      *\n-     * The map keys should be the paths and the values should be arrays of <tt>Filter</tt> objects.\n+     * The map keys should be the paths and the values should be arrays of {@code Filter} objects.\n      * It's VERY important that the type of map used preserves ordering - the order in which the iterator\n      * returns the entries must be the same as the order they were added to the map, otherwise you have no way\n      * of guaranteeing that the most specific patterns are returned before the more general ones. So make sure\n-     * the Map used is an instance of <tt>LinkedHashMap</tt> or an equivalent, rather than a plain <tt>HashMap</tt>, for\n+     * the Map used is an instance of {@code LinkedHashMap} or an equivalent, rather than a plain {@code HashMap}, for\n      * example.\n      *\n-     * @param filterChainMap the map of path Strings to <tt>List&lt;Filter&gt;</tt>s.\n+     * @param filterChainMap the map of path Strings to {@code List&lt;Filter&gt;}s.\n      */\n     @SuppressWarnings(\"unchecked\")\n     public void setFilterChainMap(Map filterChainMap) {\n@@ -198,7 +238,7 @@ private void checkPathOrder() {\n \n     /**\n      * Returns a copy of the underlying filter chain map. Modifications to the map contents\n-     * will not affect the FilterChainProxy state - to change the map call <tt>setFilterChainMap</tt>.\n+     * will not affect the FilterChainProxy state - to change the map call {@code setFilterChainMap}.\n      *\n      * @return the map of path pattern Strings to filter chain lists (with ordering guaranteed).\n      */\n@@ -216,6 +256,16 @@ public void setFilterChainValidator(FilterChainValidator filterChainValidator) {\n         this.filterChainValidator = filterChainValidator;\n     }\n \n+    /**\n+     * Sets the \"firewall\" implementation which will be used to validate and wrap (or potentially reject) the\n+     * incoming requests. The default implementation should be satisfactory for most requirements.\n+     *\n+     * @param firewall\n+     */\n+    public void setFirewall(HttpFirewall firewall) {\n+        this.firewall = firewall;\n+    }\n+\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n         sb.append(\"FilterChainProxy[\");\n@@ -230,42 +280,54 @@ public String toString() {\n \n     /**\n      * Internal {@code FilterChain} implementation that is used to pass a request through the additional\n-     * internal list of filters which match the request. Records the position in the additional filter chain and, when\n-     * completed, passes the request back to the original {@code FilterChain} supplied by the servlet container.\n+     * internal list of filters which match the request.\n      */\n     private static class VirtualFilterChain implements FilterChain {\n-        private final FilterInvocation fi;\n+        private final FilterChain originalChain;\n         private final List<Filter> additionalFilters;\n+        private final String url;\n         private final int size;\n         private int currentPosition = 0;\n \n-\n-        private VirtualFilterChain(FilterInvocation filterInvocation, List<Filter> additionalFilters) {\n-            this.fi = filterInvocation;\n+        private VirtualFilterChain(String url, FilterChain chain, List<Filter> additionalFilters) {\n+            this.originalChain = chain;\n+            this.url = url;\n             this.additionalFilters = additionalFilters;\n             this.size = additionalFilters.size();\n         }\n \n         public void doFilter(ServletRequest request, ServletResponse response) throws IOException, ServletException {\n             if (currentPosition == size) {\n                 if (logger.isDebugEnabled()) {\n-                    logger.debug(fi.getRequestUrl()\n-                        + \" reached end of additional filter chain; proceeding with original chain\");\n+                    logger.debug(url + \" reached end of additional filter chain; proceeding with original chain\");\n                 }\n \n-                fi.getChain().doFilter(request, response);\n+                // Deactivate path stripping as we exit the security filter chain\n+                resetWrapper(request);\n+\n+                originalChain.doFilter(request, response);\n             } else {\n                 currentPosition++;\n \n                 Filter nextFilter = additionalFilters.get(currentPosition - 1);\n \n                 if (logger.isDebugEnabled()) {\n-                    logger.debug(fi.getRequestUrl() + \" at position \" + currentPosition + \" of \"\n+                    logger.debug(url + \" at position \" + currentPosition + \" of \"\n                         + size + \" in additional filter chain; firing Filter: '\"\n-                        + nextFilter + \"'\");\n+                        + nextFilter.getClass().getSimpleName() + \"'\");\n                 }\n \n-               nextFilter.doFilter(request, response, this);\n+                nextFilter.doFilter(request, response, this);\n+            }\n+        }\n+\n+        private void resetWrapper(ServletRequest request) {\n+            while (request instanceof ServletRequestWrapper) {\n+                if (request instanceof FirewalledRequest) {\n+                    ((FirewalledRequest)request).reset();\n+                    break;\n+                }\n+                request = ((ServletRequestWrapper)request).getRequest();\n             }\n         }\n     }"
        },
        {
            "sha": "a40fa435dc55f8d694a776e9f224fd179d43223e",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/DefaultHttpFirewall.java",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,67 @@\n+package org.springframework.security.web.firewall;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * Default implementation which wraps requests in order to provide consistent values of the {@code servletPath} and\n+ * {@code pathInfo}, which do not contain path parameters (as defined in\n+ * <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>). Different servlet containers\n+ * interpret the servlet spec differently as to how path parameters are treated and it is possible they might be added\n+ * in order to bypass particular security constraints. When using this implementation, they will be removed for all\n+ * requests as the request passes through the security filter chain. Note that this means that any segments in the\n+ * decoded path which contain a semi-colon, will have the part following the semi-colon removed for\n+ * request matching. Your application should not contain any valid paths which contain semi-colons.\n+ * <p>\n+ * If any un-normalized paths are found (containing directory-traversal character sequences), the request will be\n+ * rejected immediately. Most containers normalize the paths before performing the servlet-mapping, but again this is\n+ * not guaranteed by the servlet spec.\n+ *\n+ * @author Luke Taylor\n+ */\n+public class DefaultHttpFirewall implements HttpFirewall {\n+\n+    public FirewalledRequest getFirewalledRequest(HttpServletRequest request) throws RequestRejectedException {\n+        FirewalledRequest fwr = new RequestWrapper(request);\n+\n+        if (!isNormalized(fwr.getServletPath()) || !isNormalized(fwr.getPathInfo())) {\n+            throw new RequestRejectedException(\"Un-normalized paths are not supported: \" + fwr.getServletPath() +\n+                (fwr.getPathInfo() != null ? fwr.getPathInfo() : \"\"));\n+        }\n+\n+        return fwr;\n+    }\n+\n+    public HttpServletResponse getFirewalledResponse(HttpServletResponse response) {\n+        return response;\n+    }\n+\n+    /**\n+     * Checks whether a path is normalized (doesn't contain path traversal sequences like \"./\", \"/../\" or \"/.\")\n+     *\n+     * @param path the path to test\n+     * @return true if the path doesn't contain any path-traversal character sequences.\n+     */\n+    private boolean isNormalized(String path) {\n+        if (path == null) {\n+            return true;\n+        }\n+\n+        for (int j = path.length(); j > 0;) {\n+            int i = path.lastIndexOf('/', j - 1);\n+            int gap = j - i;\n+\n+            if (gap == 2 && path.charAt(i+1) == '.') {\n+                // \".\", \"/./\" or \"/.\"\n+                return false;\n+            } else if (gap == 3 && path.charAt(i+1) == '.'&& path.charAt(i+2) == '.') {\n+                return false;\n+            }\n+\n+            j = i;\n+        }\n+\n+        return true;\n+    }\n+\n+}"
        },
        {
            "sha": "48cf40acc2c4f4a5d812d31d123394ac095897d8",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/FirewalledRequest.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FFirewalledRequest.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FFirewalledRequest.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FFirewalledRequest.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,34 @@\n+package org.springframework.security.web.firewall;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+\n+/**\n+ * Request wrapper which is returned by the {@code HttpFirewall} interface.\n+ * <p>\n+ * The only difference is the {@code reset} method which allows some\n+ * or all of the state to be reset by the {@code FilterChainProxy} when the\n+ * request leaves the security filter chain.\n+ *\n+ * @author Luke Taylor\n+ */\n+public abstract class FirewalledRequest extends HttpServletRequestWrapper {\n+    /**\n+     * Constructs a request object wrapping the given request.\n+     *\n+     * @throws IllegalArgumentException if the request is null\n+     */\n+    public FirewalledRequest(HttpServletRequest request) {\n+        super(request);\n+    }\n+\n+    /**\n+     * This method will be called once the request has passed through the\n+     * security filter chain, when it is about to proceed to the application\n+     * proper.\n+     * <p>\n+     * An implementation can thus choose to modify the state of the request\n+     * for the security infrastructure, while still maintaining the\n+     */\n+    public abstract void reset();\n+}"
        },
        {
            "sha": "de7b9af17e9a87a0b04bdb4e10a59a300e46171b",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/HttpFirewall.java",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FHttpFirewall.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FHttpFirewall.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FHttpFirewall.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,32 @@\n+package org.springframework.security.web.firewall;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+/**\n+ * Interface which can be used to reject potentially dangerous requests and/or wrap them to\n+ * control their behaviour.\n+ * <p>\n+ * The implementation is injected into the {@code FilterChainProxy} and will be invoked before\n+ * sending any request through the filter chain. It can also provide a response wrapper if the response\n+ * behaviour should also be restricted.\n+ *\n+ * @author Luke Taylor\n+ */\n+public interface HttpFirewall {\n+\n+    /**\n+     * Provides the request object which will be passed through the filter chain.\n+     *\n+     * @throws RequestRejectedException if the request should be rejected immediately\n+     */\n+    FirewalledRequest getFirewalledRequest(HttpServletRequest request) throws RequestRejectedException;\n+\n+    /**\n+     * Provides the response which will be passed through the filter chain.\n+     *\n+     * @param response the original response\n+     * @return either the original response or a replacement/wrapper.\n+     */\n+    HttpServletResponse getFirewalledResponse(HttpServletResponse response);\n+}"
        },
        {
            "sha": "fe334219a064118ae2dff7ff1879050220442b38",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/RequestRejectedException.java",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestRejectedException.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestRejectedException.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestRejectedException.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,10 @@\n+package org.springframework.security.web.firewall;\n+\n+/**\n+ * @author Luke Taylor\n+ */\n+public class RequestRejectedException extends RuntimeException {\n+    public RequestRejectedException(String message) {\n+        super(message);\n+    }\n+}"
        },
        {
            "sha": "9cc39219055c49b6e17f7a5efe39152c193f1930",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/RequestWrapper.java",
            "status": "added",
            "additions": 103,
            "deletions": 0,
            "changes": 103,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapper.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapper.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapper.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,103 @@\n+package org.springframework.security.web.firewall;\n+\n+import org.springframework.security.web.util.UrlUtils;\n+\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import java.util.*;\n+\n+/**\n+ * Request wrapper which ensures values of {@code servletPath} and {@code pathInfo} are returned which are suitable for\n+ * pattern matching against. It strips out path parameters and extra consecutive '/' characters.\n+ *\n+ * <h3>Path Parameters</h3>\n+ * Parameters (as defined in <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>) are stripped from the path\n+ * segments of the {@code servletPath} and {@code pathInfo} values of the request.\n+ * <p>\n+ * The parameter sequence is demarcated by a semi-colon, so each segment is checked for the occurrence of a \";\"\n+ * character and truncated at that point if it is present.\n+ * <p>\n+ * The behaviour differs between servlet containers in how they interpret the servlet spec, which\n+ * does not clearly state what the behaviour should be. For consistency, we make sure they are always removed, to\n+ * avoid the risk of URL matching rules being bypassed by the malicious addition of parameters to the path component.\n+ *\n+ * @author Luke Taylor\n+ */\n+final class RequestWrapper extends FirewalledRequest {\n+    private final String strippedServletPath;\n+    private final String strippedPathInfo;\n+    private boolean stripPaths = true;\n+\n+    public RequestWrapper(HttpServletRequest request) {\n+        super(request);\n+        strippedServletPath = strip(request.getServletPath());\n+        String pathInfo = strip(request.getPathInfo());\n+        if (pathInfo != null && pathInfo.length() == 0) {\n+            pathInfo = null;\n+        }\n+        strippedPathInfo = pathInfo;\n+    }\n+\n+    /**\n+     * Removes path parameters from each path segment in the supplied path and truncates sequences of multiple '/'\n+     * characters to a single '/'.\n+     *\n+     * @param path either the {@code servletPath} and {@code pathInfo} from the original request\n+     *\n+     * @return the supplied value, with path parameters removed and sequences of multiple '/' characters truncated,\n+     *  or null if the supplied path was null.\n+     */\n+    private String strip(String path) {\n+        if (path == null) {\n+            return null;\n+        }\n+\n+        int scIndex = path.indexOf(';');\n+\n+        if (scIndex < 0) {\n+            int doubleSlashIndex = path.indexOf(\"//\");\n+            if (doubleSlashIndex < 0) {\n+                // Most likely case, no parameters in any segment and no '//', so no stripping required\n+                return path;\n+            }\n+        }\n+\n+        StringTokenizer st = new StringTokenizer(path, \"/\");\n+        StringBuilder stripped = new StringBuilder(path.length());\n+\n+        if (path.charAt(0) == '/') {\n+            stripped.append('/');\n+        }\n+\n+        while(st.hasMoreTokens()) {\n+            String segment = st.nextToken();\n+            scIndex = segment.indexOf(';');\n+\n+            if (scIndex >= 0) {\n+                segment = segment.substring(0, scIndex);\n+            }\n+            stripped.append(segment).append('/');\n+        }\n+\n+        // Remove the trailing slash if the original path didn't have one\n+        if (path.charAt(path.length() - 1) != '/') {\n+            stripped.deleteCharAt(stripped.length() - 1);\n+        }\n+\n+        return stripped.toString();\n+    }\n+\n+    @Override\n+    public String getPathInfo() {\n+        return stripPaths ? strippedPathInfo : super.getPathInfo();\n+    }\n+\n+    @Override\n+    public String getServletPath() {\n+        return stripPaths ? strippedServletPath : super.getServletPath();\n+    }\n+\n+    public void reset() {\n+        this.stripPaths = false;\n+    }\n+}"
        },
        {
            "sha": "917dc4706354d8fabaee079943fda00da5f348ed",
            "filename": "web/src/test/java/org/springframework/security/web/FilterChainProxyTests.java",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxyTests.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxyTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2FFilterChainProxyTests.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,116 @@\n+package org.springframework.security.web;\n+\n+import static org.junit.Assert.*;\n+import static org.mockito.Mockito.*;\n+\n+import org.junit.Before;\n+import org.junit.Test;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.stubbing.Answer;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+import org.springframework.mock.web.MockHttpServletResponse;\n+import org.springframework.security.web.firewall.FirewalledRequest;\n+import org.springframework.security.web.util.RequestMatcher;\n+\n+import javax.servlet.Filter;\n+import javax.servlet.FilterChain;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+import javax.servlet.http.HttpServletResponse;\n+import java.util.*;\n+\n+/**\n+ * @author Luke Taylor\n+ */\n+@SuppressWarnings({\"unchecked\"})\n+public class FilterChainProxyTests {\n+    private FilterChainProxy fcp;\n+    private RequestMatcher matcher;\n+    private MockHttpServletRequest request;\n+    private MockHttpServletResponse response;\n+    private FilterChain chain;\n+    private Filter filter;\n+\n+    @Before\n+    public void setup() throws Exception {\n+        fcp = new FilterChainProxy();\n+        fcp.setFilterChainValidator(mock(FilterChainProxy.FilterChainValidator.class));\n+        matcher = mock(RequestMatcher.class);\n+        filter = mock(Filter.class);\n+        doAnswer(new Answer() {\n+                    public Object answer(InvocationOnMock inv) throws Throwable {\n+                        Object[] args = inv.getArguments();\n+                        FilterChain fc = (FilterChain) args[2];\n+                        HttpServletRequestWrapper extraWrapper =\n+                                new HttpServletRequestWrapper((HttpServletRequest) args[0]);\n+                        fc.doFilter(extraWrapper, (HttpServletResponse) args[1]);\n+                        return null;\n+                    }\n+                }).when(filter).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class), any(FilterChain.class));\n+        LinkedHashMap map = new LinkedHashMap();\n+        map.put(matcher, Arrays.asList(filter));\n+        fcp.setFilterChainMap(map);\n+        request = new MockHttpServletRequest();\n+        request.setServletPath(\"/path\");\n+        response = new MockHttpServletResponse();\n+        chain = mock(FilterChain.class);\n+    }\n+\n+    @Test\n+    public void toStringCallSucceeds() throws Exception {\n+        fcp.afterPropertiesSet();\n+        fcp.toString();\n+    }\n+\n+    @Test\n+    public void securityFilterChainIsNotInvokedIfMatchFails() throws Exception {\n+        when(matcher.matches(any(HttpServletRequest.class))).thenReturn(false);\n+        fcp.doFilter(request, response, chain);\n+        assertEquals(1, fcp.getFilterChainMap().size());\n+        assertSame(filter, fcp.getFilterChainMap().get(matcher).get(0));\n+\n+        verifyZeroInteractions(filter);\n+        // The actual filter chain should be invoked though\n+        verify(chain).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));\n+    }\n+\n+    @Test\n+    public void originalChainIsInvokedAfterSecurityChainIfMatchSucceeds() throws Exception {\n+        when(matcher.matches(any(HttpServletRequest.class))).thenReturn(true);\n+        fcp.doFilter(request, response, chain);\n+\n+        verify(filter).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class), any(FilterChain.class));\n+        verify(chain).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));\n+    }\n+\n+    @Test\n+    public void originalFilterChainIsInvokedIfMatchingSecurityChainIsEmpty() throws Exception {\n+        LinkedHashMap map = new LinkedHashMap();\n+        map.put(matcher, Collections.emptyList());\n+        fcp.setFilterChainMap(map);\n+\n+        when(matcher.matches(any(HttpServletRequest.class))).thenReturn(true);\n+        fcp.doFilter(request, response, chain);\n+\n+        verify(chain).doFilter(any(HttpServletRequest.class), any(HttpServletResponse.class));\n+    }\n+\n+    @Test\n+    public void requestIsWrappedForMatchingAndFilteringWhenMatchIsFound() throws Exception {\n+        when(matcher.matches(any(HttpServletRequest.class))).thenReturn(true);\n+        fcp.doFilter(request, response, chain);\n+        verify(matcher).matches(any(FirewalledRequest.class));\n+        verify(filter).doFilter(any(FirewalledRequest.class), any(HttpServletResponse.class), any(FilterChain.class));\n+        verify(chain).doFilter(any(FirewalledRequest.class), any(HttpServletResponse.class));\n+    }\n+\n+    @Test\n+    public void requestIsWrappedForMatchingAndFilteringWhenMatchIsNotFound() throws Exception {\n+        when(matcher.matches(any(HttpServletRequest.class))).thenReturn(false);\n+        fcp.doFilter(request, response, chain);\n+        verify(matcher).matches(any(FirewalledRequest.class));\n+        verifyZeroInteractions(filter);\n+        verify(chain).doFilter(any(FirewalledRequest.class), any(HttpServletResponse.class));\n+    }\n+\n+}"
        },
        {
            "sha": "8b3df587e908f448b44956a7c321576ae86f645d",
            "filename": "web/src/test/java/org/springframework/security/web/firewall/DefaultHttpFirewallTests.java",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,44 @@\n+package org.springframework.security.web.firewall;\n+\n+import static org.junit.Assert.fail;\n+\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+/**\n+ * @author Luke Taylor\n+ */\n+public class DefaultHttpFirewallTests {\n+    public String[] unnormalizedPaths = {\n+            \"/..\",\n+            \"/./path/\",\n+            \"/path/path/.\",\n+            \"/path/path//.\",\n+            \"./path/../path//.\",\n+            \"./path\",\n+            \".//path\",\n+            \".\"\n+    };\n+\n+    @Test\n+    public void unnormalizedPathsAreRejected() throws Exception {\n+        DefaultHttpFirewall fw = new DefaultHttpFirewall();\n+\n+        MockHttpServletRequest request;\n+        for (String path : unnormalizedPaths) {\n+            request = new MockHttpServletRequest();\n+            request.setServletPath(path);\n+            try {\n+                fw.getFirewalledRequest(request);\n+                fail(path + \" is un-normalized\");\n+            } catch (RequestRejectedException expected) {\n+            }\n+            request.setPathInfo(path);\n+            try {\n+                fw.getFirewalledRequest(request);\n+                fail(path + \" is un-normalized\");\n+            } catch (RequestRejectedException expected) {\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "b46225144024c625dfc70098abb277442ef0105f",
            "filename": "web/src/test/java/org/springframework/security/web/firewall/RequestWrapperTests.java",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapperTests.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/7d97adc68789f4a191cee15de482530dd9d5c31d/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapperTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FRequestWrapperTests.java?ref=7d97adc68789f4a191cee15de482530dd9d5c31d",
            "patch": "@@ -0,0 +1,62 @@\n+package org.springframework.security.web.firewall;\n+\n+import static org.junit.Assert.assertEquals;\n+\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.springframework.mock.web.MockHttpServletRequest;\n+\n+import java.util.*;\n+\n+/**\n+ * @author Luke Taylor\n+ */\n+public class RequestWrapperTests {\n+    private static Map<String, String> testPaths = new LinkedHashMap<String,String>();\n+\n+    @BeforeClass\n+    // Some of these may be unrealistic values, but we can't be sure because of the\n+    // inconsistency in the spec.\n+    public static void createTestMap() {\n+        testPaths.put(\"/path1;x=y;z=w/path2;x=y/path3;x=y\", \"/path1/path2/path3\");\n+        testPaths.put(\"/path1;x=y/path2;x=y/\", \"/path1/path2/\");\n+        testPaths.put(\"/path1//path2/\", \"/path1/path2/\");\n+        testPaths.put(\"//path1/path2//\", \"/path1/path2/\");\n+        testPaths.put(\";x=y;z=w\", \"\");\n+    }\n+\n+    @Test\n+    public void pathParametersAreRemovedFromServletPath() {\n+        MockHttpServletRequest request = new MockHttpServletRequest();\n+\n+        for (Map.Entry<String,String> entry : testPaths.entrySet()) {\n+            String path = entry.getKey();\n+            String expectedResult = entry.getValue();\n+            request.setServletPath(path);\n+            RequestWrapper wrapper = new RequestWrapper(request);\n+            assertEquals(expectedResult, wrapper.getServletPath());\n+            wrapper.reset();\n+            assertEquals(path, wrapper.getServletPath());\n+        }\n+    }\n+\n+    @Test\n+    public void pathParametersAreRemovedFromPathInfo() {\n+        MockHttpServletRequest request = new MockHttpServletRequest();\n+\n+        for (Map.Entry<String,String> entry : testPaths.entrySet()) {\n+            String path = entry.getKey();\n+            String expectedResult = entry.getValue();\n+            // Should be null when stripped value is empty\n+            if (expectedResult.length() == 0) {\n+                expectedResult = null;\n+            }\n+            request.setPathInfo(path);\n+            RequestWrapper wrapper = new RequestWrapper(request);\n+            assertEquals(expectedResult, wrapper.getPathInfo());\n+            wrapper.reset();\n+            assertEquals(path, wrapper.getPathInfo());\n+        }\n+    }\n+\n+}"
        }
    ]
}
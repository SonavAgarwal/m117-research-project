{
    "sha": "9f8f2f2f5f7df873061679c80edd151c94afdd38",
    "node_id": "MDY6Q29tbWl0MjA2NDEyOjlmOGYyZjJmNWY3ZGY4NzMwNjE2NzljODBlZGQxNTFjOTRhZmRkMzg=",
    "commit": {
        "author": {
            "name": "Martijn Dashorst",
            "email": "martijn.dashorst@gmail.com",
            "date": "2015-11-06T22:32:45Z"
        },
        "committer": {
            "name": "Martijn Dashorst",
            "email": "martijn.dashorst@gmail.com",
            "date": "2015-11-06T23:36:41Z"
        },
        "message": "WICKET-6021: consistent iteration even after modifications\n\nThis commit fixes WICKET-6021 by implementing an improved iterator for\nmarkupcontainer that is able to act on changes in the implementation of\nthe underlying data structure that stores the children without throwing\na ConcurrentModificationException.",
        "tree": {
            "sha": "890a468af7e0853fe9db6f5d084f2d2ed8b9482d",
            "url": "https://api.github.com/repos/apache/wicket/git/trees/890a468af7e0853fe9db6f5d084f2d2ed8b9482d"
        },
        "url": "https://api.github.com/repos/apache/wicket/git/commits/9f8f2f2f5f7df873061679c80edd151c94afdd38",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/wicket/commits/9f8f2f2f5f7df873061679c80edd151c94afdd38",
    "html_url": "https://github.com/apache/wicket/commit/9f8f2f2f5f7df873061679c80edd151c94afdd38",
    "comments_url": "https://api.github.com/repos/apache/wicket/commits/9f8f2f2f5f7df873061679c80edd151c94afdd38/comments",
    "author": {
        "login": "dashorst",
        "id": 46626,
        "node_id": "MDQ6VXNlcjQ2NjI2",
        "avatar_url": "https://avatars.githubusercontent.com/u/46626?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dashorst",
        "html_url": "https://github.com/dashorst",
        "followers_url": "https://api.github.com/users/dashorst/followers",
        "following_url": "https://api.github.com/users/dashorst/following{/other_user}",
        "gists_url": "https://api.github.com/users/dashorst/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dashorst/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dashorst/subscriptions",
        "organizations_url": "https://api.github.com/users/dashorst/orgs",
        "repos_url": "https://api.github.com/users/dashorst/repos",
        "events_url": "https://api.github.com/users/dashorst/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dashorst/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "dashorst",
        "id": 46626,
        "node_id": "MDQ6VXNlcjQ2NjI2",
        "avatar_url": "https://avatars.githubusercontent.com/u/46626?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dashorst",
        "html_url": "https://github.com/dashorst",
        "followers_url": "https://api.github.com/users/dashorst/followers",
        "following_url": "https://api.github.com/users/dashorst/following{/other_user}",
        "gists_url": "https://api.github.com/users/dashorst/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dashorst/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dashorst/subscriptions",
        "organizations_url": "https://api.github.com/users/dashorst/orgs",
        "repos_url": "https://api.github.com/users/dashorst/repos",
        "events_url": "https://api.github.com/users/dashorst/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dashorst/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "e0c2f1bbae576d26f2dc54996905e9acb63ccca0",
            "url": "https://api.github.com/repos/apache/wicket/commits/e0c2f1bbae576d26f2dc54996905e9acb63ccca0",
            "html_url": "https://github.com/apache/wicket/commit/e0c2f1bbae576d26f2dc54996905e9acb63ccca0"
        }
    ],
    "stats": {
        "total": 1570,
        "additions": 1454,
        "deletions": 116
    },
    "files": [
        {
            "sha": "171f9b4dc208476ec04b95d695e83d2486eb998c",
            "filename": "pom.xml",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/wicket/blob/9f8f2f2f5f7df873061679c80edd151c94afdd38/pom.xml",
            "raw_url": "https://github.com/apache/wicket/raw/9f8f2f2f5f7df873061679c80edd151c94afdd38/pom.xml",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/pom.xml?ref=9f8f2f2f5f7df873061679c80edd151c94afdd38",
            "patch": "@@ -270,6 +270,11 @@\n \t\t\t\t<version>1.2.17</version>\n \t\t\t\t<optional>true</optional>\n \t\t\t</dependency>\n+\t\t\t<dependency>\n+\t\t\t\t<groupId>org.apache.commons</groupId>\n+\t\t\t\t<artifactId>commons-collections4</artifactId>\n+\t\t\t\t<version>4.0</version>\n+\t\t\t</dependency>\n \t\t\t<dependency>\n \t\t\t\t<groupId>org.apache.velocity</groupId>\n \t\t\t\t<artifactId>velocity</artifactId>"
        },
        {
            "sha": "add921d65c487f42cf0c09841e69d1595af1f327",
            "filename": "wicket-core/pom.xml",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/apache/wicket/blob/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fpom.xml",
            "raw_url": "https://github.com/apache/wicket/raw/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fpom.xml",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-core%2Fpom.xml?ref=9f8f2f2f5f7df873061679c80edd151c94afdd38",
            "patch": "@@ -42,6 +42,10 @@\n \t\t\t<!-- provided because of WicketTester -->\n \t\t\t<scope>provided</scope>\n \t\t</dependency>\n+\t\t<dependency>\n+\t\t    <groupId>org.apache.commons</groupId>\n+\t\t    <artifactId>commons-collections4</artifactId>\n+\t\t</dependency>\n \t\t<dependency>\n \t\t\t<groupId>org.apache.wicket</groupId>\n \t\t\t<artifactId>wicket-request</artifactId>"
        },
        {
            "sha": "26fe0f9e2e6f359dd0fc880946fc42d1144b1649",
            "filename": "wicket-core/src/main/java/org/apache/wicket/MarkupContainer.java",
            "status": "modified",
            "additions": 380,
            "deletions": 96,
            "changes": 476,
            "blob_url": "https://github.com/apache/wicket/blob/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainer.java",
            "raw_url": "https://github.com/apache/wicket/raw/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainer.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-core%2Fsrc%2Fmain%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainer.java?ref=9f8f2f2f5f7df873061679c80edd151c94afdd38",
            "patch": "@@ -16,14 +16,16 @@\n  */\n package org.apache.wicket;\n \n+import java.io.Serializable;\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.Comparator;\n import java.util.Iterator;\n-import java.util.LinkedHashMap;\n+import java.util.LinkedList;\n import java.util.List;\n import java.util.Map;\n \n+import org.apache.commons.collections4.map.LinkedMap;\n import org.apache.wicket.core.util.string.ComponentStrings;\n import org.apache.wicket.markup.ComponentTag;\n import org.apache.wicket.markup.IMarkupFragment;\n@@ -91,12 +93,11 @@\n  * \n  * @see MarkupStream\n  * @author Jonathan Locke\n- * \n  */\n public abstract class MarkupContainer extends Component implements Iterable<Component>\n {\n \tprivate static final long serialVersionUID = 1L;\n-\t\n+\n \tprivate static final int INITIAL_CHILD_LIST_CAPACITY = 12;\n \n \t/**\n@@ -108,11 +109,51 @@ public abstract class MarkupContainer extends Component implements Iterable<Comp\n \t * We have focused on adding elements to a list, instead of indexed lookups because adding is an\n \t * action that is performed very often, and lookups often are done by component IDs, not index.\n \t */\n-\tprivate static final int MAPIFY_THRESHOLD = 24; // 32 * 0.75\n+\tstatic final int MAPIFY_THRESHOLD = 24; // 32 * 0.75\n \n \t/** Log for reporting. */\n \tprivate static final Logger log = LoggerFactory.getLogger(MarkupContainer.class);\n \n+\t/**\n+\t * Metadata key for looking up the list of removed children necessary for tracking modifications\n+\t * during iteration of the children of this markup container.\n+\t * \n+\t * This is stored in meta data because it only is necessary when a child is removed, and this\n+\t * saves the memory necessary for a field on a widely used class.\n+\t */\n+\tprivate static final MetaDataKey<LinkedList<RemovedChild>> REMOVALS_KEY = new MetaDataKey<LinkedList<RemovedChild>>()\n+\t{\n+\t\tprivate static final long serialVersionUID = 1L;\n+\t};\n+\n+\t/**\n+\t * Administrative class for detecting removed children during child iteration. Not intended to\n+\t * be serializable but for e.g. determining the size of the component it has to be serializable.\n+\t */\n+\tprivate static class RemovedChild implements Serializable\n+\t{\n+\t\tprivate static final long serialVersionUID = 1L;\n+\n+\t\tprivate transient final Component removedChild;\n+\t\tprivate transient final Component previousSibling;\n+\n+\t\tprivate RemovedChild(Component removedChild, Component previousSibling)\n+\t\t{\n+\t\t\tthis.removedChild = removedChild;\n+\t\t\tthis.previousSibling = previousSibling;\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Administrative counter to keep track of modifications to the list of children during\n+\t * iteration.\n+\t * \n+\t * When the {@link #children_size()} changes due to an addition or removal of a child component,\n+\t * the modCounter is increased. This way iterators that iterate over the children of this\n+\t * container can keep track when they need to change their iteration strategy.\n+\t */\n+\tprivate transient int modCounter = 0;\n+\n \t/**\n \t * The children of this markup container, if any. Can be a Component when there's only one\n \t * child, a List when the number of children is fewer than {@link #MAPIFY_THRESHOLD} or a Map\n@@ -137,17 +178,17 @@ public MarkupContainer(final String id, IModel<?> model)\n \t}\n \n \t/**\n-\t * Adds a child component to this container.\n+\t * Adds the child component(s) to this container.\n \t * \n-\t * @param childs\n+\t * @param children\n \t *            The child(ren) to add.\n \t * @throws IllegalArgumentException\n \t *             Thrown if a child with the same id is replaced by the add operation.\n \t * @return This\n \t */\n-\tpublic MarkupContainer add(final Component... childs)\n+\tpublic MarkupContainer add(final Component... children)\n \t{\n-\t\tfor (Component child : childs)\n+\t\tfor (Component child : children)\n \t\t{\n \t\t\tArgs.notNull(child, \"child\");\n \n@@ -185,16 +226,9 @@ public MarkupContainer add(final Component... childs)\n \t\t\t\tlog.debug(\"Add \" + child.getId() + \" to \" + this);\n \t\t\t}\n \n-\t\t\t// remove child from existing parent\n-\t\t\tparent = child.getParent();\n-\t\t\tif (parent != null)\n-\t\t\t{\n-\t\t\t\tparent.remove(child);\n-\t\t\t}\n-\n-\t\t\t// Add the child to my children \n-\t\t\tComponent previousChild = put(child);\n-\t\t\tif (previousChild != null)\n+\t\t\t// Add the child to my children\n+\t\t\tComponent previousChild = children_put(child);\n+\t\t\tif (previousChild != null && previousChild != child)\n \t\t\t{\n \t\t\t\tthrow new IllegalArgumentException(\n \t\t\t\t\texceptionMessage(\"A child '\" + previousChild.getClass().getSimpleName() +\n@@ -211,13 +245,13 @@ public MarkupContainer add(final Component... childs)\n \t * Replaces a child component of this container with another or just adds it in case no child\n \t * with the same id existed yet.\n \t * \n-\t * @param childs\n-\t *            The child(s) to be added or replaced\n-\t * @return This\n+\t * @param children\n+\t *            The child(ren) to be added or replaced\n+\t * @return this markup container\n \t */\n-\tpublic MarkupContainer addOrReplace(final Component... childs)\n+\tpublic MarkupContainer addOrReplace(final Component... children)\n \t{\n-\t\tfor (Component child : childs)\n+\t\tfor (Component child : children)\n \t\t{\n \t\t\tArgs.notNull(child, \"child\");\n \n@@ -273,12 +307,12 @@ public final boolean autoAdd(final Component component, MarkupStream markupStrea\n \t\t// that's all what most auto-components need. Unfortunately child.onDetach() will not / can\n \t\t// not be invoked, since the parent doesn't known its one of his children. Hence we need to\n \t\t// properly add it.\n-\t\tchildren_remove(component);\n+\t\tchildren_remove(component.getId());\n \t\tadd(component);\n-\t\t\n+\n \t\treturn true;\n \t}\n-\t\n+\n \t/**\n \t * @param component\n \t *            The component to check\n@@ -452,14 +486,14 @@ public Markup getAssociatedMarkup()\n \t}\n \n \t/**\n-\t * Get the childs markup\n+\t * Get the markup of the child.\n \t * \n \t * @see Component#getMarkup()\n \t * \n \t * @param child\n \t *            The child component. If null, the container's markup will be returned. See Border,\n \t *            Panel or Enclosure where getMarkup(null) != getMarkup().\n-\t * @return The childs markup\n+\t * @return The child's markup\n \t */\n \tpublic IMarkupFragment getMarkup(final Component child)\n \t{\n@@ -468,12 +502,12 @@ public IMarkupFragment getMarkup(final Component child)\n \t}\n \n \t/**\n-\t * Get the type of associated markup for this component.\n+\t * Get the type of associated markup for this component. The markup type for a component is\n+\t * independent of whether or not the component actually has an associated markup resource file\n+\t * (which is determined at runtime).\n \t * \n \t * @return The type of associated markup for this component (for example, \"html\", \"wml\" or\n-\t *         \"vxml\"). The markup type for a component is independent of whether or not the\n-\t *         component actually has an associated markup resource file (which is determined at\n-\t *         runtime). If there is no markup type for a component, null may be returned, but this\n+\t *         \"vxml\"). If there is no markup type for a component, null may be returned, but this\n \t *         means that no markup can be loaded for the class. Null is also returned if the\n \t *         component, or any of its parents, has not been added to a Page.\n \t */\n@@ -505,52 +539,128 @@ public void internalAdd(final Component child)\n \t\t}\n \n \t\t// Add to map\n-\t\tput(child);\n+\t\tchildren_put(child);\n \t\taddedComponent(child);\n \t}\n \n \t/**\n+\t * Gives an iterator that allow you to iterate through the children of this markup container in\n+\t * the order the children were added. The iterator supports additions and removals from the list\n+\t * of children during iteration.\n+\t * \n \t * @return Iterator that iterates through children in the order they were added\n \t */\n \t@Override\n-\t@SuppressWarnings(\"unchecked\")\n \tpublic Iterator<Component> iterator()\n \t{\n-\t\treturn new Iterator<Component>()\n-\t\t{\n-\t\t\tComponent currentComponent = null;\n-\t\t\tIterator<Component> internalIterator = copyChildren().iterator();\n+\t\t/**\n+\t\t * Iterator that knows how to change between a single child, list of children and map of\n+\t\t * children. Keeps track when the iterator was last sync'd with the markup container's\n+\t\t * tracking of changes to the list of children.\n+\t\t */\n+\t\tclass MarkupChildIterator implements Iterator<Component>\n+\t\t{\n+\t\t\tprivate int indexInRemovalsSinceLastUpdate = removals_size();\n+\t\t\tprivate int expectedModCounter = -1;\n+\t\t\tprivate Component currentComponent = null;\n+\t\t\tprivate Iterator<Component> internalIterator = null;\n \n \t\t\t@Override\n \t\t\tpublic boolean hasNext()\n \t\t\t{\n+\t\t\t\trefreshInternalIteratorIfNeeded();\n \t\t\t\treturn internalIterator.hasNext();\n \t\t\t}\n \n \t\t\t@Override\n \t\t\tpublic Component next()\n \t\t\t{\n+\t\t\t\trefreshInternalIteratorIfNeeded();\n \t\t\t\treturn currentComponent = internalIterator.next();\n \t\t\t}\n \n \t\t\t@Override\n \t\t\tpublic void remove()\n \t\t\t{\n-\t\t\t\tif (children instanceof Component)\n+\t\t\t\tMarkupContainer.this.remove(currentComponent);\n+\t\t\t\trefreshInternalIteratorIfNeeded();\n+\t\t\t}\n+\n+\t\t\tprivate void refreshInternalIteratorIfNeeded()\n+\t\t\t{\n+\t\t\t\tif (modCounter != 0 && expectedModCounter >= modCounter)\n+\t\t\t\t\treturn;\n+\n+\t\t\t\tif (children == null)\n+\t\t\t\t{\n+\t\t\t\t\tinternalIterator = Collections.emptyIterator();\n+\t\t\t\t}\n+\t\t\t\telse if (children instanceof Component)\n+\t\t\t\t{\n+\t\t\t\t\tinternalIterator = Collections.singleton((Component)children).iterator();\n+\t\t\t\t}\n+\t\t\t\telse if (children instanceof List)\n \t\t\t\t{\n-\t\t\t\t\tchildren = null;\n+\t\t\t\t\tList<Component> childrenList = children();\n+\t\t\t\t\tinternalIterator = childrenList.iterator();\n \t\t\t\t}\n \t\t\t\telse\n \t\t\t\t{\n-\t\t\t\t\tinternalIterator.remove();\n+\t\t\t\t\tMap<String, Component> childrenMap = children();\n+\t\t\t\t\tinternalIterator = childrenMap.values().iterator();\n+\t\t\t\t}\n+\n+\t\t\t\t// since we now have a new iterator, we need to set it to the last known position\n+\t\t\t\tcurrentComponent = findLastExistingChildAlreadyReturned(currentComponent);\n+\t\t\t\texpectedModCounter = modCounter;\n+\t\t\t\tindexInRemovalsSinceLastUpdate = removals_size();\n+\n+\t\t\t\tif (currentComponent != null)\n+\t\t\t\t{\n+\t\t\t\t\t// move the new internal iterator to the place of the last processed component\n+\t\t\t\t\twhile (internalIterator.hasNext() &&\n+\t\t\t\t\t\tinternalIterator.next() != currentComponent)\n+\t\t\t\t\t\t// noop\n+\t\t\t\t\t\t;\n+\t\t\t\t}\n+\t\t\t}\n+\n+\t\t\tprivate Component findLastExistingChildAlreadyReturned(Component target)\n+\t\t\t{\n+\t\t\t\twhile (true)\n+\t\t\t\t{\n+\t\t\t\t\tif (target == null)\n+\t\t\t\t\t\treturn null;\n+\n+\t\t\t\t\tRemovedChild removedChild = null;\n+\t\t\t\t\tfor (int i = indexInRemovalsSinceLastUpdate; i < removals_size(); i++)\n+\t\t\t\t\t{\n+\t\t\t\t\t\tRemovedChild curRemovedChild = removals_get(i);\n+\t\t\t\t\t\tif (curRemovedChild.removedChild == target ||\n+\t\t\t\t\t\t\tcurRemovedChild.removedChild == null)\n+\t\t\t\t\t\t{\n+\t\t\t\t\t\t\tremovedChild = curRemovedChild;\n+\t\t\t\t\t\t\tbreak;\n+\t\t\t\t\t\t}\n+\t\t\t\t\t}\n+\t\t\t\t\tif (removedChild == null)\n+\t\t\t\t\t{\n+\t\t\t\t\t\treturn target;\n+\t\t\t\t\t}\n+\t\t\t\t\telse\n+\t\t\t\t\t{\n+\t\t\t\t\t\ttarget = removedChild.previousSibling;\n+\t\t\t\t\t}\n \t\t\t\t}\n-\t\t\t\tcheckHierarchyChange(currentComponent);\n-\t\t\t\tremovedComponent(currentComponent);\n \t\t\t}\n \t\t};\n+\t\treturn new MarkupChildIterator();\n \t}\n \n \t/**\n+\t * Creates an iterator that iterates over children in the order specified by comparator. This\n+\t * works on a copy of the children list.\n+\t * \n \t * @param comparator\n \t *            The comparator\n \t * @return Iterator that iterates over children in the order specified by comparator\n@@ -563,6 +673,8 @@ public final Iterator<Component> iterator(Comparator<Component> comparator)\n \t}\n \n \t/**\n+\t * Removes a component from the children identified by the {@code component.getId()}\n+\t * \n \t * @param component\n \t *            Component to remove from this container\n \t * @return {@code this} for chaining\n@@ -573,7 +685,7 @@ public MarkupContainer remove(final Component component)\n \n \t\tArgs.notNull(component, \"component\");\n \n-\t\tchildren_remove(component);\n+\t\tchildren_remove(component.getId());\n \t\tremovedComponent(component);\n \n \t\treturn this;\n@@ -618,7 +730,7 @@ public MarkupContainer removeAll()\n \t\t{\n \t\t\taddStateChange();\n \n-\t\t\tfor (Component child: this)\n+\t\t\tfor (Component child : this)\n \t\t\t{\n \t\t\t\t// Do not call remove() because the state change would then be\n \t\t\t\t// recorded twice.\n@@ -628,6 +740,7 @@ public MarkupContainer removeAll()\n \t\t\t}\n \n \t\t\tchildren = null;\n+\t\t\tremovals_add(null, null);\n \t\t}\n \n \t\treturn this;\n@@ -719,8 +832,7 @@ public MarkupContainer replace(final Component child)\n \n \t\tif (child.getParent() != this)\n \t\t{\n-\t\t\t// Get the child component to replace\n-\t\t\tfinal Component replaced = children_get(child.getId());\n+\t\t\tfinal Component replaced = children_put(child);\n \n \t\t\t// Look up to make sure it was already in the map\n \t\t\tif (replaced == null)\n@@ -729,10 +841,7 @@ public MarkupContainer replace(final Component child)\n \t\t\t\t\texceptionMessage(\"Cannot replace a component which has not been added: id='\" +\n \t\t\t\t\t\tchild.getId() + \"', component=\" + child));\n \t\t\t}\n-\t\t\t\n-\t\t\t// Add to map\n-\t\t\tput(child);\n-\t\t\t\n+\n \t\t\t// first remove the component.\n \t\t\tremovedComponent(replaced);\n \n@@ -881,7 +990,7 @@ private void addedComponent(final Component child)\n \t\tArgs.notNull(child, \"child\");\n \n \t\tMarkupContainer parent = child.getParent();\n-\t\tif (parent != null)\n+\t\tif (parent != null && parent != this)\n \t\t{\n \t\t\tparent.remove(child);\n \t\t}\n@@ -957,91 +1066,147 @@ public void component(final Component component, final IVisit<Void> visit)\n \t\t});\n \t}\n \n+\t/*\n+\t * === Internal management for keeping track of child components ===\n+\t * \n+\t * A markup container is the base component for containing child objects. It is one of the most\n+\t * heavily used components so we should keep it's (memory and CPU) footprint small.\n+\t * \n+\t * The goals for the internal management of the list of child components are:\n+\t * \n+\t * - as low big-O complexity as possible, preferrably O(1)\n+\t * \n+\t * - as low memory consumption as possible (don't use more memory than strictly necessary)\n+\t * \n+\t * - ensure that iterating through the (list of) children be as consistent as possible\n+\t * \n+\t * - retain the order of addition in the iteration\n+\t * \n+\t * These goals are attained by storing the children in a single field that is implemented using:\n+\t * \n+\t * - a component when there's only one child\n+\t * \n+\t * - a list of components when there are more than 1 children\n+\t * \n+\t * - a map of components when the number of children makes looking up children by id more costly\n+\t * than an indexed search (see MAPIFY_THRESHOLD)\n+\t * \n+\t * To ensure that iterating through the list of children keeps working even when children are\n+\t * added, replaced and removed without throwing a ConcurrentModificationException a special\n+\t * iterator is used. The markup container tracks removals from and additions to the children\n+\t * during the request, enabling the iterator to skip over those items and adjust to changing\n+\t * internal data structures.\n+\t */\n+\n \t/**\n+\t * A type washing accessor method for getting the children without having to cast the field\n+\t * explicitly.\n \t * \n-\t * @param id\n-\t * @return The child component\n+\t * @return the children as a T\n \t */\n \t@SuppressWarnings(\"unchecked\")\n-\tprivate Component children_get(final String id)\n+\tprivate <T> T children()\n+\t{\n+\t\treturn (T)children;\n+\t}\n+\n+\t/**\n+\t * Gets the child with the given {@code childId}\n+\t * \n+\t * @param childId\n+\t *            the component identifier\n+\t * @return The child component or {@code null} when no child with the given identifier exists\n+\t */\n+\tprivate Component children_get(final String childId)\n \t{\n \t\tif (children == null)\n \t\t{\n \t\t\treturn null;\n \t\t}\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\treturn ((Component)children).getId().equals(id) ? (Component)children : null;\n+\t\t\tComponent child = children();\n+\t\t\treturn child.getId().equals(childId) ? child : null;\n \t\t}\n \t\tif (children instanceof List)\n \t\t{\n-\t\t\tfor (Component child : (List<Component>)children)\n+\t\t\tList<Component> kids = children();\n+\t\t\tfor (Component child : kids)\n \t\t\t{\n-\t\t\t\tif (child.getId().equals(id))\n+\t\t\t\tif (child.getId().equals(childId))\n \t\t\t\t{\n \t\t\t\t\treturn child;\n \t\t\t\t}\n \t\t\t}\n \t\t\treturn null;\n \t\t}\n-\t\treturn ((Map<String, Component>)children).get(id);\n+\t\tMap<String, Component> kids = children();\n+\t\treturn kids.get(childId);\n \t}\n \n \t/**\n+\t * Removes the child component identified by {@code childId} from the list of children.\n \t * \n-\t * @param component\n-\t * @return The component that is removed.\n+\t * Will change the internal list or map to a single component when the number of children hits\n+\t * 1, but not change the internal map to a list when the threshold is reached (the memory was\n+\t * already claimed, so there's little to be gained other than wasting CPU cycles for the\n+\t * conversion).\n+\t * \n+\t * @param childId\n+\t *            the id of the child component to remove\n \t */\n-\tprivate Component children_remove(Component component)\n+\tprivate void children_remove(String childId)\n \t{\n-\t\tif (children == null)\n-\t\t{\n-\t\t\treturn null;\n-\t\t}\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tif (((Component)children).getId().equals(component.getId()))\n+\t\t\tComponent oldChild = children();\n+\t\t\tif (oldChild.getId().equals(childId))\n \t\t\t{\n-\t\t\t\tComponent oldChild = (Component)children;\n \t\t\t\tchildren = null;\n-\t\t\t\treturn oldChild;\n+\t\t\t\tremovals_add(oldChild, null);\n \t\t\t}\n-\t\t\treturn null;\n \t\t}\n-\t\tif (children instanceof List)\n+\t\telse if (children instanceof List)\n \t\t{\n-\t\t\t@SuppressWarnings(\"unchecked\")\n-\t\t\tList<Component> childrenList = (List<Component>)children;\n+\t\t\tList<Component> childrenList = children();\n \t\t\tIterator<Component> it = childrenList.iterator();\n+\t\t\tComponent prevChild = null;\n \t\t\twhile (it.hasNext())\n \t\t\t{\n \t\t\t\tComponent child = it.next();\n-\t\t\t\tif (child.getId().equals(component.getId()))\n+\t\t\t\tif (child.getId().equals(childId))\n \t\t\t\t{\n \t\t\t\t\tit.remove();\n+\t\t\t\t\tremovals_add(child, prevChild);\n \t\t\t\t\tif (childrenList.size() == 1)\n \t\t\t\t\t{\n \t\t\t\t\t\tchildren = childrenList.get(0);\n \t\t\t\t\t}\n-\t\t\t\t\treturn child;\n+\t\t\t\t\treturn;\n \t\t\t\t}\n+\t\t\t\tprevChild = child;\n \t\t\t}\n-\t\t\treturn null;\n \t\t}\n-\n-\t\t@SuppressWarnings(\"unchecked\")\n-\t\tMap<String, Component> childrenMap = (Map<String, Component>)children;\n-\t\tComponent oldChild = childrenMap.remove(component.getId());\n-\t\tif (childrenMap.size() == 1)\n+\t\telse if (children instanceof LinkedMap)\n \t\t{\n-\t\t\tchildren = childrenMap.values().iterator().next();\n+\t\t\tLinkedMap<String, Component> childrenMap = children();\n+\t\t\tif (childrenMap.containsKey(childId))\n+\t\t\t{\n+\t\t\t\tString prevSiblingId = childrenMap.previousKey(childId);\n+\t\t\t\tComponent oldChild = childrenMap.remove(childId);\n+\t\t\t\tremovals_add(oldChild, childrenMap.get(prevSiblingId));\n+\t\t\t\tif (childrenMap.size() == 1)\n+\t\t\t\t{\n+\t\t\t\t\tchildren = childrenMap.values().iterator().next();\n+\t\t\t\t}\n+\t\t\t}\n \t\t}\n-\t\treturn oldChild;\n \t}\n \n \t/**\n+\t * Gets the number of child components of this markup container.\n \t * \n-\t * @return The size of the children\n+\t * @return The number of children\n \t */\n \tprivate int children_size()\n \t{\n@@ -1055,47 +1220,70 @@ private int children_size()\n \t\t}\n \t\tif (children instanceof List)\n \t\t{\n-\t\t\treturn ((List<?>)children).size();\n+\t\t\tList<?> kids = children();\n+\t\t\treturn kids.size();\n \t\t}\n \t\treturn ((Map<?, ?>)children).size();\n \t}\n \n \t/**\n-\t * Ensure that there is space in childForId map for a new entry before adding it.\n+\t * Puts the {@code child} component into the list of children of this markup container. If a\n+\t * component existed with the same {@code child.getId()} it is replaced and the old component is\n+\t * returned.\n+\t * \n+\t * When a component is replaced, the internal structure of the children is not modified, so we\n+\t * don't have to update the internal {@link #modCounter} in those circumstances. When a\n+\t * component is added, we do have to increase the {@link #modCounter} to notify iterators of\n+\t * this change.\n \t * \n \t * @param child\n-\t *            The child to put into the map\n+\t *            The child\n \t * @return Any component that was replaced\n \t */\n-\t@SuppressWarnings(\"unchecked\")\n-\tprivate Component put(final Component child)\n+\tprivate Component children_put(final Component child)\n \t{\n \t\tif (children == null)\n \t\t{\n \t\t\tchildren = child;\n+\n+\t\t\t// it is an addtion, so we need to notify the iterators of this change.\n+\t\t\tmodCounter++;\n+\n \t\t\treturn null;\n \t\t}\n+\n \t\tif (children instanceof Component)\n \t\t{\n-\t\t\tComponent oldChild = (Component)children;\n+\t\t\t/* first see if the child replaces the existing child */\n+\t\t\tComponent oldChild = children();\n \t\t\tif (oldChild.getId().equals(child.getId()))\n \t\t\t{\n \t\t\t\tchildren = child;\n \t\t\t\treturn oldChild;\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tComponent originalChild = (Component)children;\n+\t\t\t\t/*\n+\t\t\t\t * the put doesn't replace the existing child, so we need to increase the children\n+\t\t\t\t * storage to a list and add the existing and new child to it\n+\t\t\t\t */\n+\t\t\t\tComponent originalChild = children();\n \t\t\t\tList<Component> newChildren = new ArrayList<>(INITIAL_CHILD_LIST_CAPACITY);\n \t\t\t\tnewChildren.add(originalChild);\n \t\t\t\tnewChildren.add(child);\n \t\t\t\tchildren = newChildren;\n+\n+\t\t\t\t// it is an addtion, so we need to notify the iterators of this change.\n+\t\t\t\tmodCounter++;\n \t\t\t\treturn null;\n \t\t\t}\n \t\t}\n+\n \t\tif (children instanceof List)\n \t\t{\n-\t\t\tList<Component> childrenList = (List<Component>)children;\n+\t\t\tList<Component> childrenList = children();\n+\n+\t\t\t// first see if the child replaces an existing child\n \t\t\tfor (int i = 0; i < childrenList.size(); i++)\n \t\t\t{\n \t\t\t\tComponent curChild = childrenList.get(i);\n@@ -1104,13 +1292,21 @@ private Component put(final Component child)\n \t\t\t\t\treturn childrenList.set(i, child);\n \t\t\t\t}\n \t\t\t}\n+\n+\t\t\t// it is an addtion, so we need to notify the iterators of this change.\n+\t\t\tmodCounter++;\n+\n+\t\t\t/*\n+\t\t\t * If it still fits in the allotted number of items of a List, just add it, otherwise\n+\t\t\t * change the internal data structure to a Map for speedier lookups.\n+\t\t\t */\n \t\t\tif (childrenList.size() < MAPIFY_THRESHOLD)\n \t\t\t{\n \t\t\t\tchildrenList.add(child);\n \t\t\t}\n \t\t\telse\n \t\t\t{\n-\t\t\t\tMap<String, Component> newChildren = new LinkedHashMap<>(MAPIFY_THRESHOLD * 2);\n+\t\t\t\tMap<String, Component> newChildren = new LinkedMap<>(MAPIFY_THRESHOLD * 2);\n \t\t\t\tfor (Component curChild : childrenList)\n \t\t\t\t{\n \t\t\t\t\tnewChildren.put(curChild.getId(), curChild);\n@@ -1120,7 +1316,92 @@ private Component put(final Component child)\n \t\t\t}\n \t\t\treturn null;\n \t\t}\n-\t\treturn ((Map<String, Component>)children).put(child.getId(), child);\n+\n+\t\tMap<String, Component> childrenMap = children();\n+\t\tComponent oldChild = childrenMap.put(child.getId(), child);\n+\n+\t\tif (oldChild == null)\n+\t\t{\n+\t\t\t// it is an addtion, so we need to notify the iterators of this change.\n+\t\t\tmodCounter++;\n+\t\t}\n+\t\treturn oldChild;\n+\t}\n+\n+\t/**\n+\t * Retrieves the during the request removed children. These are stored in the metadata and\n+\t * cleared at the end of the request {@link #onDetach()}\n+\t * \n+\t * @return the list of removed children, may be {@code null}\n+\t */\n+\tprivate LinkedList<RemovedChild> removals_get()\n+\t{\n+\t\treturn getMetaData(REMOVALS_KEY);\n+\t}\n+\n+\t/**\n+\t * Sets the during the request removed children. These are stored in the metadata and cleared at\n+\t * the end of the request, see {@link #onDetach()}.\n+\t * \n+\t * @param removals\n+\t *            the new list of removals\n+\t */\n+\tprivate void removals_set(LinkedList<RemovedChild> removals)\n+\t{\n+\t\tsetMetaData(REMOVALS_KEY, removals);\n+\t}\n+\n+\t/**\n+\t * Removes the list of removals from the metadata.\n+\t */\n+\tprivate void removals_clear()\n+\t{\n+\t\tsetMetaData(REMOVALS_KEY, null);\n+\t}\n+\n+\t/**\n+\t * Adds the {@code removedChild} to the list of removals and links it to the\n+\t * {@code previousSibling}\n+\t * \n+\t * @param removedChild\n+\t *            the child that was removed\n+\t * @param prevSibling\n+\t *            the child that was the previous sibling of the removed child\n+\t */\n+\tprivate void removals_add(Component removedChild, Component prevSibling)\n+\t{\n+\t\tmodCounter++;\n+\n+\t\tLinkedList<RemovedChild> removals = removals_get();\n+\t\tif (removals == null)\n+\t\t{\n+\t\t\tremovals = new LinkedList<>();\n+\t\t\tremovals_set(removals);\n+\t\t}\n+\t\tremovals.add(new RemovedChild(removedChild, prevSibling));\n+\t}\n+\n+\t/**\n+\t * Gets the {@link RemovedChild} from the list of removals at given position.\n+\t * \n+\t * @param i\n+\t *            the position\n+\t * @return the removed child\n+\t */\n+\tprivate RemovedChild removals_get(int i)\n+\t{\n+\t\treturn getMetaData(REMOVALS_KEY).get(i);\n+\t}\n+\n+\t/**\n+\t * Gets the number of removals that happened during the request.\n+\t * \n+\t * @return the number of removals\n+\t */\n+\tprivate int removals_size()\n+\t{\n+\t\tLinkedList<RemovedChild> removals = removals_get();\n+\t\treturn removals == null ? 0 : removals.size();\n \t}\n \n \t/**\n@@ -1135,7 +1416,7 @@ private void removedComponent(final Component component)\n \t\t{\n \t\t\tpage.componentRemoved(component);\n \t\t}\n-\t\t\n+\n \t\tcomponent.detach();\n \n \t\tcomponent.internalOnRemove();\n@@ -1181,7 +1462,7 @@ else if (component != null)\n \t\t\t\t\tcomponent.setMarkup(markupStream.getMarkupFragment());\n \t\t\t\t}\n \t\t\t}\n-\n+\t\t\n \t\t\t// Failed to find it?\n \t\t\tif (component != null)\n \t\t\t{\n@@ -1551,6 +1832,9 @@ protected void onDetach()\n \t{\n \t\tsuper.onDetach();\n \n+\t\tmodCounter = 0;\n+\t\tremovals_clear();\n+\n \t\tif (queue != null && !queue.isEmpty())\n \t\t{\n \t\t\tthrow new WicketRuntimeException("
        },
        {
            "sha": "aba21485ed145b3c0a3a26ad723d74d31aa731e9",
            "filename": "wicket-core/src/test/java/org/apache/wicket/MarkupContainerTest.java",
            "status": "modified",
            "additions": 1065,
            "deletions": 20,
            "changes": 1085,
            "blob_url": "https://github.com/apache/wicket/blob/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainerTest.java",
            "raw_url": "https://github.com/apache/wicket/raw/9f8f2f2f5f7df873061679c80edd151c94afdd38/wicket-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainerTest.java",
            "contents_url": "https://api.github.com/repos/apache/wicket/contents/wicket-core%2Fsrc%2Ftest%2Fjava%2Forg%2Fapache%2Fwicket%2FMarkupContainerTest.java?ref=9f8f2f2f5f7df873061679c80edd151c94afdd38",
            "patch": "@@ -16,22 +16,39 @@\n  */\n package org.apache.wicket;\n \n+import static org.hamcrest.CoreMatchers.equalToObject;\n+import static org.hamcrest.CoreMatchers.instanceOf;\n+import static org.hamcrest.CoreMatchers.is;\n+import static org.hamcrest.CoreMatchers.not;\n+import static org.hamcrest.CoreMatchers.nullValue;\n+import static org.hamcrest.CoreMatchers.sameInstance;\n+import static org.hamcrest.Matchers.greaterThanOrEqualTo;\n+\n+import java.lang.reflect.Field;\n+import java.util.ConcurrentModificationException;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Random;\n+\n+import org.apache.commons.collections4.map.LinkedMap;\n+import org.apache.wicket.core.util.lang.WicketObjects;\n import org.apache.wicket.markup.IMarkupResourceStreamProvider;\n import org.apache.wicket.markup.html.WebComponent;\n import org.apache.wicket.markup.html.WebMarkupContainer;\n import org.apache.wicket.markup.html.WebPage;\n+import org.apache.wicket.markup.html.basic.Label;\n+import org.apache.wicket.markup.html.panel.EmptyPanel;\n import org.apache.wicket.util.resource.IResourceStream;\n import org.apache.wicket.util.resource.StringResourceStream;\n import org.apache.wicket.util.tester.WicketTestCase;\n+import org.junit.Assert;\n import org.junit.Test;\n \n-\n-/**\n- * \n- * @author Juergen Donnerstag\n- */\n+@SuppressWarnings({ \"javadoc\", \"serial\" })\n public class MarkupContainerTest extends WicketTestCase\n {\n+\tprivate static final int NUMBER_OF_CHILDREN_FOR_A_MAP = MarkupContainer.MAPIFY_THRESHOLD + 1;\n+\n \t/**\n \t * Make sure components are iterated in the order they were added. Required e.g. for Repeaters\n \t */\n@@ -50,18 +67,12 @@ public void iteratorOrder()\n \t\t}\n \t}\n \n-\t/**\n-\t * @throws Exception\n-\t */\n \t@Test\n \tpublic void markupId() throws Exception\n \t{\n \t\texecuteTest(MarkupIdTestPage.class, \"MarkupIdTestPageExpectedResult.html\");\n \t}\n \n-\t/**\n-\t * \n-\t */\n \t@Test\n \tpublic void get()\n \t{\n@@ -125,9 +136,12 @@ public void addMyself()\n \tpublic void rerenderAfterRenderFailure()\n \t{\n \t\tFirstRenderFailsPage page = new FirstRenderFailsPage();\n-\t\ttry {\n+\t\ttry\n+\t\t{\n \t\t\ttester.startPage(page);\n-\t\t} catch (WicketRuntimeException expected) {\n+\t\t}\n+\t\tcatch (WicketRuntimeException expected)\n+\t\t{\n \t\t}\n \n \t\ttester.startPage(page);\n@@ -204,23 +218,27 @@ public IResourceStream getMarkupResourceStream(MarkupContainer container,\n \t\t}\n \t}\n \n-\tprivate static class FirstRenderFailsPage extends WebPage\timplements IMarkupResourceStreamProvider\n+\tprivate static class FirstRenderFailsPage extends WebPage\n+\t\timplements\n+\t\t\tIMarkupResourceStreamProvider\n \t{\n \t\tprivate boolean firstRender = true;\n \n \t\tprivate int beforeRenderCalls = 0;\n \n \t\tprivate FirstRenderFailsPage()\n \t\t{\n-\n-\t\t\tWebMarkupContainer a1 = new WebMarkupContainer(\"a1\") {\n+\t\t\tWebMarkupContainer a1 = new WebMarkupContainer(\"a1\")\n+\t\t\t{\n \t\t\t\t@Override\n-\t\t\t\tprotected void onBeforeRender() {\n+\t\t\t\tprotected void onBeforeRender()\n+\t\t\t\t{\n \t\t\t\t\tsuper.onBeforeRender();\n \n \t\t\t\t\tbeforeRenderCalls++;\n \n-\t\t\t\t\tif (firstRender) {\n+\t\t\t\t\tif (firstRender)\n+\t\t\t\t\t{\n \t\t\t\t\t\tfirstRender = false;\n \t\t\t\t\t\tthrow new WicketRuntimeException();\n \t\t\t\t\t}\n@@ -233,8 +251,1035 @@ protected void onBeforeRender() {\n \t\tpublic IResourceStream getMarkupResourceStream(MarkupContainer container,\n \t\t\tClass<?> containerClass)\n \t\t{\n-\t\t\treturn new StringResourceStream(\n-\t\t\t\t\"<html><body><div wicket:id='a1'></div></body></html>\");\n+\t\t\treturn new StringResourceStream(\"<html><body><div wicket:id='a1'></div></body></html>\");\n \t\t}\n \t}\n+\n+\n+\t/*\n+\t * Iterator tests\n+\t * \n+\t * The tests below are specific for testing addition and removal of children while maintaining\n+\t * the correct order of iterators without throwing ConcurrentModificationException.\n+\t */\n+\n+\t@Test\n+\tpublic void noChildShouldNotIterate()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddingChildAfterIteratorAcquiredShouldIterateAndReturnNewChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\twmc.add(label1);\n+\n+\t\tassertThat(wmc.size(), is(1));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddingNChildrenAfterIteratorAcquiredShouldIterateAndReturnNewChildren()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tassertThat(wmc.size(), is(NUMBER_OF_CHILDREN_FOR_A_MAP));\n+\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\twmc.add(label1);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\n+\t\ttakeNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddingNChildrenAfterIteratorAcquiredShouldIterateAndReturnNewChildren2()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tassertThat(wmc.size(), is(NUMBER_OF_CHILDREN_FOR_A_MAP));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\ttakeNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\twmc.add(label1);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddingAndRemoveChildAfterIteratorAcquiredShouldNotIterate()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.add(label1);\n+\t\twmc.remove(label1);\n+\n+\t\tassertThat(wmc.size(), is(0));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void addingNewChildAfterIterationHasStartedShouldIterateNewChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\t// add one child\n+\t\taddNChildren(wmc, 1);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\t// iterate\n+\t\ttakeNChildren(iterator, 1);\n+\n+\t\t// there are no more children to iterate\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\n+\t\t// add the new child\n+\t\tLabel newChild = new Label(\"label1\", \"Label1\");\n+\t\twmc.add(newChild);\n+\n+\t\tassertThat(wmc.size(), is(2));\n+\n+\t\t// ensure that the newChild is up next (as it was added)\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(newChild)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void replacingTheFirstChildAfterIteratingDoesntIterateTheNewChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\tComponent label2 = new Label(\"label2\", \"Label2\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\t\twmc.add(label1);\n+\t\twmc.add(label2);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\ttakeNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\titerator.next();\n+\n+\t\t// replace the first child **after** we already passed the child with the iterator\n+\t\tLabel newChild = new Label(\"label1\", \"newChild\");\n+\t\twmc.replace(newChild);\n+\n+\t\t// the next child is still label 2\n+\t\tassertThat(iterator.next(), is(sameInstance(label2)));\n+\n+\t\t// and the new child is not iterated (was replaced before the current position of the\n+\t\t// iterator).\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void removingComponentsDuringIterationDoesntFail()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tComponent label1 = new Label(\"label1\", \"Label1\");\n+\t\tComponent label2 = new Label(\"label2\", \"Label2\");\n+\t\tComponent label3 = new Label(\"label3\", \"Label3\");\n+\t\tComponent label4 = new Label(\"label4\", \"Label4\");\n+\t\tComponent label5 = new Label(\"label5\", \"Label5\");\n+\n+\t\twmc.add(label1);\n+\t\twmc.add(label2);\n+\t\twmc.add(label3);\n+\t\twmc.add(label4);\n+\t\twmc.add(label5);\n+\n+\t\t// start iterating the 5 children\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tassertThat(iterator.next(), is(sameInstance(label1)));\n+\t\tassertThat(iterator.next(), is(sameInstance(label2)));\n+\t\tassertThat(iterator.next(), is(sameInstance(label3)));\n+\n+\t\t// remove the current, previous and next children\n+\t\twmc.remove(label3);\n+\t\twmc.remove(label2);\n+\t\twmc.remove(label4);\n+\n+\t\t// ensure that the next iterated child is the 5th label\n+\t\tassertThat(iterator.next(), is(sameInstance(label5)));\n+\n+\t\t// and that there are no more children to iterate\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void childrenBecomesListWhenMoreThanOneChild() throws Exception\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, 5);\n+\n+\t\tField childrenField = MarkupContainer.class.getDeclaredField(\"children\");\n+\t\tchildrenField.setAccessible(true);\n+\t\tObject field = childrenField.get(wmc);\n+\t\tassertThat(field, is(instanceOf(List.class)));\n+\t}\n+\n+\t@Test\n+\tpublic void childrenListBecomesMapWhenThresholdPassed() throws Exception\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP - 1);\n+\t\tassertChildrenType(wmc, List.class);\n+\n+\t\taddNChildren(wmc, 1);\n+\t\tassertChildrenType(wmc, LinkedMap.class);\n+\t}\n+\n+\t@Test\n+\tpublic void childrenBecomesLinkedMapWhenThresholdPassed() throws Exception\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP + 1);\n+\n+\t\tassertChildrenType(wmc, LinkedMap.class);\n+\t}\n+\n+\t@Test\n+\tpublic void linkedMapChildrenBecomesChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\t\twmc.add(new EmptyPanel(\"panel\"));\n+\n+\t\tassertChildrenType(wmc, LinkedMap.class);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\t\tremoveNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tassertChildrenType(wmc, EmptyPanel.class);\n+\t}\n+\n+\t@Test\n+\tpublic void listChildrenBecomesChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP - 2);\n+\t\twmc.add(new EmptyPanel(\"panel\"));\n+\n+\t\tassertChildrenType(wmc, List.class);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\t\tremoveNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP - 2);\n+\n+\t\tassertChildrenType(wmc, EmptyPanel.class);\n+\t}\n+\n+\t@Test\n+\tpublic void geenIdee3() throws Exception\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP + 1);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tremoveNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tassertThat(iterator.hasNext(), is(true));\n+\t\tassertThat(wmc.size(), is(1));\n+\n+\t\titerator.next();\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddIterateAndRemoveChildShouldIterateChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.add(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\n+\t\twmc.remove(label1);\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddIterateAndRemoveAndAddSameChildShouldIterateChildTwice()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.add(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\n+\t\twmc.remove(label1);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\n+\t\twmc.add(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddIterateAndRemoveAndAddDifferentChildShouldIterateNewChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\tLabel label2 = new Label(\"label1\", \"Label2\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.add(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\n+\t\twmc.remove(label1);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\n+\t\twmc.add(label2);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildAddingAndReplaceChildAfterIteratorAcquiredShouldIterateAndReturnNewReplacementChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\tLabel label2 = new Label(\"label1\", \"Label2\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.add(label1);\n+\t\twmc.replace(label2);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void singleChildIterateOneChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void singleChildShouldAllowReplacingChildAfterIterationHasStarted()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tComponent label1 = new Label(\"label1\", \"Label1\");\n+\t\tComponent label2 = new Label(\"label1\", \"Label2\");\n+\n+\t\twmc.add(label1);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.replace(label2);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(sameInstance(label2)));\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void singleChildShouldAllowReplacingVisitedChildButNotRevisitReplacementChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\tLabel label2 = new Label(\"label1\", \"Label2\");\n+\t\twmc.add(label1);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(true));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\n+\t\twmc.replace(label2);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void multipleChildIteratorRetainsOrderOfAddition()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\t\twmc.add(label3 = new Label(\"label3\", \"Label3\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowAddingComponentAfterIterationStarted()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\n+\t\twmc.add(label3 = new Label(\"label3\", \"Label3\"));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowRemovingComponentAfterIterationStarted0()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\t\twmc.add(label3 = new Label(\"label3\", \"Label3\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.remove(label1);\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowRemovingComponentAfterIterationStarted1()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1 = new Label(\"label1\", \"Label1\");\n+\t\tLabel label2 = new Label(\"label2\", \"Label2\");\n+\t\tLabel label3 = new Label(\"label3\", \"Label3\");\n+\t\twmc.add(label1);\n+\t\twmc.add(label2);\n+\t\twmc.add(label3);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\twmc.remove(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowRemovingComponentAfterIterationStarted2()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\t\twmc.add(label3 = new Label(\"label3\", \"Label3\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\twmc.remove(label1);\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowRemovingComponentAfterIterationStarted3()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\t\twmc.add(label3 = new Label(\"label3\", \"Label3\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\t\twmc.remove(label1);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowReplacingComponentAfterIterationStarted0()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.replace(label3 = new Label(\"label1\", \"Label3\"));\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowReplacingComponentAfterIterationStarted1()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.replace(label3 = new Label(\"label1\", \"Label3\"));\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowReplacingComponentAfterIterationStarted()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label2)));\n+\n+\t\twmc.replace(label3 = new Label(\"label1\", \"Label3\"));\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void iteratorShouldAllowReplacingComponentAfterIterationStarted24()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\tLabel label1;\n+\t\tLabel label2;\n+\t\tLabel label3;\n+\t\twmc.add(label1 = new Label(\"label1\", \"Label1\"));\n+\t\twmc.add(label2 = new Label(\"label2\", \"Label2\"));\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label1)));\n+\n+\t\twmc.replace(label3 = new Label(\"label2\", \"Label3\"));\n+\n+\t\tAssert.assertThat(iterator.next(), is(equalToObject(label3)));\n+\n+\t\ttakeNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tAssert.assertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildLeftBehindRemoveEach()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\t\twhile (iterator.hasNext())\n+\t\t{\n+\t\t\titerator.next();\n+\t\t\titerator.remove();\n+\t\t}\n+\t\tassertThat(wmc.size(), is(0));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildLeftBehindRemoveAll()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\twmc.removeAll();\n+\n+\t\tassertThat(wmc.size(), is(0));\n+\t\tassertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void noChildLeftBehindRemoveAll2()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\titerator.next();\n+\n+\t\twmc.removeAll();\n+\n+\t\tassertThat(wmc.size(), is(0));\n+\t\tassertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void ensureSerializationDeserializationWorks()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\t\tassertThat(wmc.size(), is(NUMBER_OF_CHILDREN_FOR_A_MAP));\n+\n+\t\tassertThat(WicketObjects.cloneObject(wmc), is(not(nullValue())));\n+\n+\t\tremoveNChildren(iterator, 1);\n+\t\tassertThat(wmc.size(), is(NUMBER_OF_CHILDREN_FOR_A_MAP - 1));\n+\t\tassertThat(WicketObjects.cloneObject(wmc), is(not(nullValue())));\n+\n+\t\tremoveNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP - 2);\n+\t\tassertThat(WicketObjects.cloneObject(wmc), is(not(nullValue())));\n+\n+\t\tassertThat(wmc.size(), is(1));\n+\t\tremoveNChildren(iterator, 1);\n+\t\tassertThat(wmc.size(), is(0));\n+\t\tassertThat(WicketObjects.cloneObject(wmc), is(not(nullValue())));\n+\t}\n+\n+\t@Test\n+\tpublic void detachDuringIterationWorks()\n+\t{\n+\t\tint halfOfChildren = NUMBER_OF_CHILDREN_FOR_A_MAP / 2;\n+\t\tint numberOfRemainingChildren = halfOfChildren + NUMBER_OF_CHILDREN_FOR_A_MAP % 2;\n+\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP);\n+\n+\t\ttakeNChildren(iterator, halfOfChildren);\n+\n+\t\twmc.detach();\n+\n+\t\ttakeNChildren(iterator, numberOfRemainingChildren);\n+\n+\t\tassertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t@Test\n+\tpublic void detachDuringIterationWithRemovalsSucceeds()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\taddNChildren(wmc, 2);\n+\t\tremoveNChildren(iterator, 1);\n+\t\twmc.detach();\n+\t\ttakeNChildren(iterator, 1);\n+\n+\t\tassertThat(iterator.hasNext(), is(false));\n+\t\tassertThat(wmc.size(), is(1));\n+\t}\n+\n+\t/**\n+\t * Tests whether two iterators being used simultaneously keep correct score of where they are.\n+\t */\n+\t@Test\n+\tpublic void twoIteratorsWorkInTandem()\n+\t{\n+\t\tint n = NUMBER_OF_CHILDREN_FOR_A_MAP * 2;\n+\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, n);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\t\tIterator<Component> iterator2 = wmc.iterator();\n+\n+\t\tRandom r = new Random();\n+\n+\t\tfor (int i = 0; i < n; i++)\n+\t\t{\n+\t\t\tif (r.nextBoolean())\n+\t\t\t{\n+\t\t\t\titerator1.next();\n+\t\t\t\titerator1.remove();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\titerator2.next();\n+\t\t\t\titerator2.remove();\n+\t\t\t}\n+\t\t}\n+\n+\t\t// after 2*N removals there should not be any child left\n+\t\tassertThat(iterator1.hasNext(), is(false));\n+\t\tassertThat(iterator2.hasNext(), is(false));\n+\t}\n+\n+\t/**\n+\t * Tests removing a child when an iterator is active, followed by a detach still has the correct\n+\t * state for the iterator.\n+\t */\n+\t@Test\n+\tpublic void detachWithOneIteratorOneChild()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, 1);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\n+\t\titerator1.next();\n+\t\titerator1.remove();\n+\n+\t\twmc.detach();\n+\n+\t\tassertThat(iterator1.hasNext(), is(false));\n+\t}\n+\n+\t/**\n+\t * Tests removing and adding a component when an iterator is active, followed by a detach still\n+\t * has the correct state for the iterator.\n+\t */\n+\t@Test\n+\tpublic void detachWithOneIteratorOneChildRemovedAndAdded()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, 1);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\n+\t\titerator1.next();\n+\t\titerator1.remove();\n+\n+\t\taddNChildren(wmc, 1);\n+\n+\t\tassertThat(iterator1.hasNext(), is(true));\n+\n+\t\twmc.detach();\n+\n+\t\tassertThat(iterator1.hasNext(), is(true));\n+\t\tassertThat(iterator1.next(), is(not(nullValue())));\n+\t}\n+\n+\t/**\n+\t * Tests the case when one child is removed from a list the iterator still works after a detach.\n+\t */\n+\t@Test\n+\tpublic void detachWithOneIteratorTwoChildren()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, 2);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\n+\t\titerator1.next();\n+\t\titerator1.remove();\n+\n+\t\tassertThat(iterator1.hasNext(), is(true));\n+\n+\t\twmc.detach();\n+\n+\t\tassertThat(iterator1.hasNext(), is(true));\n+\t\tassertThat(iterator1.next(), is(not(nullValue())));\n+\t}\n+\n+\t/**\n+\t * Tests whether when the children is a list, removal and iteration still work after a detach.\n+\t */\n+\t@Test\n+\tpublic void detachWithOneIteratorWithListForChildren()\n+\t{\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, NUMBER_OF_CHILDREN_FOR_A_MAP - 2);\n+\n+\t\tassertChildrenType(wmc, List.class);\n+\n+\t\tIterator<Component> iterator = wmc.iterator();\n+\n+\t\ttakeNChildren(iterator, 1);\n+\n+\t\tremoveNChildren(iterator, 1);\n+\n+\t\twmc.detach();\n+\n+\t\ttakeNChildren(iterator, NUMBER_OF_CHILDREN_FOR_A_MAP - 4);\n+\t\tassertThat(iterator.hasNext(), is(false));\n+\t}\n+\n+\t/**\n+\t * Tests whether when the children is a map, removal and iteration still work after a detach.\n+\t */\n+\t@Test\n+\tpublic void detachWithOneIteratorsWithMapForChildren()\n+\t{\n+\t\tint n = NUMBER_OF_CHILDREN_FOR_A_MAP * 2;\n+\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, n);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\n+\t\tRandom r = new Random();\n+\n+\t\tfor (int i = 0; i < NUMBER_OF_CHILDREN_FOR_A_MAP; i++)\n+\t\t{\n+\t\t\titerator1.next();\n+\t\t\titerator1.remove();\n+\t\t}\n+\t\twmc.detach();\n+\t\tfor (int i = 0; i < NUMBER_OF_CHILDREN_FOR_A_MAP; i++)\n+\t\t{\n+\t\t\titerator1.next();\n+\t\t\titerator1.remove();\n+\t\t}\n+\t\tassertThat(iterator1.hasNext(), is(false));\n+\t}\n+\n+\t/**\n+\t * This tests a functional bug in the iterator implementation where you have multiple iterators\n+\t * traversing the children, a detach happens and one of the iterators removes a child component\n+\t * before the other iterator has a chance to update its internal state to the new world. This is\n+\t * a known bug and we expect that this doesn't pose a problem in real world usage.\n+\t */\n+\t@Test(expected = ConcurrentModificationException.class)\n+\tpublic void knownBugForDetachWithTwoIteratorsAndRemovals()\n+\t{\n+\t\tint n = NUMBER_OF_CHILDREN_FOR_A_MAP * 2;\n+\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, n);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\t\tIterator<Component> iterator2 = wmc.iterator();\n+\n+\t\tRandom r = new Random();\n+\n+\t\tfor (int i = 0; i < NUMBER_OF_CHILDREN_FOR_A_MAP; i++)\n+\t\t{\n+\t\t\tif (r.nextBoolean())\n+\t\t\t{\n+\t\t\t\titerator1.next();\n+\t\t\t\titerator1.remove();\n+\t\t\t}\n+\t\t\telse\n+\t\t\t{\n+\t\t\t\titerator2.next();\n+\t\t\t\titerator2.remove();\n+\t\t\t}\n+\t\t}\n+\t\twmc.detach();\n+\t\titerator1.next();\n+\t\titerator1.remove();\n+\n+\t\t// implementation detail that gets in the way of properly solving this exotic use case: at\n+\t\t// this moment iterator 2 doesn't know that the modification count was reset before the\n+\t\t// iterator 1 removed the component.\n+\t\titerator2.next();\n+\n+\t\t// code never reaches this point due to the ConcurrentModificationException\n+\t}\n+\n+\t/**\n+\t * This test is the working case for the above scenario where two iterators traverse the\n+\t * children, the component gets detached and in this case both iterators have a chance to update\n+\t * their internal state to the new world, before they continue to traverse the children.\n+\t */\n+\t@Test\n+\tpublic void detachWithTwoIteratorsAndRemovalsWork()\n+\t{\n+\t\tint n = NUMBER_OF_CHILDREN_FOR_A_MAP * 2;\n+\n+\t\tWebMarkupContainer wmc = new WebMarkupContainer(\"id\");\n+\t\taddNChildren(wmc, n);\n+\n+\t\tIterator<Component> iterator1 = wmc.iterator();\n+\t\tIterator<Component> iterator2 = wmc.iterator();\n+\n+\t\tRandom r = new Random();\n+\n+\t\tfor (int i = 0; i < NUMBER_OF_CHILDREN_FOR_A_MAP; i++)\n+\t\t{\n+\t\t\tIterator<Component> iterator = r.nextBoolean() ? iterator1 : iterator2;\n+\t\t\tif (iterator.hasNext())\n+\t\t\t{\n+\t\t\t\titerator.next();\n+\t\t\t\titerator.remove();\n+\t\t\t}\n+\t\t}\n+\t\twmc.detach();\n+\t\titerator1.next();\n+\t\titerator2.next();\n+\t\titerator1.remove();\n+\t\twhile (iterator1.hasNext() || iterator2.hasNext())\n+\t\t{\n+\t\t\tIterator<Component> iterator = r.nextBoolean() ? iterator1 : iterator2;\n+\t\t\tif (iterator.hasNext())\n+\t\t\t{\n+\t\t\t\titerator.next();\n+\t\t\t\titerator.remove();\n+\t\t\t}\n+\t\t}\n+\t\tassertThat(iterator1.hasNext(), is(false));\n+\t\tassertThat(iterator2.hasNext(), is(false));\n+\t}\n+\n+\t/**\n+\t * Asserts that the children property of the {@code wmc} is of a particular {@code type}.\n+\t * \n+\t * @param wmc\n+\t *            the web markup container whose children property is to be checked\n+\t * @param type\n+\t *            the expected type\n+\t */\n+\tprivate void assertChildrenType(WebMarkupContainer wmc, Class<?> type)\n+\t{\n+\t\ttry\n+\t\t{\n+\t\t\tField childrenField = MarkupContainer.class.getDeclaredField(\"children\");\n+\t\t\tchildrenField.setAccessible(true);\n+\t\t\tObject field = childrenField.get(wmc);\n+\t\t\tassertThat(field, is(instanceOf(type)));\n+\t\t}\n+\t\tcatch (Exception e)\n+\t\t{\n+\t\t\tthrow new AssertionError(\"Unable to read children\", e);\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Adds {@code numberOfChildrenToAdd} anonymous children to the {@code parent}.\n+\t * \n+\t * @param parent\n+\t *            the parent to add the children to\n+\t * @param numberOfChildrenToAdd\n+\t *            the number of children\n+\t */\n+\tprivate void addNChildren(WebMarkupContainer parent, int numberOfChildrenToAdd)\n+\t{\n+\t\tassertThat(numberOfChildrenToAdd, is(greaterThanOrEqualTo(0)));\n+\t\tint start = parent.size();\n+\t\tfor (int i = 0; i < numberOfChildrenToAdd; i++)\n+\t\t{\n+\t\t\tint index = start + i;\n+\t\t\tparent.add(new Label(\"padding\" + index, \"padding\" + index));\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Removes {@code numberOfChildrenToRemove} anonymous children from the parent using the\n+\t * {@code iterator}.\n+\t * \n+\t * @param iterator\n+\t *            the iterator to remove the children with\n+\t * @param numberOfChildrenToAdd\n+\t *            the number of children\n+\t */\n+\tprivate void removeNChildren(Iterator<Component> iterator, int numberOfChildrenToRemove)\n+\t{\n+\t\tfor (int i = 0; i < numberOfChildrenToRemove; i++)\n+\t\t{\n+\t\t\titerator.next();\n+\t\t\titerator.remove();\n+\t\t}\n+\t}\n+\n+\t/**\n+\t * Progresses the {@code iterator} with {@code numberOfChildrenToTake} anonymous children.\n+\t * \n+\t * @param iterator\n+\t *            the iterator to progress\n+\t * @param numberOfChildrenToTake\n+\t *            the number of children\n+\t */\n+\tprivate void takeNChildren(Iterator<Component> iterator, int numberOfChildrenToTake)\n+\t{\n+\t\tfor (int i = 0; i < numberOfChildrenToTake; i++)\n+\t\t\titerator.next();\n+\t}\n }"
        }
    ]
}
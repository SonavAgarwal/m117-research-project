{
    "sha": "7bf019a9c2779368133850f141174febede6ad96",
    "node_id": "MDY6Q29tbWl0NTAyMjk0ODc6N2JmMDE5YTljMjc3OTM2ODEzMzg1MGYxNDExNzRmZWJlZGU2YWQ5Ng==",
    "commit": {
        "author": {
            "name": "Gregory Chanan",
            "email": "gchanan@cloudera.com",
            "date": "2016-06-17T23:49:48Z"
        },
        "committer": {
            "name": "Gregory Chanan",
            "email": "gchanan@cloudera.com",
            "date": "2016-07-28T16:59:05Z"
        },
        "message": "SOLR-9200: Add Delegation Token Support to Solr",
        "tree": {
            "sha": "baedb459b2259a6ee362f1e8efe9cad9a056df15",
            "url": "https://api.github.com/repos/apache/lucene-solr/git/trees/baedb459b2259a6ee362f1e8efe9cad9a056df15"
        },
        "url": "https://api.github.com/repos/apache/lucene-solr/git/commits/7bf019a9c2779368133850f141174febede6ad96",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/lucene-solr/commits/7bf019a9c2779368133850f141174febede6ad96",
    "html_url": "https://github.com/apache/lucene-solr/commit/7bf019a9c2779368133850f141174febede6ad96",
    "comments_url": "https://api.github.com/repos/apache/lucene-solr/commits/7bf019a9c2779368133850f141174febede6ad96/comments",
    "author": {
        "login": "grchanan",
        "id": 3768599,
        "node_id": "MDQ6VXNlcjM3Njg1OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3768599?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/grchanan",
        "html_url": "https://github.com/grchanan",
        "followers_url": "https://api.github.com/users/grchanan/followers",
        "following_url": "https://api.github.com/users/grchanan/following{/other_user}",
        "gists_url": "https://api.github.com/users/grchanan/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/grchanan/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/grchanan/subscriptions",
        "organizations_url": "https://api.github.com/users/grchanan/orgs",
        "repos_url": "https://api.github.com/users/grchanan/repos",
        "events_url": "https://api.github.com/users/grchanan/events{/privacy}",
        "received_events_url": "https://api.github.com/users/grchanan/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "grchanan",
        "id": 3768599,
        "node_id": "MDQ6VXNlcjM3Njg1OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/3768599?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/grchanan",
        "html_url": "https://github.com/grchanan",
        "followers_url": "https://api.github.com/users/grchanan/followers",
        "following_url": "https://api.github.com/users/grchanan/following{/other_user}",
        "gists_url": "https://api.github.com/users/grchanan/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/grchanan/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/grchanan/subscriptions",
        "organizations_url": "https://api.github.com/users/grchanan/orgs",
        "repos_url": "https://api.github.com/users/grchanan/repos",
        "events_url": "https://api.github.com/users/grchanan/events{/privacy}",
        "received_events_url": "https://api.github.com/users/grchanan/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "58f0fbd3767af649da1d47ea62f6f35b1ae28c19",
            "url": "https://api.github.com/repos/apache/lucene-solr/commits/58f0fbd3767af649da1d47ea62f6f35b1ae28c19",
            "html_url": "https://github.com/apache/lucene-solr/commit/58f0fbd3767af649da1d47ea62f6f35b1ae28c19"
        }
    ],
    "stats": {
        "total": 2473,
        "additions": 2255,
        "deletions": 218
    },
    "files": [
        {
            "sha": "bc46ee6ccac442febccd721d50cac9f1a29c171e",
            "filename": "lucene/ivy-versions.properties",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/lucene%2Fivy-versions.properties",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/lucene%2Fivy-versions.properties",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/lucene%2Fivy-versions.properties?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -106,6 +106,7 @@ io.netty.netty-all.version = 4.0.36.Final\n org.apache.curator.version = 2.8.0\n /org.apache.curator/curator-client = ${org.apache.curator.version}\n /org.apache.curator/curator-framework = ${org.apache.curator.version}\n+/org.apache.curator/curator-recipes = ${org.apache.curator.version}\n \n /org.apache.derby/derby = 10.9.1.0\n "
        },
        {
            "sha": "6707e1adde584661d365a87413b6bb19d8b36ed5",
            "filename": "solr/CHANGES.txt",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2FCHANGES.txt",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2FCHANGES.txt",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2FCHANGES.txt?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -100,6 +100,9 @@ New Features\n * SOLR-9275: XML QueryParser support (defType=xmlparser) now extensible via configuration.\n   (Christine Poerschke)\n \n+* SOLR-9200: Add Delegation Token Support to Solr.\n+  (Gregory Chanan)\n+\n Bug Fixes\n ----------------------\n "
        },
        {
            "sha": "08272ad74482505f81e8608ccb9e49a2798addf8",
            "filename": "solr/core/ivy.xml",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fivy.xml",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fivy.xml",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fivy.xml?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -134,6 +134,10 @@\n     <dependency org=\"antlr\" name=\"antlr\" rev=\"${/antlr/antlr}\" conf=\"test.MiniKdc\"/>\n     <dependency org=\"net.sf.ehcache\" name=\"ehcache-core\" rev=\"${/net.sf.ehcache/ehcache-core}\" conf=\"test.MiniKdc\"/>\n \n+    <dependency org=\"org.apache.curator\" name=\"curator-framework\" rev=\"${/org.apache.curator/curator-framework}\" conf=\"compile\"/>\n+    <dependency org=\"org.apache.curator\" name=\"curator-client\" rev=\"${/org.apache.curator/curator-client}\" conf=\"compile\"/>\n+    <dependency org=\"org.apache.curator\" name=\"curator-recipes\" rev=\"${/org.apache.curator/curator-recipes}\" conf=\"compile\"/>\n+\n     <!-- StatsComponents percentiles Dependencies-->\n     <dependency org=\"com.tdunning\" name=\"t-digest\" rev=\"${/com.tdunning/t-digest}\" conf=\"compile->*\"/>\n     <!-- SQL Parser -->"
        },
        {
            "sha": "d8f2ef21279527ca4d0117ec2e4e1157add234bd",
            "filename": "solr/core/src/java/org/apache/solr/security/AuthenticationPlugin.java",
            "status": "modified",
            "additions": 5,
            "deletions": 24,
            "changes": 29,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FAuthenticationPlugin.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FAuthenticationPlugin.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FAuthenticationPlugin.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -17,18 +17,11 @@\n package org.apache.solr.security;\n \n import javax.servlet.FilterChain;\n-import javax.servlet.ServletException;\n import javax.servlet.ServletRequest;\n import javax.servlet.ServletResponse;\n-import javax.servlet.http.HttpServletRequest;\n-import javax.servlet.http.HttpServletRequestWrapper;\n import java.io.Closeable;\n-import java.io.IOException;\n-import java.security.Principal;\n import java.util.Map;\n \n-import org.apache.http.auth.BasicUserPrincipal;\n-\n /**\n  * \n  * @lucene.experimental\n@@ -42,32 +35,20 @@ public abstract class AuthenticationPlugin implements Closeable {\n    * @param pluginConfig Config parameters, possibly from a ZK source\n    */\n   public abstract void init(Map<String, Object> pluginConfig);\n-\n-  protected void forward(String user, ServletRequest  req, ServletResponse rsp,\n-                                    FilterChain chain) throws IOException, ServletException {\n-    if(user != null) {\n-      final Principal p = new BasicUserPrincipal(user);\n-      req = new HttpServletRequestWrapper((HttpServletRequest) req) {\n-        @Override\n-        public Principal getUserPrincipal() {\n-          return p;\n-        }\n-      };\n-    }\n-    chain.doFilter(req,rsp);\n-  }\n  \n   /**\n-   * This method must authenticate the request. Upon a successful authentication, this \n+   * This method attempts to authenticate the request. Upon a successful authentication, this\n    * must call the next filter in the filter chain and set the user principal of the request,\n    * or else, upon an error or an authentication failure, throw an exception.\n-   * \n+   *\n    * @param request the http request\n    * @param response the http response\n    * @param filterChain the servlet filter chain\n+   * @return false if the request not be processed by Solr (not continue), i.e.\n+   * the response and status code have already been sent.\n    * @throws Exception any exception thrown during the authentication, e.g. PrivilegedActionException\n    */\n-  public abstract void doAuthenticate(ServletRequest request, ServletResponse response,\n+  public abstract boolean doAuthenticate(ServletRequest request, ServletResponse response,\n       FilterChain filterChain) throws Exception;\n \n "
        },
        {
            "sha": "e3f53a26ae872b8fad994e4de9949cfad51ca501",
            "filename": "solr/core/src/java/org/apache/solr/security/BasicAuthPlugin.java",
            "status": "modified",
            "additions": 4,
            "deletions": 1,
            "changes": 5,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FBasicAuthPlugin.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FBasicAuthPlugin.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FBasicAuthPlugin.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -99,7 +99,7 @@ private void authenticationFailure(HttpServletResponse response, String message)\n   }\n \n   @Override\n-  public void doAuthenticate(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws Exception {\n+  public boolean doAuthenticate(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws Exception {\n \n     HttpServletRequest request = (HttpServletRequest) servletRequest;\n     HttpServletResponse response = (HttpServletResponse) servletResponse;\n@@ -127,6 +127,7 @@ public Principal getUserPrincipal() {\n                   }\n                 };\n                 filterChain.doFilter(wrapper, response);\n+                return true;\n               }\n \n             } else {\n@@ -143,8 +144,10 @@ public Principal getUserPrincipal() {\n       } else {\n         request.setAttribute(AuthenticationPlugin.class.getName(), zkAuthentication.getPromptHeaders());\n         filterChain.doFilter(request, response);\n+        return true;\n       }\n     }\n+    return false;\n   }\n \n   @Override"
        },
        {
            "sha": "7dbb1ad85454ef66881bd640d5307763430e0d59",
            "filename": "solr/core/src/java/org/apache/solr/security/DelegationTokenKerberosFilter.java",
            "status": "added",
            "additions": 171,
            "deletions": 0,
            "changes": 171,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FDelegationTokenKerberosFilter.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FDelegationTokenKerberosFilter.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FDelegationTokenKerberosFilter.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,171 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.security;\n+\n+import java.io.IOException;\n+import java.lang.invoke.MethodHandles;\n+import java.util.LinkedList;\n+import java.util.List;\n+\n+import javax.servlet.FilterChain;\n+import javax.servlet.FilterConfig;\n+import javax.servlet.ServletException;\n+import javax.servlet.ServletRequest;\n+import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n+\n+import org.apache.curator.RetryPolicy;\n+import org.apache.curator.framework.AuthInfo;\n+import org.apache.curator.framework.CuratorFramework;\n+import org.apache.curator.framework.CuratorFrameworkFactory;\n+import org.apache.curator.framework.api.ACLProvider;\n+import org.apache.curator.retry.ExponentialBackoffRetry;\n+\n+import org.apache.hadoop.security.authentication.server.AuthenticationHandler;\n+import org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticationFilter;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.cloud.ZkACLProvider;\n+import org.apache.solr.common.cloud.ZkCredentialsProvider;\n+import org.apache.zookeeper.data.ACL;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class DelegationTokenKerberosFilter extends DelegationTokenAuthenticationFilter {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+\n+  private CuratorFramework curatorFramework;\n+\n+  @Override\n+  public void init(FilterConfig conf) throws ServletException {\n+    if (conf != null && \"zookeeper\".equals(conf.getInitParameter(\"signer.secret.provider\"))) {\n+      SolrZkClient zkClient =\n+          (SolrZkClient)conf.getServletContext().getAttribute(KerberosPlugin.DELEGATION_TOKEN_ZK_CLIENT);\n+      conf.getServletContext().setAttribute(\"signer.secret.provider.zookeeper.curator.client\",\n+          getCuratorClient(zkClient));\n+    }\n+    super.init(conf);\n+  }\n+\n+  @Override\n+  public void doFilter(ServletRequest request, ServletResponse response,\n+      FilterChain filterChain) throws IOException, ServletException {\n+    // HttpClient 4.4.x throws NPE if query string is null and parsed through URLEncodedUtils.\n+    // See HTTPCLIENT-1746 and HADOOP-12767\n+    HttpServletRequest httpRequest = (HttpServletRequest)request;\n+    String queryString = httpRequest.getQueryString();\n+    final String nonNullQueryString = queryString == null ? \"\" : queryString;\n+    HttpServletRequest requestNonNullQueryString = new HttpServletRequestWrapper(httpRequest){\n+      @Override\n+      public String getQueryString() {\n+        return nonNullQueryString;\n+      }\n+    };\n+    super.doFilter(requestNonNullQueryString, response, filterChain);\n+  }\n+\n+  @Override\n+  public void destroy() {\n+    super.destroy();\n+    if (curatorFramework != null) curatorFramework.close();\n+    curatorFramework = null;\n+  }\n+\n+  @Override\n+  protected void initializeAuthHandler(String authHandlerClassName,\n+                                       FilterConfig filterConfig) throws ServletException {\n+    // set the internal authentication handler in order to record whether the request should continue\n+    super.initializeAuthHandler(authHandlerClassName, filterConfig);\n+    AuthenticationHandler authHandler = getAuthenticationHandler();\n+    super.initializeAuthHandler(KerberosPlugin.RequestContinuesRecorderAuthenticationHandler.class.getName(), filterConfig);\n+    KerberosPlugin.RequestContinuesRecorderAuthenticationHandler newAuthHandler =\n+        (KerberosPlugin.RequestContinuesRecorderAuthenticationHandler)getAuthenticationHandler();\n+    newAuthHandler.setAuthHandler(authHandler);\n+  }\n+\n+  protected CuratorFramework getCuratorClient(SolrZkClient zkClient) {\n+    // should we try to build a RetryPolicy off of the ZkController?\n+    RetryPolicy retryPolicy = new ExponentialBackoffRetry(1000, 3);\n+    if (zkClient == null) {\n+      throw new IllegalArgumentException(\"zkClient required\");\n+    }\n+    String zkHost = zkClient.getZkServerAddress();\n+    String zkChroot = zkHost.substring(zkHost.indexOf(\"/\"));\n+    zkChroot = zkChroot.startsWith(\"/\") ? zkChroot.substring(1) : zkChroot;\n+    String zkNamespace = zkChroot + SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH;\n+    String zkConnectionString = zkHost.substring(0, zkHost.indexOf(\"/\"));\n+    SolrZkToCuratorCredentialsACLs curatorToSolrZk = new SolrZkToCuratorCredentialsACLs(zkClient);\n+    final int connectionTimeoutMs = 30000; // this value is currently hard coded, see SOLR-7561.\n+\n+    curatorFramework = CuratorFrameworkFactory.builder()\n+        .namespace(zkNamespace)\n+        .connectString(zkConnectionString)\n+        .retryPolicy(retryPolicy)\n+        .aclProvider(curatorToSolrZk.getACLProvider())\n+        .authorization(curatorToSolrZk.getAuthInfos())\n+        .sessionTimeoutMs(zkClient.getZkClientTimeout())\n+        .connectionTimeoutMs(connectionTimeoutMs)\n+        .build();\n+    curatorFramework.start();\n+    return curatorFramework;\n+  }\n+\n+  /**\n+   * Convert Solr Zk Credentials/ACLs to Curator versions\n+   */\n+  protected static class SolrZkToCuratorCredentialsACLs {\n+    private final ACLProvider aclProvider;\n+    private final List<AuthInfo> authInfos;\n+\n+    public SolrZkToCuratorCredentialsACLs(SolrZkClient zkClient) {\n+      this.aclProvider = createACLProvider(zkClient);\n+      this.authInfos = createAuthInfo(zkClient);\n+    }\n+\n+    public ACLProvider getACLProvider() { return aclProvider; }\n+    public List<AuthInfo> getAuthInfos() { return authInfos; }\n+\n+    private ACLProvider createACLProvider(SolrZkClient zkClient) {\n+      final ZkACLProvider zkACLProvider = zkClient.getZkACLProvider();\n+      return new ACLProvider() {\n+        @Override\n+        public List<ACL> getDefaultAcl() {\n+          return zkACLProvider.getACLsToAdd(null);\n+        }\n+\n+        @Override\n+        public List<ACL> getAclForPath(String path) {\n+           List<ACL> acls = zkACLProvider.getACLsToAdd(path);\n+           return acls;\n+        }\n+      };\n+    }\n+\n+    private List<AuthInfo> createAuthInfo(SolrZkClient zkClient) {\n+      List<AuthInfo> ret = new LinkedList<AuthInfo>();\n+\n+      // In theory the credentials to add could change here if zookeeper hasn't been initialized\n+      ZkCredentialsProvider credentialsProvider =\n+        zkClient.getZkClientConnectionStrategy().getZkCredentialsToAddAutomatically();\n+      for (ZkCredentialsProvider.ZkCredentials zkCredentials : credentialsProvider.getCredentials()) {\n+        ret.add(new AuthInfo(zkCredentials.getScheme(), zkCredentials.getAuth()));\n+      }\n+      return ret;\n+    }\n+  }\n+}"
        },
        {
            "sha": "9c5305056d2ef4d02b2833760b5464d156b849c5",
            "filename": "solr/core/src/java/org/apache/solr/security/KerberosFilter.java",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosFilter.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosFilter.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosFilter.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -26,6 +26,7 @@\n import javax.servlet.http.HttpServletRequest;\n import javax.servlet.http.HttpServletResponse;\n import org.apache.hadoop.security.authentication.server.AuthenticationFilter;\n+import org.apache.hadoop.security.authentication.server.AuthenticationHandler;\n \n public class KerberosFilter extends AuthenticationFilter {\n   \n@@ -34,6 +35,19 @@ public void init(FilterConfig conf) throws ServletException {\n     super.init(conf);\n   }\n \n+  @Override\n+  protected void initializeAuthHandler(String authHandlerClassName,\n+                                       FilterConfig filterConfig) throws ServletException {\n+    // set the internal authentication handler in order to record whether the request should continue\n+    super.initializeAuthHandler(authHandlerClassName, filterConfig);\n+    AuthenticationHandler authHandler = getAuthenticationHandler();\n+    super.initializeAuthHandler(\n+        KerberosPlugin.RequestContinuesRecorderAuthenticationHandler.class.getName(), filterConfig);\n+    KerberosPlugin.RequestContinuesRecorderAuthenticationHandler newAuthHandler =\n+        (KerberosPlugin.RequestContinuesRecorderAuthenticationHandler)getAuthenticationHandler();\n+    newAuthHandler.setAuthHandler(authHandler);\n+  }\n+\n   @Override\n   protected void doFilter(FilterChain filterChain, HttpServletRequest request,\n       HttpServletResponse response) throws IOException, ServletException {"
        },
        {
            "sha": "1cd476fc8f84144da55a77aa92e500cadb3bf552",
            "filename": "solr/core/src/java/org/apache/solr/security/KerberosPlugin.java",
            "status": "modified",
            "additions": 176,
            "deletions": 19,
            "changes": 195,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosPlugin.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosPlugin.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FKerberosPlugin.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -16,14 +16,18 @@\n  */\n package org.apache.solr.security;\n \n+import java.io.IOException;\n import java.io.InputStream;\n+import java.io.PrintWriter;\n import java.lang.invoke.MethodHandles;\n import java.net.MalformedURLException;\n import java.net.URL;\n+import java.util.Collections;\n import java.util.Enumeration;\n import java.util.EventListener;\n import java.util.HashMap;\n import java.util.Map;\n+import java.util.Properties;\n import java.util.Set;\n \n import javax.servlet.Filter;\n@@ -41,12 +45,22 @@\n import javax.servlet.SessionCookieConfig;\n import javax.servlet.SessionTrackingMode;\n import javax.servlet.descriptor.JspConfigDescriptor;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+import javax.servlet.http.HttpServletResponseWrapper;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.commons.collections.iterators.IteratorEnumeration;\n+import org.apache.hadoop.security.authentication.client.AuthenticationException;\n+import org.apache.hadoop.security.authentication.server.AuthenticationHandler;\n+import org.apache.hadoop.security.authentication.server.AuthenticationToken;\n import org.apache.solr.client.solrj.impl.Krb5HttpClientBuilder;\n import org.apache.solr.client.solrj.impl.SolrHttpClientBuilder;\n+import org.apache.solr.cloud.ZkController;\n import org.apache.solr.common.SolrException;\n import org.apache.solr.common.SolrException.ErrorCode;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n+import org.apache.solr.common.util.SuppressForbidden;\n import org.apache.solr.core.CoreContainer;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -55,7 +69,7 @@ public class KerberosPlugin extends AuthenticationPlugin implements HttpClientBu\n   private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n \n   Krb5HttpClientBuilder kerberosBuilder = new Krb5HttpClientBuilder();\n-  Filter kerberosFilter = new KerberosFilter();\n+  Filter kerberosFilter;\n   \n   public static final String NAME_RULES_PARAM = \"solr.kerberos.name.rules\";\n   public static final String COOKIE_DOMAIN_PARAM = \"solr.kerberos.cookie.domain\";\n@@ -64,6 +78,26 @@ public class KerberosPlugin extends AuthenticationPlugin implements HttpClientBu\n   public static final String KEYTAB_PARAM = \"solr.kerberos.keytab\";\n   public static final String TOKEN_VALID_PARAM = \"solr.kerberos.token.valid\";\n   public static final String COOKIE_PORT_AWARE_PARAM = \"solr.kerberos.cookie.portaware\";\n+  public static final String DELEGATION_TOKEN_ENABLED = \"solr.kerberos.delegation.token.enabled\";\n+  public static final String DELEGATION_TOKEN_KIND = \"solr.kerberos.delegation.token.kind\";\n+  public static final String DELEGATION_TOKEN_VALIDITY = \"solr.kerberos.delegation.token.validity\";\n+  public static final String DELEGATION_TOKEN_SECRET_PROVIDER = \"solr.kerberos.delegation.token.signer.secret.provider\";\n+  public static final String DELEGATION_TOKEN_SECRET_PROVIDER_ZK_PATH =\n+      \"solr.kerberos.delegation.token.signer.secret.provider.zookeper.path\";\n+  public static final String DELEGATION_TOKEN_SECRET_MANAGER_ZNODE_WORKING_PATH =\n+      \"solr.kerberos.delegation.token.secret.manager.znode.working.path\";\n+  public static final String DELEGATION_TOKEN_TYPE_DEFAULT = \"solr-dt\";\n+  \n+  // filled in by Plugin/Filter\n+  static final String REQUEST_CONTINUES_ATTR =\n+      \"org.apache.solr.security.kerberosplugin.requestcontinues\";\n+  static final String DELEGATION_TOKEN_ZK_CLIENT =\n+      \"solr.kerberos.delegation.token.zk.client\";\n+\n+  // allows test to specify an alternate auth handler\n+  @VisibleForTesting\n+  public static final String AUTH_HANDLER_PARAM = \"solr.kerberos.auth.handler\";\n+\n   private final CoreContainer coreContainer;\n \n   public KerberosPlugin(CoreContainer coreContainer) {\n@@ -74,12 +108,47 @@ public KerberosPlugin(CoreContainer coreContainer) {\n   public void init(Map<String, Object> pluginConfig) {\n     try {\n       Map<String, String> params = new HashMap();\n-      params.put(\"type\", \"kerberos\");\n+      putParam(params, \"type\", AUTH_HANDLER_PARAM, \"kerberos\");\n       putParam(params, \"kerberos.name.rules\", NAME_RULES_PARAM, \"DEFAULT\");\n       putParam(params, \"token.valid\", TOKEN_VALID_PARAM, \"30\");\n       putParam(params, \"cookie.path\", COOKIE_PATH_PARAM, \"/\");\n-      putParam(params, \"kerberos.principal\", PRINCIPAL_PARAM, null);\n-      putParam(params, \"kerberos.keytab\", KEYTAB_PARAM, null);\n+      if (\"kerberos\".equals(params.get(\"type\"))) {\n+        putParam(params, \"kerberos.principal\", PRINCIPAL_PARAM, null);\n+        putParam(params, \"kerberos.keytab\", KEYTAB_PARAM, null);\n+      } else {\n+        // allow tests which specify AUTH_HANDLER_PARAM to avoid specifying kerberos principal/keytab\n+        putParamOptional(params, \"kerberos.principal\", PRINCIPAL_PARAM);\n+        putParamOptional(params, \"kerberos.keytab\", KEYTAB_PARAM);\n+      }\n+\n+      String delegationTokenStr = System.getProperty(DELEGATION_TOKEN_ENABLED, null);\n+      boolean delegationTokenEnabled =\n+          (delegationTokenStr == null) ? false : Boolean.parseBoolean(delegationTokenStr);\n+      ZkController controller = coreContainer.getZkController();\n+\n+      if (delegationTokenEnabled) {\n+        putParam(params, \"delegation-token.token-kind\", DELEGATION_TOKEN_KIND, DELEGATION_TOKEN_TYPE_DEFAULT);\n+        if (coreContainer.isZooKeeperAware()) {\n+          putParam(params, \"signer.secret.provider\", DELEGATION_TOKEN_SECRET_PROVIDER, \"zookeeper\");\n+          if (\"zookeeper\".equals(params.get(\"signer.secret.provider\"))) {\n+            String zkHost = controller.getZkServerAddress();\n+            putParam(params, \"token.validity\", DELEGATION_TOKEN_VALIDITY, \"36000\");\n+            params.put(\"zk-dt-secret-manager.enable\", \"true\");\n+            // Note - Curator complains if the znodeWorkingPath starts with /\n+            String chrootPath = zkHost.substring(zkHost.indexOf(\"/\"));\n+            String relativePath = chrootPath.startsWith(\"/\") ? chrootPath.substring(1) : chrootPath;\n+            putParam(params, \"zk-dt-secret-manager.znodeWorkingPath\",\n+                DELEGATION_TOKEN_SECRET_MANAGER_ZNODE_WORKING_PATH,\n+                relativePath + SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH + \"/zkdtsm\");\n+            putParam(params, \"signer.secret.provider.zookeeper.path\",\n+                DELEGATION_TOKEN_SECRET_PROVIDER_ZK_PATH, \"/token\");\n+            // ensure krb5 is setup properly before running curator\n+            getHttpClientBuilder(SolrHttpClientBuilder.create());\n+          }\n+        } else {\n+          log.info(\"CoreContainer is not ZooKeeperAware, not setting ZK-related delegation token properties\");\n+        }\n+      }\n \n       // Special handling for the \"cookie.domain\" based on whether port should be\n       // appended to the domain. Useful for situations where multiple solr nodes are\n@@ -94,16 +163,27 @@ public void init(Map<String, Object> pluginConfig) {\n         if (host==null) {\n           throw new SolrException(ErrorCode.SERVER_ERROR, \"Missing required parameter '\"+COOKIE_DOMAIN_PARAM+\"'.\");\n         }\n-        int port = coreContainer.getZkController().getHostPort();\n+        int port = controller.getHostPort();\n         params.put(\"cookie.domain\", host + \":\" + port);\n       }\n-      \n+\n+      final ServletContext servletContext = new AttributeOnlyServletContext();\n+      if (delegationTokenEnabled) {\n+        kerberosFilter = new DelegationTokenKerberosFilter();\n+        // pass an attribute-enabled context in order to pass the zkClient\n+        // and because the filter may pass a curator instance.\n+        if (controller != null) {\n+          servletContext.setAttribute(DELEGATION_TOKEN_ZK_CLIENT, controller.getZkClient());\n+        }\n+      } else {\n+        kerberosFilter = new KerberosFilter();\n+      }\n       log.info(\"Params: \"+params);\n \n       FilterConfig conf = new FilterConfig() {\n         @Override\n         public ServletContext getServletContext() {\n-          return noContext;\n+          return servletContext;\n         }\n \n         @Override\n@@ -136,11 +216,43 @@ private void putParam(Map<String, String> params, String internalParamName, Stri\n     params.put(internalParamName, value);\n   }\n \n+  private void putParamOptional(Map<String, String> params, String internalParamName, String externalParamName) {\n+    String value = System.getProperty(externalParamName);\n+    if (value!=null) {\n+      params.put(internalParamName, value);\n+    }\n+  }\n+\n   @Override\n-  public void doAuthenticate(ServletRequest req, ServletResponse rsp,\n+  public boolean doAuthenticate(ServletRequest req, ServletResponse rsp,\n       FilterChain chain) throws Exception {\n     log.debug(\"Request to authenticate using kerberos: \"+req);\n-    kerberosFilter.doFilter(req, rsp, chain);    \n+\n+    final HttpServletResponse frsp = (HttpServletResponse)rsp;\n+\n+    // kerberosFilter may close the stream and write to closed streams,\n+    // see HADOOP-13346.  To work around, pass a PrintWriter that ignores\n+    // closes\n+    HttpServletResponse rspCloseShield = new HttpServletResponseWrapper(frsp) {\n+      @SuppressForbidden(reason = \"Hadoop DelegationTokenAuthenticationFilter uses response writer, this\" +\n+          \"is providing a CloseShield on top of that\")\n+      @Override\n+      public PrintWriter getWriter() throws IOException {\n+        final PrintWriter pw = new PrintWriterWrapper(frsp.getWriter()) {\n+          @Override\n+          public void close() {};\n+        };\n+        return pw;\n+      }\n+    };\n+    kerberosFilter.doFilter(req, rspCloseShield, chain);\n+    String requestContinuesAttr = (String)req.getAttribute(REQUEST_CONTINUES_ATTR);\n+    if (requestContinuesAttr == null) {\n+      log.warn(\"Could not find \" + REQUEST_CONTINUES_ATTR);\n+      return false;\n+    } else {\n+      return Boolean.parseBoolean(requestContinuesAttr);\n+    }\n   }\n \n   @Override\n@@ -153,21 +265,26 @@ public void close() {\n     kerberosBuilder.close();\n   }\n \n-  protected static ServletContext noContext = new ServletContext() {\n-    \n+  protected static class AttributeOnlyServletContext implements ServletContext {\n+    private Map<String, Object> attributes = new HashMap<String, Object>();\n+\n     @Override\n     public void setSessionTrackingModes(Set<SessionTrackingMode> sessionTrackingModes) {}\n     \n     @Override\n     public boolean setInitParameter(String name, String value) {\n       return false;\n     }\n-    \n+\n     @Override\n-    public void setAttribute(String name, Object object) {}\n-    \n+    public void setAttribute(String name, Object object) {\n+      attributes.put(name, object);\n+    }\n+\n     @Override\n-    public void removeAttribute(String name) {}\n+    public void removeAttribute(String name) {\n+      attributes.remove(name);\n+    }\n     \n     @Override\n     public void log(String message, Throwable throwable) {}\n@@ -327,15 +444,15 @@ public ServletContext getContext(String uripath) {\n     public ClassLoader getClassLoader() {\n       return null;\n     }\n-    \n+\n     @Override\n     public Enumeration<String> getAttributeNames() {\n-      return null;\n+      return Collections.enumeration(attributes.keySet());\n     }\n-    \n+\n     @Override\n     public Object getAttribute(String name) {\n-      return null;\n+      return attributes.get(name);\n     }\n     \n     @Override\n@@ -395,4 +512,44 @@ public Dynamic addFilter(String filterName, String className) {\n       return null;\n     }\n   };\n+\n+  /*\n+   * {@link AuthenticationHandler} that delegates to another {@link AuthenticationHandler}\n+   * and records the response of managementOperation (which indicates whether the request\n+   * should continue or not).\n+   */\n+  public static class RequestContinuesRecorderAuthenticationHandler implements AuthenticationHandler {\n+    private AuthenticationHandler authHandler;\n+\n+    public void setAuthHandler(AuthenticationHandler authHandler) {\n+      this.authHandler = authHandler;\n+    }\n+\n+    public String getType() {\n+      return authHandler.getType();\n+    }\n+\n+    public void init(Properties config) throws ServletException {\n+      // authHandler has already been init'ed, nothing to do here\n+    }\n+\n+    public void destroy() {\n+      authHandler.destroy();\n+    }\n+\n+    public boolean managementOperation(AuthenticationToken token,\n+                                       HttpServletRequest request,\n+                                       HttpServletResponse response)\n+        throws IOException, AuthenticationException {\n+      boolean result = authHandler.managementOperation(token, request, response);\n+      request.setAttribute(KerberosPlugin.REQUEST_CONTINUES_ATTR, new Boolean(result).toString());\n+      return result;\n+    }\n+\n+\n+    public AuthenticationToken authenticate(HttpServletRequest request, HttpServletResponse response)\n+        throws IOException, AuthenticationException {\n+      return authHandler.authenticate(request, response);\n+    }\n+  }\n }"
        },
        {
            "sha": "e5d26531fbe0ee9956c17e3118cf2ff812f9bca9",
            "filename": "solr/core/src/java/org/apache/solr/security/PKIAuthenticationPlugin.java",
            "status": "modified",
            "additions": 7,
            "deletions": 6,
            "changes": 13,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPKIAuthenticationPlugin.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPKIAuthenticationPlugin.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPKIAuthenticationPlugin.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -89,27 +89,27 @@ public void init(Map<String, Object> pluginConfig) {\n \n   @SuppressForbidden(reason = \"Needs currentTimeMillis to compare against time in header\")\n   @Override\n-  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n+  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws Exception {\n \n     String requestURI = ((HttpServletRequest) request).getRequestURI();\n     if (requestURI.endsWith(PATH)) {\n       filterChain.doFilter(request, response);\n-      return;\n+      return true;\n     }\n     long receivedTime = System.currentTimeMillis();\n     String header = ((HttpServletRequest) request).getHeader(HEADER);\n     if (header == null) {\n       //this must not happen\n       log.error(\"No SolrAuth header present\");\n       filterChain.doFilter(request, response);\n-      return;\n+      return true;\n     }\n \n     List<String> authInfo = StrUtils.splitWS(header, false);\n     if (authInfo.size() < 2) {\n       log.error(\"Invalid SolrAuth Header {}\", header);\n       filterChain.doFilter(request, response);\n-      return;\n+      return true;\n     }\n \n     String nodeName = authInfo.get(0);\n@@ -119,19 +119,20 @@ public void doAuthenticate(ServletRequest request, ServletResponse response, Fil\n     if (decipher == null) {\n       log.error(\"Could not decipher a header {} . No principal set\", header);\n       filterChain.doFilter(request, response);\n-      return;\n+      return true;\n     }\n     if ((receivedTime - decipher.timestamp) > MAX_VALIDITY) {\n       log.error(\"Invalid key request timestamp: {} , received timestamp: {} , TTL: {}\", decipher.timestamp, receivedTime, MAX_VALIDITY);\n         filterChain.doFilter(request, response);\n-        return;\n+        return true;\n     }\n \n     final Principal principal = \"$\".equals(decipher.userName) ?\n         SU :\n         new BasicUserPrincipal(decipher.userName);\n \n     filterChain.doFilter(getWrapper((HttpServletRequest) request, principal), response);\n+    return true;\n   }\n \n   private static HttpServletRequestWrapper getWrapper(final HttpServletRequest request, final Principal principal) {"
        },
        {
            "sha": "a4e47b5e4f1a0f6202509d7bade9d61f8bde4cbb",
            "filename": "solr/core/src/java/org/apache/solr/security/PrintWriterWrapper.java",
            "status": "added",
            "additions": 215,
            "deletions": 0,
            "changes": 215,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPrintWriterWrapper.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPrintWriterWrapper.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fsecurity%2FPrintWriterWrapper.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,215 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.security;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.NotImplementedException;\n+\n+/**\n+ * Wrapper for PrintWriter that delegates to constructor arg\n+ */\n+public class PrintWriterWrapper extends PrintWriter {\n+  private PrintWriter printWriter;\n+\n+  public PrintWriterWrapper(PrintWriter printWriter) {\n+    super(new StringWriter());\n+    this.printWriter = printWriter;\n+  }\n+\n+  @Override\n+  public PrintWriter append(char c) {\n+    return printWriter.append(c);\n+  }\n+\n+  @Override\n+  public PrintWriter append(CharSequence csq) {\n+    return printWriter.append(csq);\n+  }\n+\n+  @Override\n+  public PrintWriter append(CharSequence csq, int start, int end) {\n+    return printWriter.append(csq, start, end);\n+  }\n+\n+  @Override\n+  public boolean checkError() {\n+    return printWriter.checkError();\n+  }\n+\n+  @Override\n+  protected void clearError() {\n+    throw new NotImplementedException();\n+  }\n+\n+  @Override\n+  public void close() {\n+    printWriter.close();\n+  }\n+\n+  @Override\n+  public void flush() {\n+    printWriter.flush();\n+  }\n+\n+  @Override\n+  public PrintWriter format(Locale l, String format, Object... args) {\n+    return printWriter.format(l, format, args);\n+  }\n+\n+  @Override\n+  public PrintWriter format(String format, Object... args) {\n+    throw new NotImplementedException(\"Forbidden API\");\n+  }\n+\n+  @Override\n+  public void print(boolean b) {\n+    printWriter.print(b);\n+  }\n+\n+  @Override\n+  public void print(char c) {\n+    printWriter.print(c);\n+  }\n+\n+  @Override\n+  public void print(char[] s) {\n+    printWriter.print(s);\n+  }\n+\n+  @Override\n+  public void print(double d) {\n+    printWriter.print(d);\n+  }\n+\n+  @Override\n+  public void print(float f) {\n+    printWriter.print(f);\n+  }\n+\n+  @Override\n+  public void print(int i) {\n+    printWriter.print(i);\n+  }\n+\n+  @Override\n+  public void print(long l) {\n+    printWriter.print(l);\n+  }\n+\n+  @Override\n+  public void print(Object obj) {\n+    printWriter.print(obj);\n+  }\n+\n+  @Override\n+  public void print(String s) {\n+    printWriter.print(s);\n+  }\n+\n+  @Override\n+  public PrintWriter printf(Locale l, String format, Object... args) {\n+    return printWriter.printf(l, format, args);\n+  }\n+\n+  @Override\n+  public PrintWriter printf(String format, Object... args) {\n+    throw new NotImplementedException(\"Forbidden API\");\n+  }\n+\n+  @Override\n+  public void println() {\n+    printWriter.println();\n+  }\n+\n+  @Override\n+  public void println(boolean x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(char x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(char[] x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(double x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(float x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(int x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(long x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(Object x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  public void println(String x) {\n+    printWriter.println(x);\n+  }\n+\n+  @Override\n+  protected void setError() {\n+    throw new NotImplementedException();\n+  }\n+\n+  @Override\n+  public void write(char[] buf) {\n+    printWriter.write(buf);\n+  }\n+\n+  @Override\n+  public void write(char[] buf, int off, int len) {\n+    printWriter.write(buf, off, len);\n+  }\n+\n+  @Override\n+  public void write(int c) {\n+    printWriter.write(c);\n+  }\n+\n+  @Override\n+  public void write(String s) {\n+    printWriter.write(s);\n+  }\n+\n+  @Override\n+  public void write(String s, int off, int len) {\n+    printWriter.write(s, off, len);\n+  }\n+}"
        },
        {
            "sha": "4a680e5591c2a4ef273a2b318d7fbe08849cd821",
            "filename": "solr/core/src/java/org/apache/solr/servlet/SolrDispatchFilter.java",
            "status": "modified",
            "additions": 9,
            "deletions": 3,
            "changes": 12,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fservlet%2FSolrDispatchFilter.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fservlet%2FSolrDispatchFilter.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fservlet%2FSolrDispatchFilter.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -296,6 +296,7 @@ protected HttpSolrCall getHttpSolrCall(HttpServletRequest request, HttpServletRe\n   }\n \n   private boolean authenticateRequest(ServletRequest request, ServletResponse response, final AtomicReference<ServletRequest> wrappedRequest) throws IOException {\n+    boolean requestContinues = false;\n     final AtomicBoolean isAuthenticated = new AtomicBoolean(false);\n     AuthenticationPlugin authenticationPlugin = cores.getAuthenticationPlugin();\n     if (authenticationPlugin == null) {\n@@ -308,7 +309,7 @@ private boolean authenticateRequest(ServletRequest request, ServletResponse resp\n       try {\n         log.debug(\"Request to authenticate: {}, domain: {}, port: {}\", request, request.getLocalName(), request.getLocalPort());\n         // upon successful authentication, this should call the chain's next filter.\n-        authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n+        requestContinues = authenticationPlugin.doAuthenticate(request, response, new FilterChain() {\n           public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException, ServletException {\n             isAuthenticated.set(true);\n             wrappedRequest.set(req);\n@@ -319,8 +320,13 @@ public void doFilter(ServletRequest req, ServletResponse rsp) throws IOException\n         throw new SolrException(ErrorCode.SERVER_ERROR, \"Error during request authentication, \", e);\n       }\n     }\n-    // failed authentication?\n-    if (!isAuthenticated.get()) {\n+    // requestContinues is an optional short circuit, thus we still need to check isAuthenticated.\n+    // This is because the AuthenticationPlugin doesn't always have enough information to determine if\n+    // it should short circuit, e.g. the Kerberos Authentication Filter will send an error and not\n+    // call later filters in chain, but doesn't throw an exception.  We could force each Plugin\n+    // to implement isAuthenticated to simplify the check here, but that just moves the complexity to\n+    // multiple code paths.\n+    if (!requestContinues || !isAuthenticated.get()) {\n       response.flushBuffer();\n       return false;\n     }"
        },
        {
            "sha": "eb272181fafc6bdc94cbed282a140515b50456db",
            "filename": "solr/core/src/test/org/apache/solr/cloud/KerberosTestServices.java",
            "status": "renamed",
            "additions": 107,
            "deletions": 26,
            "changes": 133,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FKerberosTestServices.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FKerberosTestServices.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FKerberosTestServices.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -16,6 +16,8 @@\n  */\n package org.apache.solr.cloud;\n \n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n import java.io.File;\n import java.util.Arrays;\n import java.util.HashMap;\n@@ -24,18 +26,56 @@\n import java.util.Map;\n import java.util.Properties;\n \n-import javax.security.auth.login.AppConfigurationEntry;\n-import javax.security.auth.login.Configuration;\n-\n+import com.carrotsearch.ant.tasks.junit4.dependencies.com.google.common.base.Preconditions;\n import org.apache.hadoop.minikdc.MiniKdc;\n+import org.apache.solr.client.solrj.impl.Krb5HttpClientBuilder;\n+\n+public class KerberosTestServices {\n+\n+  private MiniKdc kdc;\n+  private JaasConfiguration jaasConfiguration;\n+  private Configuration savedConfig;\n+  private Locale savedLocale;\n+\n+  private KerberosTestServices(MiniKdc kdc,\n+                               JaasConfiguration jaasConfiguration,\n+                               Configuration savedConfig,\n+                               Locale savedLocale) {\n+    this.kdc = kdc;\n+    this.jaasConfiguration = jaasConfiguration;\n+    this.savedConfig = savedConfig;\n+    this.savedLocale = savedLocale;\n+  }\n+\n+  public MiniKdc getKdc() {\n+    return kdc;\n+  }\n+\n+  public void start() throws Exception {\n+    if (kdc != null) kdc.start();\n+    Configuration.setConfiguration(jaasConfiguration);\n+    Krb5HttpClientBuilder.regenerateJaasConfiguration();\n+    if (brokenLanguagesWithMiniKdc.contains(Locale.getDefault().getLanguage())) {\n+      Locale.setDefault(Locale.US);\n+    }\n+  }\n+\n+  public void stop() {\n+    if (kdc != null) kdc.stop();\n+    Configuration.setConfiguration(savedConfig);\n+    Krb5HttpClientBuilder.regenerateJaasConfiguration();\n+    Locale.setDefault(savedLocale);\n+  }\n \n-public class KerberosTestUtil {\n+  public static Builder builder() {\n+    return new Builder();\n+  }\n \n   /**\n    * Returns a MiniKdc that can be used for creating kerberos principals\n    * and keytabs.  Caller is responsible for starting/stopping the kdc.\n    */\n-  public static MiniKdc getKdc(File workDir) throws Exception {\n+  private static MiniKdc getKdc(File workDir) throws Exception {\n     Properties conf = MiniKdc.createConf();\n     return new MiniKdc(conf, workDir);\n   }\n@@ -44,7 +84,7 @@ public static MiniKdc getKdc(File workDir) throws Exception {\n    * Programmatic version of a jaas.conf file suitable for connecting\n    * to a SASL-configured zookeeper.\n    */\n-  public static class JaasConfiguration extends Configuration {\n+  private static class JaasConfiguration extends Configuration {\n \n     private static AppConfigurationEntry[] clientEntry;\n     private static AppConfigurationEntry[] serverEntry;\n@@ -60,7 +100,7 @@ public static class JaasConfiguration extends Configuration {\n      * @param serverKeytab The location of the keytab with the serverPrincipal\n      */\n     public JaasConfiguration(String clientPrincipal, File clientKeytab,\n-        String serverPrincipal, File serverKeytab) {\n+                             String serverPrincipal, File serverKeytab) {\n       Map<String, String> clientOptions = new HashMap();\n       clientOptions.put(\"principal\", clientPrincipal);\n       clientOptions.put(\"keyTab\", clientKeytab.getAbsolutePath());\n@@ -73,9 +113,9 @@ public JaasConfiguration(String clientPrincipal, File clientKeytab,\n         clientOptions.put(\"debug\", \"true\");\n       }\n       clientEntry = new AppConfigurationEntry[]{\n-        new AppConfigurationEntry(getKrb5LoginModuleName(),\n-        AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n-        clientOptions)};\n+          new AppConfigurationEntry(getKrb5LoginModuleName(),\n+              AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+              clientOptions)};\n       if(serverPrincipal!=null && serverKeytab!=null) {\n         Map<String, String> serverOptions = new HashMap(clientOptions);\n         serverOptions.put(\"principal\", serverPrincipal);\n@@ -88,9 +128,9 @@ public JaasConfiguration(String clientPrincipal, File clientKeytab,\n     }\n \n     /**\n-     * Add an entry to the jaas configuration with the passed in principal and keytab, \n+     * Add an entry to the jaas configuration with the passed in principal and keytab,\n      * along with the app name.\n-     * \n+     *\n      * @param principal The principal\n      * @param keytab The keytab containing credentials for the principal\n      * @param appName The app name of the configuration\n@@ -127,21 +167,62 @@ private String getKrb5LoginModuleName() {\n    */\n   private final static List<String> brokenLanguagesWithMiniKdc =\n       Arrays.asList(\n-          new Locale(\"th\").getLanguage(), \n-          new Locale(\"ja\").getLanguage(), \n+          new Locale(\"th\").getLanguage(),\n+          new Locale(\"ja\").getLanguage(),\n           new Locale(\"hi\").getLanguage()\n-          );\n-  /** \n-   *returns the currently set locale, and overrides it with {@link Locale#US} if it's \n-   * currently something MiniKdc can not handle\n-   *\n-   * @see Locale#setDefault\n-   */\n-  public static final Locale overrideLocaleIfNotSpportedByMiniKdc() {\n-    Locale old = Locale.getDefault();\n-    if (brokenLanguagesWithMiniKdc.contains(Locale.getDefault().getLanguage())) {\n-      Locale.setDefault(Locale.US);\n+      );\n+\n+  public static class Builder {\n+    private File kdcWorkDir;\n+    private String clientPrincipal;\n+    private File clientKeytab;\n+    private String serverPrincipal;\n+    private File serverKeytab;\n+    private String appName;\n+    private Locale savedLocale;\n+\n+    public Builder() {\n+      savedLocale = Locale.getDefault();\n+    }\n+\n+    public Builder withKdc(File kdcWorkDir) {\n+      this.kdcWorkDir = kdcWorkDir;\n+      return this;\n+    }\n+\n+    public Builder withJaasConfiguration(String clientPrincipal, File clientKeytab,\n+                                         String serverPrincipal, File serverKeytab) {\n+      Preconditions.checkNotNull(clientPrincipal);\n+      Preconditions.checkNotNull(clientKeytab);\n+      this.clientPrincipal = clientPrincipal;\n+      this.clientKeytab = clientKeytab;\n+      this.serverPrincipal = serverPrincipal;\n+      this.serverKeytab = serverKeytab;\n+      this.appName = null;\n+      return this;\n+    }\n+\n+    public Builder withJaasConfiguration(String principal, File keytab, String appName) {\n+      Preconditions.checkNotNull(principal);\n+      Preconditions.checkNotNull(keytab);\n+      this.clientPrincipal = principal;\n+      this.clientKeytab = keytab;\n+      this.serverPrincipal = null;\n+      this.serverKeytab = null;\n+      this.appName = appName;\n+      return this;\n+    }\n+\n+    public KerberosTestServices build() throws Exception {\n+      final MiniKdc kdc = kdcWorkDir != null ? getKdc(kdcWorkDir) : null;\n+      final Configuration oldConfig = clientPrincipal != null ? Configuration.getConfiguration() : null;\n+      JaasConfiguration jaasConfiguration = null;\n+      if (clientPrincipal != null) {\n+        jaasConfiguration = (appName == null) ?\n+            new JaasConfiguration(clientPrincipal, clientKeytab, serverPrincipal, serverKeytab) :\n+            new JaasConfiguration(clientPrincipal, clientKeytab, appName);\n+      }\n+      return new KerberosTestServices(kdc, jaasConfiguration, oldConfig, savedLocale);\n     }\n-    return old;\n   }\n }",
            "previous_filename": "solr/core/src/test/org/apache/solr/cloud/KerberosTestUtil.java"
        },
        {
            "sha": "08845767af9b0226ff226bd83497682a871c0cf8",
            "filename": "solr/core/src/test/org/apache/solr/cloud/OutOfBoxZkACLAndCredentialsProvidersTest.java",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOutOfBoxZkACLAndCredentialsProvidersTest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOutOfBoxZkACLAndCredentialsProvidersTest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOutOfBoxZkACLAndCredentialsProvidersTest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -23,6 +23,7 @@\n import java.util.List;\n \n import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n import org.apache.solr.common.cloud.SolrZkClient;\n import org.apache.zookeeper.CreateMode;\n import org.apache.zookeeper.ZooDefs;\n@@ -77,6 +78,7 @@ public void setUp() throws Exception {\n     zkClient.makePath(\"/protectedMakePathNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.create(\"/unprotectedCreateNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.makePath(\"/unprotectedMakePathNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n+    zkClient.create(SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH, \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.close();\n \n     log.info(\"####SETUP_END \" + getTestName());\n@@ -93,7 +95,9 @@ public void tearDown() throws Exception {\n   public void testOutOfBoxSolrZkClient() throws Exception {\n     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, true, true, true);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, true, true, true,\n+          true, true, true, true, true);\n     } finally {\n       zkClient.close();\n     }\n@@ -110,6 +114,7 @@ public void testOpenACLUnsafeAllover() throws Exception {\n       assertTrue(verifiedList.contains(\"/solr/unprotectedMakePathNode\"));\n       assertTrue(verifiedList.contains(\"/solr/protectedMakePathNode\"));\n       assertTrue(verifiedList.contains(\"/solr/protectedCreateNode\"));\n+      assertTrue(verifiedList.contains(\"/solr\" + SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH));\n     } finally {\n       zkClient.close();\n     }"
        },
        {
            "sha": "56c0df90d3bf84bd8364c43c853de4ad3939c305",
            "filename": "solr/core/src/test/org/apache/solr/cloud/OverriddenZkACLAndCredentialsProvidersTest.java",
            "status": "modified",
            "additions": 37,
            "deletions": 34,
            "changes": 71,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOverriddenZkACLAndCredentialsProvidersTest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOverriddenZkACLAndCredentialsProvidersTest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FOverriddenZkACLAndCredentialsProvidersTest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -18,18 +18,15 @@\n \n import org.apache.solr.SolrTestCaseJ4;\n import org.apache.solr.common.StringUtils;\n-import org.apache.solr.common.cloud.DefaultZkACLProvider;\n import org.apache.solr.common.cloud.DefaultZkCredentialsProvider;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n import org.apache.solr.common.cloud.SolrZkClient;\n import org.apache.solr.common.cloud.VMParamsAllAndReadonlyDigestZkACLProvider;\n import org.apache.solr.common.cloud.VMParamsSingleSetCredentialsDigestZkCredentialsProvider;\n import org.apache.solr.common.cloud.ZkACLProvider;\n import org.apache.solr.common.cloud.ZkCredentialsProvider;\n import org.apache.zookeeper.CreateMode;\n-import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n-import org.apache.zookeeper.data.Id;\n-import org.apache.zookeeper.server.auth.DigestAuthenticationProvider;\n import org.junit.AfterClass;\n import org.junit.BeforeClass;\n import org.junit.Test;\n@@ -40,7 +37,6 @@\n import java.io.UnsupportedEncodingException;\n import java.lang.invoke.MethodHandles;\n import java.nio.charset.Charset;\n-import java.security.NoSuchAlgorithmException;\n import java.util.ArrayList;\n import java.util.Collection;\n import java.util.List;\n@@ -88,6 +84,7 @@ public void setUp() throws Exception {\n         \"readonlyACLUsername\", \"readonlyACLPassword\").getSolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     zkClient.create(\"/protectedCreateNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.makePath(\"/protectedMakePathNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n+    zkClient.create(SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH, \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.close();\n     \n     zkClient = new SolrZkClientFactoryUsingCompletelyNewProviders(null, null, \n@@ -114,7 +111,9 @@ public void testNoCredentialsSolrZkClientFactoryUsingCompletelyNewProviders() th\n     SolrZkClient zkClient = new SolrZkClientFactoryUsingCompletelyNewProviders(null, null, \n         null, null).getSolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, false, false, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -125,7 +124,9 @@ public void testWrongCredentialsSolrZkClientFactoryUsingCompletelyNewProviders()\n     SolrZkClient zkClient = new SolrZkClientFactoryUsingCompletelyNewProviders(\"connectAndAllACLUsername\", \"connectAndAllACLPasswordWrong\", \n         null, null).getSolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, false, false, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -136,7 +137,9 @@ public void testAllCredentialsSolrZkClientFactoryUsingCompletelyNewProviders() t\n     SolrZkClient zkClient = new SolrZkClientFactoryUsingCompletelyNewProviders(\"connectAndAllACLUsername\", \"connectAndAllACLPassword\", \n         null, null).getSolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, true, true, true);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, true, true, true,\n+          true, true, true, true, true);\n     } finally {\n       zkClient.close();\n     }\n@@ -147,7 +150,9 @@ public void testReadonlyCredentialsSolrZkClientFactoryUsingCompletelyNewProvider\n     SolrZkClient zkClient = new SolrZkClientFactoryUsingCompletelyNewProviders(\"readonlyACLUsername\", \"readonlyACLPassword\",\n         null, null).getSolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -159,7 +164,9 @@ public void testNoCredentialsSolrZkClientFactoryUsingVMParamsProvidersButWithDif\n     \n     SolrZkClient zkClient = new SolrZkClientUsingVMParamsProvidersButWithDifferentVMParamsNames(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, false, false, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -171,7 +178,9 @@ public void testWrongCredentialsSolrZkClientFactoryUsingVMParamsProvidersButWith\n     \n     SolrZkClient zkClient = new SolrZkClientUsingVMParamsProvidersButWithDifferentVMParamsNames(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, false, false, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -183,7 +192,9 @@ public void testAllCredentialsSolrZkClientFactoryUsingVMParamsProvidersButWithDi\n     \n     SolrZkClient zkClient = new SolrZkClientUsingVMParamsProvidersButWithDifferentVMParamsNames(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, true, true, true);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, true, true, true,\n+          true, true, true, true, true);\n     } finally {\n       zkClient.close();\n     }\n@@ -195,7 +206,9 @@ public void testReadonlyCredentialsSolrZkClientFactoryUsingVMParamsProvidersButW\n     \n     SolrZkClient zkClient = new SolrZkClientUsingVMParamsProvidersButWithDifferentVMParamsNames(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -240,28 +253,18 @@ protected Collection<ZkCredentials> createCredentials() {\n \n         @Override\n         public ZkACLProvider createZkACLProvider() {\n-          return new DefaultZkACLProvider() {\n+          return new VMParamsAllAndReadonlyDigestZkACLProvider() {\n             @Override\n-            protected List<ACL> createGlobalACLsToAdd() {\n-              try {\n-                List<ACL> result = new ArrayList<ACL>();\n-            \n-                if (!StringUtils.isEmpty(digestUsername) && !StringUtils.isEmpty(digestPassword)) {\n-                  result.add(new ACL(ZooDefs.Perms.ALL, new Id(\"digest\", DigestAuthenticationProvider.generateDigest(digestUsername + \":\" + digestPassword))));\n-                }\n-            \n-                if (!StringUtils.isEmpty(digestReadonlyUsername) && !StringUtils.isEmpty(digestReadonlyPassword)) {\n-                  result.add(new ACL(ZooDefs.Perms.READ, new Id(\"digest\", DigestAuthenticationProvider.generateDigest(digestReadonlyUsername + \":\" + digestReadonlyPassword))));\n-                }\n-                \n-                if (result.isEmpty()) {\n-                  result = ZooDefs.Ids.OPEN_ACL_UNSAFE;\n-                }\n-                \n-                return result;\n-              } catch (NoSuchAlgorithmException e) {\n-                throw new RuntimeException(e);\n-              }\n+            protected List<ACL> createNonSecurityACLsToAdd() {\n+              return createACLsToAdd(true, digestUsername, digestPassword, digestReadonlyUsername, digestReadonlyPassword);\n+            }\n+\n+            /**\n+             * @return Set of ACLs to return security-related znodes\n+             */\n+            @Override\n+            protected List<ACL> createSecurityACLsToAdd() {\n+              return createACLsToAdd(false, digestUsername, digestPassword, digestReadonlyUsername, digestReadonlyPassword);\n             }\n           };\n         }"
        },
        {
            "sha": "16b67a34a21576e205e3f3135b4fa3f25cdf120e",
            "filename": "solr/core/src/test/org/apache/solr/cloud/SaslZkACLProviderTest.java",
            "status": "modified",
            "additions": 17,
            "deletions": 22,
            "changes": 39,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FSaslZkACLProviderTest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FSaslZkACLProviderTest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FSaslZkACLProviderTest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -20,15 +20,12 @@\n import java.io.IOException;\n import java.lang.invoke.MethodHandles;\n import java.nio.charset.Charset;\n-import java.util.Locale;\n \n-import javax.security.auth.login.Configuration;\n-\n-import org.apache.hadoop.minikdc.MiniKdc;\n import org.apache.lucene.util.Constants;\n import org.apache.solr.SolrTestCaseJ4;\n import org.apache.solr.common.cloud.DefaultZkACLProvider;\n import org.apache.solr.common.cloud.SaslZkACLProvider;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n import org.apache.solr.common.cloud.SolrZkClient;\n import org.apache.solr.common.cloud.ZkACLProvider;\n import org.apache.solr.util.BadZookeeperThreadsFilter;\n@@ -50,8 +47,6 @@ public class SaslZkACLProviderTest extends SolrTestCaseJ4 {\n \n   private static final Charset DATA_ENCODING = Charset.forName(\"UTF-8\");\n \n-  protected Locale savedLocale = null;\n-\n   protected ZkTestServer zkServer;\n \n   @BeforeClass\n@@ -71,7 +66,6 @@ public static void afterClass() throws InterruptedException {\n   @Override\n   public void setUp() throws Exception {\n     super.setUp();\n-    savedLocale = KerberosTestUtil.overrideLocaleIfNotSpportedByMiniKdc();\n     log.info(\"####SETUP_START \" + getTestName());\n     createTempDir();\n \n@@ -99,6 +93,7 @@ protected void setupZNodes() throws Exception {\n     try {\n       zkClient.create(\"/protectedCreateNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n       zkClient.makePath(\"/protectedMakePathNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n+      zkClient.create(SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH, \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -115,7 +110,6 @@ protected void setupZNodes() throws Exception {\n   @Override\n   public void tearDown() throws Exception {\n     zkServer.shutdown();\n-    Locale.setDefault(savedLocale);\n     super.tearDown();\n   }\n \n@@ -124,7 +118,9 @@ public void testSaslZkACLProvider() throws Exception {\n     // Test with Sasl enabled\n     SolrZkClient zkClient = new SolrZkClientWithACLs(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, true, true, true);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, true, true, true,\n+          true, true, true, true, true);\n      } finally {\n       zkClient.close();\n     }\n@@ -134,7 +130,9 @@ public void testSaslZkACLProvider() throws Exception {\n     System.setProperty(\"zookeeper.sasl.client\", \"false\");\n     zkClient = new SolrZkClientNoACLs(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient, true, true, false, false, false);\n+      VMParamsZkACLAndCredentialsProvidersTest.doTest(zkClient,\n+          true, true, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n       System.clearProperty(\"zookeeper.sasl.client\");\n@@ -176,8 +174,7 @@ public ZkACLProvider createZkACLProvider() {\n    */\n   public static class SaslZkTestServer extends ZkTestServer {\n     private String kdcDir;\n-    private MiniKdc kdc;\n-    private Configuration conf;\n+    private KerberosTestServices kerberosTestServices;\n \n     public SaslZkTestServer(String zkDir, String kdcDir) {\n       super(zkDir);\n@@ -187,13 +184,11 @@ public SaslZkTestServer(String zkDir, String kdcDir) {\n     public SaslZkTestServer(String zkDir, int port, String kdcDir) {\n       super(zkDir, port);\n       this.kdcDir = kdcDir;\n-      conf = Configuration.getConfiguration();\n     }\n \n     @Override\n     public void run() throws InterruptedException {\n       try {\n-        kdc = KerberosTestUtil.getKdc(new File(kdcDir));\n         // Don't require that credentials match the entire principal string, e.g.\n         // can match \"solr\" rather than \"solr/host@DOMAIN\"\n         System.setProperty(\"zookeeper.kerberos.removeRealmFromPrincipal\", \"true\");\n@@ -202,12 +197,13 @@ public void run() throws InterruptedException {\n         String zkClientPrincipal = \"solr\";\n         String zkServerPrincipal = \"zookeeper/127.0.0.1\";\n \n-        kdc.start();\n-        // Create ZK client and server principals and load them into the Configuration\n-        kdc.createPrincipal(keytabFile, zkClientPrincipal, zkServerPrincipal);\n-        KerberosTestUtil.JaasConfiguration jaas = new KerberosTestUtil.JaasConfiguration(\n-        zkClientPrincipal, keytabFile, zkServerPrincipal, keytabFile);\n-        Configuration.setConfiguration(jaas);\n+        kerberosTestServices = KerberosTestServices.builder()\n+            .withKdc(new File(kdcDir))\n+            .withJaasConfiguration(zkClientPrincipal, keytabFile, zkServerPrincipal, keytabFile)\n+            .build();\n+        kerberosTestServices.start();\n+\n+        kerberosTestServices.getKdc().createPrincipal(keytabFile, zkClientPrincipal, zkServerPrincipal);\n       } catch (Exception ex) {\n         throw new RuntimeException(ex);\n       }\n@@ -220,8 +216,7 @@ public void shutdown() throws IOException, InterruptedException {\n       System.clearProperty(\"zookeeper.authProvider.1\");\n       System.clearProperty(\"zookeeper.kerberos.removeRealmFromPrincipal\");\n       System.clearProperty(\"zookeeper.kerberos.removeHostFromPrincipal\");\n-      Configuration.setConfiguration(conf);\n-      kdc.stop();\n+      kerberosTestServices.stop();\n     }\n   }\n }"
        },
        {
            "sha": "6b562a1815beb9ea3a768d7beb1e11c1e501998a",
            "filename": "solr/core/src/test/org/apache/solr/cloud/TestAuthenticationFramework.java",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestAuthenticationFramework.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestAuthenticationFramework.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestAuthenticationFramework.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -235,21 +235,23 @@ public static class MockAuthenticationPlugin extends AuthenticationPlugin implem\n     public void init(Map<String,Object> pluginConfig) {}\n \n     @Override\n-    public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain)\n+    public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain)\n         throws Exception {\n       if (expectedUsername == null) {\n         filterChain.doFilter(request, response);\n-        return;\n+        return true;\n       }\n       HttpServletRequest httpRequest = (HttpServletRequest)request;\n       String username = httpRequest.getHeader(\"username\");\n       String password = httpRequest.getHeader(\"password\");\n       \n       log.info(\"Username: \"+username+\", password: \"+password);\n-      if(MockAuthenticationPlugin.expectedUsername.equals(username) && MockAuthenticationPlugin.expectedPassword.equals(password))      \n+      if(MockAuthenticationPlugin.expectedUsername.equals(username) && MockAuthenticationPlugin.expectedPassword.equals(password)) {\n         filterChain.doFilter(request, response);\n-      else {\n+        return true;\n+      } else {\n         ((HttpServletResponse)response).sendError(401, \"Unauthorized request\");\n+        return false;\n       }\n     }\n "
        },
        {
            "sha": "d644967481f496c8dedf7104787ef579fa03fbf7",
            "filename": "solr/core/src/test/org/apache/solr/cloud/TestMiniSolrCloudClusterKerberos.java",
            "status": "modified",
            "additions": 9,
            "deletions": 20,
            "changes": 29,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestMiniSolrCloudClusterKerberos.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestMiniSolrCloudClusterKerberos.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestMiniSolrCloudClusterKerberos.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -16,16 +16,13 @@\n  */\n package org.apache.solr.cloud;\n \n-import javax.security.auth.login.Configuration;\n import java.io.File;\n import java.nio.charset.StandardCharsets;\n-import java.util.Locale;\n \n import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;\n import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n \n import org.apache.commons.io.FileUtils;\n-import org.apache.hadoop.minikdc.MiniKdc;\n import org.apache.lucene.util.LuceneTestCase;\n import org.apache.lucene.util.LuceneTestCase.SuppressSysoutChecks;\n import org.apache.solr.util.BadZookeeperThreadsFilter;\n@@ -52,17 +49,14 @@\n @SuppressSysoutChecks(bugUrl = \"Solr logs to JUL\")\n public class TestMiniSolrCloudClusterKerberos extends TestMiniSolrCloudCluster {\n \n-  private final Configuration originalConfig = Configuration.getConfiguration();\n-\n   public TestMiniSolrCloudClusterKerberos () {\n     NUM_SERVERS = 5;\n     NUM_SHARDS = 2;\n     REPLICATION_FACTOR = 2;\n   }\n   \n-  private MiniKdc kdc;\n+  private KerberosTestServices kerberosTestServices;\n \n-  private Locale savedLocale; // in case locale is broken and we need to fill in a working locale\n   @Rule\n   public TestRule solrTestRules = RuleChain\n       .outerRule(new SystemPropertiesRestoreRule());\n@@ -74,20 +68,22 @@ public TestMiniSolrCloudClusterKerberos () {\n \n   @Override\n   public void setUp() throws Exception {\n-    savedLocale = KerberosTestUtil.overrideLocaleIfNotSpportedByMiniKdc();\n     super.setUp();\n     setupMiniKdc();\n   }\n   \n   private void setupMiniKdc() throws Exception {\n     String kdcDir = createTempDir()+File.separator+\"minikdc\";\n-    kdc = KerberosTestUtil.getKdc(new File(kdcDir));\n     File keytabFile = new File(kdcDir, \"keytabs\");\n     String principal = \"HTTP/127.0.0.1\";\n     String zkServerPrincipal = \"zookeeper/127.0.0.1\";\n+    KerberosTestServices kerberosTestServices = KerberosTestServices.builder()\n+        .withKdc(new File(kdcDir))\n+        .withJaasConfiguration(principal, keytabFile, zkServerPrincipal, keytabFile)\n+        .build();\n \n-    kdc.start();\n-    kdc.createPrincipal(keytabFile, principal, zkServerPrincipal);\n+    kerberosTestServices.start();\n+    kerberosTestServices.getKdc().createPrincipal(keytabFile, principal, zkServerPrincipal);\n \n     String jaas = \"Client {\\n\"\n         + \" com.sun.security.auth.module.Krb5LoginModule required\\n\"\n@@ -109,10 +105,7 @@ private void setupMiniKdc() throws Exception {\n         + \" debug=true\\n\"\n         + \" principal=\\\"\"+zkServerPrincipal+\"\\\";\\n\" \n         + \"};\\n\";\n-    \n-    Configuration conf = new KerberosTestUtil.JaasConfiguration(principal, keytabFile, zkServerPrincipal, keytabFile);\n-    javax.security.auth.login.Configuration.setConfiguration(conf);\n-    \n+\n     String jaasFilePath = kdcDir+File.separator + \"jaas-client.conf\";\n     FileUtils.write(new File(jaasFilePath), jaas, StandardCharsets.UTF_8);\n     System.setProperty(\"java.security.auth.login.config\", jaasFilePath);\n@@ -156,11 +149,7 @@ public void tearDown() throws Exception {\n     System.clearProperty(\"kerberos.principal\");\n     System.clearProperty(\"kerberos.keytab\");\n     System.clearProperty(\"authenticationPlugin\");\n-    Configuration.setConfiguration(this.originalConfig);\n-    if (kdc != null) {\n-      kdc.stop();\n-    }\n-    Locale.setDefault(savedLocale);\n+    kerberosTestServices.stop();\n     super.tearDown();\n   }\n }"
        },
        {
            "sha": "ae1c4393b88e53480b041e93b6387afe2907d30a",
            "filename": "solr/core/src/test/org/apache/solr/cloud/TestSolrCloudWithDelegationTokens.java",
            "status": "added",
            "additions": 405,
            "deletions": 0,
            "changes": 405,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithDelegationTokens.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithDelegationTokens.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithDelegationTokens.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,405 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.cloud;\n+\n+import junit.framework.Assert;\n+import org.apache.hadoop.util.Time;\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.client.solrj.impl.HttpSolrClient;\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.embedded.JettySolrRunner;\n+import org.apache.solr.client.solrj.request.CollectionAdminRequest;\n+import org.apache.solr.client.solrj.request.DelegationTokenRequest;\n+import org.apache.solr.client.solrj.response.DelegationTokenResponse;\n+import org.apache.solr.common.SolrException.ErrorCode;\n+import org.apache.solr.common.cloud.SolrZkClient;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.common.params.ModifiableSolrParams;\n+import static org.apache.solr.security.HttpParamDelegationTokenAuthenticationHandler.USER_PARAM;\n+\n+import org.apache.http.HttpStatus;\n+import org.apache.solr.security.HttpParamDelegationTokenAuthenticationHandler;\n+import org.apache.solr.security.KerberosPlugin;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import java.lang.invoke.MethodHandles;\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * Test the delegation token support in the {@link org.apache.solr.security.KerberosPlugin}.\n+ */\n+@LuceneTestCase.Slow\n+public class TestSolrCloudWithDelegationTokens extends SolrTestCaseJ4 {\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n+  private static final int NUM_SERVERS = 2;\n+  private static MiniSolrCloudCluster miniCluster;\n+  private static HttpSolrClient solrClientPrimary;\n+  private static HttpSolrClient solrClientSecondary;\n+\n+  @BeforeClass\n+  public static void startup() throws Exception {\n+    System.setProperty(\"authenticationPlugin\", KerberosPlugin.class.getName());\n+    System.setProperty(KerberosPlugin.DELEGATION_TOKEN_ENABLED, \"true\");\n+    System.setProperty(KerberosPlugin.AUTH_HANDLER_PARAM,\n+        HttpParamDelegationTokenAuthenticationHandler.class.getName());\n+    System.setProperty(\"solr.kerberos.cookie.domain\", \"127.0.0.1\");\n+\n+    miniCluster = new MiniSolrCloudCluster(NUM_SERVERS, createTempDir(), buildJettyConfig(\"/solr\"));\n+    JettySolrRunner runnerPrimary = miniCluster.getJettySolrRunners().get(0);\n+    solrClientPrimary =\n+        new HttpSolrClient.Builder(runnerPrimary.getBaseUrl().toString())\n+            .build();\n+    JettySolrRunner runnerSecondary = miniCluster.getJettySolrRunners().get(1);\n+    solrClientSecondary =\n+        new HttpSolrClient.Builder(runnerSecondary.getBaseUrl().toString())\n+            .build();\n+  }\n+\n+  @AfterClass\n+  public static void shutdown() throws Exception {\n+    if (miniCluster != null) {\n+      miniCluster.shutdown();\n+    }\n+    miniCluster = null;\n+    solrClientPrimary.close();\n+    solrClientPrimary = null;\n+    solrClientSecondary.close();\n+    solrClientSecondary = null;\n+    System.clearProperty(\"authenticationPlugin\");\n+    System.clearProperty(KerberosPlugin.DELEGATION_TOKEN_ENABLED);\n+    System.clearProperty(KerberosPlugin.AUTH_HANDLER_PARAM);\n+    System.clearProperty(\"solr.kerberos.cookie.domain\");\n+  }\n+\n+  private String getDelegationToken(final String renewer, final String user, HttpSolrClient solrClient) throws Exception {\n+    DelegationTokenRequest.Get get = new DelegationTokenRequest.Get(renewer) {\n+      @Override\n+      public SolrParams getParams() {\n+        ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());\n+        params.set(USER_PARAM, user);\n+        return params;\n+      }\n+    };\n+    DelegationTokenResponse.Get getResponse = get.process(solrClient);\n+    return getResponse.getDelegationToken();\n+  }\n+\n+  private long renewDelegationToken(final String token, final int expectedStatusCode,\n+      final String user, HttpSolrClient client) throws Exception {\n+    DelegationTokenRequest.Renew renew = new DelegationTokenRequest.Renew(token) {\n+      @Override\n+      public SolrParams getParams() {\n+        ModifiableSolrParams params = new ModifiableSolrParams(super.getParams());\n+        params.set(USER_PARAM, user);\n+        return params;\n+      }\n+\n+      @Override\n+      public Set<String> getQueryParams() {\n+        Set<String> queryParams = super.getQueryParams();\n+        queryParams.add(USER_PARAM);\n+        return queryParams;\n+      }\n+    };\n+    try {\n+      DelegationTokenResponse.Renew renewResponse = renew.process(client);\n+      assertEquals(HttpStatus.SC_OK, expectedStatusCode);\n+      return renewResponse.getExpirationTime();\n+    } catch (HttpSolrClient.RemoteSolrException ex) {\n+      assertEquals(expectedStatusCode, ex.code());\n+      return -1;\n+    }\n+  }\n+\n+  private void cancelDelegationToken(String token, int expectedStatusCode, HttpSolrClient client)\n+  throws Exception {\n+    DelegationTokenRequest.Cancel cancel = new DelegationTokenRequest.Cancel(token);\n+    try {\n+      cancel.process(client);\n+      assertEquals(HttpStatus.SC_OK, expectedStatusCode);\n+    } catch (HttpSolrClient.RemoteSolrException ex) {\n+      assertEquals(expectedStatusCode, ex.code());\n+    }\n+  }\n+\n+  private void doSolrRequest(String token, int expectedStatusCode, HttpSolrClient client)\n+  throws Exception {\n+    doSolrRequest(token, expectedStatusCode, client, 1);\n+  }\n+\n+  private void doSolrRequest(String token, int expectedStatusCode, HttpSolrClient client, int trials)\n+  throws Exception {\n+    int lastStatusCode = 0;\n+    for (int i = 0; i < trials; ++i) {\n+      lastStatusCode = getStatusCode(token, null, null, client);\n+      if (lastStatusCode == expectedStatusCode) {\n+        return;\n+      }\n+      Thread.sleep(1000);\n+    }\n+    assertEquals(\"Did not receieve excepted status code\", expectedStatusCode, lastStatusCode);\n+  }\n+\n+  private SolrRequest getAdminRequest(final SolrParams params) {\n+    return new CollectionAdminRequest.List() {\n+      @Override\n+      public SolrParams getParams() {\n+        ModifiableSolrParams p = new ModifiableSolrParams(super.getParams());\n+        p.add(params);\n+        return p;\n+      }\n+    };\n+  }\n+\n+  private int getStatusCode(String token, final String user, final String op, HttpSolrClient client)\n+  throws Exception {\n+    HttpSolrClient delegationTokenServer =\n+        new HttpSolrClient.Builder(client.getBaseURL().toString())\n+            .withDelegationToken(token)\n+            .withResponseParser(client.getParser())\n+            .build();\n+    try {\n+      ModifiableSolrParams p = new ModifiableSolrParams();\n+      if (user != null) p.set(USER_PARAM, user);\n+      if (op != null) p.set(\"op\", op);\n+      SolrRequest req = getAdminRequest(p);\n+      if (user != null || op != null) {\n+        Set<String> queryParams = new HashSet<String>();\n+        if (user != null) queryParams.add(USER_PARAM);\n+        if (op != null) queryParams.add(\"op\");\n+        req.setQueryParams(queryParams);\n+      }\n+      try {\n+        delegationTokenServer.request(req, null, null);\n+        return HttpStatus.SC_OK;\n+      } catch (HttpSolrClient.RemoteSolrException re) {\n+        return re.code();\n+      }\n+    } finally {\n+      delegationTokenServer.close();\n+    }\n+  }\n+\n+  private void doSolrRequest(HttpSolrClient client, SolrRequest request,\n+      int expectedStatusCode) throws Exception {\n+    try {\n+      client.request(request);\n+      assertEquals(HttpStatus.SC_OK, expectedStatusCode);\n+    } catch (HttpSolrClient.RemoteSolrException ex) {\n+      assertEquals(expectedStatusCode, ex.code());\n+    }\n+  }\n+\n+  private void verifyTokenValid(String token) throws Exception {\n+     // pass with token\n+    doSolrRequest(token, HttpStatus.SC_OK, solrClientPrimary);\n+\n+    // fail without token\n+    doSolrRequest(null, ErrorCode.UNAUTHORIZED.code, solrClientPrimary);\n+\n+    // pass with token on other server\n+    doSolrRequest(token, HttpStatus.SC_OK, solrClientSecondary);\n+\n+    // fail without token on other server\n+    doSolrRequest(null, ErrorCode.UNAUTHORIZED.code, solrClientSecondary);\n+  }\n+\n+  /**\n+   * Test basic Delegation Token get/verify\n+   */\n+  @Test\n+  public void testDelegationTokenVerify() throws Exception {\n+    final String user = \"bar\";\n+\n+    // Get token\n+    String token = getDelegationToken(null, user, solrClientPrimary);\n+    assertNotNull(token);\n+    verifyTokenValid(token);\n+  }\n+\n+  private void verifyTokenCancelled(String token, HttpSolrClient client) throws Exception {\n+    // fail with token on both servers.  If cancelToOtherURL is true,\n+    // the request went to other url, so FORBIDDEN should be returned immediately.\n+    // The cancelled token may take awhile to propogate to the standard url (via ZK).\n+    // This is of course the opposite if cancelToOtherURL is false.\n+    doSolrRequest(token, ErrorCode.FORBIDDEN.code, client, 10);\n+\n+    // fail without token on both servers\n+    doSolrRequest(null, ErrorCode.UNAUTHORIZED.code, solrClientPrimary);\n+    doSolrRequest(null, ErrorCode.UNAUTHORIZED.code, solrClientSecondary);\n+  }\n+\n+  @Test\n+  public void testDelegationTokenCancel() throws Exception {\n+    {\n+      // Get token\n+      String token = getDelegationToken(null, \"user\", solrClientPrimary);\n+      assertNotNull(token);\n+\n+      // cancel token, note don't need to be authenticated to cancel (no user specified)\n+      cancelDelegationToken(token, HttpStatus.SC_OK, solrClientPrimary);\n+      verifyTokenCancelled(token, solrClientPrimary);\n+    }\n+\n+    {\n+      // cancel token on different server from where we got it\n+      String token = getDelegationToken(null, \"user\", solrClientPrimary);\n+      assertNotNull(token);\n+\n+      cancelDelegationToken(token, HttpStatus.SC_OK, solrClientSecondary);\n+      verifyTokenCancelled(token, solrClientSecondary);\n+    }\n+  }\n+\n+  @Test\n+  public void testDelegationTokenCancelFail() throws Exception {\n+    // cancel a bogus token\n+    cancelDelegationToken(\"BOGUS\", ErrorCode.NOT_FOUND.code, solrClientPrimary);\n+\n+    {\n+      // cancel twice, first on same server\n+      String token = getDelegationToken(null, \"bar\", solrClientPrimary);\n+      assertNotNull(token);\n+      cancelDelegationToken(token, HttpStatus.SC_OK, solrClientPrimary);\n+      cancelDelegationToken(token, ErrorCode.NOT_FOUND.code, solrClientSecondary);\n+      cancelDelegationToken(token, ErrorCode.NOT_FOUND.code, solrClientPrimary);\n+    }\n+\n+    {\n+      // cancel twice, first on other server\n+      String token = getDelegationToken(null, \"bar\", solrClientPrimary);\n+      assertNotNull(token);\n+      cancelDelegationToken(token, HttpStatus.SC_OK, solrClientSecondary);\n+      cancelDelegationToken(token, ErrorCode.NOT_FOUND.code, solrClientSecondary);\n+      cancelDelegationToken(token, ErrorCode.NOT_FOUND.code, solrClientPrimary);\n+    }\n+  }\n+\n+  private void verifyDelegationTokenRenew(String renewer, String user)\n+  throws Exception {\n+    {\n+      // renew on same server\n+      String token = getDelegationToken(renewer, user, solrClientPrimary);\n+      assertNotNull(token);\n+      long now = Time.now();\n+      assertTrue(renewDelegationToken(token, HttpStatus.SC_OK, user, solrClientPrimary) > now);\n+      verifyTokenValid(token);\n+    }\n+\n+    {\n+      // renew on different server\n+      String token = getDelegationToken(renewer, user, solrClientPrimary);\n+      assertNotNull(token);\n+      long now = Time.now();\n+      assertTrue(renewDelegationToken(token, HttpStatus.SC_OK, user, solrClientSecondary) > now);\n+      verifyTokenValid(token);\n+    }\n+  }\n+\n+  @Test\n+  public void testDelegationTokenRenew() throws Exception {\n+    // test with specifying renewer\n+    verifyDelegationTokenRenew(\"bar\", \"bar\");\n+\n+    // test without specifying renewer\n+    verifyDelegationTokenRenew(null, \"bar\");\n+  }\n+\n+  @Test\n+  public void testDelegationTokenRenewFail() throws Exception {\n+    // don't set renewer and try to renew as an a different user\n+    String token = getDelegationToken(null, \"bar\", solrClientPrimary);\n+    assertNotNull(token);\n+    renewDelegationToken(token, ErrorCode.FORBIDDEN.code, \"foo\", solrClientPrimary);\n+    renewDelegationToken(token, ErrorCode.FORBIDDEN.code, \"foo\", solrClientSecondary);\n+\n+    // set renewer and try to renew as different user\n+    token = getDelegationToken(\"renewUser\", \"bar\", solrClientPrimary);\n+    assertNotNull(token);\n+    renewDelegationToken(token, ErrorCode.FORBIDDEN.code, \"notRenewUser\", solrClientPrimary);\n+    renewDelegationToken(token, ErrorCode.FORBIDDEN.code, \"notRenewUser\", solrClientSecondary);\n+  }\n+\n+  /**\n+   * Test that a non-delegation-token \"op\" http param is handled correctly\n+   */\n+  @Test\n+  public void testDelegationOtherOp() throws Exception {\n+    assertEquals(HttpStatus.SC_OK, getStatusCode(null, \"bar\", \"someSolrOperation\", solrClientPrimary));\n+  }\n+\n+  @Test\n+  public void testZNodePaths() throws Exception {\n+    getDelegationToken(null, \"bar\", solrClientPrimary);\n+    SolrZkClient zkClient = new SolrZkClient(miniCluster.getZkServer().getZkAddress(), 1000);\n+    try {\n+      assertTrue(zkClient.exists(\"/security/zkdtsm\", true));\n+      assertTrue(zkClient.exists(\"/security/token\", true));\n+    } finally {\n+      zkClient.close();\n+    }\n+  }\n+\n+  /**\n+   * Test HttpSolrServer's delegation token support\n+   */\n+  @Test\n+  public void testDelegationTokenSolrClient() throws Exception {\n+    // Get token\n+    String token = getDelegationToken(null, \"bar\", solrClientPrimary);\n+    assertNotNull(token);\n+\n+    SolrRequest request = getAdminRequest(new ModifiableSolrParams());\n+\n+    // test without token\n+    HttpSolrClient ss =\n+        new HttpSolrClient.Builder(solrClientPrimary.getBaseURL().toString())\n+            .withResponseParser(solrClientPrimary.getParser())\n+            .build();\n+    try {\n+      doSolrRequest(ss, request, ErrorCode.UNAUTHORIZED.code);\n+    } finally {\n+      ss.close();\n+    }\n+\n+    ss = new HttpSolrClient.Builder(solrClientPrimary.getBaseURL().toString())\n+        .withDelegationToken(token)\n+        .withResponseParser(solrClientPrimary.getParser())\n+        .build();\n+    try {\n+      // test with token via property\n+      doSolrRequest(ss, request, HttpStatus.SC_OK);\n+\n+      // test with param -- should throw an exception\n+      ModifiableSolrParams tokenParam = new ModifiableSolrParams();\n+      tokenParam.set(\"delegation\", \"invalidToken\");\n+      try {\n+        doSolrRequest(ss, getAdminRequest(tokenParam), ErrorCode.FORBIDDEN.code);\n+        Assert.fail(\"Expected exception\");\n+      } catch (IllegalArgumentException ex) {}\n+    } finally {\n+      ss.close();\n+    }\n+  }\n+}"
        },
        {
            "sha": "c505b519c88d957ac26d2c664e09bb15528a9cc5",
            "filename": "solr/core/src/test/org/apache/solr/cloud/TestSolrCloudWithKerberosAlt.java",
            "status": "modified",
            "additions": 16,
            "deletions": 21,
            "changes": 37,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithKerberosAlt.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithKerberosAlt.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FTestSolrCloudWithKerberosAlt.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -17,15 +17,12 @@\n package org.apache.solr.cloud;\n \n import java.io.File;\n+import java.lang.invoke.MethodHandles;\n import java.nio.charset.StandardCharsets;\n import java.util.List;\n-import java.util.Locale;\n import java.util.Properties;\n \n-import javax.security.auth.login.Configuration;\n-\n import org.apache.commons.io.FileUtils;\n-import org.apache.hadoop.minikdc.MiniKdc;\n import org.apache.lucene.index.TieredMergePolicy;\n import org.apache.lucene.util.Constants;\n import org.apache.lucene.util.LuceneTestCase;\n@@ -49,6 +46,8 @@\n import org.junit.Test;\n import org.junit.rules.RuleChain;\n import org.junit.rules.TestRule;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n import com.carrotsearch.randomizedtesting.annotations.ThreadLeakFilters;\n import com.carrotsearch.randomizedtesting.rules.SystemPropertiesRestoreRule;\n@@ -67,7 +66,7 @@\n @LuceneTestCase.SuppressSysoutChecks(bugUrl = \"Solr logs to JUL\")\n public class TestSolrCloudWithKerberosAlt extends LuceneTestCase {\n \n-  private final Configuration originalConfig = Configuration.getConfiguration();\n+  private static final Logger log = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   protected final int NUM_SERVERS;\n   protected final int NUM_SHARDS;\n   protected final int REPLICATION_FACTOR;\n@@ -78,10 +77,8 @@ public TestSolrCloudWithKerberosAlt () {\n     REPLICATION_FACTOR = 1;\n   }\n \n-  private MiniKdc kdc;\n+  private KerberosTestServices kerberosTestServices;\n \n-  private Locale savedLocale; // in case locale is broken and we need to fill in a working locale\n-  \n   @Rule\n   public TestRule solrTestRules = RuleChain\n       .outerRule(new SystemPropertiesRestoreRule());\n@@ -98,20 +95,22 @@ public static void betterNotBeJava9() {\n \n   @Override\n   public void setUp() throws Exception {\n-    savedLocale = KerberosTestUtil.overrideLocaleIfNotSpportedByMiniKdc();\n     super.setUp();\n     setupMiniKdc();\n   }\n \n   private void setupMiniKdc() throws Exception {\n     System.setProperty(\"solr.jaas.debug\", \"true\");\n     String kdcDir = createTempDir()+File.separator+\"minikdc\";\n-    kdc = KerberosTestUtil.getKdc(new File(kdcDir));\n+    String solrClientPrincipal = \"solr\";\n     File keytabFile = new File(kdcDir, \"keytabs\");\n+    kerberosTestServices = KerberosTestServices.builder()\n+        .withKdc(new File(kdcDir))\n+        .withJaasConfiguration(solrClientPrincipal, keytabFile, \"SolrClient\")\n+        .build();\n     String solrServerPrincipal = \"HTTP/127.0.0.1\";\n-    String solrClientPrincipal = \"solr\";\n-    kdc.start();\n-    kdc.createPrincipal(keytabFile, solrServerPrincipal, solrClientPrincipal);\n+    kerberosTestServices.start();\n+    kerberosTestServices.getKdc().createPrincipal(keytabFile, solrServerPrincipal, solrClientPrincipal);\n \n     String jaas = \"SolrClient {\\n\"\n         + \" com.sun.security.auth.module.Krb5LoginModule required\\n\"\n@@ -124,9 +123,6 @@ private void setupMiniKdc() throws Exception {\n         + \" principal=\\\"\" + solrClientPrincipal + \"\\\";\\n\"\n         + \"};\";\n \n-    Configuration conf = new KerberosTestUtil.JaasConfiguration(solrClientPrincipal, keytabFile, \"SolrClient\");\n-    Configuration.setConfiguration(conf);\n-\n     String jaasFilePath = kdcDir+File.separator+\"jaas-client.conf\";\n     FileUtils.write(new File(jaasFilePath), jaas, StandardCharsets.UTF_8);\n     System.setProperty(\"java.security.auth.login.config\", jaasFilePath);\n@@ -135,6 +131,9 @@ private void setupMiniKdc() throws Exception {\n     System.setProperty(\"solr.kerberos.principal\", solrServerPrincipal);\n     System.setProperty(\"solr.kerberos.keytab\", keytabFile.getAbsolutePath());\n     System.setProperty(\"authenticationPlugin\", \"org.apache.solr.security.KerberosPlugin\");\n+    boolean enableDt = random().nextBoolean();\n+    log.info(\"Enable delegation token: \" + enableDt);\n+    System.setProperty(\"solr.kerberos.delegation.token.enabled\", new Boolean(enableDt).toString());\n     // Extracts 127.0.0.1 from HTTP/127.0.0.1@EXAMPLE.COM\n     System.setProperty(\"solr.kerberos.name.rules\", \"RULE:[1:$1@$0](.*EXAMPLE.COM)s/@.*//\"\n         + \"\\nRULE:[2:$2@$0](.*EXAMPLE.COM)s/@.*//\"\n@@ -240,11 +239,7 @@ public void tearDown() throws Exception {\n     System.clearProperty(\"authenticationPlugin\");\n     System.clearProperty(\"solr.kerberos.name.rules\");\n     System.clearProperty(\"solr.jaas.debug\");\n-    Configuration.setConfiguration(this.originalConfig);\n-    if (kdc != null) {\n-      kdc.stop();\n-    }\n-    Locale.setDefault(savedLocale);\n+    kerberosTestServices.stop();\n     super.tearDown();\n   }\n }"
        },
        {
            "sha": "95422fa04b2a32abb61872f6d10fdad13b95ef40",
            "filename": "solr/core/src/test/org/apache/solr/cloud/VMParamsZkACLAndCredentialsProvidersTest.java",
            "status": "modified",
            "additions": 20,
            "deletions": 5,
            "changes": 25,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FVMParamsZkACLAndCredentialsProvidersTest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FVMParamsZkACLAndCredentialsProvidersTest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fcloud%2FVMParamsZkACLAndCredentialsProvidersTest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -21,6 +21,7 @@\n import java.nio.charset.Charset;\n \n import org.apache.solr.SolrTestCaseJ4;\n+import org.apache.solr.common.cloud.SecurityAwareZkACLProvider;\n import org.apache.solr.common.cloud.SolrZkClient;\n import org.apache.solr.common.cloud.VMParamsAllAndReadonlyDigestZkACLProvider;\n import org.apache.solr.common.cloud.VMParamsSingleSetCredentialsDigestZkCredentialsProvider;\n@@ -76,6 +77,8 @@ public void setUp() throws Exception {\n     zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     zkClient.create(\"/protectedCreateNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.makePath(\"/protectedMakePathNode\", \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n+\n+    zkClient.create(SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH, \"content\".getBytes(DATA_ENCODING), CreateMode.PERSISTENT, false);\n     zkClient.close();\n     \n     clearSecuritySystemProperties();\n@@ -106,7 +109,9 @@ public void testNoCredentials() throws Exception {\n     \n     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      doTest(zkClient, false, false, false, false, false);\n+      doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -118,7 +123,9 @@ public void testWrongCredentials() throws Exception {\n     \n     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      doTest(zkClient, false, false, false, false, false);\n+      doTest(zkClient,\n+          false, false, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n@@ -130,7 +137,9 @@ public void testAllCredentials() throws Exception {\n \n     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      doTest(zkClient, true, true, true, true, true);\n+      doTest(zkClient,\n+          true, true, true, true, true,\n+          true, true, true, true, true);\n     } finally {\n       zkClient.close();\n     }\n@@ -142,17 +151,23 @@ public void testReadonlyCredentials() throws Exception {\n \n     SolrZkClient zkClient = new SolrZkClient(zkServer.getZkAddress(), AbstractZkTestCase.TIMEOUT);\n     try {\n-      doTest(zkClient, true, true, false, false, false);\n+      doTest(zkClient,\n+          true, true, false, false, false,\n+          false, false, false, false, false);\n     } finally {\n       zkClient.close();\n     }\n   }\n     \n-  protected static void doTest(SolrZkClient zkClient, boolean getData, boolean list, boolean create, boolean setData, boolean delete) throws Exception {\n+  protected static void doTest(\n+      SolrZkClient zkClient,\n+      boolean getData, boolean list, boolean create, boolean setData, boolean delete,\n+      boolean secureGet, boolean secureList, boolean secureCreate, boolean secureSet, boolean secureDelete) throws Exception {\n     doTest(zkClient, \"/protectedCreateNode\", getData, list, create, setData, delete);\n     doTest(zkClient, \"/protectedMakePathNode\", getData, list, create, setData, delete);\n     doTest(zkClient, \"/unprotectedCreateNode\", true, true, true, true, delete);\n     doTest(zkClient, \"/unprotectedMakePathNode\", true, true, true, true, delete);\n+    doTest(zkClient, SecurityAwareZkACLProvider.SECURITY_ZNODE_PATH, secureGet, secureList, secureCreate, secureSet, secureDelete);\n   }\n   \n   protected static void doTest(SolrZkClient zkClient, String path, boolean getData, boolean list, boolean create, boolean setData, boolean delete) throws Exception {"
        },
        {
            "sha": "7c5c94a04446ee0ae4baf91dfa8a4fc48e803d7b",
            "filename": "solr/core/src/test/org/apache/solr/security/HttpParamDelegationTokenAuthenticationHandler.java",
            "status": "added",
            "additions": 109,
            "deletions": 0,
            "changes": 109,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FHttpParamDelegationTokenAuthenticationHandler.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FHttpParamDelegationTokenAuthenticationHandler.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FHttpParamDelegationTokenAuthenticationHandler.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,109 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.security;\n+\n+import java.io.IOException;\n+import java.nio.charset.Charset;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Properties;\n+\n+import javax.servlet.ServletException;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletResponse;\n+\n+import org.apache.hadoop.security.authentication.client.AuthenticationException;\n+import org.apache.hadoop.security.authentication.server.AuthenticationHandler;\n+import org.apache.hadoop.security.authentication.server.AuthenticationToken;\n+import org.apache.hadoop.security.token.delegation.web.DelegationTokenAuthenticationHandler;\n+\n+import org.apache.http.NameValuePair;\n+import org.apache.http.client.utils.URLEncodedUtils;\n+\n+/**\n+ * AuthenticationHandler that supports delegation tokens and simple\n+ * authentication via the \"user\" http parameter\n+ */\n+public class HttpParamDelegationTokenAuthenticationHandler extends\n+    DelegationTokenAuthenticationHandler {\n+\n+  public static final String USER_PARAM = \"user\";\n+\n+  public HttpParamDelegationTokenAuthenticationHandler() {\n+    super(new HttpParamAuthenticationHandler());\n+  }\n+\n+  @Override\n+  public void init(Properties config) throws ServletException {\n+    Properties conf = new Properties();\n+    for (Map.Entry entry : config.entrySet()) {\n+      conf.setProperty((String) entry.getKey(), (String) entry.getValue());\n+    }\n+    conf.setProperty(TOKEN_KIND, KerberosPlugin.DELEGATION_TOKEN_TYPE_DEFAULT);\n+    super.init(conf);\n+  }\n+ \n+  private static String getHttpParam(HttpServletRequest request, String param) {\n+    List<NameValuePair> pairs =\n+      URLEncodedUtils.parse(request.getQueryString(), Charset.forName(\"UTF-8\"));\n+    for (NameValuePair nvp : pairs) {\n+      if(param.equals(nvp.getName())) {\n+        return nvp.getValue();\n+      }\n+    }\n+    return null;\n+  }\n+\n+  private static class HttpParamAuthenticationHandler\n+      implements AuthenticationHandler {\n+\n+    @Override\n+    public String getType() {\n+      return \"dummy\";\n+    }\n+\n+    @Override\n+    public void init(Properties config) throws ServletException {\n+    }\n+\n+    @Override\n+    public void destroy() {\n+    }\n+\n+    @Override\n+    public boolean managementOperation(AuthenticationToken token,\n+        HttpServletRequest request, HttpServletResponse response)\n+        throws IOException, AuthenticationException {\n+      return false;\n+    }\n+\n+    @Override\n+    public AuthenticationToken authenticate(HttpServletRequest request,\n+        HttpServletResponse response)\n+        throws IOException, AuthenticationException {\n+      AuthenticationToken token = null;\n+      String userName = getHttpParam(request, USER_PARAM);\n+      if (userName != null) {\n+        return new AuthenticationToken(userName, userName, \"test\");\n+      } else {\n+        response.setStatus(HttpServletResponse.SC_UNAUTHORIZED);\n+        response.setHeader(\"WWW-Authenticate\", \"dummy\");\n+      }\n+      return token;\n+    }\n+  }\n+}"
        },
        {
            "sha": "3013086d63d09605ae17779475f656df7b0e9c0b",
            "filename": "solr/core/src/test/org/apache/solr/security/MockAuthenticationPlugin.java",
            "status": "modified",
            "additions": 30,
            "deletions": 2,
            "changes": 32,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FMockAuthenticationPlugin.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FMockAuthenticationPlugin.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fcore%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fsecurity%2FMockAuthenticationPlugin.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -20,11 +20,16 @@\n import javax.servlet.ServletException;\n import javax.servlet.ServletRequest;\n import javax.servlet.ServletResponse;\n+import javax.servlet.http.HttpServletRequest;\n+import javax.servlet.http.HttpServletRequestWrapper;\n import java.io.IOException;\n import java.security.Principal;\n import java.util.Map;\n+import java.util.concurrent.atomic.AtomicBoolean;\n import java.util.function.Predicate;\n \n+import org.apache.http.auth.BasicUserPrincipal;\n+\n public class MockAuthenticationPlugin extends AuthenticationPlugin {\n   static Predicate<ServletRequest> predicate;\n \n@@ -33,17 +38,40 @@ public void init(Map<String, Object> pluginConfig) {\n   }\n \n   @Override\n-  public void doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n+  public boolean doAuthenticate(ServletRequest request, ServletResponse response, FilterChain filterChain) throws IOException, ServletException {\n     String user = null;\n     if (predicate != null) {\n       if (predicate.test(request)) {\n         user = (String) request.getAttribute(Principal.class.getName());\n         request.removeAttribute(Principal.class.getName());\n       }\n     }\n-    forward(user, request, response, filterChain);\n+\n+    final FilterChain ffc = filterChain;\n+    final AtomicBoolean requestContinues = new AtomicBoolean(false);\n+    forward(user, request, response, new FilterChain() {\n+      @Override\n+      public void doFilter(ServletRequest req, ServletResponse res) throws IOException, ServletException {\n+        ffc.doFilter(req, res);\n+        requestContinues.set(true);\n+      }\n+    });\n+    return requestContinues.get();\n   }\n \n+  protected void forward(String user, ServletRequest  req, ServletResponse rsp,\n+                                    FilterChain chain) throws IOException, ServletException {\n+    if(user != null) {\n+      final Principal p = new BasicUserPrincipal(user);\n+      req = new HttpServletRequestWrapper((HttpServletRequest) req) {\n+        @Override\n+        public Principal getUserPrincipal() {\n+          return p;\n+        }\n+      };\n+    }\n+    chain.doFilter(req,rsp);\n+  }\n \n   @Override\n   public void close() throws IOException {"
        },
        {
            "sha": "82d894643cf821cbc75ad33c9c09ef5bc0aeb901",
            "filename": "solr/licenses/curator-recipes-2.8.0.jar.sha1",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-2.8.0.jar.sha1",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-2.8.0.jar.sha1",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Flicenses%2Fcurator-recipes-2.8.0.jar.sha1?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1 @@\n+c563e25fb37f85a6b029bc9746e75573640474fb"
        },
        {
            "sha": "7a4a3ea2424c09fbe48d455aed1eaa94d9124835",
            "filename": "solr/licenses/curator-recipes-LICENSE-ASL.txt",
            "status": "added",
            "additions": 202,
            "deletions": 0,
            "changes": 202,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-LICENSE-ASL.txt",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-LICENSE-ASL.txt",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Flicenses%2Fcurator-recipes-LICENSE-ASL.txt?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,202 @@\n+\n+                                 Apache License\n+                           Version 2.0, January 2004\n+                        http://www.apache.org/licenses/\n+\n+   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+   1. Definitions.\n+\n+      \"License\" shall mean the terms and conditions for use, reproduction,\n+      and distribution as defined by Sections 1 through 9 of this document.\n+\n+      \"Licensor\" shall mean the copyright owner or entity authorized by\n+      the copyright owner that is granting the License.\n+\n+      \"Legal Entity\" shall mean the union of the acting entity and all\n+      other entities that control, are controlled by, or are under common\n+      control with that entity. For the purposes of this definition,\n+      \"control\" means (i) the power, direct or indirect, to cause the\n+      direction or management of such entity, whether by contract or\n+      otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+      outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+      \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+      exercising permissions granted by this License.\n+\n+      \"Source\" form shall mean the preferred form for making modifications,\n+      including but not limited to software source code, documentation\n+      source, and configuration files.\n+\n+      \"Object\" form shall mean any form resulting from mechanical\n+      transformation or translation of a Source form, including but\n+      not limited to compiled object code, generated documentation,\n+      and conversions to other media types.\n+\n+      \"Work\" shall mean the work of authorship, whether in Source or\n+      Object form, made available under the License, as indicated by a\n+      copyright notice that is included in or attached to the work\n+      (an example is provided in the Appendix below).\n+\n+      \"Derivative Works\" shall mean any work, whether in Source or Object\n+      form, that is based on (or derived from) the Work and for which the\n+      editorial revisions, annotations, elaborations, or other modifications\n+      represent, as a whole, an original work of authorship. For the purposes\n+      of this License, Derivative Works shall not include works that remain\n+      separable from, or merely link (or bind by name) to the interfaces of,\n+      the Work and Derivative Works thereof.\n+\n+      \"Contribution\" shall mean any work of authorship, including\n+      the original version of the Work and any modifications or additions\n+      to that Work or Derivative Works thereof, that is intentionally\n+      submitted to Licensor for inclusion in the Work by the copyright owner\n+      or by an individual or Legal Entity authorized to submit on behalf of\n+      the copyright owner. For the purposes of this definition, \"submitted\"\n+      means any form of electronic, verbal, or written communication sent\n+      to the Licensor or its representatives, including but not limited to\n+      communication on electronic mailing lists, source code control systems,\n+      and issue tracking systems that are managed by, or on behalf of, the\n+      Licensor for the purpose of discussing and improving the Work, but\n+      excluding communication that is conspicuously marked or otherwise\n+      designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+      \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+      on behalf of whom a Contribution has been received by Licensor and\n+      subsequently incorporated within the Work.\n+\n+   2. Grant of Copyright License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      copyright license to reproduce, prepare Derivative Works of,\n+      publicly display, publicly perform, sublicense, and distribute the\n+      Work and such Derivative Works in Source or Object form.\n+\n+   3. Grant of Patent License. Subject to the terms and conditions of\n+      this License, each Contributor hereby grants to You a perpetual,\n+      worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+      (except as stated in this section) patent license to make, have made,\n+      use, offer to sell, sell, import, and otherwise transfer the Work,\n+      where such license applies only to those patent claims licensable\n+      by such Contributor that are necessarily infringed by their\n+      Contribution(s) alone or by combination of their Contribution(s)\n+      with the Work to which such Contribution(s) was submitted. If You\n+      institute patent litigation against any entity (including a\n+      cross-claim or counterclaim in a lawsuit) alleging that the Work\n+      or a Contribution incorporated within the Work constitutes direct\n+      or contributory patent infringement, then any patent licenses\n+      granted to You under this License for that Work shall terminate\n+      as of the date such litigation is filed.\n+\n+   4. Redistribution. You may reproduce and distribute copies of the\n+      Work or Derivative Works thereof in any medium, with or without\n+      modifications, and in Source or Object form, provided that You\n+      meet the following conditions:\n+\n+      (a) You must give any other recipients of the Work or\n+          Derivative Works a copy of this License; and\n+\n+      (b) You must cause any modified files to carry prominent notices\n+          stating that You changed the files; and\n+\n+      (c) You must retain, in the Source form of any Derivative Works\n+          that You distribute, all copyright, patent, trademark, and\n+          attribution notices from the Source form of the Work,\n+          excluding those notices that do not pertain to any part of\n+          the Derivative Works; and\n+\n+      (d) If the Work includes a \"NOTICE\" text file as part of its\n+          distribution, then any Derivative Works that You distribute must\n+          include a readable copy of the attribution notices contained\n+          within such NOTICE file, excluding those notices that do not\n+          pertain to any part of the Derivative Works, in at least one\n+          of the following places: within a NOTICE text file distributed\n+          as part of the Derivative Works; within the Source form or\n+          documentation, if provided along with the Derivative Works; or,\n+          within a display generated by the Derivative Works, if and\n+          wherever such third-party notices normally appear. The contents\n+          of the NOTICE file are for informational purposes only and\n+          do not modify the License. You may add Your own attribution\n+          notices within Derivative Works that You distribute, alongside\n+          or as an addendum to the NOTICE text from the Work, provided\n+          that such additional attribution notices cannot be construed\n+          as modifying the License.\n+\n+      You may add Your own copyright statement to Your modifications and\n+      may provide additional or different license terms and conditions\n+      for use, reproduction, or distribution of Your modifications, or\n+      for any such Derivative Works as a whole, provided Your use,\n+      reproduction, and distribution of the Work otherwise complies with\n+      the conditions stated in this License.\n+\n+   5. Submission of Contributions. Unless You explicitly state otherwise,\n+      any Contribution intentionally submitted for inclusion in the Work\n+      by You to the Licensor shall be under the terms and conditions of\n+      this License, without any additional terms or conditions.\n+      Notwithstanding the above, nothing herein shall supersede or modify\n+      the terms of any separate license agreement you may have executed\n+      with Licensor regarding such Contributions.\n+\n+   6. Trademarks. This License does not grant permission to use the trade\n+      names, trademarks, service marks, or product names of the Licensor,\n+      except as required for reasonable and customary use in describing the\n+      origin of the Work and reproducing the content of the NOTICE file.\n+\n+   7. Disclaimer of Warranty. Unless required by applicable law or\n+      agreed to in writing, Licensor provides the Work (and each\n+      Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+      implied, including, without limitation, any warranties or conditions\n+      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+      PARTICULAR PURPOSE. You are solely responsible for determining the\n+      appropriateness of using or redistributing the Work and assume any\n+      risks associated with Your exercise of permissions under this License.\n+\n+   8. Limitation of Liability. In no event and under no legal theory,\n+      whether in tort (including negligence), contract, or otherwise,\n+      unless required by applicable law (such as deliberate and grossly\n+      negligent acts) or agreed to in writing, shall any Contributor be\n+      liable to You for damages, including any direct, indirect, special,\n+      incidental, or consequential damages of any character arising as a\n+      result of this License or out of the use or inability to use the\n+      Work (including but not limited to damages for loss of goodwill,\n+      work stoppage, computer failure or malfunction, or any and all\n+      other commercial damages or losses), even if such Contributor\n+      has been advised of the possibility of such damages.\n+\n+   9. Accepting Warranty or Additional Liability. While redistributing\n+      the Work or Derivative Works thereof, You may choose to offer,\n+      and charge a fee for, acceptance of support, warranty, indemnity,\n+      or other liability obligations and/or rights consistent with this\n+      License. However, in accepting such obligations, You may act only\n+      on Your own behalf and on Your sole responsibility, not on behalf\n+      of any other Contributor, and only if You agree to indemnify,\n+      defend, and hold each Contributor harmless for any liability\n+      incurred by, or claims asserted against, such Contributor by reason\n+      of your accepting any such warranty or additional liability.\n+\n+   END OF TERMS AND CONDITIONS\n+\n+   APPENDIX: How to apply the Apache License to your work.\n+\n+      To apply the Apache License to your work, attach the following\n+      boilerplate notice, with the fields enclosed by brackets \"[]\"\n+      replaced with your own identifying information. (Don't include\n+      the brackets!)  The text should be enclosed in the appropriate\n+      comment syntax for the file format. We also recommend that a\n+      file or class name and description of purpose be included on the\n+      same \"printed page\" as the copyright notice for easier\n+      identification within third-party archives.\n+\n+   Copyright [yyyy] [name of copyright owner]\n+\n+   Licensed under the Apache License, Version 2.0 (the \"License\");\n+   you may not use this file except in compliance with the License.\n+   You may obtain a copy of the License at\n+\n+       http://www.apache.org/licenses/LICENSE-2.0\n+\n+   Unless required by applicable law or agreed to in writing, software\n+   distributed under the License is distributed on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+   See the License for the specific language governing permissions and\n+   limitations under the License.\n\\ No newline at end of file"
        },
        {
            "sha": "f568d0fe32eeca6ac18ce475cb92f0c565f1fa4b",
            "filename": "solr/licenses/curator-recipes-NOTICE.txt",
            "status": "added",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-NOTICE.txt",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Flicenses%2Fcurator-recipes-NOTICE.txt",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Flicenses%2Fcurator-recipes-NOTICE.txt?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,5 @@\n+Apache Curator\n+Copyright 2013-2014 The Apache Software Foundation\n+\n+This product includes software developed at\n+The Apache Software Foundation (http://www.apache.org/).\n\\ No newline at end of file"
        },
        {
            "sha": "f2296c55a7f93d9e490e17924b7df432779937ec",
            "filename": "solr/solrj/ivy.xml",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fivy.xml",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fivy.xml",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fivy.xml?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -1,3 +1,4 @@\n+<?xml version=\"1.0\" encoding=\"utf-8\"?>\n <!--\n    Licensed to the Apache Software Foundation (ASF) under one\n    or more contributor license agreements.  See the NOTICE file\n@@ -40,6 +41,10 @@\n \n     <dependency org=\"org.slf4j\" name=\"slf4j-log4j12\" rev=\"${/org.slf4j/slf4j-log4j12}\" conf=\"test\"/>\n \n+    <dependency org=\"com.fasterxml.jackson.core\" name=\"jackson-annotations\"  rev=\"${/com.fasterxml.jackson.core/jackson-annotations}\"   conf=\"compile\"/>\n+    <dependency org=\"com.fasterxml.jackson.core\" name=\"jackson-core\" rev=\"${/com.fasterxml.jackson.core/jackson-core}\" conf=\"compile\"/>\n+    <dependency org=\"com.fasterxml.jackson.core\" name=\"jackson-databind\" rev=\"${/com.fasterxml.jackson.core/jackson-databind}\" conf=\"compile\"/>\n+    <dependency org=\"com.google.guava\" name=\"guava\" rev=\"${/com.google.guava/guava}\" conf=\"compile\"/>\n     <exclude org=\"*\" ext=\"*\" matcher=\"regexp\" type=\"${ivy.exclude.types}\"/>\n   </dependencies>\n </ivy-module>"
        },
        {
            "sha": "222119c0744098a7fded91595ab43057a54b2810",
            "filename": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/HttpSolrClient.java",
            "status": "modified",
            "additions": 54,
            "deletions": 3,
            "changes": 57,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FHttpSolrClient.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FHttpSolrClient.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FHttpSolrClient.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -23,13 +23,15 @@\n import java.net.ConnectException;\n import java.net.SocketTimeoutException;\n import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n import java.util.Collection;\n import java.util.Collections;\n import java.util.Iterator;\n import java.util.LinkedList;\n import java.util.List;\n import java.util.Locale;\n import java.util.Set;\n+import java.util.TreeSet;\n import java.util.concurrent.ExecutorService;\n import java.util.concurrent.Future;\n \n@@ -743,7 +745,44 @@ public RemoteSolrException(String remoteHost, int code, String msg, Throwable th\n       super(code, \"Error from server at \" + remoteHost + \": \" + msg, th);\n     }\n   }\n-  \n+\n+  private static class DelegationTokenHttpSolrClient extends HttpSolrClient {\n+    private final String DELEGATION_TOKEN_PARAM = \"delegation\";\n+    private final String delegationToken;\n+\n+    public DelegationTokenHttpSolrClient(String baseURL,\n+                                         HttpClient client,\n+                                         ResponseParser parser,\n+                                         boolean allowCompression,\n+                                         String delegationToken) {\n+      super(baseURL, client, parser, allowCompression);\n+      if (delegationToken == null) {\n+        throw new IllegalArgumentException(\"Delegation token cannot be null\");\n+      }\n+      this.delegationToken = delegationToken;\n+      setQueryParams(new TreeSet<String>(Arrays.asList(DELEGATION_TOKEN_PARAM)));\n+      invariantParams = new ModifiableSolrParams();\n+      invariantParams.set(DELEGATION_TOKEN_PARAM, delegationToken);\n+    }\n+\n+    @Override\n+    protected HttpRequestBase createMethod(final SolrRequest request, String collection) throws IOException, SolrServerException {\n+      SolrParams params = request.getParams();\n+      if (params.getParams(DELEGATION_TOKEN_PARAM) != null) {\n+        throw new IllegalArgumentException(DELEGATION_TOKEN_PARAM + \" parameter not supported\");\n+      }\n+      return super.createMethod(request, collection);\n+    }\n+\n+    @Override\n+    public void setQueryParams(Set<String> queryParams) {\n+      if (queryParams == null || !queryParams.contains(DELEGATION_TOKEN_PARAM)) {\n+        throw new IllegalArgumentException(\"Query params must contain \" + DELEGATION_TOKEN_PARAM);\n+      }\n+      super.setQueryParams(queryParams);\n+    }\n+  }\n+\n   /**\n    * Constructs {@link HttpSolrClient} instances from provided configuration.\n    */\n@@ -752,6 +791,7 @@ public static class Builder {\n     private HttpClient httpClient;\n     private ResponseParser responseParser;\n     private boolean compression;\n+    private String delegationToken;\n     \n     /**\n      * Create a Builder object, based on the provided Solr URL.\n@@ -788,15 +828,26 @@ public Builder allowCompression(boolean compression) {\n       this.compression = compression;\n       return this;\n     }\n-    \n+\n+    /**\n+     * Use a delegation token for authenticating via the KerberosPlugin\n+     */\n+    public Builder withDelegationToken(String delegationToken) {\n+      this.delegationToken = delegationToken;\n+      return this;\n+    }\n     /**\n      * Create a {@link HttpSolrClient} based on provided configuration.\n      */\n     public HttpSolrClient build() {\n       if (baseSolrUrl == null) {\n         throw new IllegalArgumentException(\"Cannot create HttpSolrClient without a valid baseSolrUrl!\");\n       }\n-      return new HttpSolrClient(baseSolrUrl, httpClient, responseParser, compression);\n+      if (delegationToken == null) {\n+        return new HttpSolrClient(baseSolrUrl, httpClient, responseParser, compression);\n+      } else {\n+        return new DelegationTokenHttpSolrClient(baseSolrUrl, httpClient, responseParser, compression, delegationToken);\n+      }\n     }\n   }\n }"
        },
        {
            "sha": "84fe5f94c0bc41f1f5f75a8af76ff9dd74ccd836",
            "filename": "solr/solrj/src/java/org/apache/solr/client/solrj/impl/Krb5HttpClientBuilder.java",
            "status": "modified",
            "additions": 14,
            "deletions": 4,
            "changes": 18,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FKrb5HttpClientBuilder.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FKrb5HttpClientBuilder.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fimpl%2FKrb5HttpClientBuilder.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -26,6 +26,7 @@\n import javax.security.auth.login.AppConfigurationEntry;\n import javax.security.auth.login.Configuration;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.http.HttpEntity;\n import org.apache.http.HttpEntityEnclosingRequest;\n import org.apache.http.HttpRequestInterceptor;\n@@ -51,12 +52,21 @@ public class Krb5HttpClientBuilder  {\n   public static final String LOGIN_CONFIG_PROP = \"java.security.auth.login.config\";\n   private static final Logger logger = LoggerFactory.getLogger(MethodHandles.lookup().lookupClass());\n   \n-  private static final Configuration jaasConfig = new SolrJaasConfiguration();\n+  private static Configuration jaasConfig = new SolrJaasConfiguration();\n \n   public Krb5HttpClientBuilder() {\n \n   }\n-  \n+\n+  /**\n+   * The jaasConfig is static, which makes it problematic for testing in the same jvm.\n+   * Call this function to regenerate the static config (this is not thread safe).\n+   */\n+  @VisibleForTesting\n+  public static void regenerateJaasConfiguration() {\n+    jaasConfig = new SolrJaasConfiguration();\n+  }\n+\n   public SolrHttpClientBuilder getBuilder() {\n     return getBuilder(HttpClientUtil.getHttpClientBuilder());\n   }\n@@ -104,9 +114,9 @@ public Principal getUserPrincipal() {\n             return null;\n           }\n         };\n-        \n+\n         HttpClientUtil.setCookiePolicy(SolrPortAwareCookieSpecFactory.POLICY_NAME);\n-        \n+\n         builder.setCookieSpecRegistryProvider(() -> {\n           SolrPortAwareCookieSpecFactory cookieFactory = new SolrPortAwareCookieSpecFactory();\n "
        },
        {
            "sha": "6d2f0cb8c2f226e79f882a62cc86e2a3d55ebec6",
            "filename": "solr/solrj/src/java/org/apache/solr/client/solrj/request/DelegationTokenRequest.java",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FDelegationTokenRequest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FDelegationTokenRequest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FDelegationTokenRequest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,152 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.request;\n+\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.Collection;\n+import java.util.Set;\n+import java.util.TreeSet;\n+\n+import org.apache.solr.client.solrj.SolrRequest;\n+import org.apache.solr.client.solrj.SolrClient;\n+import org.apache.solr.client.solrj.impl.NoOpResponseParser;\n+import org.apache.solr.client.solrj.response.DelegationTokenResponse;\n+\n+import org.apache.solr.common.params.ModifiableSolrParams;\n+import org.apache.solr.common.params.SolrParams;\n+import org.apache.solr.common.util.ContentStream;\n+\n+/**\n+ * Class for making Solr delegation token requests.\n+ *\n+ * @since Solr 6.2\n+ */\n+public abstract class DelegationTokenRequest\n+    <Q extends DelegationTokenRequest<Q,R>, R extends DelegationTokenResponse>\n+    extends SolrRequest<R> {\n+\n+  protected static final String OP_KEY = \"op\";\n+  protected static final String TOKEN_KEY = \"token\";\n+\n+  public DelegationTokenRequest(METHOD m) {\n+    // path doesn't really matter -- the filter will respond to any path.\n+    // setting the path to admin/collections lets us pass through CloudSolrServer\n+    // without having to specify a collection (that may not even exist yet).\n+    super(m, \"/admin/collections\");\n+  }\n+\n+  protected abstract Q getThis();\n+\n+  /**\n+   * {@inheritDoc}\n+   */\n+  @Override\n+  public Collection<ContentStream> getContentStreams() throws IOException {\n+    return null;\n+  }\n+\n+  @Override\n+  protected abstract R createResponse(SolrClient client);\n+\n+  public static class Get extends DelegationTokenRequest<Get, DelegationTokenResponse.Get> {\n+    protected String renewer;\n+\n+    public Get() {\n+      this(null);\n+    }\n+\n+    public Get(String renewer) {\n+      super(METHOD.GET);\n+      this.renewer = renewer;\n+      setResponseParser(new DelegationTokenResponse.JsonMapResponseParser());\n+      setQueryParams(new TreeSet<String>(Arrays.asList(OP_KEY)));\n+    }\n+\n+    @Override\n+    protected Get getThis() {\n+      return this;\n+    }\n+\n+    @Override\n+    public SolrParams getParams() {\n+      ModifiableSolrParams params = new ModifiableSolrParams();\n+      params.set(OP_KEY, \"GETDELEGATIONTOKEN\");\n+      if (renewer != null) params.set(\"renewer\", renewer);\n+      return params;\n+    }\n+\n+    @Override\n+    public DelegationTokenResponse.Get createResponse(SolrClient client) { return new DelegationTokenResponse.Get(); }\n+  }\n+\n+  public static class Renew extends DelegationTokenRequest<Renew, DelegationTokenResponse.Renew> {\n+    protected String token;\n+\n+    @Override\n+    protected Renew getThis() {\n+      return this;\n+    }\n+\n+    public Renew(String token) {\n+      super(METHOD.PUT);\n+      this.token = token;\n+      setResponseParser(new DelegationTokenResponse.JsonMapResponseParser());\n+      setQueryParams(new TreeSet<String>(Arrays.asList(OP_KEY, TOKEN_KEY)));\n+    }\n+\n+    @Override\n+    public SolrParams getParams() {\n+      ModifiableSolrParams params = new ModifiableSolrParams();\n+      params.set(OP_KEY, \"RENEWDELEGATIONTOKEN\");\n+      params.set(TOKEN_KEY, token);\n+      return params;\n+    }\n+\n+    @Override\n+    public DelegationTokenResponse.Renew createResponse(SolrClient client) { return new DelegationTokenResponse.Renew(); }\n+  }\n+\n+  public static class Cancel extends DelegationTokenRequest<Cancel, DelegationTokenResponse.Cancel> {\n+    protected String token;\n+\n+    public Cancel(String token) {\n+      super(METHOD.PUT);\n+      this.token = token;\n+      setResponseParser(new NoOpResponseParser());\n+      Set<String> queryParams = new TreeSet<String>();\n+      setQueryParams(new TreeSet<String>(Arrays.asList(OP_KEY, TOKEN_KEY)));\n+    }\n+\n+    @Override\n+    protected Cancel getThis() {\n+      return this;\n+    }\n+\n+    @Override\n+    public SolrParams getParams() {\n+      ModifiableSolrParams params = new ModifiableSolrParams();\n+      params.set(OP_KEY, \"CANCELDELEGATIONTOKEN\");\n+      params.set(TOKEN_KEY, token);\n+      return params;\n+    }\n+\n+    @Override\n+    public DelegationTokenResponse.Cancel createResponse(SolrClient client) { return new DelegationTokenResponse.Cancel(); }\n+  }\n+}"
        },
        {
            "sha": "c80e2eb44b95193d1ec72e72dc93056ed4f9d20a",
            "filename": "solr/solrj/src/java/org/apache/solr/client/solrj/response/DelegationTokenResponse.java",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FDelegationTokenResponse.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FDelegationTokenResponse.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FDelegationTokenResponse.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,108 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.response;\n+\n+import org.apache.solr.client.solrj.ResponseParser;\n+import org.apache.solr.common.SolrException;\n+import org.apache.solr.common.util.NamedList;\n+\n+import com.fasterxml.jackson.databind.ObjectMapper;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.io.Reader;\n+import java.util.Map;\n+\n+/**\n+ * Delegation Token responses\n+ */\n+public abstract class DelegationTokenResponse extends SolrResponseBase {\n+\n+  public static class Get extends DelegationTokenResponse {\n+\n+    /**\n+     * Get the urlString to be used as the delegation token\n+     */\n+    public String getDelegationToken() {\n+      try {\n+        Map map = (Map)getResponse().get(\"Token\");\n+        if (map != null) {\n+          return (String)map.get(\"urlString\");\n+        }\n+      } catch (ClassCastException e) {\n+        throw new SolrException (SolrException.ErrorCode.SERVER_ERROR,\n+          \"parsing error\", e);\n+      }\n+      return null;\n+    }\n+  }\n+\n+  public static class Renew extends DelegationTokenResponse {\n+    public Long getExpirationTime() {\n+      try {\n+        return (Long)getResponse().get(\"long\");\n+      } catch (ClassCastException e) {\n+        throw new SolrException (SolrException.ErrorCode.SERVER_ERROR,\n+          \"parsing error\", e);\n+      }\n+    }\n+  }\n+\n+  public static class Cancel extends DelegationTokenResponse {\n+  }\n+\n+  /**\n+   * ResponseParser for JsonMaps.  Used for Get and Renew DelegationToken responses.\n+   */\n+  public static class JsonMapResponseParser extends ResponseParser {\n+    @Override\n+    public String getWriterType() {\n+      return \"json\";\n+    }\n+\n+    @Override\n+    public NamedList<Object> processResponse(InputStream body, String encoding) {\n+      ObjectMapper mapper = new ObjectMapper();\n+      Map map = null;\n+      try {\n+        map = mapper.readValue(body, Map.class);\n+      } catch (IOException e) {\n+        throw new SolrException (SolrException.ErrorCode.SERVER_ERROR,\n+          \"parsing error\", e);\n+      }\n+      NamedList<Object> list = new NamedList<Object>();\n+      list.addAll(map);\n+      return list;\n+    }\n+\n+    @Override\n+    public NamedList<Object> processResponse(Reader reader) {\n+      throw new RuntimeException(\"Cannot handle character stream\");\n+    }\n+\n+    @Override\n+    public String getContentType() {\n+      return \"application/json\";\n+    }\n+\n+    @Override\n+    public String getVersion() {\n+      return \"1\";\n+    }\n+  }\n+}"
        },
        {
            "sha": "c67ad12d1d52ab46c0cfce3d29954e11a044001d",
            "filename": "solr/solrj/src/java/org/apache/solr/common/cloud/SaslZkACLProvider.java",
            "status": "modified",
            "additions": 12,
            "deletions": 9,
            "changes": 21,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSaslZkACLProvider.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSaslZkACLProvider.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSaslZkACLProvider.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -30,19 +30,22 @@\n  * configurations have already been set up and will not be modified, or\n  * where configuration changes are controlled via Solr APIs.\n  */\n-public class SaslZkACLProvider extends DefaultZkACLProvider {\n+public class SaslZkACLProvider extends SecurityAwareZkACLProvider {\n \n   private static String superUser = System.getProperty(\"solr.authorization.superuser\", \"solr\");\n \n   @Override\n-  protected List<ACL> createGlobalACLsToAdd() {\n-    List<ACL> result = new ArrayList<ACL>();\n-    result.add(new ACL(ZooDefs.Perms.ALL, new Id(\"sasl\", superUser)));\n-    result.add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n+  protected List<ACL> createNonSecurityACLsToAdd() {\n+    List<ACL> ret = new ArrayList<ACL>();\n+    ret.add(new ACL(ZooDefs.Perms.ALL, new Id(\"sasl\", superUser)));\n+    ret.add(new ACL(ZooDefs.Perms.READ, ZooDefs.Ids.ANYONE_ID_UNSAFE));\n+    return ret;\n+  }\n \n-    if (result.isEmpty()) {\n-      result = super.createGlobalACLsToAdd();\n-    }\n-    return result;\n+  @Override\n+  protected List<ACL> createSecurityACLsToAdd() {\n+    List<ACL> ret = new ArrayList<ACL>();\n+    ret.add(new ACL(ZooDefs.Perms.ALL, new Id(\"sasl\", superUser)));\n+    return ret;\n   }\n }"
        },
        {
            "sha": "1c74d948222e3ac2fc5b00d3e19b096342b273b0",
            "filename": "solr/solrj/src/java/org/apache/solr/common/cloud/SecurityAwareZkACLProvider.java",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSecurityAwareZkACLProvider.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSecurityAwareZkACLProvider.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSecurityAwareZkACLProvider.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.common.cloud;\n+\n+import java.util.List;\n+\n+import org.apache.zookeeper.data.ACL;\n+\n+/**\n+ * {@link ZkACLProvider} capable of returning a different set of\n+ * {@link ACL}s for security-related znodes (default: subtree under /security)\n+ * vs non-security-related znodes.\n+ */\n+public abstract class SecurityAwareZkACLProvider implements ZkACLProvider {\n+  public static final String SECURITY_ZNODE_PATH = \"/security\";\n+\n+  private List<ACL> nonSecurityACLsToAdd;\n+  private List<ACL> securityACLsToAdd;\n+\n+\n+  @Override\n+  public List<ACL> getACLsToAdd(String zNodePath) {\n+    if (isSecurityZNodePath(zNodePath)) {\n+      return getSecurityACLsToAdd();\n+    } else {\n+      return getNonSecurityACLsToAdd();\n+    }\n+  }\n+\n+  protected boolean isSecurityZNodePath(String zNodePath) {\n+    if (zNodePath != null\n+        && (zNodePath.equals(SECURITY_ZNODE_PATH) || zNodePath.startsWith(SECURITY_ZNODE_PATH + \"/\"))) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * @return Set of ACLs to return for non-security related znodes\n+   */\n+  protected abstract List<ACL> createNonSecurityACLsToAdd();\n+\n+  /**\n+   * @return Set of ACLs to return security-related znodes\n+   */\n+  protected abstract List<ACL> createSecurityACLsToAdd();\n+\n+  private List<ACL> getNonSecurityACLsToAdd() {\n+    if (nonSecurityACLsToAdd == null) {\n+      synchronized (this) {\n+        if (nonSecurityACLsToAdd == null) nonSecurityACLsToAdd = createNonSecurityACLsToAdd();\n+      }\n+    }\n+    return nonSecurityACLsToAdd;\n+  }\n+\n+  private List<ACL> getSecurityACLsToAdd() {\n+    if (securityACLsToAdd == null) {\n+      synchronized (this) {\n+        if (securityACLsToAdd == null) securityACLsToAdd = createSecurityACLsToAdd();\n+      }\n+    }\n+    return securityACLsToAdd;\n+  }\n+}"
        },
        {
            "sha": "516b7b947c8d690767d9ed4dc176ee752e1a6a52",
            "filename": "solr/solrj/src/java/org/apache/solr/common/cloud/SolrZkClient.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSolrZkClient.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSolrZkClient.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FSolrZkClient.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -122,12 +122,12 @@ public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConne\n \n   public SolrZkClient(String zkServerAddress, int zkClientTimeout, int clientConnectTimeout,\n       ZkClientConnectionStrategy strat, final OnReconnect onReconnect, BeforeReconnect beforeReconnect, ZkACLProvider zkACLProvider) {\n-    this.zkClientConnectionStrategy = strat;\n     this.zkServerAddress = zkServerAddress;\n     \n     if (strat == null) {\n       strat = new DefaultConnectionStrategy();\n     }\n+    this.zkClientConnectionStrategy = strat;\n \n     if (!strat.hasZkCredentialsToAddAutomatically()) {\n       ZkCredentialsProvider zkCredentialsToAddAutomatically = createZkCredentialsToAddAutomatically();"
        },
        {
            "sha": "88662455e71042c8438ad4dbc57223e272abadf8",
            "filename": "solr/solrj/src/java/org/apache/solr/common/cloud/VMParamsAllAndReadonlyDigestZkACLProvider.java",
            "status": "modified",
            "additions": 40,
            "deletions": 12,
            "changes": 52,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FVMParamsAllAndReadonlyDigestZkACLProvider.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FVMParamsAllAndReadonlyDigestZkACLProvider.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FVMParamsAllAndReadonlyDigestZkACLProvider.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -20,13 +20,14 @@\n import java.util.ArrayList;\n import java.util.List;\n \n+import com.google.common.annotations.VisibleForTesting;\n import org.apache.solr.common.StringUtils;\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.ACL;\n import org.apache.zookeeper.data.Id;\n import org.apache.zookeeper.server.auth.DigestAuthenticationProvider;\n \n-public class VMParamsAllAndReadonlyDigestZkACLProvider extends DefaultZkACLProvider {\n+public class VMParamsAllAndReadonlyDigestZkACLProvider extends SecurityAwareZkACLProvider {\n \n   public static final String DEFAULT_DIGEST_READONLY_USERNAME_VM_PARAM_NAME = \"zkDigestReadonlyUsername\";\n   public static final String DEFAULT_DIGEST_READONLY_PASSWORD_VM_PARAM_NAME = \"zkDigestReadonlyPassword\";\n@@ -53,29 +54,56 @@ public VMParamsAllAndReadonlyDigestZkACLProvider(String zkDigestAllUsernameVMPar\n     this.zkDigestReadonlyPasswordVMParamName = zkDigestReadonlyPasswordVMParamName;\n   }\n \n+  /**\n+   * @return Set of ACLs to return for non-security related znodes\n+   */\n+  @Override\n+  protected List<ACL> createNonSecurityACLsToAdd() {\n+    return createACLsToAdd(true);\n+  }\n \n+  /**\n+   * @return Set of ACLs to return security-related znodes\n+   */\n   @Override\n-  protected List<ACL> createGlobalACLsToAdd() {\n-    try {\n+  protected List<ACL> createSecurityACLsToAdd() {\n+    return createACLsToAdd(false);\n+  }\n+\n+  protected List<ACL> createACLsToAdd(boolean includeReadOnly) {\n+    String digestAllUsername = System.getProperty(zkDigestAllUsernameVMParamName);\n+    String digestAllPassword = System.getProperty(zkDigestAllPasswordVMParamName);\n+    String digestReadonlyUsername = System.getProperty(zkDigestReadonlyUsernameVMParamName);\n+    String digestReadonlyPassword = System.getProperty(zkDigestReadonlyPasswordVMParamName);\n+\n+    return createACLsToAdd(includeReadOnly,\n+        digestAllUsername, digestAllPassword,\n+        digestReadonlyUsername, digestReadonlyPassword);\n+  }\n+\n+  @VisibleForTesting\n+  protected List<ACL> createACLsToAdd(boolean includeReadOnly,\n+                                      String digestAllUsername, String digestAllPassword,\n+                                      String digestReadonlyUsername, String digestReadonlyPassword) {\n+\n+      try {\n       List<ACL> result = new ArrayList<ACL>();\n   \n       // Not to have to provide too much credentials and ACL information to the process it is assumed that you want \"ALL\"-acls\n       // added to the user you are using to connect to ZK (if you are using VMParamsSingleSetCredentialsDigestZkCredentialsProvider)\n-      String digestAllUsername = System.getProperty(zkDigestAllUsernameVMParamName);\n-      String digestAllPassword = System.getProperty(zkDigestAllPasswordVMParamName);\n       if (!StringUtils.isEmpty(digestAllUsername) && !StringUtils.isEmpty(digestAllPassword)) {\n         result.add(new ACL(ZooDefs.Perms.ALL, new Id(\"digest\", DigestAuthenticationProvider.generateDigest(digestAllUsername + \":\" + digestAllPassword))));\n       }\n-  \n-      // Besides that support for adding additional \"READONLY\"-acls for another user\n-      String digestReadonlyUsername = System.getProperty(zkDigestReadonlyUsernameVMParamName);\n-      String digestReadonlyPassword = System.getProperty(zkDigestReadonlyPasswordVMParamName);\n-      if (!StringUtils.isEmpty(digestReadonlyUsername) && !StringUtils.isEmpty(digestReadonlyPassword)) {\n-        result.add(new ACL(ZooDefs.Perms.READ, new Id(\"digest\", DigestAuthenticationProvider.generateDigest(digestReadonlyUsername + \":\" + digestReadonlyPassword))));\n+\n+      if (includeReadOnly) {\n+        // Besides that support for adding additional \"READONLY\"-acls for another user\n+        if (!StringUtils.isEmpty(digestReadonlyUsername) && !StringUtils.isEmpty(digestReadonlyPassword)) {\n+          result.add(new ACL(ZooDefs.Perms.READ, new Id(\"digest\", DigestAuthenticationProvider.generateDigest(digestReadonlyUsername + \":\" + digestReadonlyPassword))));\n+        }\n       }\n       \n       if (result.isEmpty()) {\n-        result = super.createGlobalACLsToAdd();\n+        result = ZooDefs.Ids.OPEN_ACL_UNSAFE;\n       }\n       \n       return result;"
        },
        {
            "sha": "acc5abf7c383ca36816878b3eb8becbb825aa00f",
            "filename": "solr/solrj/src/java/org/apache/solr/common/cloud/ZkClientConnectionStrategy.java",
            "status": "modified",
            "additions": 3,
            "deletions": 1,
            "changes": 4,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FZkClientConnectionStrategy.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FZkClientConnectionStrategy.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Fjava%2Forg%2Fapache%2Fsolr%2Fcommon%2Fcloud%2FZkClientConnectionStrategy.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -97,7 +97,9 @@ public void setZkCredentialsToAddAutomatically(ZkCredentialsProvider zkCredentia\n   public boolean hasZkCredentialsToAddAutomatically() {\n     return zkCredentialsToAddAutomatically != null;\n   }\n-  \n+\n+  public ZkCredentialsProvider getZkCredentialsToAddAutomatically() { return zkCredentialsToAddAutomatically; }\n+\n   protected SolrZooKeeper createSolrZooKeeper(final String serverAddress, final int zkClientTimeout,\n       final Watcher watcher) throws IOException {\n     SolrZooKeeper result = new SolrZooKeeper(serverAddress, zkClientTimeout, watcher);"
        },
        {
            "sha": "47b8385cf06ae3ddbbc47ebdf4640b3d8428b44d",
            "filename": "solr/solrj/src/test/org/apache/solr/client/solrj/request/TestDelegationTokenRequest.java",
            "status": "added",
            "additions": 70,
            "deletions": 0,
            "changes": 70,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FTestDelegationTokenRequest.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FTestDelegationTokenRequest.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Frequest%2FTestDelegationTokenRequest.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,70 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.solr.client.solrj.request;\n+\n+import org.apache.lucene.util.LuceneTestCase;\n+\n+import org.junit.Test;\n+\n+/**\n+ * Test for DelegationTokenRequests\n+ */\n+public class TestDelegationTokenRequest extends LuceneTestCase {\n+\n+  @Test\n+  public void testGetRequest() throws Exception {\n+    // without renewer\n+    DelegationTokenRequest.Get get = new DelegationTokenRequest.Get();\n+    assertEquals(\"GETDELEGATIONTOKEN\", get.getParams().get(\"op\"));\n+    assertNull(get.getParams().get(\"renewer\"));\n+\n+\n+    // with renewer\n+    final String renewer = \"test\";\n+    get = new DelegationTokenRequest.Get(renewer);\n+    assertEquals(\"GETDELEGATIONTOKEN\", get.getParams().get(\"op\"));\n+    assertEquals(renewer, get.getParams().get(\"renewer\"));\n+  }\n+\n+  @Test\n+  public void testRenewRequest() throws Exception {\n+    final String token = \"testToken\";\n+    DelegationTokenRequest.Renew renew = new DelegationTokenRequest.Renew(token);\n+    assertEquals(\"RENEWDELEGATIONTOKEN\", renew.getParams().get(\"op\"));\n+    assertEquals(token, renew.getParams().get(\"token\"));\n+    assertTrue(renew.getQueryParams().contains(\"op\"));\n+    assertTrue(renew.getQueryParams().contains(\"token\"));\n+\n+    // can handle null token\n+    renew = new DelegationTokenRequest.Renew(null);\n+    renew.getParams();\n+  }\n+\n+  @Test\n+  public void testCancelRequest() throws Exception {\n+    final String token = \"testToken\";\n+    DelegationTokenRequest.Cancel cancel = new DelegationTokenRequest.Cancel(token);\n+    assertEquals(\"CANCELDELEGATIONTOKEN\", cancel.getParams().get(\"op\"));\n+    assertEquals(token, cancel.getParams().get(\"token\"));\n+    assertTrue(cancel.getQueryParams().contains(\"op\"));\n+    assertTrue(cancel.getQueryParams().contains(\"token\"));\n+\n+    // can handle null token\n+    cancel = new DelegationTokenRequest.Cancel(null);\n+    cancel.getParams();\n+  }\n+}"
        },
        {
            "sha": "c376223b3e448348ef04e0b1b8ce7b308aca02b7",
            "filename": "solr/solrj/src/test/org/apache/solr/client/solrj/response/TestDelegationTokenResponse.java",
            "status": "added",
            "additions": 138,
            "deletions": 0,
            "changes": 138,
            "blob_url": "https://github.com/apache/lucene-solr/blob/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FTestDelegationTokenResponse.java",
            "raw_url": "https://github.com/apache/lucene-solr/raw/7bf019a9c2779368133850f141174febede6ad96/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FTestDelegationTokenResponse.java",
            "contents_url": "https://api.github.com/repos/apache/lucene-solr/contents/solr%2Fsolrj%2Fsrc%2Ftest%2Forg%2Fapache%2Fsolr%2Fclient%2Fsolrj%2Fresponse%2FTestDelegationTokenResponse.java?ref=7bf019a9c2779368133850f141174febede6ad96",
            "patch": "@@ -0,0 +1,138 @@\n+/*\n+ * Licensed to the Apache Software Foundation (ASF) under one or more\n+ * contributor license agreements.  See the NOTICE file distributed with\n+ * this work for additional information regarding copyright ownership.\n+ * The ASF licenses this file to You under the Apache License, Version 2.0\n+ * (the \"License\"); you may not use this file except in compliance with\n+ * the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.solr.client.solrj.response;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.io.IOUtils;\n+\n+import org.apache.lucene.util.LuceneTestCase;\n+import org.apache.solr.client.solrj.ResponseParser;\n+import org.apache.solr.client.solrj.request.DelegationTokenRequest;\n+import org.apache.solr.common.SolrException;\n+\n+import org.junit.Test;\n+\n+import org.noggit.CharArr;\n+import org.noggit.JSONWriter;\n+\n+public class TestDelegationTokenResponse extends LuceneTestCase {\n+\n+  private void delegationTokenResponse(DelegationTokenRequest request,\n+      DelegationTokenResponse response, String responseBody) throws Exception {\n+    ResponseParser parser = request.getResponseParser();\n+    response.setResponse(parser.processResponse(\n+      IOUtils.toInputStream(responseBody, \"UTF-8\"), \"UTF-8\"));\n+  }\n+\n+  private String getNestedMapJson(String outerKey, String innerKey, Object innerValue) {\n+    CharArr out = new CharArr();\n+    JSONWriter w = new JSONWriter(out, 2);\n+    Map<String, Object> innerMap = new HashMap<String, Object>();\n+    innerMap.put(innerKey, innerValue);\n+    Map<String, Map<String, Object>> outerMap = new HashMap<String, Map<String, Object>>();\n+    outerMap.put(outerKey, innerMap);\n+    w.write(outerMap);\n+    return out.toString();\n+  }\n+\n+  private String getMapJson(String key, Object value) {\n+    CharArr out = new CharArr();\n+    JSONWriter w = new JSONWriter(out, 2);\n+    Map<String, Object> map = new HashMap<String, Object>();\n+    map.put(key, value);\n+    w.write(map);\n+    return out.toString();\n+  }\n+\n+  @Test\n+  public void testGetResponse() throws Exception {\n+    DelegationTokenRequest.Get getRequest = new DelegationTokenRequest.Get();\n+    DelegationTokenResponse.Get getResponse = new DelegationTokenResponse.Get();\n+\n+    // not a map\n+    try {\n+      delegationTokenResponse(getRequest, getResponse, \"\");\n+      getResponse.getDelegationToken();\n+      fail(\"Expected SolrException\");\n+    } catch (SolrException se) {\n+    }\n+\n+    // doesn't have Token outerMap\n+    final String someToken = \"someToken\";\n+    delegationTokenResponse(getRequest, getResponse, getNestedMapJson(\"NotToken\", \"urlString\", someToken));\n+    assertNull(getResponse.getDelegationToken());\n+\n+    // Token is not a map\n+    try {\n+      delegationTokenResponse(getRequest, getResponse, getMapJson(\"Token\", someToken));\n+      getResponse.getDelegationToken();\n+      fail(\"Expected SolrException\");\n+    } catch (SolrException se) {\n+    }\n+\n+    // doesn't have urlString\n+    delegationTokenResponse(getRequest, getResponse, getNestedMapJson(\"Token\", \"notUrlString\", someToken));\n+    assertNull(getResponse.getDelegationToken());\n+\n+    // has Token + urlString\n+    delegationTokenResponse(getRequest, getResponse, getNestedMapJson(\"Token\", \"urlString\", someToken));\n+    assertEquals(someToken, getResponse.getDelegationToken());\n+  }\n+\n+  @Test\n+  public void testRenewResponse() throws Exception {\n+    DelegationTokenRequest.Renew renewRequest = new DelegationTokenRequest.Renew(\"token\");\n+    DelegationTokenResponse.Renew renewResponse = new DelegationTokenResponse.Renew();\n+\n+    // not a map\n+    try {\n+      delegationTokenResponse(renewRequest, renewResponse, \"\");\n+      renewResponse.getExpirationTime();\n+      fail(\"Expected SolrException\");\n+    } catch (SolrException se) {\n+    }\n+\n+    // doesn't have long\n+    delegationTokenResponse(renewRequest, renewResponse, getMapJson(\"notLong\", \"123\"));\n+    assertNull(renewResponse.getExpirationTime());\n+\n+    // long isn't valid\n+    try {\n+      delegationTokenResponse(renewRequest, renewResponse, getMapJson(\"long\", \"aaa\"));\n+      renewResponse.getExpirationTime();\n+      fail(\"Expected SolrException\");\n+    } catch (SolrException se) {\n+    }\n+\n+    // valid\n+    Long expirationTime = new Long(Long.MAX_VALUE);\n+    delegationTokenResponse(renewRequest, renewResponse,\n+      getMapJson(\"long\", expirationTime));\n+    assertEquals(expirationTime, renewResponse.getExpirationTime());\n+  }\n+\n+  @Test\n+  public void testCancelResponse() throws Exception {\n+    // expect empty response\n+    DelegationTokenRequest.Cancel cancelRequest = new DelegationTokenRequest.Cancel(\"token\");\n+    DelegationTokenResponse.Cancel cancelResponse = new DelegationTokenResponse.Cancel();\n+    delegationTokenResponse(cancelRequest, cancelResponse, \"\");\n+  }\n+}"
        }
    ]
}
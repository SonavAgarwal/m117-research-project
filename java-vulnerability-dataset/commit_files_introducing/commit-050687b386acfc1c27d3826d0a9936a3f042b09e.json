{
    "sha": "050687b386acfc1c27d3826d0a9936a3f042b09e",
    "node_id": "MDY6Q29tbWl0NTc5NTEwMTI6MDUwNjg3YjM4NmFjZmMxYzI3ZDM4MjZkMGE5OTM2YTNmMDQyYjA5ZQ==",
    "commit": {
        "author": {
            "name": "Dmitry Trusevich",
            "email": "dmitry.trusevich@duallab.com",
            "date": "2015-11-12T14:31:01Z"
        },
        "committer": {
            "name": "Dmitry Trusevich",
            "email": "dmitry.trusevich@duallab.com",
            "date": "2015-11-12T14:31:01Z"
        },
        "message": "Implement filling and removing XFA forms\n\n(DEVSIX-324)",
        "tree": {
            "sha": "f1b8bc9dced8769edb5f9973c168bf28ad08a9bd",
            "url": "https://api.github.com/repos/itext/itext-java/git/trees/f1b8bc9dced8769edb5f9973c168bf28ad08a9bd"
        },
        "url": "https://api.github.com/repos/itext/itext-java/git/commits/050687b386acfc1c27d3826d0a9936a3f042b09e",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/itext/itext-java/commits/050687b386acfc1c27d3826d0a9936a3f042b09e",
    "html_url": "https://github.com/itext/itext-java/commit/050687b386acfc1c27d3826d0a9936a3f042b09e",
    "comments_url": "https://api.github.com/repos/itext/itext-java/commits/050687b386acfc1c27d3826d0a9936a3f042b09e/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "1981a7e898d8e62e6199c92e6a9536305ed31e46",
            "url": "https://api.github.com/repos/itext/itext-java/commits/1981a7e898d8e62e6199c92e6a9536305ed31e46",
            "html_url": "https://github.com/itext/itext-java/commit/1981a7e898d8e62e6199c92e6a9536305ed31e46"
        }
    ],
    "stats": {
        "total": 1791,
        "additions": 1730,
        "deletions": 61
    },
    "files": [
        {
            "sha": "710315b24ce1fce003b60d3bb7dd525575d58c16",
            "filename": "core/src/main/java/com/itextpdf/core/crypto/StandardDecryption.java",
            "status": "modified",
            "additions": 60,
            "deletions": 60,
            "changes": 120,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fcrypto%2FStandardDecryption.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fcrypto%2FStandardDecryption.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fcrypto%2FStandardDecryption.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -1,61 +1,61 @@\n-package com.itextpdf.core.crypto;\r\n-\r\n-public class StandardDecryption {\r\n-\r\n-    protected ARCFOUREncryption arcfour;\r\n-    protected AESCipher cipher;\r\n-    private byte[] key;\r\n-    private static final int AES_128 = 4;\r\n-    private static final int AES_256 = 5;\r\n-    private boolean aes;\r\n-    private boolean initiated;\r\n-    private byte[] iv = new byte[16];\r\n-    private int ivptr;\r\n-\r\n-    /**\r\n-     * Creates a new instance of StandardDecryption\r\n-     */\r\n-    public StandardDecryption(byte key[], int off, int len, int revision) {\r\n-        aes = (revision == AES_128 || revision == AES_256);\r\n-        if (aes) {\r\n-            this.key = new byte[len];\r\n-            System.arraycopy(key, off, this.key, 0, len);\r\n-        } else {\r\n-            arcfour = new ARCFOUREncryption();\r\n-            arcfour.prepareARCFOURKey(key, off, len);\r\n-        }\r\n-    }\r\n-\r\n-    public byte[] update(byte[] b, int off, int len) {\r\n-        if (aes) {\r\n-            if (initiated) {\r\n-                return cipher.update(b, off, len);\r\n-            } else {\r\n-                int left = Math.min(iv.length - ivptr, len);\r\n-                System.arraycopy(b, off, iv, ivptr, left);\r\n-                off += left;\r\n-                len -= left;\r\n-                ivptr += left;\r\n-                if (ivptr == iv.length) {\r\n-                    cipher = new AESCipher(false, key, iv);\r\n-                    initiated = true;\r\n-                    if (len > 0)\r\n-                        return cipher.update(b, off, len);\r\n-                }\r\n-                return null;\r\n-            }\r\n-        } else {\r\n-            byte[] b2 = new byte[len];\r\n-            arcfour.encryptARCFOUR(b, off, len, b2, 0);\r\n-            return b2;\r\n-        }\r\n-    }\r\n-\r\n-    public byte[] finish() {\r\n-        if (aes) {\r\n-            return cipher.doFinal();\r\n-        } else {\r\n-            return null;\r\n-        }\r\n-    }\r\n+package com.itextpdf.core.crypto;\n+\n+public class StandardDecryption {\n+\n+    protected ARCFOUREncryption arcfour;\n+    protected AESCipher cipher;\n+    private byte[] key;\n+    private static final int AES_128 = 4;\n+    private static final int AES_256 = 5;\n+    private boolean aes;\n+    private boolean initiated;\n+    private byte[] iv = new byte[16];\n+    private int ivptr;\n+\n+    /**\n+     * Creates a new instance of StandardDecryption\n+     */\n+    public StandardDecryption(byte key[], int off, int len, int revision) {\n+        aes = (revision == AES_128 || revision == AES_256);\n+        if (aes) {\n+            this.key = new byte[len];\n+            System.arraycopy(key, off, this.key, 0, len);\n+        } else {\n+            arcfour = new ARCFOUREncryption();\n+            arcfour.prepareARCFOURKey(key, off, len);\n+        }\n+    }\n+\n+    public byte[] update(byte[] b, int off, int len) {\n+        if (aes) {\n+            if (initiated) {\n+                return cipher.update(b, off, len);\n+            } else {\n+                int left = Math.min(iv.length - ivptr, len);\n+                System.arraycopy(b, off, iv, ivptr, left);\n+                off += left;\n+                len -= left;\n+                ivptr += left;\n+                if (ivptr == iv.length) {\n+                    cipher = new AESCipher(false, key, iv);\n+                    initiated = true;\n+                    if (len > 0)\n+                        return cipher.update(b, off, len);\n+                }\n+                return null;\n+            }\n+        } else {\n+            byte[] b2 = new byte[len];\n+            arcfour.encryptARCFOUR(b, off, len, b2, 0);\n+            return b2;\n+        }\n+    }\n+\n+    public byte[] finish() {\n+        if (aes && cipher != null) {\n+            return cipher.doFinal();\n+        } else {\n+            return null;\n+        }\n+    }\n }\n\\ No newline at end of file"
        },
        {
            "sha": "13938e87cc54d8429070372ea0251b9d858739a2",
            "filename": "core/src/main/java/com/itextpdf/core/xmp/XmlDomWriter.java",
            "status": "added",
            "additions": 342,
            "deletions": 0,
            "changes": 342,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fxmp%2FXmlDomWriter.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fxmp%2FXmlDomWriter.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fcore%2Fxmp%2FXmlDomWriter.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,342 @@\n+package com.itextpdf.core.xmp;\n+\n+import org.w3c.dom.Attr;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.DocumentType;\n+import org.w3c.dom.NamedNodeMap;\n+import org.w3c.dom.Node;\n+\n+import java.io.OutputStream;\n+import java.io.OutputStreamWriter;\n+import java.io.PrintWriter;\n+import java.io.UnsupportedEncodingException;\n+\n+\n+public class XmlDomWriter {\n+\n+    /**\n+     * Print writer.\n+     */\n+    protected PrintWriter fOut;\n+\n+    /**\n+     * Canonical output.\n+     */\n+    protected boolean fCanonical;\n+\n+    /**\n+     * Processing XML 1.1 document.\n+     */\n+    protected boolean fXML11;\n+\n+    //\n+    // Constructors\n+    //\n+\n+    /**\n+     * Default constructor.\n+     */\n+    public XmlDomWriter() {\n+    } // <init>()\n+\n+    public XmlDomWriter(boolean canonical) {\n+        fCanonical = canonical;\n+    } // <init>(boolean)\n+\n+    //\n+    // Public methods\n+    //\n+\n+    /**\n+     * Sets whether output is canonical.\n+     */\n+    public void setCanonical(boolean canonical) {\n+        fCanonical = canonical;\n+    } // setCanonical(boolean)\n+\n+    /**\n+     * Sets the output stream for printing.\n+     */\n+    public void setOutput(OutputStream stream, String encoding)\n+            throws UnsupportedEncodingException {\n+\n+        if (encoding == null) {\n+            encoding = \"UTF8\";\n+        }\n+\n+        java.io.Writer writer = new OutputStreamWriter(stream, encoding);\n+        fOut = new PrintWriter(writer);\n+\n+    } // setOutput(OutputStream,String)\n+\n+    /**\n+     * Sets the output writer.\n+     */\n+    public void setOutput(java.io.Writer writer) {\n+\n+        fOut = writer instanceof PrintWriter\n+                ? (PrintWriter) writer : new PrintWriter(writer);\n+\n+    } // setOutput(java.io.Writer)\n+\n+    /**\n+     * Writes the specified node, recursively.\n+     */\n+    public void write(Node node) {\n+\n+        // is there anything to do?\n+        if (node == null) {\n+            return;\n+        }\n+\n+        short type = node.getNodeType();\n+        switch (type) {\n+            case Node.DOCUMENT_NODE: {\n+                Document document = (Document) node;\n+                fXML11 = false; //\"1.1\".equals(getVersion(document));\n+                if (!fCanonical) {\n+                    if (fXML11) {\n+                        fOut.println(\"<?xml version=\\\"1.1\\\" encoding=\\\"UTF-8\\\"?>\");\n+                    } else {\n+                        fOut.println(\"<?xml version=\\\"1.0\\\" encoding=\\\"UTF-8\\\"?>\");\n+                    }\n+                    fOut.flush();\n+                    write(document.getDoctype());\n+                }\n+                write(document.getDocumentElement());\n+                break;\n+            }\n+\n+            case Node.DOCUMENT_TYPE_NODE: {\n+                DocumentType doctype = (DocumentType) node;\n+                fOut.print(\"<!DOCTYPE \");\n+                fOut.print(doctype.getName());\n+                String publicId = doctype.getPublicId();\n+                String systemId = doctype.getSystemId();\n+                if (publicId != null) {\n+                    fOut.print(\" PUBLIC '\");\n+                    fOut.print(publicId);\n+                    fOut.print(\"' '\");\n+                    fOut.print(systemId);\n+                    fOut.print('\\'');\n+                } else if (systemId != null) {\n+                    fOut.print(\" SYSTEM '\");\n+                    fOut.print(systemId);\n+                    fOut.print('\\'');\n+                }\n+                String internalSubset = doctype.getInternalSubset();\n+                if (internalSubset != null) {\n+                    fOut.println(\" [\");\n+                    fOut.print(internalSubset);\n+                    fOut.print(']');\n+                }\n+                fOut.println('>');\n+                break;\n+            }\n+\n+            case Node.ELEMENT_NODE: {\n+                fOut.print('<');\n+                fOut.print(node.getNodeName());\n+                Attr attrs[] = sortAttributes(node.getAttributes());\n+                for (int i = 0; i < attrs.length; i++) {\n+                    Attr attr = attrs[i];\n+                    fOut.print(' ');\n+                    fOut.print(attr.getNodeName());\n+                    fOut.print(\"=\\\"\");\n+                    normalizeAndPrint(attr.getNodeValue(), true);\n+                    fOut.print('\"');\n+                }\n+                fOut.print('>');\n+                fOut.flush();\n+\n+                Node child = node.getFirstChild();\n+                while (child != null) {\n+                    write(child);\n+                    child = child.getNextSibling();\n+                }\n+                break;\n+            }\n+\n+            case Node.ENTITY_REFERENCE_NODE: {\n+                if (fCanonical) {\n+                    Node child = node.getFirstChild();\n+                    while (child != null) {\n+                        write(child);\n+                        child = child.getNextSibling();\n+                    }\n+                } else {\n+                    fOut.print('&');\n+                    fOut.print(node.getNodeName());\n+                    fOut.print(';');\n+                    fOut.flush();\n+                }\n+                break;\n+            }\n+\n+            case Node.CDATA_SECTION_NODE: {\n+                if (fCanonical) {\n+                    normalizeAndPrint(node.getNodeValue(), false);\n+                } else {\n+                    fOut.print(\"<![CDATA[\");\n+                    fOut.print(node.getNodeValue());\n+                    fOut.print(\"]]>\");\n+                }\n+                fOut.flush();\n+                break;\n+            }\n+\n+            case Node.TEXT_NODE: {\n+                normalizeAndPrint(node.getNodeValue(), false);\n+                fOut.flush();\n+                break;\n+            }\n+\n+            case Node.PROCESSING_INSTRUCTION_NODE: {\n+                fOut.print(\"<?\");\n+                fOut.print(node.getNodeName());\n+                String data = node.getNodeValue();\n+                if (data != null && data.length() > 0) {\n+                    fOut.print(' ');\n+                    fOut.print(data);\n+                }\n+                fOut.print(\"?>\");\n+                fOut.flush();\n+                break;\n+            }\n+\n+            case Node.COMMENT_NODE: {\n+                if (!fCanonical) {\n+                    fOut.print(\"<!--\");\n+                    String comment = node.getNodeValue();\n+                    if (comment != null && comment.length() > 0) {\n+                        fOut.print(comment);\n+                    }\n+                    fOut.print(\"-->\");\n+                    fOut.flush();\n+                }\n+            }\n+        }\n+\n+        if (type == Node.ELEMENT_NODE) {\n+            fOut.print(\"</\");\n+            fOut.print(node.getNodeName());\n+            fOut.print('>');\n+            fOut.flush();\n+        }\n+\n+    } // write(Node)\n+\n+    /**\n+     * Returns a sorted list of attributes.\n+     */\n+    protected Attr[] sortAttributes(NamedNodeMap attrs) {\n+\n+        int len = (attrs != null) ? attrs.getLength() : 0;\n+        Attr array[] = new Attr[len];\n+        for (int i = 0; i < len; i++) {\n+            array[i] = (Attr) attrs.item(i);\n+        }\n+        for (int i = 0; i < len - 1; i++) {\n+            String name = array[i].getNodeName();\n+            int index = i;\n+            for (int j = i + 1; j < len; j++) {\n+                String curName = array[j].getNodeName();\n+                if (curName.compareTo(name) < 0) {\n+                    name = curName;\n+                    index = j;\n+                }\n+            }\n+            if (index != i) {\n+                Attr temp = array[i];\n+                array[i] = array[index];\n+                array[index] = temp;\n+            }\n+        }\n+\n+        return array;\n+\n+    } // sortAttributes(NamedNodeMap):Attr[]\n+\n+    //\n+    // Protected methods\n+    //\n+\n+    /**\n+     * Normalizes and prints the given string.\n+     */\n+    protected void normalizeAndPrint(String s, boolean isAttValue) {\n+\n+        int len = (s != null) ? s.length() : 0;\n+        for (int i = 0; i < len; i++) {\n+            char c = s.charAt(i);\n+            normalizeAndPrint(c, isAttValue);\n+        }\n+\n+    } // normalizeAndPrint(String,boolean)\n+\n+    /**\n+     * Normalizes and print the given character.\n+     */\n+    protected void normalizeAndPrint(char c, boolean isAttValue) {\n+\n+        switch (c) {\n+            case '<': {\n+                fOut.print(\"&lt;\");\n+                break;\n+            }\n+            case '>': {\n+                fOut.print(\"&gt;\");\n+                break;\n+            }\n+            case '&': {\n+                fOut.print(\"&amp;\");\n+                break;\n+            }\n+            case '\"': {\n+                // A '\"' that appears in character data\n+                // does not need to be escaped.\n+                if (isAttValue) {\n+                    fOut.print(\"&quot;\");\n+                } else {\n+                    fOut.print(\"\\\"\");\n+                }\n+                break;\n+            }\n+            case '\\r': {\n+                // If CR is part of the document's content, it\n+                // must not be printed as a literal otherwise\n+                // it would be normalized to LF when the document\n+                // is reparsed.\n+                fOut.print(\"&#xD;\");\n+                break;\n+            }\n+            case '\\n': {\n+                if (fCanonical) {\n+                    fOut.print(\"&#xA;\");\n+                    break;\n+                }\n+                // else, default print char\n+            }\n+            default: {\n+                // In XML 1.1, control chars in the ranges [#x1-#x1F, #x7F-#x9F] must be escaped.\n+                //\n+                // Escape space characters that would be normalized to #x20 in attribute values\n+                // when the document is reparsed.\n+                //\n+                // Escape NEL (0x85) and LSEP (0x2028) that appear in content\n+                // if the document is XML 1.1, since they would be normalized to LF\n+                // when the document is reparsed.\n+                if (fXML11 && ((c >= 0x01 && c <= 0x1F && c != 0x09 && c != 0x0A)\n+                        || (c >= 0x7F && c <= 0x9F) || c == 0x2028)\n+                        || isAttValue && (c == 0x09 || c == 0x0A)) {\n+                    fOut.print(\"&#x\");\n+                    fOut.print(Integer.toHexString(c).toUpperCase());\n+                    fOut.print(\";\");\n+                } else {\n+                    fOut.print(c);\n+                }\n+            }\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "18494f7fddad59fbb1248a2a69771b6098e682ba",
            "filename": "forms/src/main/java/com/itextpdf/forms/PdfAcroForm.java",
            "status": "modified",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2FPdfAcroForm.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2FPdfAcroForm.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2FPdfAcroForm.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -18,6 +18,9 @@\n import com.itextpdf.core.pdf.annot.PdfAnnotation;\n import com.itextpdf.core.pdf.xobject.PdfFormXObject;\n import com.itextpdf.forms.fields.PdfFormField;\n+import com.itextpdf.forms.xfa.XfaForm;\n+import com.itextpdf.forms.xfa.Xml2Som;\n+import org.w3c.dom.Node;\n \n import java.util.ArrayList;\n import java.util.LinkedHashMap;\n@@ -39,16 +42,20 @@ public class PdfAcroForm extends PdfObjectWrapper<PdfDictionary> {\n     private static PdfName resourceNames[] = {PdfName.Font, PdfName.XObject, PdfName.ColorSpace, PdfName.Pattern};\n     private PdfDictionary defaultResources;\n     private LinkedHashSet<PdfFormField> fieldsForFlattening = new LinkedHashSet<>();\n+    private XfaForm xfaForm;\n+\n \n     public PdfAcroForm(PdfDictionary pdfObject) {\n         super(pdfObject);\n         getFormFields();\n+        xfaForm = new XfaForm(pdfObject);\n     }\n \n     public PdfAcroForm(PdfArray fields) {\n         super(new PdfDictionary());\n         put(PdfName.Fields, fields);\n         getFormFields();\n+        xfaForm = new XfaForm();\n     }\n \n     /**\n@@ -78,8 +85,11 @@ public static PdfAcroForm getAcroForm(PdfDocument document, boolean createIfNotE\n                 acroForm.defaultResources = new PdfDictionary();\n             }\n             acroForm.document = document;\n+            acroForm.xfaForm = new XfaForm(document);\n         }\n \n+\n+\n         return acroForm;\n     }\n \n@@ -502,6 +512,57 @@ public void mergeResources(PdfDictionary result, PdfDictionary source, PdfFormFi\n         }\n     }\n \n+    public boolean hasXfaForm(){\n+        return xfaForm != null && xfaForm.isXfaPresent();\n+    }\n+\n+    public XfaForm getXfaForm(){\n+        return xfaForm;\n+    }\n+\n+    /**\n+     * Removes the XFA stream from the document.\n+     */\n+    public void removeXfaForm() {\n+        if(hasXfaForm()) {\n+            PdfDictionary root = document.getCatalog().getPdfObject();\n+            PdfDictionary acroform = root.getAsDictionary(PdfName.AcroForm);\n+            acroform.remove(PdfName.XFA);\n+            xfaForm = new XfaForm();\n+        }\n+    }\n+\n+    public void setXfaFieldValue(String name, String value) {\n+        if (hasXfaForm()) {\n+            name = xfaForm.findFieldName(name, this);\n+            if (name != null) {\n+                String shortName = Xml2Som.getShortName(name);\n+                Node xn = xfaForm.findDatasetsNode(shortName);\n+                if (xn == null) {\n+                    xn = xfaForm.getDatasetsSom().insertNode(xfaForm.getDatasetsNode(), shortName);\n+                }\n+                xfaForm.setNodeText(xn, value);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Gets the xfa field value.\n+     * @param name the fully qualified field name\n+     * @return the field value\n+     */\n+    public String getXfaFieldValue(String name) {\n+        if (xfaForm.isXfaPresent()) {\n+            name = xfaForm.findFieldName(name, this);\n+            if (name != null) {\n+\n+                name = Xml2Som.getShortName(name);\n+                return XfaForm.getNodeText(xfaForm.findDatasetsNode(name));\n+            }\n+        }\n+        return null;\n+    }\n+\n     private PdfPage getPage(PdfDictionary pageDic) {\n         PdfPage page;\n         for (int i = 1; i <= document.getNumOfPages(); i++) {"
        },
        {
            "sha": "993fb9fe8aa487e6fa37eac3a44ec0c9cd93e4e4",
            "filename": "forms/src/main/java/com/itextpdf/forms/fields/PdfFormField.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Ffields%2FPdfFormField.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Ffields%2FPdfFormField.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Ffields%2FPdfFormField.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -350,7 +350,7 @@ public <T extends PdfFormField> T setValue(String value, boolean generateAppeara\n             put(PdfName.V, new PdfString(value));\n         }\n \n-        if (formType.equals(PdfName.Btn) && (getFieldFlags() & PdfButtonFormField.FF_PUSH_BUTTON) == 0) {\n+        if (PdfName.Btn.equals(formType) && (getFieldFlags() & PdfButtonFormField.FF_PUSH_BUTTON) == 0) {\n             if (generateAppearance) {\n                 regenerateField();\n             }"
        },
        {
            "sha": "0b3a7c1d86dcf8cbc746a09f9990dcdc0e2edd51",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/AcroFieldsSearch.java",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FAcroFieldsSearch.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FAcroFieldsSearch.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FAcroFieldsSearch.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,47 @@\n+package com.itextpdf.forms.xfa;\n+\n+import java.util.Collection;\n+import java.util.HashMap;\n+\n+/**\n+ * A class to process \"classic\" fields.\n+ */\n+public class AcroFieldsSearch extends Xml2Som {\n+    private HashMap<String, String> acroShort2LongName;\n+\n+    /**\n+     * Creates a new instance from a Collection with the full names.\n+     *\n+     * @param items the Collection\n+     */\n+    public AcroFieldsSearch(Collection<String> items) {\n+        inverseSearch = new HashMap<String, InverseStore>();\n+        acroShort2LongName = new HashMap<String, String>();\n+        for (String string : items) {\n+            String itemName = string;\n+            String itemShort = getShortName(itemName);\n+            acroShort2LongName.put(itemShort, itemName);\n+            inverseSearchAdd(inverseSearch, splitParts(itemShort), itemName);\n+        }\n+    }\n+\n+    /**\n+     * Gets the mapping from short names to long names. A long\n+     * name may contain the #subform name part.\n+     *\n+     * @return the mapping from short names to long names\n+     */\n+    public HashMap<String, String> getAcroShort2LongName() {\n+        return acroShort2LongName;\n+    }\n+\n+    /**\n+     * Sets the mapping from short names to long names. A long\n+     * name may contain the #subform name part.\n+     *\n+     * @param acroShort2LongName the mapping from short names to long names\n+     */\n+    public void setAcroShort2LongName(HashMap<String, String> acroShort2LongName) {\n+        this.acroShort2LongName = acroShort2LongName;\n+    }\n+}"
        },
        {
            "sha": "dc486bc0a2d40abc3d7251d7ae7dbf5280f38e72",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/InverseStore.java",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FInverseStore.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FInverseStore.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FInverseStore.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,47 @@\n+package com.itextpdf.forms.xfa;\n+\n+import java.util.ArrayList;\n+\n+/**\n+ * A structure to store each part of a SOM name and link it to the next part\n+ * beginning from the lower hierarchy.\n+ */\n+public  class InverseStore {\n+    protected ArrayList<String> part = new ArrayList<String>();\n+    protected ArrayList<Object> follow = new ArrayList<Object>();\n+\n+    /**\n+     * Gets the full name by traversing the hierarchy using only the\n+     * index 0.\n+     *\n+     * @return the full name\n+     */\n+    public String getDefaultName() {\n+        InverseStore store = this;\n+        while (true) {\n+            Object obj = store.follow.get(0);\n+            if (obj instanceof String)\n+                return (String) obj;\n+            store = (InverseStore) obj;\n+        }\n+    }\n+\n+    /**\n+     * Search the current node for a similar name. A similar name starts\n+     * with the same name but has a different index. For example, \"detail[3]\"\n+     * is similar to \"detail[9]\". The main use is to discard names that\n+     * correspond to out of bounds records.\n+     *\n+     * @param name the name to search\n+     * @return <CODE>true</CODE> if a similitude was found\n+     */\n+    public boolean isSimilar(String name) {\n+        int idx = name.indexOf('[');\n+        name = name.substring(0, idx + 1);\n+        for (int k = 0; k < part.size(); ++k) {\n+            if (part.get(k).startsWith(name))\n+                return true;\n+        }\n+        return false;\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "6f85335df93ce3e0ea35c440006570e85b49f43e",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/Stack2.java",
            "status": "added",
            "additions": 56,
            "deletions": 0,
            "changes": 56,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FStack2.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FStack2.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FStack2.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,56 @@\n+package com.itextpdf.forms.xfa;\n+\n+import java.util.ArrayList;\n+import java.util.EmptyStackException;\n+\n+/**\n+ * Another stack implementation. The main use is to facilitate\n+ * the porting to other languages.\n+ */\n+public  class Stack2<T> extends ArrayList<T> {\n+    private static final long serialVersionUID = -7451476576174095212L;\n+\n+    /**\n+     * Looks at the object at the top of this stack without removing it from the stack.\n+     *\n+     * @return the object at the top of this stack\n+     */\n+    public T peek() {\n+        if (size() == 0)\n+            throw new EmptyStackException();\n+        return get(size() - 1);\n+    }\n+\n+    /**\n+     * Removes the object at the top of this stack and returns that object as the value of this function.\n+     *\n+     * @return the object at the top of this stack\n+     */\n+    public T pop() {\n+        if (size() == 0)\n+            throw new EmptyStackException();\n+        T ret = get(size() - 1);\n+        remove(size() - 1);\n+        return ret;\n+    }\n+\n+    /**\n+     * Pushes an item onto the top of this stack.\n+     *\n+     * @param item the item to be pushed onto this stack\n+     * @return the <CODE>item</CODE> argument\n+     */\n+    public T push(T item) {\n+        add(item);\n+        return item;\n+    }\n+\n+    /**\n+     * Tests if this stack is empty.\n+     *\n+     * @return <CODE>true</CODE> if and only if this stack contains no items; <CODE>false</CODE> otherwise\n+     */\n+    public boolean empty() {\n+        return size() == 0;\n+    }\n+}"
        },
        {
            "sha": "df048a7e9460ac2a795285fe89701e5a1cf884c2",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/XfaForm.java",
            "status": "added",
            "additions": 557,
            "deletions": 0,
            "changes": 557,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXfaForm.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXfaForm.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXfaForm.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,557 @@\n+package com.itextpdf.forms.xfa;\n+\n+\n+import com.itextpdf.basics.PdfException;\n+import com.itextpdf.core.pdf.PdfArray;\n+import com.itextpdf.core.pdf.PdfDictionary;\n+import com.itextpdf.core.pdf.PdfDocument;\n+import com.itextpdf.core.pdf.PdfName;\n+import com.itextpdf.core.pdf.PdfObject;\n+import com.itextpdf.core.pdf.PdfReader;\n+import com.itextpdf.core.pdf.PdfStream;\n+import com.itextpdf.core.pdf.PdfString;\n+import com.itextpdf.core.xmp.XmlDomWriter;\n+import com.itextpdf.forms.PdfAcroForm;\n+import com.itextpdf.forms.fields.PdfFormField;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+import org.xml.sax.SAXException;\n+\n+import javax.xml.parsers.DocumentBuilder;\n+import javax.xml.parsers.DocumentBuilderFactory;\n+import javax.xml.parsers.ParserConfigurationException;\n+import java.io.ByteArrayInputStream;\n+import java.io.ByteArrayOutputStream;\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Processes XFA forms.\n+ */\n+public class XfaForm {\n+\n+    private Xml2SomTemplate templateSom;\n+    private Node templateNode;\n+    private Xml2SomDatasets datasetsSom;\n+    private Node datasetsNode;\n+    private AcroFieldsSearch acroFieldsSom;\n+    private PdfDocument pdfDocument;\n+    private boolean xfaPresent = false;\n+    private org.w3c.dom.Document domDocument;\n+    private boolean changed = false;\n+    public static final String XFA_DATA_SCHEMA = \"http://www.xfa.org/schema/xfa-data/1.0/\";\n+\n+    /**\n+     * An empty constructor to build on.\n+     */\n+    public XfaForm() {\n+    }\n+\n+    public XfaForm(PdfDictionary acroFormDictionary) {\n+        this.pdfDocument = acroFormDictionary.getDocument();\n+        PdfObject xfa = acroFormDictionary.get(PdfName.XFA);\n+        if (xfa != null) {\n+            try {\n+                initXfaForm(xfa);\n+            } catch (Exception e) {\n+                throw new PdfException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * A constructor from a <CODE>PdfDocument</CODE>. It basically does everything\n+     * from finding the XFA stream to the XML parsing.\n+     *\n+     * @param pdfDocument the PdfDocument instance\n+     */\n+    public XfaForm(PdfDocument pdfDocument) {\n+        this.pdfDocument = pdfDocument;\n+        PdfObject xfa = getXfaObject(pdfDocument);\n+        if (xfa != null) {\n+            try {\n+                initXfaForm(xfa);\n+            } catch (Exception e) {\n+                throw new PdfException(e);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return the XFA Object, could be an array, could be a Stream.\n+     * Returns null f no XFA Object is present.\n+     *\n+     * @param pdfDocument a PdfDocument instance\n+     * @return the XFA object\n+     * @since 2.1.3\n+     */\n+    public static PdfObject getXfaObject(PdfDocument pdfDocument) {\n+        PdfDictionary af = pdfDocument.getCatalog().getPdfObject().getAsDictionary(PdfName.AcroForm);\n+        return af == null ? null : af.get(PdfName.XFA);\n+    }\n+\n+    public void write(PdfDocument document) throws IOException {\n+        if (isChanged()) {\n+            setXfaForm(this, document);\n+        }\n+    }\n+\n+    /**\n+     * Sets the XFA key from a byte array. The old XFA is erased.\n+     *\n+     * @param form        the data\n+     * @param pdfDocument pdfDocument\n+     * @throws java.io.IOException on error\n+     */\n+    public static void setXfaForm(XfaForm form, PdfDocument pdfDocument) throws IOException {\n+        PdfDictionary af = pdfDocument.getCatalog().getPdfObject().getAsDictionary(PdfName.AcroForm);\n+        if (af == null) {\n+            return;\n+        }\n+        PdfObject xfa = getXfaObject(pdfDocument);\n+        if (xfa.isArray()) {\n+            PdfArray ar = (PdfArray) xfa;\n+            int t = -1;\n+            int d = -1;\n+            for (int k = 0; k < ar.size(); k += 2) {\n+                PdfString s = ar.getAsString(k);\n+                if (\"template\".equals(s.toString())) {\n+                    t = k + 1;\n+                }\n+                if (\"datasets\".equals(s.toString())) {\n+                    d = k + 1;\n+                }\n+            }\n+            if (t > -1 && d > -1) {\n+                //reader.killXref(ar.getAsIndirectObject(t));\n+                //reader.killXref(ar.getAsIndirectObject(d));\n+                PdfStream tStream = new PdfStream(serializeDocument(form.templateNode));\n+                tStream.setCompressionLevel(pdfDocument.getWriter().getCompressionLevel());\n+                ar.set(t, tStream);\n+                PdfStream dStream = new PdfStream(serializeDocument(form.datasetsNode));\n+                dStream.setCompressionLevel(pdfDocument.getWriter().getCompressionLevel());\n+                ar.set(d, dStream);\n+                ar.flush();\n+                af.put(PdfName.XFA, new PdfArray(ar));\n+                return;\n+            }\n+        }\n+        //reader.killXref(af.get(PdfName.XFA));\n+        PdfStream stream = new PdfStream(serializeDocument(form.domDocument));\n+        stream.setCompressionLevel(pdfDocument.getWriter().getCompressionLevel());\n+        stream.flush();\n+        af.put(PdfName.XFA, stream);\n+    }\n+\n+    public static Map<String, Node> extractXFANodes(Document domDocument) {\n+        Map<String, Node> xfaNodes = new HashMap<String, Node>();\n+        Node n = domDocument.getFirstChild();\n+        while (n.getChildNodes().getLength() == 0) {\n+            n = n.getNextSibling();\n+        }\n+        n = n.getFirstChild();\n+        while (n != null) {\n+            if (n.getNodeType() == Node.ELEMENT_NODE) {\n+                String s = n.getLocalName();\n+                xfaNodes.put(s, n);\n+            }\n+            n = n.getNextSibling();\n+        }\n+\n+        return xfaNodes;\n+    }\n+\n+    /**\n+     * Serializes a XML document to a byte array.\n+     *\n+     * @param n the XML document\n+     * @return the serialized XML document\n+     * @throws java.io.IOException on error\n+     */\n+    public static byte[] serializeDocument(Node n) throws IOException {\n+        XmlDomWriter xw = new XmlDomWriter();\n+        ByteArrayOutputStream fout = new ByteArrayOutputStream();\n+        xw.setOutput(fout, null);\n+        xw.setCanonical(false);\n+        xw.write(n);\n+        fout.close();\n+        return fout.toByteArray();\n+    }\n+\n+    /**\n+     * Returns <CODE>true</CODE> if it is a XFA form.\n+     *\n+     * @return <CODE>true</CODE> if it is a XFA form\n+     */\n+    public boolean isXfaPresent() {\n+        return xfaPresent;\n+    }\n+\n+    /**\n+     * Gets the top level DOM document.\n+     *\n+     * @return the top level DOM document\n+     */\n+    public org.w3c.dom.Document getDomDocument() {\n+        return domDocument;\n+    }\n+\n+    /**\n+     * Finds the complete field name contained in the \"classic\" forms from a partial\n+     * name.\n+     *\n+     * @param name the complete or partial name\n+     * @param af   the fields\n+     * @return the complete name or <CODE>null</CODE> if not found\n+     */\n+    public String findFieldName(String name, PdfAcroForm af) {\n+        Map<String, PdfFormField> items = af.getFormFields();\n+        if (items.containsKey(name))\n+            return name;\n+        if (acroFieldsSom == null) {\n+            if (items.isEmpty() && xfaPresent) {\n+                acroFieldsSom = new AcroFieldsSearch(datasetsSom.getName2Node().keySet());\n+            } else {\n+                acroFieldsSom = new AcroFieldsSearch(items.keySet());\n+            }\n+        }\n+        return acroFieldsSom.getAcroShort2LongName().containsKey(name) ? acroFieldsSom.getAcroShort2LongName().get(name) : acroFieldsSom.inverseSearchGlobal(Xml2Som.splitParts(name));\n+    }\n+\n+    /**\n+     * Finds the complete SOM name contained in the datasets section from a\n+     * possibly partial name.\n+     *\n+     * @param name the complete or partial name\n+     * @return the complete name or <CODE>null</CODE> if not found\n+     */\n+    public String findDatasetsName(String name) {\n+        return datasetsSom.getName2Node().containsKey(name) ? name : datasetsSom.inverseSearchGlobal(Xml2Som.splitParts(name));\n+    }\n+\n+    /**\n+     * Finds the <CODE>Node</CODE> contained in the datasets section from a\n+     * possibly partial name.\n+     *\n+     * @param name the complete or partial name\n+     * @return the <CODE>Node</CODE> or <CODE>null</CODE> if not found\n+     */\n+    public Node findDatasetsNode(String name) {\n+        if (name == null)\n+            return null;\n+        name = findDatasetsName(name);\n+        if (name == null)\n+            return null;\n+        return datasetsSom.getName2Node().get(name);\n+    }\n+\n+    /**\n+     * Gets all the text contained in the child nodes of this node.\n+     *\n+     * @param n the <CODE>Node</CODE>\n+     * @return the text found or \"\" if no text was found\n+     */\n+    public static String getNodeText(Node n) {\n+        return n == null ? \"\" : getNodeText(n, \"\");\n+    }\n+\n+    private static String getNodeText(Node n, String name) {\n+        Node n2 = n.getFirstChild();\n+        while (n2 != null) {\n+            if (n2.getNodeType() == Node.ELEMENT_NODE) {\n+                name = getNodeText(n2, name);\n+            } else if (n2.getNodeType() == Node.TEXT_NODE) {\n+                name += n2.getNodeValue();\n+            }\n+            n2 = n2.getNextSibling();\n+        }\n+        return name;\n+    }\n+\n+    /**\n+     * Sets the text of this node. All the child's node are deleted and a new\n+     * child text node is created.\n+     *\n+     * @param n    the <CODE>Node</CODE> to add the text to\n+     * @param text the text to add\n+     */\n+    public void setNodeText(Node n, String text) {\n+        if (n == null)\n+            return;\n+        Node nc = null;\n+        while ((nc = n.getFirstChild()) != null) {\n+            n.removeChild(nc);\n+        }\n+        if (n.getAttributes().getNamedItemNS(XFA_DATA_SCHEMA, \"dataNode\") != null)\n+            n.getAttributes().removeNamedItemNS(XFA_DATA_SCHEMA, \"dataNode\");\n+        n.appendChild(domDocument.createTextNode(text));\n+        changed = true;\n+    }\n+\n+    /**\n+     * Sets the XFA form flag signaling that this is a valid XFA form.\n+     *\n+     * @param xfaPresent the XFA form flag signaling that this is a valid XFA form\n+     */\n+    public void setXfaPresent(boolean xfaPresent) {\n+        this.xfaPresent = xfaPresent;\n+    }\n+\n+    /**\n+     * Sets the top DOM document.\n+     *\n+     * @param domDocument the top DOM document\n+     */\n+    public void setDomDocument(org.w3c.dom.Document domDocument) {\n+        this.domDocument = domDocument;\n+        extractNodes();\n+    }\n+\n+    /**\n+     * Gets the <CODE>PdfReader</CODE> used by this instance.\n+     *\n+     * @return the <CODE>PdfReader</CODE> used by this instance\n+     */\n+    public PdfReader getReader() {\n+        return pdfDocument.getReader();\n+    }\n+\n+    /**\n+     * Checks if this XFA form was changed.\n+     *\n+     * @return <CODE>true</CODE> if this XFA form was changed\n+     */\n+    public boolean isChanged() {\n+        return changed;\n+    }\n+\n+    /**\n+     * Sets the changed status of this XFA instance.\n+     *\n+     * @param changed the changed status of this XFA instance\n+     */\n+    public void setChanged(boolean changed) {\n+        this.changed = changed;\n+    }\n+\n+    /**\n+     * Gets the class that contains the template processing section of the XFA.\n+     *\n+     * @return the class that contains the template processing section of the XFA\n+     */\n+    public Xml2SomTemplate getTemplateSom() {\n+        return templateSom;\n+    }\n+\n+    /**\n+     * Sets the class that contains the template processing section of the XFA\n+     *\n+     * @param templateSom the class that contains the template processing section of the XFA\n+     */\n+    public void setTemplateSom(Xml2SomTemplate templateSom) {\n+        this.templateSom = templateSom;\n+    }\n+\n+    /**\n+     * Gets the class that contains the datasets processing section of the XFA.\n+     *\n+     * @return the class that contains the datasets processing section of the XFA\n+     */\n+    public Xml2SomDatasets getDatasetsSom() {\n+        return datasetsSom;\n+    }\n+\n+    /**\n+     * Sets the class that contains the datasets processing section of the XFA.\n+     *\n+     * @param datasetsSom the class that contains the datasets processing section of the XFA\n+     */\n+    public void setDatasetsSom(Xml2SomDatasets datasetsSom) {\n+        this.datasetsSom = datasetsSom;\n+    }\n+\n+    /**\n+     * Gets the class that contains the \"classic\" fields processing.\n+     *\n+     * @return the class that contains the \"classic\" fields processing\n+     */\n+    public AcroFieldsSearch getAcroFieldsSom() {\n+        return acroFieldsSom;\n+    }\n+\n+    /**\n+     * Sets the class that contains the \"classic\" fields processing.\n+     *\n+     * @param acroFieldsSom the class that contains the \"classic\" fields processing\n+     */\n+    public void setAcroFieldsSom(AcroFieldsSearch acroFieldsSom) {\n+        this.acroFieldsSom = acroFieldsSom;\n+    }\n+\n+    /**\n+     * Gets the <CODE>Node</CODE> that corresponds to the datasets part.\n+     *\n+     * @return the <CODE>Node</CODE> that corresponds to the datasets part\n+     */\n+    public Node getDatasetsNode() {\n+        return datasetsNode;\n+    }\n+\n+    public void fillXfaForm(File file) throws IOException {\n+        fillXfaForm(file, false);\n+    }\n+\n+    public void fillXfaForm(File file, boolean readOnly) throws IOException {\n+        fillXfaForm(new FileInputStream(file), readOnly);\n+    }\n+\n+    public void fillXfaForm(InputStream is) throws IOException {\n+        fillXfaForm(is, false);\n+    }\n+\n+    public void fillXfaForm(InputStream is, boolean readOnly) throws IOException {\n+        fillXfaForm(new InputSource(is), readOnly);\n+    }\n+\n+    public void fillXfaForm(InputSource is) throws IOException {\n+        fillXfaForm(is, false);\n+    }\n+\n+    public void fillXfaForm(InputSource is, boolean readOnly) throws IOException {\n+        DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();\n+        DocumentBuilder db;\n+        try {\n+            db = dbf.newDocumentBuilder();\n+            Document newdoc = db.parse(is);\n+            fillXfaForm(newdoc.getDocumentElement(), readOnly);\n+        } catch (ParserConfigurationException e) {\n+            throw new PdfException(e);\n+        } catch (SAXException e) {\n+            throw new PdfException(e);\n+        }\n+    }\n+\n+    public void fillXfaForm(Node node) {\n+        fillXfaForm(node, false);\n+    }\n+\n+    /**\n+     * Replaces the data under datasets/data.\n+     *\n+     * @since iText 5.0.0\n+     */\n+    public void fillXfaForm(Node node, boolean readOnly) {\n+        if (readOnly) {\n+            NodeList nodeList = domDocument.getElementsByTagName(\"field\");\n+            for (int i = 0; i < nodeList.getLength(); i++) {\n+                ((Element) nodeList.item(i)).setAttribute(\"access\", \"readOnly\");\n+            }\n+        }\n+        NodeList allChilds = datasetsNode.getChildNodes();\n+        int len = allChilds.getLength();\n+        Node data = null;\n+        for (int k = 0; k < len; ++k) {\n+            Node n = allChilds.item(k);\n+            if (n.getNodeType() == Node.ELEMENT_NODE && n.getLocalName().equals(\"data\") && XFA_DATA_SCHEMA.equals(n.getNamespaceURI())) {\n+                data = n;\n+                break;\n+            }\n+        }\n+        if (data == null) {\n+            data = datasetsNode.getOwnerDocument().createElementNS(XFA_DATA_SCHEMA, \"xfa:data\");\n+            datasetsNode.appendChild(data);\n+        }\n+        NodeList list = data.getChildNodes();\n+        if (list.getLength() == 0) {\n+            data.appendChild(domDocument.importNode(node, true));\n+        } else {\n+            // There's a possibility that first child node of XFA data is not an ELEMENT but simply a TEXT. In this case data will be duplicated.\n+            // data.replaceChild(domDocument.importNode(node, true), data.getFirstChild());\n+            Node firstNode = getFirstElementNode(data);\n+            if (firstNode != null)\n+                data.replaceChild(domDocument.importNode(node, true), firstNode);\n+        }\n+        extractNodes();\n+        setChanged(true);\n+    }\n+\n+    private void initXfaForm(PdfObject xfa) throws IOException, ParserConfigurationException, SAXException {\n+        xfaPresent = true;\n+        ByteArrayOutputStream bout = new ByteArrayOutputStream();\n+        if (xfa.isArray()) {\n+            PdfArray ar = (PdfArray) xfa;\n+            for (int k = 1; k < ar.size(); k += 2) {\n+                PdfObject ob = ar.get(k);\n+                if (ob instanceof PdfStream) {\n+                    byte[] b = ((PdfStream) ob).getBytes();\n+                    bout.write(b);\n+                }\n+            }\n+        } else if (xfa instanceof PdfStream) {\n+            byte[] b = ((PdfStream) xfa).getBytes();\n+            bout.write(b);\n+        }\n+        bout.close();\n+        DocumentBuilderFactory fact = DocumentBuilderFactory.newInstance();\n+        fact.setNamespaceAware(true);\n+        DocumentBuilder db = fact.newDocumentBuilder();\n+        domDocument = db.parse(new ByteArrayInputStream(bout.toByteArray()));\n+        extractNodes();\n+    }\n+\n+    /**\n+     * Extracts the nodes from the domDocument.\n+     *\n+     * @since 2.1.5\n+     */\n+    private void extractNodes() {\n+        Map<String, Node> xfaNodes = extractXFANodes(domDocument);\n+\n+        if (xfaNodes.containsKey(\"template\")) {\n+            templateNode = xfaNodes.get(\"template\");\n+            templateSom = new Xml2SomTemplate(templateNode);\n+        }\n+        if (xfaNodes.containsKey(\"datasets\")) {\n+            datasetsNode = xfaNodes.get(\"datasets\");\n+            datasetsSom = new Xml2SomDatasets(datasetsNode.getFirstChild());\n+        }\n+        if (datasetsNode == null)\n+            createDatasetsNode(domDocument.getFirstChild());\n+    }\n+\n+\n+    /**\n+     * Some XFA forms don't have a datasets node.\n+     * If this is the case, we have to add one.\n+     */\n+    private void createDatasetsNode(Node n) {\n+        while (n.getChildNodes().getLength() == 0) {\n+            n = n.getNextSibling();\n+        }\n+        if (n != null) {\n+            Element e = n.getOwnerDocument().createElement(\"xfa:datasets\");\n+            e.setAttribute(\"xmlns:xfa\", XFA_DATA_SCHEMA);\n+            datasetsNode = e;\n+            n.appendChild(datasetsNode);\n+        }\n+    }\n+\n+    private Node getFirstElementNode(Node src) {\n+        Node result = null;\n+        NodeList list = src.getChildNodes();\n+        for (int i = 0; i < list.getLength(); i++) {\n+            if (list.item(i).getNodeType() == Node.ELEMENT_NODE) {\n+                result = list.item(i);\n+                break;\n+            }\n+        }\n+        return result;\n+    }\n+}"
        },
        {
            "sha": "e7e2d1a4292991afb7a6425fccb1693a1a6c26da",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/Xml2Som.java",
            "status": "added",
            "additions": 273,
            "deletions": 0,
            "changes": 273,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2Som.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2Som.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2Som.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,273 @@\n+package com.itextpdf.forms.xfa;\n+\n+import org.w3c.dom.Node;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+/**\n+ * A class for some basic SOM processing.\n+ */\n+public class Xml2Som {\n+    /**\n+     * The order the names appear in the XML, depth first.\n+     */\n+    protected ArrayList<String> order;\n+    /**\n+     * The mapping of full names to nodes.\n+     */\n+    protected HashMap<String, Node> name2Node;\n+    /**\n+     * The data to do a search from the bottom hierarchy.\n+     */\n+    protected HashMap<String, InverseStore> inverseSearch;\n+    /**\n+     * A stack to be used when parsing.\n+     */\n+    protected Stack2<String> stack;\n+    /**\n+     * A temporary store for the repetition count.\n+     */\n+    protected int anform;\n+\n+    /**\n+     * Escapes a SOM string fragment replacing \".\" with \"\\.\".\n+     *\n+     * @param s the unescaped string\n+     * @return the escaped string\n+     */\n+    public static String escapeSom(String s) {\n+        if (s == null)\n+            return \"\";\n+        int idx = s.indexOf('.');\n+        if (idx < 0)\n+            return s;\n+        StringBuffer sb = new StringBuffer();\n+        int last = 0;\n+        while (idx >= 0) {\n+            sb.append(s.substring(last, idx));\n+            sb.append('\\\\');\n+            last = idx;\n+            idx = s.indexOf('.', idx + 1);\n+        }\n+        sb.append(s.substring(last));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Unescapes a SOM string fragment replacing \"\\.\" with \".\".\n+     *\n+     * @param s the escaped string\n+     * @return the unescaped string\n+     */\n+    public static String unescapeSom(String s) {\n+        int idx = s.indexOf('\\\\');\n+        if (idx < 0)\n+            return s;\n+        StringBuffer sb = new StringBuffer();\n+        int last = 0;\n+        while (idx >= 0) {\n+            sb.append(s.substring(last, idx));\n+            last = idx + 1;\n+            idx = s.indexOf('\\\\', idx + 1);\n+        }\n+        sb.append(s.substring(last));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Outputs the stack as the sequence of elements separated\n+     * by '.'.\n+     *\n+     * @return the stack as the sequence of elements separated by '.'\n+     */\n+    protected String printStack() {\n+        if (stack.empty())\n+            return \"\";\n+        StringBuffer s = new StringBuffer();\n+        for (int k = 0; k < stack.size(); ++k)\n+            s.append('.').append(stack.get(k));\n+        return s.substring(1);\n+    }\n+\n+    /**\n+     * Gets the name with the <CODE>#subform</CODE> removed.\n+     *\n+     * @param s the long name\n+     * @return the short name\n+     */\n+    public static String getShortName(String s) {\n+        int idx = s.indexOf(\".#subform[\");\n+        if (idx < 0)\n+            return s;\n+        int last = 0;\n+        StringBuffer sb = new StringBuffer();\n+        while (idx >= 0) {\n+            sb.append(s.substring(last, idx));\n+            idx = s.indexOf(\"]\", idx + 10);\n+            if (idx < 0)\n+                return sb.toString();\n+            last = idx + 1;\n+            idx = s.indexOf(\".#subform[\", last);\n+        }\n+        sb.append(s.substring(last));\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Adds a SOM name to the search node chain.\n+     *\n+     * @param unstack the SOM name\n+     */\n+    public void inverseSearchAdd(String unstack) {\n+        inverseSearchAdd(inverseSearch, stack, unstack);\n+    }\n+\n+    /**\n+     * Adds a SOM name to the search node chain.\n+     *\n+     * @param inverseSearch the start point\n+     * @param stack         the stack with the separated SOM parts\n+     * @param unstack       the full name\n+     */\n+    public static void inverseSearchAdd(HashMap<String, InverseStore> inverseSearch, Stack2<String> stack, String unstack) {\n+        String last = stack.peek();\n+        InverseStore store = inverseSearch.get(last);\n+        if (store == null) {\n+            store = new InverseStore();\n+            inverseSearch.put(last, store);\n+        }\n+        for (int k = stack.size() - 2; k >= 0; --k) {\n+            last = stack.get(k);\n+            InverseStore store2;\n+            int idx = store.part.indexOf(last);\n+            if (idx < 0) {\n+                store.part.add(last);\n+                store2 = new InverseStore();\n+                store.follow.add(store2);\n+            } else\n+                store2 = (InverseStore) store.follow.get(idx);\n+            store = store2;\n+        }\n+        store.part.add(\"\");\n+        store.follow.add(unstack);\n+    }\n+\n+    /**\n+     * Searches the SOM hierarchy from the bottom.\n+     *\n+     * @param parts the SOM parts\n+     * @return the full name or <CODE>null</CODE> if not found\n+     */\n+    public String inverseSearchGlobal(ArrayList<String> parts) {\n+        if (parts.isEmpty())\n+            return null;\n+        InverseStore store = inverseSearch.get(parts.get(parts.size() - 1));\n+        if (store == null)\n+            return null;\n+        for (int k = parts.size() - 2; k >= 0; --k) {\n+            String part = parts.get(k);\n+            int idx = store.part.indexOf(part);\n+            if (idx < 0) {\n+                if (store.isSimilar(part))\n+                    return null;\n+                return store.getDefaultName();\n+            }\n+            store = (InverseStore) store.follow.get(idx);\n+        }\n+        return store.getDefaultName();\n+    }\n+\n+    /**\n+     * Splits a SOM name in the individual parts.\n+     *\n+     * @param name the full SOM name\n+     * @return the split name\n+     */\n+    public static Stack2<String> splitParts(String name) {\n+        while (name.startsWith(\".\"))\n+            name = name.substring(1);\n+        Stack2<String> parts = new Stack2<String>();\n+        int last = 0;\n+        int pos = 0;\n+        String part;\n+        while (true) {\n+            pos = last;\n+            while (true) {\n+                pos = name.indexOf('.', pos);\n+                if (pos < 0)\n+                    break;\n+                if (name.charAt(pos - 1) == '\\\\')\n+                    ++pos;\n+                else\n+                    break;\n+            }\n+            if (pos < 0)\n+                break;\n+            part = name.substring(last, pos);\n+            if (!part.endsWith(\"]\"))\n+                part += \"[0]\";\n+            parts.add(part);\n+            last = pos + 1;\n+        }\n+        part = name.substring(last);\n+        if (!part.endsWith(\"]\"))\n+            part += \"[0]\";\n+        parts.add(part);\n+        return parts;\n+    }\n+\n+    /**\n+     * Gets the order the names appear in the XML, depth first.\n+     *\n+     * @return the order the names appear in the XML, depth first\n+     */\n+    public ArrayList<String> getOrder() {\n+        return order;\n+    }\n+\n+    /**\n+     * Sets the order the names appear in the XML, depth first\n+     *\n+     * @param order the order the names appear in the XML, depth first\n+     */\n+    public void setOrder(ArrayList<String> order) {\n+        this.order = order;\n+    }\n+\n+    /**\n+     * Gets the mapping of full names to nodes.\n+     *\n+     * @return the mapping of full names to nodes\n+     */\n+    public HashMap<String, Node> getName2Node() {\n+        return name2Node;\n+    }\n+\n+    /**\n+     * Sets the mapping of full names to nodes.\n+     *\n+     * @param name2Node the mapping of full names to nodes\n+     */\n+    public void setName2Node(HashMap<String, Node> name2Node) {\n+        this.name2Node = name2Node;\n+    }\n+\n+    /**\n+     * Gets the data to do a search from the bottom hierarchy.\n+     *\n+     * @return the data to do a search from the bottom hierarchy\n+     */\n+    public HashMap<String, InverseStore> getInverseSearch() {\n+        return inverseSearch;\n+    }\n+\n+    /**\n+     * Sets the data to do a search from the bottom hierarchy.\n+     *\n+     * @param inverseSearch the data to do a search from the bottom hierarchy\n+     */\n+    public void setInverseSearch(HashMap<String, InverseStore> inverseSearch) {\n+        this.inverseSearch = inverseSearch;\n+    }\n+}"
        },
        {
            "sha": "5c436323fbe14d8c9c93b072fb23df93727f3ee6",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/Xml2SomDatasets.java",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomDatasets.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomDatasets.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomDatasets.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,123 @@\n+package com.itextpdf.forms.xfa;\n+\n+import org.w3c.dom.Node;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+/**\n+ * Processes the datasets section in the XFA form.\n+ */\n+public class Xml2SomDatasets extends Xml2Som {\n+    /**\n+     * Creates a new instance from the datasets node. This expects\n+     * not the datasets but the data node that comes below.\n+     *\n+     * @param n the datasets node\n+     */\n+    public Xml2SomDatasets(Node n) {\n+        order = new ArrayList<String>();\n+        name2Node = new HashMap<String, Node>();\n+        stack = new Stack2<String>();\n+        anform = 0;\n+        inverseSearch = new HashMap<String, InverseStore>();\n+        processDatasetsInternal(n);\n+    }\n+\n+    /**\n+     * Inserts a new <CODE>Node</CODE> that will match the short name.\n+     *\n+     * @param n         the datasets top <CODE>Node</CODE>\n+     * @param shortName the short name\n+     * @return the new <CODE>Node</CODE> of the inserted name\n+     */\n+    public Node insertNode(Node n, String shortName) {\n+        Stack2<String> stack = splitParts(shortName);\n+        org.w3c.dom.Document doc = n.getOwnerDocument();\n+        Node n2 = null;\n+        n = n.getFirstChild();\n+        while (n.getNodeType() != Node.ELEMENT_NODE)\n+            n = n.getNextSibling();\n+        for (int k = 0; k < stack.size(); ++k) {\n+            String part = stack.get(k);\n+            int idx = part.lastIndexOf('[');\n+            String name = part.substring(0, idx);\n+            idx = Integer.parseInt(part.substring(idx + 1, part.length() - 1));\n+            int found = -1;\n+            for (n2 = n.getFirstChild(); n2 != null; n2 = n2.getNextSibling()) {\n+                if (n2.getNodeType() == Node.ELEMENT_NODE) {\n+                    String s = escapeSom(n2.getLocalName());\n+                    if (s.equals(name)) {\n+                        ++found;\n+                        if (found == idx)\n+                            break;\n+                    }\n+                }\n+            }\n+            for (; found < idx; ++found) {\n+                n2 = doc.createElementNS(null, name);\n+                n2 = n.appendChild(n2);\n+                Node attr = doc.createAttributeNS(XfaForm.XFA_DATA_SCHEMA, \"dataNode\");\n+                attr.setNodeValue(\"dataGroup\");\n+                n2.getAttributes().setNamedItemNS(attr);\n+            }\n+            n = n2;\n+        }\n+        inverseSearchAdd(inverseSearch, stack, shortName);\n+        name2Node.put(shortName, n2);\n+        order.add(shortName);\n+        return n2;\n+    }\n+\n+    private static boolean hasChildren(Node n) {\n+        Node dataNodeN = n.getAttributes().getNamedItemNS(XfaForm.XFA_DATA_SCHEMA, \"dataNode\");\n+        if (dataNodeN != null) {\n+            String dataNode = dataNodeN.getNodeValue();\n+            if (\"dataGroup\".equals(dataNode))\n+                return true;\n+            else if (\"dataValue\".equals(dataNode))\n+                return false;\n+        }\n+        if (!n.hasChildNodes())\n+            return false;\n+        Node n2 = n.getFirstChild();\n+        while (n2 != null) {\n+            if (n2.getNodeType() == Node.ELEMENT_NODE) {\n+                return true;\n+            }\n+            n2 = n2.getNextSibling();\n+        }\n+        return false;\n+    }\n+\n+    private void processDatasetsInternal(Node n) {\n+        if (n != null) {\n+            HashMap<String, Integer> ss = new HashMap<String, Integer>();\n+            Node n2 = n.getFirstChild();\n+            while (n2 != null) {\n+                if (n2.getNodeType() == Node.ELEMENT_NODE) {\n+                    String s = escapeSom(n2.getLocalName());\n+                    Integer i = ss.get(s);\n+                    if (i == null)\n+                        i = Integer.valueOf(0);\n+                    else\n+                        i = Integer.valueOf(i.intValue() + 1);\n+                    ss.put(s, i);\n+                    if (hasChildren(n2)) {\n+                        stack.push(s + \"[\" + i.toString() + \"]\");\n+                        processDatasetsInternal(n2);\n+                        stack.pop();\n+                    } else {\n+                        stack.push(s + \"[\" + i.toString() + \"]\");\n+                        String unstack = printStack();\n+                        order.add(unstack);\n+                        inverseSearchAdd(unstack);\n+                        name2Node.put(unstack, n2);\n+                        stack.pop();\n+                    }\n+                }\n+                n2 = n2.getNextSibling();\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "9a190eb559bf1c0bc4029d97accab200aefcb1d4",
            "filename": "forms/src/main/java/com/itextpdf/forms/xfa/Xml2SomTemplate.java",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/itext/itext-java/blob/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomTemplate.java",
            "raw_url": "https://github.com/itext/itext-java/raw/050687b386acfc1c27d3826d0a9936a3f042b09e/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomTemplate.java",
            "contents_url": "https://api.github.com/repos/itext/itext-java/contents/forms%2Fsrc%2Fmain%2Fjava%2Fcom%2Fitextpdf%2Fforms%2Fxfa%2FXml2SomTemplate.java?ref=050687b386acfc1c27d3826d0a9936a3f042b09e",
            "patch": "@@ -0,0 +1,163 @@\n+package com.itextpdf.forms.xfa;\n+\n+import org.w3c.dom.Node;\n+\n+import java.util.ArrayList;\n+import java.util.HashMap;\n+\n+/**\n+ * Processes the template section in the XFA form.\n+ */\n+public  class Xml2SomTemplate extends Xml2Som {\n+    private boolean dynamicForm;\n+    private int templateLevel;\n+\n+    /**\n+     * Creates a new instance from the datasets node.\n+     *\n+     * @param n the template node\n+     */\n+    public Xml2SomTemplate(Node n) {\n+        order = new ArrayList<String>();\n+        name2Node = new HashMap<String, Node>();\n+        stack = new Stack2<String>();\n+        anform = 0;\n+        templateLevel = 0;\n+        inverseSearch = new HashMap<String, InverseStore>();\n+        processTemplate(n, null);\n+    }\n+\n+    /**\n+     * Gets the field type as described in the <CODE>template</CODE> section of the XFA.\n+     *\n+     * @param s the exact template name\n+     * @return the field type or <CODE>null</CODE> if not found\n+     */\n+    public String getFieldType(String s) {\n+        Node n = name2Node.get(s);\n+        if (n == null)\n+            return null;\n+        if (\"exclGroup\".equals(n.getLocalName()))\n+            return \"exclGroup\";\n+        Node ui = n.getFirstChild();\n+        while (ui != null) {\n+            if (ui.getNodeType() == Node.ELEMENT_NODE && \"ui\".equals(ui.getLocalName())) {\n+                break;\n+            }\n+            ui = ui.getNextSibling();\n+        }\n+        if (ui == null)\n+            return null;\n+        Node type = ui.getFirstChild();\n+        while (type != null) {\n+            if (type.getNodeType() == Node.ELEMENT_NODE && !(\"extras\".equals(type.getLocalName()) && \"picture\".equals(type.getLocalName()))) {\n+                return type.getLocalName();\n+            }\n+            type = type.getNextSibling();\n+        }\n+        return null;\n+    }\n+\n+    private void processTemplate(Node n, HashMap<String, Integer> ff) {\n+        if (ff == null)\n+            ff = new HashMap<String, Integer>();\n+        HashMap<String, Integer> ss = new HashMap<String, Integer>();\n+        Node n2 = n.getFirstChild();\n+        while (n2 != null) {\n+            if (n2.getNodeType() == Node.ELEMENT_NODE) {\n+                String s = n2.getLocalName();\n+                if (\"subform\".equals(s)) {\n+                    Node name = n2.getAttributes().getNamedItem(\"name\");\n+                    String nn = \"#subform\";\n+                    boolean annon = true;\n+                    if (name != null) {\n+                        nn = escapeSom(name.getNodeValue());\n+                        annon = false;\n+                    }\n+                    Integer i;\n+                    if (annon) {\n+                        i = Integer.valueOf(anform);\n+                        ++anform;\n+                    } else {\n+                        i = ss.get(nn);\n+                        if (i == null)\n+                            i = Integer.valueOf(0);\n+                        else\n+                            i = Integer.valueOf(i.intValue() + 1);\n+                        ss.put(nn, i);\n+                    }\n+                    stack.push(nn + \"[\" + i.toString() + \"]\");\n+                    ++templateLevel;\n+                    if (annon)\n+                        processTemplate(n2, ff);\n+                    else\n+                        processTemplate(n2, null);\n+                    --templateLevel;\n+                    stack.pop();\n+                } else if (\"field\".equals(s) || \"exclGroup\".equals(s)) {\n+                    Node name = n2.getAttributes().getNamedItem(\"name\");\n+                    if (name != null) {\n+                        String nn = escapeSom(name.getNodeValue());\n+                        Integer i = ff.get(nn);\n+                        if (i == null)\n+                            i = Integer.valueOf(0);\n+                        else\n+                            i = Integer.valueOf(i.intValue() + 1);\n+                        ff.put(nn, i);\n+                        stack.push(nn + \"[\" + i.toString() + \"]\");\n+                        String unstack = printStack();\n+                        order.add(unstack);\n+                        inverseSearchAdd(unstack);\n+                        name2Node.put(unstack, n2);\n+                        stack.pop();\n+                    }\n+                } else if (!dynamicForm && templateLevel > 0 && \"occur\".equals(s)) {\n+                    int initial = 1;\n+                    int min = 1;\n+                    int max = 1;\n+                    Node a = n2.getAttributes().getNamedItem(\"initial\");\n+                    if (a != null)\n+                        try {\n+                            initial = Integer.parseInt(a.getNodeValue().trim());\n+                        } catch (Exception e) {\n+                        }\n+                    a = n2.getAttributes().getNamedItem(\"min\");\n+                    if (a != null)\n+                        try {\n+                            min = Integer.parseInt(a.getNodeValue().trim());\n+                        } catch (Exception e) {\n+                        }\n+                    a = n2.getAttributes().getNamedItem(\"max\");\n+                    if (a != null)\n+                        try {\n+                            max = Integer.parseInt(a.getNodeValue().trim());\n+                        } catch (Exception e) {\n+                        }\n+                    if (initial != min || min != max)\n+                        dynamicForm = true;\n+                }\n+            }\n+            n2 = n2.getNextSibling();\n+        }\n+    }\n+\n+    /**\n+     * <CODE>true</CODE> if it's a dynamic form; <CODE>false</CODE>\n+     * if it's a static form.\n+     *\n+     * @return <CODE>true</CODE> if it's a dynamic form; <CODE>false</CODE>\n+     * if it's a static form\n+     */\n+    public boolean isDynamicForm() {\n+        return dynamicForm;\n+    }\n+\n+    /**\n+     * Sets the dynamic form flag. It doesn't change the template.\n+     *\n+     * @param dynamicForm the dynamic form flag\n+     */\n+    public void setDynamicForm(boolean dynamicForm) {\n+        this.dynamicForm = dynamicForm;\n+    }\n+}\n\\ No newline at end of file"
        }
    ]
}
{
    "sha": "8a06bd1ccef382461c7b0a63f2012f4aeac90753",
    "node_id": "MDY6Q29tbWl0MTYwOTk5OjhhMDZiZDFjY2VmMzgyNDYxYzdiMGE2M2YyMDEyZjRhZWFjOTA3NTM=",
    "commit": {
        "author": {
            "name": "Rakesh Radhakrishnan",
            "email": "rakeshr@apache.org",
            "date": "2016-12-06T00:15:37Z"
        },
        "committer": {
            "name": "Patrick Hunt",
            "email": "phunt@apache.org",
            "date": "2016-12-06T00:15:37Z"
        },
        "message": "ZOOKEEPER-1045: Support Quorum Peer mutual authentication via SASL (rakeshr via phunt)\n\nChange-Id: I7ae6bd863d46621bba5b9abc908e1497111e0336",
        "tree": {
            "sha": "adb1ce04d02ef13efa8ace373d47b36bc2b632c3",
            "url": "https://api.github.com/repos/apache/zookeeper/git/trees/adb1ce04d02ef13efa8ace373d47b36bc2b632c3"
        },
        "url": "https://api.github.com/repos/apache/zookeeper/git/commits/8a06bd1ccef382461c7b0a63f2012f4aeac90753",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/zookeeper/commits/8a06bd1ccef382461c7b0a63f2012f4aeac90753",
    "html_url": "https://github.com/apache/zookeeper/commit/8a06bd1ccef382461c7b0a63f2012f4aeac90753",
    "comments_url": "https://api.github.com/repos/apache/zookeeper/commits/8a06bd1ccef382461c7b0a63f2012f4aeac90753/comments",
    "author": {
        "login": "rakeshadr",
        "id": 8215991,
        "node_id": "MDQ6VXNlcjgyMTU5OTE=",
        "avatar_url": "https://avatars.githubusercontent.com/u/8215991?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/rakeshadr",
        "html_url": "https://github.com/rakeshadr",
        "followers_url": "https://api.github.com/users/rakeshadr/followers",
        "following_url": "https://api.github.com/users/rakeshadr/following{/other_user}",
        "gists_url": "https://api.github.com/users/rakeshadr/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/rakeshadr/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/rakeshadr/subscriptions",
        "organizations_url": "https://api.github.com/users/rakeshadr/orgs",
        "repos_url": "https://api.github.com/users/rakeshadr/repos",
        "events_url": "https://api.github.com/users/rakeshadr/events{/privacy}",
        "received_events_url": "https://api.github.com/users/rakeshadr/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "phunt",
        "id": 15702,
        "node_id": "MDQ6VXNlcjE1NzAy",
        "avatar_url": "https://avatars.githubusercontent.com/u/15702?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/phunt",
        "html_url": "https://github.com/phunt",
        "followers_url": "https://api.github.com/users/phunt/followers",
        "following_url": "https://api.github.com/users/phunt/following{/other_user}",
        "gists_url": "https://api.github.com/users/phunt/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/phunt/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/phunt/subscriptions",
        "organizations_url": "https://api.github.com/users/phunt/orgs",
        "repos_url": "https://api.github.com/users/phunt/repos",
        "events_url": "https://api.github.com/users/phunt/events{/privacy}",
        "received_events_url": "https://api.github.com/users/phunt/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "967c3a71bd8eaf1ac29b2702173115976874bd8e",
            "url": "https://api.github.com/repos/apache/zookeeper/commits/967c3a71bd8eaf1ac29b2702173115976874bd8e",
            "html_url": "https://github.com/apache/zookeeper/commit/967c3a71bd8eaf1ac29b2702173115976874bd8e"
        }
    ],
    "stats": {
        "total": 5090,
        "additions": 4655,
        "deletions": 435
    },
    "files": [
        {
            "sha": "eb9ef86af242978faf261b5f8a642d32f58afe79",
            "filename": "CHANGES.txt",
            "status": "modified",
            "additions": 6,
            "deletions": 0,
            "changes": 6,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/CHANGES.txt",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/CHANGES.txt",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/CHANGES.txt?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -31,6 +31,12 @@ IMPROVEMENTS:\n   ZOOKEEPER-2606: SaslServerCallbackHandler#handleAuthorizeCallback() should\n   log the exception (Ted Yu via fpj)\n \n+NEW FEATURE:\n+\n+  ZOOKEEPER-1045: Support Quorum Peer mutual authentication via SASL\n+  (rakeshr via phunt)\n+\n+\n Release 3.4.9 - 2016-08-23\n \n Backward compatible changes:"
        },
        {
            "sha": "5c4fab254747cd77d6f3745d52bbb329112beedf",
            "filename": "build.xml",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/build.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/build.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/build.xml?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -75,6 +75,7 @@ xmlns:maven=\"antlib:org.apache.maven.artifact.ant\">\n     <property name=\"test.data.upgrade.dir\" value=\"${test.data.dir}/upgrade\" />\n     <property name=\"test.data.invalid.dir\" value=\"${test.data.dir}/invalidsnap\" />\n     <property name=\"test.data.buffersize.dir\" value=\"${test.data.dir}/buffersize\" />\n+    <property name=\"test.data.kerberos.dir\" value=\"${test.data.dir}/kerberos\" />\n     <property name=\"test.cppunit.dir\" value=\"${test.java.build.dir}/test-cppunit\"/>\n     <property name=\"test.tmp.dir\" value=\"${test.java.build.dir}/tmp\" />\n     <property name=\"test.output\" value=\"no\" />\n@@ -1242,6 +1243,7 @@ xmlns:maven=\"antlib:org.apache.maven.artifact.ant\">\n         <delete dir=\"${test.data.upgrade.dir}\" />\n         <delete dir=\"${test.data.invalid.dir}\" />\n         <delete dir=\"${test.data.buffersize.dir}\" />\n+        <delete dir=\"${test.data.kerberos.dir}\" />\n         <delete dir=\"${test.data.dir}\" />\n         <mkdir dir=\"${test.log.dir}\" />\n         <mkdir dir=\"${test.tmp.dir}\" />\n@@ -1258,7 +1260,10 @@ xmlns:maven=\"antlib:org.apache.maven.artifact.ant\">\n         <copy todir=\"${test.data.buffersize.dir}\">\n             <fileset dir=\"${basedir}/src/java/test/data/buffersize\"/>\n         </copy>\n-       \n+        <mkdir dir=\"${test.data.kerberos.dir}\" />\n+        <copy todir=\"${test.data.kerberos.dir}\">\n+            <fileset dir=\"${basedir}/src/java/test/data/kerberos\"/>\n+        </copy>\n     </target>\n \n     <condition property=\"quicktest\">"
        },
        {
            "sha": "437b86be04d856eec3d773b6b963456025d3fb61",
            "filename": "ivy.xml",
            "status": "modified",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/ivy.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/ivy.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/ivy.xml?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -74,6 +74,34 @@\n                 rev=\"2.4\" conf=\"releaseaudit->default\"/>\n     <dependency org=\"commons-collections\" name=\"commons-collections\" \n                 rev=\"3.2.2\" conf=\"releaseaudit->default\"/>\n+\n+    <dependency org=\"commons-io\" name=\"commons-io\" rev=\"2.4\"\n+                conf=\"test->default\"/>\n+\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-simplekdc\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-config\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-core\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-server\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-common\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-admin\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-identity\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-client\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-util\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-crypto\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-util\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-asn1\" rev=\"1.0.0-RC2\"\n+                conf=\"test->default\"/>\n   </dependencies>\n \n </ivy-module>"
        },
        {
            "sha": "3e21aae7c8ca09b8deb064917e92b38eae556ef0",
            "filename": "src/java/main/org/apache/zookeeper/Login.java",
            "status": "modified",
            "additions": 4,
            "deletions": 3,
            "changes": 7,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -32,16 +32,17 @@\n import javax.security.auth.login.LoginException;\n import javax.security.auth.callback.CallbackHandler;\n \n-import org.apache.log4j.Logger;\n import org.apache.zookeeper.client.ZooKeeperSaslClient;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n import javax.security.auth.kerberos.KerberosTicket;\n import javax.security.auth.Subject;\n import java.util.Date;\n import java.util.Random;\n import java.util.Set;\n \n public class Login {\n-    Logger LOG = Logger.getLogger(Login.class);\n+    private static final Logger LOG = LoggerFactory.getLogger(Login.class);\n     public CallbackHandler callbackHandler;\n \n     // LoginThread will sleep until 80% of time from last refresh to\n@@ -291,7 +292,7 @@ private synchronized LoginContext login(final String loginContextName) throws Lo\n         }\n         LoginContext loginContext = new LoginContext(loginContextName,callbackHandler);\n         loginContext.login();\n-        LOG.info(\"successfully logged in.\");\n+        LOG.info(\"{} successfully logged in.\", loginContextName);\n         return loginContext;\n     }\n "
        },
        {
            "sha": "d6f554955f05e2015d7c7f3c253be122f4ff45d2",
            "filename": "src/java/main/org/apache/zookeeper/SaslClientCallbackHandler.java",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is used by the SASL mechanisms to get further information to complete\n+ * the authentication. For example, a SASL mechanism might use this callback\n+ * handler to do verification operation. The CallbackHandler interface here\n+ * refers to javax.security.auth.callback.CallbackHandler. It should not be\n+ * confused with ZooKeeper packet callbacks like\n+ * org.apache.zookeeper.server.auth.SaslServerCallbackHandler.\n+ */\n+public class SaslClientCallbackHandler implements CallbackHandler {\n+    private String password = null;\n+    private static final Logger LOG = LoggerFactory.getLogger(SaslClientCallbackHandler.class);\n+    private final String entity;\n+    public SaslClientCallbackHandler(String password, String client) {\n+        this.password = password;\n+        this.entity = client;\n+    }\n+\n+    public void handle(Callback[] callbacks) throws UnsupportedCallbackException {\n+        for (Callback callback : callbacks) {\n+            if (callback instanceof NameCallback) {\n+                NameCallback nc = (NameCallback) callback;\n+                nc.setName(nc.getDefaultName());\n+            }\n+            else {\n+                if (callback instanceof PasswordCallback) {\n+                    PasswordCallback pc = (PasswordCallback)callback;\n+                    if (password != null) {\n+                        pc.setPassword(this.password.toCharArray());\n+                    } else {\n+                        LOG.warn(\"Could not login: the {} is being asked for a password, but the ZooKeeper {}\" +\n+                          \" code does not currently support obtaining a password from the user.\" +\n+                          \" Make sure that the {} is configured to use a ticket cache (using\" +\n+                          \" the JAAS configuration setting 'useTicketCache=true)' and restart the {}. If\" +\n+                          \" you still get this message after that, the TGT in the ticket cache has expired and must\" +\n+                          \" be manually refreshed. To do so, first determine if you are using a password or a\" +\n+                          \" keytab. If the former, run kinit in a Unix shell in the environment of the user who\" +\n+                          \" is running this Zookeeper {} using the command\" +\n+                          \" 'kinit <princ>' (where <princ> is the name of the {}'s Kerberos principal).\" +\n+                          \" If the latter, do\" +\n+                          \" 'kinit -k -t <keytab> <princ>' (where <princ> is the name of the Kerberos principal, and\" +\n+                          \" <keytab> is the location of the keytab file). After manually refreshing your cache,\" +\n+                          \" restart this {}. If you continue to see this message after manually refreshing\" +\n+                          \" your cache, ensure that your KDC host's clock is in sync with this host's clock.\",\n+                          new Object[]{entity, entity, entity, entity, entity, entity, entity});\n+                    }\n+                }\n+                else {\n+                    if (callback instanceof RealmCallback) {\n+                        RealmCallback rc = (RealmCallback) callback;\n+                        rc.setText(rc.getDefaultText());\n+                    }\n+                    else {\n+                        if (callback instanceof AuthorizeCallback) {\n+                            AuthorizeCallback ac = (AuthorizeCallback) callback;\n+                            String authid = ac.getAuthenticationID();\n+                            String authzid = ac.getAuthorizationID();\n+                            if (authid.equals(authzid)) {\n+                                ac.setAuthorized(true);\n+                            } else {\n+                                ac.setAuthorized(false);\n+                            }\n+                            if (ac.isAuthorized()) {\n+                                ac.setAuthorizedID(authzid);\n+                            }\n+                        }\n+                        else {\n+                            throw new UnsupportedCallbackException(callback, \"Unrecognized SASL \" + entity + \"Callback\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "f3c9d3c5453831cae81491ea7ef5165cef8cdfa8",
            "filename": "src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java",
            "status": "modified",
            "additions": 5,
            "deletions": 156,
            "changes": 161,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -19,40 +19,27 @@\n package org.apache.zookeeper.client;\n \n import java.io.IOException;\n-import java.security.Principal;\n import java.security.PrivilegedActionException;\n import java.security.PrivilegedExceptionAction;\n \n import javax.security.auth.Subject;\n-import javax.security.auth.callback.Callback;\n-import javax.security.auth.callback.CallbackHandler;\n-import javax.security.auth.callback.NameCallback;\n-import javax.security.auth.callback.PasswordCallback;\n-import javax.security.auth.callback.UnsupportedCallbackException;\n import javax.security.auth.login.AppConfigurationEntry;\n import javax.security.auth.login.Configuration;\n import javax.security.auth.login.LoginException;\n-import javax.security.sasl.AuthorizeCallback;\n-import javax.security.sasl.RealmCallback;\n-import javax.security.sasl.Sasl;\n import javax.security.sasl.SaslClient;\n import javax.security.sasl.SaslException;\n \n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.ClientCnxn;\n import org.apache.zookeeper.Environment;\n import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.apache.zookeeper.ZooDefs;\n import org.apache.zookeeper.data.Stat;\n import org.apache.zookeeper.proto.GetSASLRequest;\n import org.apache.zookeeper.proto.SetSASLResponse;\n-import org.apache.zookeeper.server.auth.KerberosName;\n-import org.ietf.jgss.GSSContext;\n-import org.ietf.jgss.GSSCredential;\n-import org.ietf.jgss.GSSException;\n-import org.ietf.jgss.GSSManager;\n-import org.ietf.jgss.Oid;\n+import org.apache.zookeeper.util.SecurityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -226,83 +213,14 @@ private SaslClient createSaslClient(final String servicePrincipal,\n                         }\n                         // note that the login object is static: it's shared amongst all zookeeper-related connections.\n                         // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n-                        login = new Login(loginContext, new ClientCallbackHandler(null));\n+                        login = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"));\n                         login.startThreadIfNeeded();\n                         initializedLogin = true;\n                     }\n                 }\n             }\n-            Subject subject = login.getSubject();\n-            SaslClient saslClient;\n-            // Use subject.getPrincipals().isEmpty() as an indication of which SASL mechanism to use:\n-            // if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n-            if (subject.getPrincipals().isEmpty()) {\n-                // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism instead.\n-                LOG.info(\"Client will use DIGEST-MD5 as SASL mechanism.\");\n-                String[] mechs = {\"DIGEST-MD5\"};\n-                String username = (String)(subject.getPublicCredentials().toArray()[0]);\n-                String password = (String)(subject.getPrivateCredentials().toArray()[0]);\n-                // \"zk-sasl-md5\" is a hard-wired 'domain' parameter shared with zookeeper server code (see ServerCnxnFactory.java)\n-                saslClient = Sasl.createSaslClient(mechs, username, \"zookeeper\", \"zk-sasl-md5\", null, new ClientCallbackHandler(password));\n-                return saslClient;\n-            }\n-            else { // GSSAPI.\n-            \tboolean usingNativeJgss =\n-            \t\t\tBoolean.getBoolean(\"sun.security.jgss.native\");\n-            \tif (usingNativeJgss) {\n-            \t\t// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n-            \t\t// \"\"\"\n-            \t\t// In addition, when performing operations as a particular\n-            \t\t// Subject, e.g. Subject.doAs(...) or Subject.doAsPrivileged(...),\n-            \t\t// the to-be-used GSSCredential should be added to Subject's\n-            \t\t// private credential set. Otherwise, the GSS operations will\n-            \t\t// fail since no credential is found.\n-            \t\t// \"\"\"\n-            \t\ttry {\n-            \t\t\tGSSManager manager = GSSManager.getInstance();\n-            \t\t\tOid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n-            \t\t\tGSSCredential cred = manager.createCredential(null,\n-            \t\t\t\t\tGSSContext.DEFAULT_LIFETIME,\n-            \t\t\t\t\tkrb5Mechanism,\n-            \t\t\t\t\tGSSCredential.INITIATE_ONLY);\n-            \t\t\tsubject.getPrivateCredentials().add(cred);\n-            \t\t\tif (LOG.isDebugEnabled()) {\n-            \t\t\t\tLOG.debug(\"Added private credential to subject: \" + cred);\n-            \t\t\t}\n-            \t\t} catch (GSSException ex) {\n-            \t\t\tLOG.warn(\"Cannot add private credential to subject; \" +\n-            \t\t\t\t\t\"authentication at the server may fail\", ex);\n-            \t\t}\n-            \t}\n-                final Object[] principals = subject.getPrincipals().toArray();\n-                // determine client principal from subject.\n-                final Principal clientPrincipal = (Principal)principals[0];\n-                final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n-                // assume that server and client are in the same realm (by default; unless the system property\n-                // \"zookeeper.server.realm\" is set).\n-                String serverRealm = System.getProperty(\"zookeeper.server.realm\",clientKerberosName.getRealm());\n-                KerberosName serviceKerberosName = new KerberosName(servicePrincipal+\"@\"+serverRealm);\n-                final String serviceName = serviceKerberosName.getServiceName();\n-                final String serviceHostname = serviceKerberosName.getHostName();\n-                final String clientPrincipalName = clientKerberosName.toString();\n-                try {\n-                    saslClient = Subject.doAs(subject,new PrivilegedExceptionAction<SaslClient>() {\n-                        public SaslClient run() throws SaslException {\n-                            LOG.info(\"Client will use GSSAPI as SASL mechanism.\");\n-                            String[] mechs = {\"GSSAPI\"};\n-                            LOG.debug(\"creating sasl client: client=\"+clientPrincipalName+\";service=\"+serviceName+\";serviceHostname=\"+serviceHostname);\n-                            SaslClient saslClient = Sasl.createSaslClient(mechs,clientPrincipalName,serviceName,serviceHostname,null,new ClientCallbackHandler(null));\n-                            return saslClient;\n-                        }\n-                    });\n-                    return saslClient;\n-                }\n-                catch (Exception e) {\n-                \tLOG.error(\"Exception while trying to create SASL client\", e);\n-                    e.printStackTrace();\n-                    return null;\n-                }\n-            }\n+            return SecurityUtils.createSaslClient(login.getSubject(),\n+                    servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n         } catch (LoginException e) {\n             // We throw LoginExceptions...\n             throw e;\n@@ -471,75 +389,6 @@ public void initialize(ClientCnxn cnxn) throws SaslException {\n         }\n     }\n \n-    // The CallbackHandler interface here refers to\n-    // javax.security.auth.callback.CallbackHandler.\n-    // It should not be confused with Zookeeper packet callbacks like\n-    //  org.apache.zookeeper.server.auth.SaslServerCallbackHandler.\n-    public static class ClientCallbackHandler implements CallbackHandler {\n-        private String password = null;\n-\n-        public ClientCallbackHandler(String password) {\n-            this.password = password;\n-        }\n-\n-        public void handle(Callback[] callbacks) throws\n-          UnsupportedCallbackException {\n-            for (Callback callback : callbacks) {\n-                if (callback instanceof NameCallback) {\n-                    NameCallback nc = (NameCallback) callback;\n-                    nc.setName(nc.getDefaultName());\n-                }\n-                else {\n-                    if (callback instanceof PasswordCallback) {\n-                        PasswordCallback pc = (PasswordCallback)callback;\n-                        if (password != null) {\n-                            pc.setPassword(this.password.toCharArray());\n-                        } else {\n-                            LOG.warn(\"Could not login: the client is being asked for a password, but the Zookeeper\" +\n-                              \" client code does not currently support obtaining a password from the user.\" +\n-                              \" Make sure that the client is configured to use a ticket cache (using\" +\n-                              \" the JAAS configuration setting 'useTicketCache=true)' and restart the client. If\" +\n-                              \" you still get this message after that, the TGT in the ticket cache has expired and must\" +\n-                              \" be manually refreshed. To do so, first determine if you are using a password or a\" +\n-                              \" keytab. If the former, run kinit in a Unix shell in the environment of the user who\" +\n-                              \" is running this Zookeeper client using the command\" +\n-                              \" 'kinit <princ>' (where <princ> is the name of the client's Kerberos principal).\" +\n-                              \" If the latter, do\" +\n-                              \" 'kinit -k -t <keytab> <princ>' (where <princ> is the name of the Kerberos principal, and\" +\n-                              \" <keytab> is the location of the keytab file). After manually refreshing your cache,\" +\n-                              \" restart this client. If you continue to see this message after manually refreshing\" +\n-                              \" your cache, ensure that your KDC host's clock is in sync with this host's clock.\");\n-                        }\n-                    }\n-                    else {\n-                        if (callback instanceof RealmCallback) {\n-                            RealmCallback rc = (RealmCallback) callback;\n-                            rc.setText(rc.getDefaultText());\n-                        }\n-                        else {\n-                            if (callback instanceof AuthorizeCallback) {\n-                                AuthorizeCallback ac = (AuthorizeCallback) callback;\n-                                String authid = ac.getAuthenticationID();\n-                                String authzid = ac.getAuthorizationID();\n-                                if (authid.equals(authzid)) {\n-                                    ac.setAuthorized(true);\n-                                } else {\n-                                    ac.setAuthorized(false);\n-                                }\n-                                if (ac.isAuthorized()) {\n-                                    ac.setAuthorizedID(authzid);\n-                                }\n-                            }\n-                            else {\n-                                throw new UnsupportedCallbackException(callback,\"Unrecognized SASL ClientCallback\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     public boolean clientTunneledAuthenticationInProgress() {\n     \tif (!isSASLConfigured) {\n     \t    return false;"
        },
        {
            "sha": "dd6ee8ff9710bd2b842acfc9297f1c9cec3e02ef",
            "filename": "src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java",
            "status": "modified",
            "additions": 3,
            "deletions": 111,
            "changes": 114,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -18,22 +18,12 @@\n \n package org.apache.zookeeper.server;\n \n-import java.security.Principal;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-\n import javax.security.auth.Subject;\n-import javax.security.sasl.Sasl;\n import javax.security.sasl.SaslException;\n import javax.security.sasl.SaslServer;\n \n import org.apache.zookeeper.Login;\n-import org.ietf.jgss.GSSContext;\n-import org.ietf.jgss.GSSCredential;\n-import org.ietf.jgss.GSSException;\n-import org.ietf.jgss.GSSManager;\n-import org.ietf.jgss.GSSName;\n-import org.ietf.jgss.Oid;\n+import org.apache.zookeeper.util.SecurityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -51,107 +41,9 @@ public class ZooKeeperSaslServer {\n     private SaslServer createSaslServer(final Login login) {\n         synchronized (login) {\n             Subject subject = login.getSubject();\n-            if (subject != null) {\n-                // server is using a JAAS-authenticated subject: determine service principal name and hostname from zk server's subject.\n-                if (subject.getPrincipals().size() > 0) {\n-                    try {\n-                        final Object[] principals = subject.getPrincipals().toArray();\n-                        final Principal servicePrincipal = (Principal)principals[0];\n-\n-                        // e.g. servicePrincipalNameAndHostname := \"zookeeper/myhost.foo.com@FOO.COM\"\n-                        final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n-\n-                        int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n-\n-                        // e.g. servicePrincipalName := \"zookeeper\"\n-                        final String servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n-\n-                        // e.g. serviceHostnameAndKerbDomain := \"myhost.foo.com@FOO.COM\"\n-                        final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf+1,servicePrincipalNameAndHostname.length());\n-\n-                        indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n-                        // e.g. serviceHostname := \"myhost.foo.com\"\n-                        final String serviceHostname = serviceHostnameAndKerbDomain.substring(0,indexOf);\n-\n-                        final String mech = \"GSSAPI\";   // TODO: should depend on zoo.cfg specified mechs, but if subject is non-null, it can be assumed to be GSSAPI.\n-\n-                        LOG.debug(\"serviceHostname is '\"+ serviceHostname + \"'\");\n-                        LOG.debug(\"servicePrincipalName is '\"+ servicePrincipalName + \"'\");\n-                        LOG.debug(\"SASL mechanism(mech) is '\"+ mech +\"'\");\n-\n-                        boolean usingNativeJgss =\n-                        \t\tBoolean.getBoolean(\"sun.security.jgss.native\");\n-                        if (usingNativeJgss) {\n-                        \t// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n-                        \t// \"\"\"\n-                        \t// In addition, when performing operations as a particular\n-                        \t// Subject, e.g. Subject.doAs(...) or\n-                        \t// Subject.doAsPrivileged(...), the to-be-used\n-                        \t// GSSCredential should be added to Subject's\n-                        \t// private credential set. Otherwise, the GSS operations\n-                        \t// will fail since no credential is found.\n-                        \t// \"\"\"\n-                        \ttry {\n-                        \t\tGSSManager manager = GSSManager.getInstance();\n-                        \t\tOid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n-                        \t\tGSSName gssName = manager.createName(\n-                        \t\t\t\tservicePrincipalName + \"@\" + serviceHostname,\n-                        \t\t\t\tGSSName.NT_HOSTBASED_SERVICE);\n-                        \t\tGSSCredential cred = manager.createCredential(gssName,\n-                        \t\t\t\tGSSContext.DEFAULT_LIFETIME,\n-                        \t\t\t\tkrb5Mechanism,\n-                        \t\t\t\tGSSCredential.ACCEPT_ONLY);\n-                        \t\tsubject.getPrivateCredentials().add(cred);\n-                        \t\tif (LOG.isDebugEnabled()) {\n-                        \t\t\tLOG.debug(\"Added private credential to subject: \" + cred);\n-                        \t\t}\n-                        \t} catch (GSSException ex) {\n-                        \t\tLOG.warn(\"Cannot add private credential to subject; \" +\n-                        \t\t\t\t\"clients authentication may fail\", ex);\n-                        \t}\n-                        }\n-                        try {\n-                            return Subject.doAs(subject,new PrivilegedExceptionAction<SaslServer>() {\n-                                public SaslServer run() {\n-                                    try {\n-                                        SaslServer saslServer;\n-                                        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, login.callbackHandler);\n-                                        return saslServer;\n-                                    }\n-                                    catch (SaslException e) {\n-                                        LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: \" + e);\n-                                        e.printStackTrace();\n-                                        return null;\n-                                    }\n-                                }\n-                            }\n-                            );\n-                        }\n-                        catch (PrivilegedActionException e) {\n-                            // TODO: exit server at this point(?)\n-                            LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context:\" + e);\n-                            e.printStackTrace();\n-                        }\n-                    }\n-                    catch (IndexOutOfBoundsException e) {\n-                        LOG.error(\"server principal name/hostname determination error: \", e);\n-                    }\n-                }\n-                else {\n-                    // JAAS non-GSSAPI authentication: assuming and supporting only DIGEST-MD5 mechanism for now.\n-                    // TODO: use 'authMech=' value in zoo.cfg.\n-                    try {\n-                        SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\",\"zookeeper\",\"zk-sasl-md5\",null, login.callbackHandler);\n-                        return saslServer;\n-                    }\n-                    catch (SaslException e) {\n-                        LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n-                    }\n-                }\n-            }\n+            return SecurityUtils.createSaslServer(subject, \"zookeeper\",\n+                    \"zk-sasl-md5\", login.callbackHandler, LOG);\n         }\n-        LOG.error(\"failed to create saslServer object.\");\n-        return null;\n     }\n \n     public byte[] evaluateResponse(byte[] response) throws SaslException {"
        },
        {
            "sha": "9f53a4d1c17d843ee3785bb4d520bd8bf55baf06",
            "filename": "src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -46,13 +46,15 @@ public class SaslServerCallbackHandler implements CallbackHandler {\n     private String userName;\n     private final Map<String,String> credentials = new HashMap<String,String>();\n \n-    public SaslServerCallbackHandler(Configuration configuration) throws IOException {\n-        String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY,\n-                                                  ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n+    public SaslServerCallbackHandler(Configuration configuration)\n+            throws IOException {\n+        String serverSection = System.getProperty(\n+                ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY,\n+                ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n         AppConfigurationEntry configurationEntries[] = configuration.getAppConfigurationEntry(serverSection);\n \n         if (configurationEntries == null) {\n-            String errorMessage = \"Could not find a 'Server' entry in this configuration: Server cannot start.\";\n+            String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n             LOG.error(errorMessage);\n             throw new IOException(errorMessage);\n         }"
        },
        {
            "sha": "2a3d4fd4da1b6089171a31bd8fcb237cc134910c",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -997,6 +997,8 @@ else if(self.getVotingView().containsKey(n.sid)) {\n                 LOG.warn(\"Failed to unregister with JMX\", e);\n             }\n             self.jmxLeaderElectionBean = null;\n+            LOG.debug(\"Number of connection processing threads: {}\",\n+                    manager.getConnectionThreadCount());\n         }\n     }\n }"
        },
        {
            "sha": "9aa0d0b5985f0755715caad9346c4819873066b9",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Follower.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -22,6 +22,7 @@\n import java.net.InetSocketAddress;\n \n import org.apache.jute.Record;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.util.SerializeUtils;\n import org.apache.zookeeper.server.util.ZxidUtils;\n import org.apache.zookeeper.txn.TxnHeader;\n@@ -64,9 +65,9 @@ void followLeader() throws InterruptedException {\n         self.end_fle = 0;\n         fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n         try {\n-            InetSocketAddress addr = findLeader();            \n+            QuorumServer leaderServer = findLeader();            \n             try {\n-                connectToLeader(addr);\n+                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                 long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n \n                 //check to see if the leader zxid is lower than ours"
        },
        {
            "sha": "710745d4a4ac9607603647758e36be6cbb516a6c",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Leader.java",
            "status": "modified",
            "additions": 10,
            "deletions": 2,
            "changes": 12,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -19,6 +19,7 @@\n package org.apache.zookeeper.server.quorum;\n \n import java.io.ByteArrayOutputStream;\n+import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.net.BindException;\n import java.net.ServerSocket;\n@@ -32,10 +33,12 @@\n import java.util.Iterator;\n import java.util.List;\n import java.util.Set;\n-import java.util.concurrent.atomic.AtomicLong;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ConcurrentMap;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import javax.security.sasl.SaslException;\n \n import org.apache.jute.BinaryOutputArchive;\n import org.apache.zookeeper.server.FinalRequestProcessor;\n@@ -318,7 +321,10 @@ public void run() {\n                         // in LearnerHandler switch to the syncLimit\n                         s.setSoTimeout(self.tickTime * self.initLimit);\n                         s.setTcpNoDelay(nodelay);\n-                        LearnerHandler fh = new LearnerHandler(s, Leader.this);\n+\n+                        BufferedInputStream is = new BufferedInputStream(\n+                                s.getInputStream());\n+                        LearnerHandler fh = new LearnerHandler(s, is, Leader.this);\n                         fh.start();\n                     } catch (SocketException e) {\n                         if (stop) {\n@@ -332,6 +338,8 @@ public void run() {\n                         } else {\n                             throw e;\n                         }\n+                    } catch (SaslException e){\n+                        LOG.error(\"Exception while connecting to quorum learner\", e);\n                     }\n                 }\n             } catch (Exception e) {"
        },
        {
            "sha": "749b2741728eb1ad78f8b32ba654074ec4d4f652",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Learner.java",
            "status": "modified",
            "additions": 14,
            "deletions": 10,
            "changes": 24,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -39,15 +39,15 @@\n import org.apache.jute.InputArchive;\n import org.apache.jute.OutputArchive;\n import org.apache.jute.Record;\n-import org.slf4j.Logger;\n-import org.slf4j.LoggerFactory;\n import org.apache.zookeeper.server.Request;\n import org.apache.zookeeper.server.ServerCnxn;\n import org.apache.zookeeper.server.ZooTrace;\n import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.util.SerializeUtils;\n import org.apache.zookeeper.server.util.ZxidUtils;\n import org.apache.zookeeper.txn.TxnHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This class is the superclass of two of the three main actors in a ZK\n@@ -191,36 +191,37 @@ void request(Request request) throws IOException {\n     /**\n      * Returns the address of the node we think is the leader.\n      */\n-    protected InetSocketAddress findLeader() {\n-        InetSocketAddress addr = null;\n+    protected QuorumServer findLeader() {\n+        QuorumServer leaderServer = null;\n         // Find the leader by id\n         Vote current = self.getCurrentVote();\n         for (QuorumServer s : self.getView().values()) {\n             if (s.id == current.getId()) {\n                 // Ensure we have the leader's correct IP address before\n                 // attempting to connect.\n                 s.recreateSocketAddresses();\n-                addr = s.addr;\n+                leaderServer = s;\n                 break;\n             }\n         }\n-        if (addr == null) {\n+        if (leaderServer == null) {\n             LOG.warn(\"Couldn't find the leader with id = \"\n                     + current.getId());\n         }\n-        return addr;\n+        return leaderServer;\n     }\n     \n     /**\n      * Establish a connection with the Leader found by findLeader. Retries\n      * 5 times before giving up. \n      * @param addr - the address of the Leader to connect to.\n-     * @throws IOException - if the socket connection fails on the 5th attempt\n+     * @throws IOException <li>if the socket connection fails on the 5th attempt</li>\n+     * <li>if there is an authentication failure while connecting to leader</li>\n      * @throws ConnectException\n      * @throws InterruptedException\n      */\n-    protected void connectToLeader(InetSocketAddress addr) \n-    throws IOException, ConnectException, InterruptedException {\n+    protected void connectToLeader(InetSocketAddress addr, String hostname)\n+            throws IOException, ConnectException, InterruptedException {\n         sock = new Socket();        \n         sock.setSoTimeout(self.tickTime * self.initLimit);\n         for (int tries = 0; tries < 5; tries++) {\n@@ -241,6 +242,9 @@ protected void connectToLeader(InetSocketAddress addr)\n             }\n             Thread.sleep(1000);\n         }\n+\n+        self.authLearner.authenticate(sock, hostname);\n+\n         leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n                 sock.getInputStream()));\n         bufferedOutput = new BufferedOutputStream(sock.getOutputStream());"
        },
        {
            "sha": "51ed7e7035c5aee8391f776ebc0fa182d3e79262",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java",
            "status": "modified",
            "additions": 22,
            "deletions": 5,
            "changes": 27,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -32,6 +32,8 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n \n+import javax.security.sasl.SaslException;\n+\n import org.apache.jute.BinaryInputArchive;\n import org.apache.jute.BinaryOutputArchive;\n import org.apache.jute.Record;\n@@ -153,15 +155,30 @@ public synchronized boolean check(long time) {\n \n     private BinaryOutputArchive oa;\n \n+    private final BufferedInputStream bufferedInput;\n     private BufferedOutputStream bufferedOutput;\n \n-    LearnerHandler(Socket sock, Leader leader) throws IOException {\n+    LearnerHandler(Socket sock, BufferedInputStream bufferedInput,\n+                   Leader leader) throws IOException {\n         super(\"LearnerHandler-\" + sock.getRemoteSocketAddress());\n         this.sock = sock;\n         this.leader = leader;\n-        leader.addLearnerHandler(this);\n+        this.bufferedInput = bufferedInput;\n+        try {\n+            leader.self.authServer.authenticate(sock,\n+                    new DataInputStream(bufferedInput));\n+        } catch (IOException e) {\n+            LOG.error(\"Server failed to authenticate quorum learner, addr: {}, closing connection\",\n+                    sock.getRemoteSocketAddress(), e);\n+            try {\n+                sock.close();\n+            } catch (IOException ie) {\n+                LOG.error(\"Exception while closing socket\", ie);\n+            }\n+            throw new SaslException(\"Authentication failure: \" + e.getMessage());\n+        }\n     }\n-    \n+\n     @Override\n     public String toString() {\n         StringBuilder sb = new StringBuilder();\n@@ -296,11 +313,11 @@ static public String packetToString(QuorumPacket p) {\n     @Override\n     public void run() {\n         try {\n+            leader.addLearnerHandler(this);\n             tickOfNextAckDeadline = leader.self.tick\n                     + leader.self.initLimit + leader.self.syncLimit;\n \n-            ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock\n-                    .getInputStream()));\n+            ia = BinaryInputArchive.getArchive(bufferedInput);\n             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n             oa = BinaryOutputArchive.getArchive(bufferedOutput);\n "
        },
        {
            "sha": "53f516fb2dc01afbc0e84b5be714b9979126bfcf",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Observer.java",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -19,11 +19,11 @@\n package org.apache.zookeeper.server.quorum;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n \n import org.apache.jute.Record;\n import org.apache.zookeeper.server.ObserverBean;\n import org.apache.zookeeper.server.Request;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.util.SerializeUtils;\n import org.apache.zookeeper.txn.TxnHeader;\n \n@@ -61,10 +61,10 @@ void observeLeader() throws InterruptedException {\n         zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n \n         try {\n-            InetSocketAddress addr = findLeader();\n-            LOG.info(\"Observing \" + addr);\n+            QuorumServer leaderServer = findLeader();\n+            LOG.info(\"Observing \" + leaderServer.addr);\n             try {\n-                connectToLeader(addr);\n+                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                 long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n \n                 syncWithLeader(newLeaderZxid);"
        },
        {
            "sha": "74d1c1e621c2c9a703b56130b2fee99e4e35618e",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java",
            "status": "modified",
            "additions": 284,
            "deletions": 63,
            "changes": 347,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -18,6 +18,7 @@\n \n package org.apache.zookeeper.server.quorum;\n \n+import java.io.BufferedInputStream;\n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n import java.io.IOException;\n@@ -28,20 +29,28 @@\n import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n import java.nio.channels.UnresolvedAddressException;\n+import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.NoSuchElementException;\n+import java.util.Set;\n import java.util.concurrent.ArrayBlockingQueue;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n-import java.util.NoSuchElementException;\n import java.util.concurrent.atomic.AtomicInteger;\n-import java.util.Date;\n+import java.util.concurrent.atomic.AtomicLong;\n+\n+import org.apache.zookeeper.server.ZooKeeperThread;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\n \n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n-import org.apache.zookeeper.server.ZooKeeperServer;\n-import org.apache.zookeeper.server.ZooKeeperThread;\n-\n /**\n  * This class implements a connection manager for leader election using TCP. It\n  * maintains one connection for every pair of servers. The tricky part is to\n@@ -89,7 +98,7 @@ public class QuorumCnxManager {\n      * Negative counter for observer server ids.\n      */\n     \n-    private long observerCounter = -1;\n+    private AtomicLong observerCounter = new AtomicLong(-1);\n     \n     /*\n      * Connection time out value in milliseconds \n@@ -100,7 +109,20 @@ public class QuorumCnxManager {\n     /*\n      * Local IP address\n      */\n-    final QuorumPeer self;\n+    final long mySid;\n+    final int socketTimeout;\n+    final Map<Long, QuorumPeer.QuorumServer> view;\n+    final boolean listenOnAllIPs;\n+    private ThreadPoolExecutor connectionExecutor;\n+    private final Set<Long> inprogressConnections = Collections\n+            .synchronizedSet(new HashSet<Long>());\n+    private QuorumAuthServer authServer;\n+    private QuorumAuthLearner authLearner;\n+    private boolean quorumSaslAuthEnabled;\n+    /*\n+     * Counter to count connection processing threads.\n+     */\n+    private AtomicInteger connectionThreadCnt = new AtomicInteger(0);\n \n     /*\n      * Mapping from Peer to Thread number\n@@ -145,7 +167,14 @@ static public class Message {\n         long sid;\n     }\n \n-    public QuorumCnxManager(QuorumPeer self) {\n+    public QuorumCnxManager(final long mySid,\n+                            Map<Long,QuorumPeer.QuorumServer> view,\n+                            QuorumAuthServer authServer,\n+                            QuorumAuthLearner authLearner,\n+                            int socketTimeout,\n+                            boolean listenOnAllIPs,\n+                            int quorumCnxnThreadsSize,\n+                            boolean quorumSaslAuthEnabled) {\n         this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);\n         this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();\n         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();\n@@ -155,13 +184,53 @@ public QuorumCnxManager(QuorumPeer self) {\n         if(cnxToValue != null){\n             this.cnxTO = new Integer(cnxToValue); \n         }\n-        \n-        this.self = self;\n+\n+        this.mySid = mySid;\n+        this.socketTimeout = socketTimeout;\n+        this.view = view;\n+        this.listenOnAllIPs = listenOnAllIPs;\n+\n+        initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,\n+                quorumSaslAuthEnabled);\n \n         // Starts listener thread that waits for connection requests \n         listener = new Listener();\n     }\n \n+    private void initializeAuth(final long mySid,\n+            final QuorumAuthServer authServer,\n+            final QuorumAuthLearner authLearner,\n+            final int quorumCnxnThreadsSize,\n+            final boolean quorumSaslAuthEnabled) {\n+        this.authServer = authServer;\n+        this.authLearner = authLearner;\n+        this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;\n+        if (!this.quorumSaslAuthEnabled) {\n+            LOG.debug(\"Not initializing connection executor as quorum sasl auth is disabled\");\n+            return;\n+        }\n+\n+        // init connection executors\n+        final AtomicInteger threadIndex = new AtomicInteger(1);\n+        SecurityManager s = System.getSecurityManager();\n+        final ThreadGroup group = (s != null) ? s.getThreadGroup()\n+                : Thread.currentThread().getThreadGroup();\n+        ThreadFactory daemonThFactory = new ThreadFactory() {\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread t = new Thread(group, r, \"QuorumConnectionThread-\"\n+                        + \"[myid=\" + mySid + \"]-\"\n+                        + threadIndex.getAndIncrement());\n+                return t;\n+            }\n+        };\n+        this.connectionExecutor = new ThreadPoolExecutor(3,\n+                quorumCnxnThreadsSize, 60, TimeUnit.SECONDS,\n+                new SynchronousQueue<Runnable>(), daemonThFactory);\n+        this.connectionExecutor.allowCoreThreadTimeOut(true);\n+    }\n+\n     /**\n      * Invokes initiateConnection for testing purposes\n      * \n@@ -173,36 +242,105 @@ public void testInitiateConnection(long sid) throws Exception {\n         }\n         Socket sock = new Socket();\n         setSockOpts(sock);\n-        sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);\n+        sock.connect(QuorumPeer.viewToVotingView(view).get(sid).electionAddr,\n+                     cnxTO);\n         initiateConnection(sock, sid);\n     }\n     \n     /**\n      * If this server has initiated the connection, then it gives up on the\n      * connection if it loses challenge. Otherwise, it keeps the connection.\n      */\n-    public boolean initiateConnection(Socket sock, Long sid) {\n+    public void initiateConnection(final Socket sock, final Long sid) {\n+        try {\n+            startConnection(sock, sid);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n+                     new Object[] { sid, sock.getRemoteSocketAddress() }, e);\n+            closeSocket(sock);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Server will initiate the connection request to its peer server\n+     * asynchronously via separate connection thread.\n+     */\n+    public void initiateConnectionAsync(final Socket sock, final Long sid) {\n+        if(!inprogressConnections.add(sid)){\n+            // simply return as there is a connection request to\n+            // server 'sid' already in progress.\n+            LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\",\n+                    sid);\n+            closeSocket(sock);\n+            return;\n+        }\n+        try {\n+            connectionExecutor.execute(\n+                    new QuorumConnectionReqThread(sock, sid));\n+            connectionThreadCnt.incrementAndGet();\n+        } catch (Throwable e) {\n+            // Imp: Safer side catching all type of exceptions and remove 'sid'\n+            // from inprogress connections. This is to avoid blocking further\n+            // connection requests from this 'sid' in case of errors.\n+            inprogressConnections.remove(sid);\n+            LOG.error(\"Exception while submitting quorum connection request\", e);\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Thread to send connection request to peer server.\n+     */\n+    private class QuorumConnectionReqThread extends ZooKeeperThread {\n+        final Socket sock;\n+        final Long sid;\n+        QuorumConnectionReqThread(final Socket sock, final Long sid) {\n+            super(\"QuorumConnectionReqThread-\" + sid);\n+            this.sock = sock;\n+            this.sid = sid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try{\n+                initiateConnection(sock, sid);\n+            } finally {\n+                inprogressConnections.remove(sid);\n+            }\n+        }\n+    }\n+\n+    private boolean startConnection(Socket sock, Long sid)\n+            throws IOException {\n         DataOutputStream dout = null;\n+        DataInputStream din = null;\n         try {\n             // Sending id and challenge\n             dout = new DataOutputStream(sock.getOutputStream());\n-            dout.writeLong(self.getId());\n+            dout.writeLong(this.mySid);\n             dout.flush();\n+\n+            din = new DataInputStream(\n+                    new BufferedInputStream(sock.getInputStream()));\n         } catch (IOException e) {\n             LOG.warn(\"Ignoring exception reading or writing challenge: \", e);\n             closeSocket(sock);\n             return false;\n         }\n-        \n+\n+        // authenticate learner\n+        authLearner.authenticate(sock, view.get(sid).hostname);\n+\n         // If lost the challenge, then drop the new connection\n-        if (sid > self.getId()) {\n+        if (sid > this.mySid) {\n             LOG.info(\"Have smaller server identifier, so dropping the \" +\n-                     \"connection: (\" + sid + \", \" + self.getId() + \")\");\n+                     \"connection: (\" + sid + \", \" + this.mySid + \")\");\n             closeSocket(sock);\n             // Otherwise proceed with the connection\n         } else {\n             SendWorker sw = new SendWorker(sock, sid);\n-            RecvWorker rw = new RecvWorker(sock, sid, sw);\n+            RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n             sw.setRecv(rw);\n \n             SendWorker vsw = senderWorkerMap.get(sid);\n@@ -225,21 +363,64 @@ public boolean initiateConnection(Socket sock, Long sid) {\n         return false;\n     }\n \n-    \n-    \n     /**\n      * If this server receives a connection request, then it gives up on the new\n      * connection if it wins. Notice that it checks whether it has a connection\n      * to this server already or not. If it does, then it sends the smallest\n      * possible long value to lose the challenge.\n      * \n      */\n-    public void receiveConnection(Socket sock) {\n+    public void receiveConnection(final Socket sock) {\n+        DataInputStream din = null;\n+        try {\n+            din = new DataInputStream(\n+                    new BufferedInputStream(sock.getInputStream()));\n+\n+            handleConnection(sock, din);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception handling connection, addr: {}, closing server connection\",\n+                     sock.getRemoteSocketAddress());\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Server receives a connection request and handles it asynchronously via\n+     * separate thread.\n+     */\n+    public void receiveConnectionAsync(final Socket sock) {\n+        try {\n+            connectionExecutor.execute(\n+                    new QuorumConnectionReceiverThread(sock));\n+            connectionThreadCnt.incrementAndGet();\n+        } catch (Throwable e) {\n+            LOG.error(\"Exception handling connection, addr: {}, closing server connection\",\n+                     sock.getRemoteSocketAddress());\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Thread to receive connection request from peer server.\n+     */\n+    private class QuorumConnectionReceiverThread extends ZooKeeperThread {\n+        private final Socket sock;\n+        QuorumConnectionReceiverThread(final Socket sock) {\n+            super(\"QuorumConnectionReceiverThread-\" + sock.getRemoteSocketAddress());\n+            this.sock = sock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            receiveConnection(sock);\n+        }\n+    }\n+\n+    private void handleConnection(Socket sock, DataInputStream din)\n+            throws IOException {\n         Long sid = null;\n-        \n         try {\n             // Read server id\n-            DataInputStream din = new DataInputStream(sock.getInputStream());\n             sid = din.readLong();\n             if (sid < 0) { // this is not a server id but a protocol version (see ZOOKEEPER-1633)\n                 sid = din.readLong();\n@@ -265,18 +446,20 @@ public void receiveConnection(Socket sock) {\n                  * Choose identifier at random. We need a value to identify\n                  * the connection.\n                  */\n-                \n-                sid = observerCounter--;\n+                sid = observerCounter.getAndDecrement();\n                 LOG.info(\"Setting arbitrary identifier to observer: \" + sid);\n             }\n         } catch (IOException e) {\n             closeSocket(sock);\n             LOG.warn(\"Exception reading or writing challenge: \" + e.toString());\n             return;\n         }\n-        \n+\n+        // do authenticating learner\n+        authServer.authenticate(sock, din);\n+\n         //If wins the challenge, then close the new connection.\n-        if (sid < self.getId()) {\n+        if (sid < this.mySid) {\n             /*\n              * This replica might still believe that the connection to sid is\n              * up, so we have to shut down the workers before trying to open a\n@@ -297,7 +480,7 @@ public void receiveConnection(Socket sock) {\n             // Otherwise start worker threads to receive data.\n         } else {\n             SendWorker sw = new SendWorker(sock, sid);\n-            RecvWorker rw = new RecvWorker(sock, sid, sw);\n+            RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n             sw.setRecv(rw);\n \n             SendWorker vsw = senderWorkerMap.get(sid);\n@@ -327,7 +510,7 @@ public void toSend(Long sid, ByteBuffer b) {\n         /*\n          * If sending message to myself, then simply enqueue it (loopback).\n          */\n-        if (self.getId() == sid) {\n+        if (this.mySid == sid) {\n              b.position(0);\n              addToRecvQueue(new Message(b.duplicate(), sid));\n             /*\n@@ -361,28 +544,32 @@ public void toSend(Long sid, ByteBuffer b) {\n      * \n      *  @param sid  server id\n      */\n-    \n-    synchronized void connectOne(long sid){\n-        if (senderWorkerMap.get(sid) == null){\n+    synchronized public void connectOne(long sid){\n+        if (!connectedToPeer(sid)){\n             InetSocketAddress electionAddr;\n-            if (self.quorumPeers.containsKey(sid)) {\n-                electionAddr = self.quorumPeers.get(sid).electionAddr;\n+            if (view.containsKey(sid)) {\n+                electionAddr = view.get(sid).electionAddr;\n             } else {\n                 LOG.warn(\"Invalid server id: \" + sid);\n                 return;\n             }\n             try {\n \n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Opening channel to server \" + sid);\n-                }\n+                LOG.debug(\"Opening channel to server \" + sid);\n                 Socket sock = new Socket();\n                 setSockOpts(sock);\n-                sock.connect(self.getView().get(sid).electionAddr, cnxTO);\n-                if (LOG.isDebugEnabled()) {\n-                    LOG.debug(\"Connected to server \" + sid);\n+                sock.connect(view.get(sid).electionAddr, cnxTO);\n+                LOG.debug(\"Connected to server \" + sid);\n+\n+                // Sends connection request asynchronously if the quorum\n+                // sasl authentication is enabled. This is required because\n+                // sasl server authentication process may take few seconds to\n+                // finish, this may delay next peer connection requests.\n+                if (quorumSaslAuthEnabled) {\n+                    initiateConnectionAsync(sock, sid);\n+                } else {\n+                    initiateConnection(sock, sid);\n                 }\n-                initiateConnection(sock, sid);\n             } catch (UnresolvedAddressException e) {\n                 // Sun doesn't include the address that causes this\n                 // exception to be thrown, also UAE cannot be wrapped cleanly\n@@ -392,8 +579,8 @@ synchronized void connectOne(long sid){\n                         + \" at election address \" + electionAddr, e);\n                 // Resolve hostname for this server in case the\n                 // underlying ip address has changed.\n-                if (self.getView().containsKey(sid)) {\n-                    self.getView().get(sid).recreateSocketAddresses();\n+                if (view.containsKey(sid)) {\n+                    view.get(sid).recreateSocketAddresses();\n                 }\n                 throw e;\n             } catch (IOException e) {\n@@ -403,8 +590,8 @@ synchronized void connectOne(long sid){\n                 // We can't really tell if the server is actually down or it failed\n                 // to connect to the server because the underlying IP address\n                 // changed. Resolve the hostname again just in case.\n-                if (self.getView().containsKey(sid)) {\n-                    self.getView().get(sid).recreateSocketAddresses();\n+                if (view.containsKey(sid)) {\n+                    view.get(sid).recreateSocketAddresses();\n                 }\n             }\n         } else {\n@@ -451,6 +638,13 @@ public void halt() {\n         listener.halt();\n         \n         softHalt();\n+\n+        // clear data structures used for auth\n+        if (connectionExecutor != null) {\n+            connectionExecutor.shutdown();\n+        }\n+        inprogressConnections.clear();\n+        resetConnectionThreadCount();\n     }\n    \n     /**\n@@ -471,7 +665,7 @@ public void softHalt() {\n      */\n     private void setSockOpts(Socket sock) throws SocketException {\n         sock.setTcpNoDelay(true);\n-        sock.setSoTimeout(self.tickTime * self.syncLimit);\n+        sock.setSoTimeout(socketTimeout);\n     }\n \n     /**\n@@ -494,11 +688,19 @@ private void closeSocket(Socket sock) {\n     public long getThreadCount() {\n         return threadCnt.get();\n     }\n+\n+    /**\n+     * Return number of connection processing threads.\n+     */\n+    public long getConnectionThreadCount() {\n+        return connectionThreadCnt.get();\n+    }\n+\n     /**\n-     * Return reference to QuorumPeer\n+     * Reset the value of connection processing threads count to zero.\n      */\n-    public QuorumPeer getQuorumPeer() {\n-        return self;\n+    private void resetConnectionThreadCount() {\n+        connectionThreadCnt.set(0);\n     }\n \n     /**\n@@ -525,22 +727,35 @@ public void run() {\n                 try {\n                     ss = new ServerSocket();\n                     ss.setReuseAddress(true);\n-                    if (self.getQuorumListenOnAllIPs()) {\n-                        int port = self.quorumPeers.get(self.getId()).electionAddr.getPort();\n+                    if (listenOnAllIPs) {\n+                        int port = view.get(QuorumCnxManager.this.mySid)\n+                            .electionAddr.getPort();\n                         addr = new InetSocketAddress(port);\n                     } else {\n-                        addr = self.quorumPeers.get(self.getId()).electionAddr;\n+                        addr = view.get(QuorumCnxManager.this.mySid)\n+                            .electionAddr;\n                     }\n                     LOG.info(\"My election bind port: \" + addr.toString());\n-                    setName(self.quorumPeers.get(self.getId()).electionAddr\n-                            .toString());\n+                    setName(view.get(QuorumCnxManager.this.mySid)\n+                            .electionAddr.toString());\n                     ss.bind(addr);\n                     while (!shutdown) {\n                         Socket client = ss.accept();\n                         setSockOpts(client);\n                         LOG.info(\"Received connection request \"\n                                 + client.getRemoteSocketAddress());\n-                        receiveConnection(client);\n+\n+                        // Receive and handle the connection request\n+                        // asynchronously if the quorum sasl authentication is\n+                        // enabled. This is required because sasl server\n+                        // authentication process may take few seconds to finish,\n+                        // this may delay next peer connection requests.\n+                        if (quorumSaslAuthEnabled) {\n+                            receiveConnectionAsync(client);\n+                        } else {\n+                            receiveConnection(client);\n+                        }\n+\n                         numRetries = 0;\n                     }\n                 } catch (IOException e) {\n@@ -562,7 +777,7 @@ public void run() {\n                 LOG.error(\"As I'm leaving the listener thread, \"\n                         + \"I won't be able to participate in leader \"\n                         + \"election any longer: \"\n-                        + self.quorumPeers.get(self.getId()).electionAddr);\n+                        + view.get(QuorumCnxManager.this.mySid).electionAddr);\n             }\n         }\n         \n@@ -573,7 +788,8 @@ void halt(){\n             try{\n                 LOG.debug(\"Trying to close listener: \" + ss);\n                 if(ss != null) {\n-                    LOG.debug(\"Closing listener: \" + self.getId());\n+                    LOG.debug(\"Closing listener: \"\n+                              + QuorumCnxManager.this.mySid);\n                     ss.close();\n                 }\n             } catch (IOException e){\n@@ -729,8 +945,9 @@ public void run() {\n                     }\n                 }\n             } catch (Exception e) {\n-                LOG.warn(\"Exception when using channel: for id \" + sid + \" my id = \" + \n-                        self.getId() + \" error = \" + e);\n+                LOG.warn(\"Exception when using channel: for id \" + sid\n+                         + \" my id = \" + QuorumCnxManager.this.mySid\n+                         + \" error = \" + e);\n             }\n             this.finish();\n             LOG.warn(\"Send worker leaving thread\");\n@@ -745,16 +962,16 @@ class RecvWorker extends ZooKeeperThread {\n         Long sid;\n         Socket sock;\n         volatile boolean running = true;\n-        DataInputStream din;\n+        final DataInputStream din;\n         final SendWorker sw;\n \n-        RecvWorker(Socket sock, Long sid, SendWorker sw) {\n+        RecvWorker(Socket sock, DataInputStream din, Long sid, SendWorker sw) {\n             super(\"RecvWorker:\" + sid);\n             this.sid = sid;\n             this.sock = sock;\n             this.sw = sw;\n+            this.din = din;\n             try {\n-                din = new DataInputStream(sock.getInputStream());\n                 // OK to wait until socket disconnects while reading.\n                 sock.setSoTimeout(0);\n             } catch (IOException e) {\n@@ -807,8 +1024,8 @@ public void run() {\n                     addToRecvQueue(new Message(message.duplicate(), sid));\n                 }\n             } catch (Exception e) {\n-                LOG.warn(\"Connection broken for id \" + sid + \", my id = \" + \n-                        self.getId() + \", error = \" , e);\n+                LOG.warn(\"Connection broken for id \" + sid + \", my id = \"\n+                         + QuorumCnxManager.this.mySid + \", error = \" , e);\n             } finally {\n                 LOG.warn(\"Interrupting SendWorker\");\n                 sw.finish();\n@@ -930,4 +1147,8 @@ public Message pollRecvQueue(long timeout, TimeUnit unit)\n        throws InterruptedException {\n        return recvQueue.poll(timeout, unit);\n     }\n+\n+    public boolean connectedToPeer(long peerSid) {\n+        return senderWorkerMap.get(peerSid) != null;\n+    }\n }"
        },
        {
            "sha": "2dbedcf802ef218d9d6a4e221df89d82c0e8a0e9",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java",
            "status": "modified",
            "additions": 167,
            "deletions": 14,
            "changes": 181,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -34,8 +34,12 @@\n import java.util.ArrayList;\n import java.util.Collections;\n import java.util.HashMap;\n+import java.util.HashSet;\n import java.util.List;\n import java.util.Map;\n+import java.util.Set;\n+\n+import javax.security.sasl.SaslException;\n \n import org.apache.zookeeper.common.AtomicFileOutputStream;\n import org.apache.zookeeper.jmx.MBeanRegistry;\n@@ -45,6 +49,13 @@\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.ZooKeeperThread;\n import org.apache.zookeeper.server.persistence.FileTxnSnapLog;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuth;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;\n import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n import org.apache.zookeeper.server.util.ZxidUtils;\n@@ -85,6 +96,8 @@ public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider\n     LocalPeerBean jmxLocalPeerBean;\n     LeaderElectionBean jmxLeaderElectionBean;\n     QuorumCnxManager qcm;\n+    QuorumAuthServer authServer;\n+    QuorumAuthLearner authLearner;\n \n     /* ZKDatabase is a top level member of quorumpeer \n      * which will be used in all the zookeeperservers\n@@ -102,7 +115,8 @@ private QuorumServer(long id, InetSocketAddress addr,\n             this.electionAddr = electionAddr;\n         }\n \n-        private QuorumServer(long id, InetSocketAddress addr) {\n+        // VisibleForTesting\n+        public QuorumServer(long id, InetSocketAddress addr) {\n             this.id = id;\n             this.addr = addr;\n             this.electionAddr = null;\n@@ -337,6 +351,50 @@ synchronized void setBCVote(Vote v) {\n      */\n     protected boolean quorumListenOnAllIPs = false;\n \n+    /**\n+     * Enable/Disables quorum authentication using sasl. Defaulting to false.\n+     */\n+    protected boolean quorumSaslEnableAuth;\n+\n+    /**\n+     * If this is false, quorum peer server will accept another quorum peer client\n+     * connection even if the authentication did not succeed. This can be used while\n+     * upgrading ZooKeeper server. Defaulting to false (required).\n+     */\n+    protected boolean quorumServerSaslAuthRequired;\n+\n+    /**\n+     * If this is false, quorum peer learner will talk to quorum peer server\n+     * without authentication. This can be used while upgrading ZooKeeper\n+     * server. Defaulting to false (required).\n+     */\n+    protected boolean quorumLearnerSaslAuthRequired;\n+\n+    /**\n+     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.\n+     */\n+    protected String quorumServicePrincipal;\n+\n+    /**\n+     * Quorum learner login context name in jaas-conf file to read the kerberos\n+     * security details. Defaulting to 'QuorumLearner'.\n+     */\n+    protected String quorumLearnerLoginContext;\n+\n+    /**\n+     * Quorum server login context name in jaas-conf file to read the kerberos\n+     * security details. Defaulting to 'QuorumServer'.\n+     */\n+    protected String quorumServerLoginContext;\n+\n+    // TODO: need to tune the default value of thread size\n+    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;\n+    /**\n+     * The maximum number of threads to allow in the connectionExecutors thread\n+     * pool which will be used to initiate quorum server connections.\n+     */\n+    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;\n+\n     /**\n      * @deprecated As of release 3.4.0, this class has been deprecated, since\n      * it is used with one of the udp-based versions of leader election, which\n@@ -449,10 +507,15 @@ public InetSocketAddress getQuorumAddress(){\n     private FileTxnSnapLog logFactory = null;\n \n     private final QuorumStats quorumStats;\n-    \n-    public QuorumPeer() {\n+\n+    public static QuorumPeer testingQuorumPeer() throws SaslException {\n+        return new QuorumPeer();\n+    }\n+\n+    private QuorumPeer() throws SaslException {\n         super(\"QuorumPeer\");\n         quorumStats = new QuorumStats(this);\n+        initialize();\n     }\n     \n    \n@@ -490,7 +553,24 @@ public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir,\n             this.quorumConfig = new QuorumMaj(countParticipants(quorumPeers));\n         else this.quorumConfig = quorumConfig;\n     }\n-    \n+\n+    public void initialize() throws SaslException {\n+        // init quorum auth server & learner\n+        if (isQuorumSaslAuthEnabled()) {\n+            Set<String> authzHosts = new HashSet<String>();\n+            for (QuorumServer qs : getView().values()) {\n+                authzHosts.add(qs.hostname);\n+            }\n+            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(),\n+                    quorumServerLoginContext, authzHosts);\n+            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(),\n+                    quorumServicePrincipal, quorumLearnerLoginContext);\n+        } else {\n+            authServer = new NullQuorumAuthServer();\n+            authLearner = new NullQuorumAuthLearner();\n+        }\n+    }\n+\n     QuorumStats quorumStats() {\n         return quorumStats;\n     }\n@@ -686,7 +766,7 @@ protected Election createElectionAlgorithm(int electionAlgorithm){\n             le = new AuthFastLeaderElection(this, true);\n             break;\n         case 3:\n-            qcm = new QuorumCnxManager(this);\n+            qcm = createCnxnManager();\n             QuorumCnxManager.Listener listener = qcm.listener;\n             if(listener != null){\n                 listener.start();\n@@ -903,33 +983,37 @@ public void shutdown() {\n             zkDb.close();\n         } catch (IOException ie) {\n             LOG.warn(\"Error closing logs \", ie);\n-        }     \n+        }\n     }\n \n     /**\n      * A 'view' is a node's current opinion of the membership of the entire\n-     * ensemble.    \n+     * ensemble.\n      */\n     public Map<Long,QuorumPeer.QuorumServer> getView() {\n         return Collections.unmodifiableMap(this.quorumPeers);\n     }\n-    \n+\n     /**\n      * Observers are not contained in this view, only nodes with \n-     * PeerType=PARTICIPANT.     \n+     * PeerType=PARTICIPANT.\n      */\n     public Map<Long,QuorumPeer.QuorumServer> getVotingView() {\n-        Map<Long,QuorumPeer.QuorumServer> ret = \n+        return QuorumPeer.viewToVotingView(getView());\n+    }\n+\n+    static Map<Long,QuorumPeer.QuorumServer> viewToVotingView(\n+            Map<Long,QuorumPeer.QuorumServer> view) {\n+        Map<Long,QuorumPeer.QuorumServer> ret =\n             new HashMap<Long, QuorumPeer.QuorumServer>();\n-        Map<Long,QuorumPeer.QuorumServer> view = getView();\n-        for (QuorumServer server : view.values()) {            \n+        for (QuorumServer server : view.values()) {\n             if (server.type == LearnerType.PARTICIPANT) {\n                 ret.put(server.id, server);\n             }\n-        }        \n+        }\n         return ret;\n     }\n-    \n+\n     /**\n      * Returns only observers, no followers.\n      */\n@@ -1306,4 +1390,73 @@ protected void updateElectionVote(long newEpoch) {\n         }\n     }\n \n+    void setQuorumServerSaslRequired(boolean serverSaslRequired) {\n+        quorumServerSaslAuthRequired = serverSaslRequired;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED,\n+                serverSaslRequired);\n+    }\n+\n+    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {\n+        quorumLearnerSaslAuthRequired = learnerSaslRequired;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED,\n+                learnerSaslRequired);\n+    }\n+\n+    void setQuorumSaslEnabled(boolean enableAuth) {\n+        quorumSaslEnableAuth = enableAuth;\n+        if (!quorumSaslEnableAuth) {\n+            LOG.info(\"QuorumPeer communication is not secured!\");\n+        } else {\n+            LOG.info(\"{} set to {}\",\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n+        }\n+    }\n+\n+    void setQuorumServicePrincipal(String servicePrincipal) {\n+        quorumServicePrincipal = servicePrincipal;\n+        LOG.info(\"{} set to {}\",QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL,\n+                quorumServicePrincipal);\n+    }\n+\n+    void setQuorumLearnerLoginContext(String learnerContext) {\n+        quorumLearnerLoginContext = learnerContext;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                quorumLearnerLoginContext);\n+    }\n+\n+    void setQuorumServerLoginContext(String serverContext) {\n+        quorumServerLoginContext = serverContext;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT,\n+                quorumServerLoginContext);\n+    }\n+\n+    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {\n+        if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n+            quorumCnxnThreadsSize = qCnxnThreadsSize;\n+        }\n+        LOG.info(\"quorum.cnxn.threads.size set to {}\", quorumCnxnThreadsSize);\n+    }\n+\n+    boolean isQuorumSaslAuthEnabled() {\n+        return quorumSaslEnableAuth;\n+    }\n+\n+    private boolean isQuorumServerSaslAuthRequired() {\n+        return quorumServerSaslAuthRequired;\n+    }\n+\n+    private boolean isQuorumLearnerSaslAuthRequired() {\n+        return quorumLearnerSaslAuthRequired;\n+    }\n+\n+    public QuorumCnxManager createCnxnManager() {\n+        return new QuorumCnxManager(this.getId(),\n+                                    this.getView(),\n+                                    this.authServer,\n+                                    this.authLearner,\n+                                    this.tickTime * this.syncLimit,\n+                                    this.getQuorumListenOnAllIPs(),\n+                                    this.quorumCnxnThreadsSize,\n+                                    this.isQuorumSaslAuthEnabled());\n+    }\n }"
        },
        {
            "sha": "621f830d81dbef6b9e017e3f1067ae0bbe1f0cd5",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java",
            "status": "modified",
            "additions": 46,
            "deletions": 2,
            "changes": 48,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -38,6 +38,7 @@\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;\n import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuth;\n import org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical;\n import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n@@ -75,7 +76,16 @@ public class QuorumPeerConfig {\n     protected boolean syncEnabled = true;\n \n     protected LearnerType peerType = LearnerType.PARTICIPANT;\n-    \n+\n+    /** Configurations for the quorumpeer-to-quorumpeer sasl authentication */\n+    protected boolean quorumServerRequireSasl = false;\n+    protected boolean quorumLearnerRequireSasl = false;\n+    protected boolean quorumEnableSasl = false;\n+    protected String quorumServicePrincipal = QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE;\n+    protected String quorumLearnerLoginContext = QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;\n+    protected String quorumServerLoginContext = QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;\n+    protected int quorumCnxnThreadsSize;\n+\n     /**\n      * Minimum snapshot retain count.\n      * @see org.apache.zookeeper.server.PurgeTxnLog#purge(File, File, int)\n@@ -246,11 +256,45 @@ public void parseProperties(Properties zkProp)\n                 int dot = key.indexOf('.');\n                 long sid = Long.parseLong(key.substring(dot + 1));\n                 serverWeight.put(sid, Long.parseLong(value));\n+            } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {\n+                quorumEnableSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {\n+                quorumServerRequireSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {\n+                quorumLearnerRequireSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {\n+                quorumLearnerLoginContext = value;\n+            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {\n+                quorumServerLoginContext = value;\n+            } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {\n+                quorumServicePrincipal = value;\n+            } else if (key.equals(\"quorum.cnxn.threads.size\")) {\n+                quorumCnxnThreadsSize = Integer.parseInt(value);\n             } else {\n                 System.setProperty(\"zookeeper.\" + key, value);\n             }\n         }\n-        \n+        if (!quorumEnableSasl && quorumServerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED\n+                    + \" is disabled, so cannot enable \"\n+                    + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n+        }\n+        if (!quorumEnableSasl && quorumLearnerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED\n+                    + \" is disabled, so cannot enable \"\n+                    + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);\n+        }\n+        // If quorumpeer learner is not auth enabled then self won't be able to\n+        // join quorum. So this condition is ensuring that the quorumpeer learner\n+        // is also auth enabled while enabling quorum server require sasl.\n+        if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED\n+                    + \" is disabled, so cannot enable \"\n+                    + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n+        }\n         // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n         // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n         // than 3."
        },
        {
            "sha": "4ea7e54caed2dbb9ff8d4b0d3b186c055ffb639a",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java",
            "status": "modified",
            "additions": 25,
            "deletions": 14,
            "changes": 39,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -130,26 +130,37 @@ public void runFromConfig(QuorumPeerConfig config) throws IOException {\n           cnxnFactory.configure(config.getClientPortAddress(),\n                                 config.getMaxClientCnxns());\n   \n-          quorumPeer = new QuorumPeer();\n+          quorumPeer = new QuorumPeer(config.getServers(),\n+                                      new File(config.getDataDir()),\n+                                      new File(config.getDataLogDir()),\n+                                      config.getElectionAlg(),\n+                                      config.getServerId(),\n+                                      config.getTickTime(),\n+                                      config.getInitLimit(),\n+                                      config.getSyncLimit(),\n+                                      config.getQuorumListenOnAllIPs(),\n+                                      cnxnFactory,\n+                                      config.getQuorumVerifier());\n           quorumPeer.setClientPortAddress(config.getClientPortAddress());\n-          quorumPeer.setTxnFactory(new FileTxnSnapLog(\n-                      new File(config.getDataLogDir()),\n-                      new File(config.getDataDir())));\n-          quorumPeer.setQuorumPeers(config.getServers());\n-          quorumPeer.setElectionType(config.getElectionAlg());\n-          quorumPeer.setMyid(config.getServerId());\n-          quorumPeer.setTickTime(config.getTickTime());\n           quorumPeer.setMinSessionTimeout(config.getMinSessionTimeout());\n           quorumPeer.setMaxSessionTimeout(config.getMaxSessionTimeout());\n-          quorumPeer.setInitLimit(config.getInitLimit());\n-          quorumPeer.setSyncLimit(config.getSyncLimit());\n-          quorumPeer.setQuorumVerifier(config.getQuorumVerifier());\n-          quorumPeer.setCnxnFactory(cnxnFactory);\n           quorumPeer.setZKDatabase(new ZKDatabase(quorumPeer.getTxnFactory()));\n           quorumPeer.setLearnerType(config.getPeerType());\n           quorumPeer.setSyncEnabled(config.getSyncEnabled());\n-          quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n-  \n+\n+          // sets quorum sasl authentication configurations\n+          quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n+          if(quorumPeer.isQuorumSaslAuthEnabled()){\n+              quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n+              quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n+              quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n+              quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n+              quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n+          }\n+\n+          quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n+          quorumPeer.initialize();\n+\n           quorumPeer.start();\n           quorumPeer.join();\n       } catch (InterruptedException e) {"
        },
        {
            "sha": "0af891c55e1faf829aa756eb091ca494a67a545f",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/NullQuorumAuthLearner.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,33 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.net.Socket;\n+\n+/**\n+ * This class represents no authentication learner, it just return\n+ * without performing any authentication.\n+ */\n+public class NullQuorumAuthLearner implements QuorumAuthLearner {\n+\n+    @Override\n+    public void authenticate(Socket sock, String hostname) {\n+        return; // simply return don't require auth\n+    }\n+}"
        },
        {
            "sha": "b26a54a81ea2ec0dfadcc655b3f8a2f2a188caff",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/NullQuorumAuthServer.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.net.Socket;\n+\n+/**\n+ * This class represents no authentication server, it just return\n+ * without performing any authentication.\n+ */\n+public class NullQuorumAuthServer implements QuorumAuthServer {\n+\n+    @Override\n+    public void authenticate(final Socket sock, final DataInputStream din) {\n+        return; // simply return don't require auth\n+    }\n+}"
        },
        {
            "sha": "8bfa394deccaaefbbfff6054c53f374164ffcf04",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuth.java",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import org.apache.jute.BinaryInputArchive;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+\n+public class QuorumAuth {\n+    private static final Logger LOG = LoggerFactory.getLogger(QuorumAuth.class);\n+\n+    public static final String QUORUM_SASL_AUTH_ENABLED = \"quorum.auth.enableSasl\";\n+    public static final String QUORUM_SERVER_SASL_AUTH_REQUIRED = \"quorum.auth.serverRequireSasl\";\n+    public static final String QUORUM_LEARNER_SASL_AUTH_REQUIRED = \"quorum.auth.learnerRequireSasl\";\n+\n+    public static final String QUORUM_KERBEROS_SERVICE_PRINCIPAL = \"quorum.auth.kerberos.servicePrincipal\";\n+    public static final String QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE = \"zkquorum/localhost\";\n+\n+    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT = \"quorum.auth.learner.saslLoginContext\";\n+    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE = \"QuorumLearner\";\n+\n+    public static final String QUORUM_SERVER_SASL_LOGIN_CONTEXT = \"quorum.auth.server.saslLoginContext\";\n+    public static final String QUORUM_SERVER_SASL_LOGIN_CONTEXT_DFAULT_VALUE = \"QuorumServer\";\n+\n+    static final String QUORUM_SERVER_PROTOCOL_NAME = \"zookeeper-quorum\";\n+    static final String QUORUM_SERVER_SASL_DIGEST = \"zk-quorum-sasl-md5\";\n+    static final String QUORUM_AUTH_MESSAGE_TAG = \"qpconnect\";\n+\n+    // this is negative, so that if a learner that does auth, connects to a\n+    // server, it'll think the received packet is an authentication packet\n+    public static final long QUORUM_AUTH_MAGIC_NUMBER = -0xa0dbcafecafe1234L;\n+\n+    public enum Status {\n+         IN_PROGRESS(0), SUCCESS(1), ERROR(-1);\n+        private int status;\n+\n+        Status(int status) {\n+            this.status = status;\n+        }\n+\n+        static Status getStatus(int status) {\n+            switch (status) {\n+            case 0:\n+                return IN_PROGRESS;\n+            case 1:\n+                return SUCCESS;\n+            case -1:\n+                return ERROR;\n+            default:\n+                LOG.error(\"Unknown status:{}!\", status);\n+                assert false : \"Unknown status!\";\n+                return ERROR;\n+            }\n+        }\n+\n+        int status() {\n+            return status;\n+        }\n+    }\n+\n+    public static QuorumAuthPacket createPacket(Status status, byte[] response) {\n+        return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER,\n+                                    status.status(), response);\n+    }\n+\n+    public static boolean nextPacketIsAuth(DataInputStream din)\n+            throws IOException {\n+        din.mark(32);\n+        BinaryInputArchive bia = new BinaryInputArchive(din);\n+        boolean firstIsAuth = (bia.readLong(\"NO_TAG\")\n+                               == QuorumAuth.QUORUM_AUTH_MAGIC_NUMBER);\n+        din.reset();\n+        return firstIsAuth;\n+    }\n+}"
        },
        {
            "sha": "af71257480232b1abdfc1da0e5c9edd9fcf35c68",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuthLearner.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+\n+/**\n+ * Interface for quorum learner authentication mechanisms.\n+ */\n+public interface QuorumAuthLearner {\n+\n+    /**\n+     * Performs an authentication step for the given socket connection.\n+     *\n+     * @param sock\n+     *            socket connection to other quorum peer server\n+     * @param hostname\n+     *            host name of other quorum peer server\n+     * @throws IOException\n+     *             if there is an authentication failure\n+     */\n+    public void authenticate(Socket sock, String hostname) throws IOException;\n+}"
        },
        {
            "sha": "e9de8f00a5a8d1cbf37d4129f7727b718793539d",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuthServer.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+\n+/**\n+ * Interface for quorum server authentication mechanisms.\n+ */\n+public interface QuorumAuthServer {\n+\n+    /**\n+     * Performs an authentication step for the given socket connection.\n+     *\n+     * @param sock\n+     *            socket connection to other quorum peer\n+     * @param din\n+     *            stream used to read auth data send by the quorum learner\n+     * @throws IOException if the server fails to authenticate connecting quorum learner\n+     */\n+    public void authenticate(Socket sock, DataInputStream din)\n+            throws IOException;\n+}"
        },
        {
            "sha": "fffb55ac496ed89da6d7794e58f6565d01060ab2",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumAuthLearner.java",
            "status": "added",
            "additions": 230,
            "deletions": 0,
            "changes": 230,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,230 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.jute.BinaryInputArchive;\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+import org.apache.zookeeper.util.SecurityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SaslQuorumAuthLearner implements QuorumAuthLearner {\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(SaslQuorumAuthLearner.class);\n+\n+    private final Login learnerLogin;\n+    private final boolean quorumRequireSasl;\n+    private final String quorumServicePrincipal;\n+\n+    public SaslQuorumAuthLearner(boolean quorumRequireSasl,\n+            String quorumServicePrincipal, String loginContext)\n+                    throws SaslException {\n+        this.quorumRequireSasl = quorumRequireSasl;\n+        this.quorumServicePrincipal = quorumServicePrincipal;\n+        try {\n+            AppConfigurationEntry entries[] = Configuration\n+                .getConfiguration()\n+                .getAppConfigurationEntry(loginContext);\n+            if (entries == null || entries.length == 0) {\n+                throw new LoginException(\"SASL-authentication failed because\"\n+                                         + \" the specified JAAS configuration \"\n+                                         + \"section '\" + loginContext\n+                                         + \"' could not be found.\");\n+            }\n+            this.learnerLogin = new Login(loginContext,\n+                                    new SaslClientCallbackHandler(null, \"QuorumLearner\"));\n+            this.learnerLogin.startThreadIfNeeded();\n+        } catch (LoginException e) {\n+            throw new SaslException(\"Failed to initialize authentication mechanism using SASL\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void authenticate(Socket sock, String hostName) throws IOException {\n+        if (!quorumRequireSasl) { // let it through, we don't require auth\n+            LOG.info(\"Skipping SASL authentication as {}={}\",\n+                    QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED,\n+                    quorumRequireSasl);\n+            return;\n+        }\n+        SaslClient sc = null;\n+        String principalConfig = SecurityUtils\n+                .getServerPrincipal(quorumServicePrincipal, hostName);\n+        try {\n+            DataOutputStream dout = new DataOutputStream(\n+                    sock.getOutputStream());\n+            DataInputStream din = new DataInputStream(sock.getInputStream());\n+            byte[] responseToken = new byte[0];\n+            sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(),\n+                    principalConfig,\n+                    QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME,\n+                    QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, \"QuorumLearner\");\n+\n+            if (sc.hasInitialResponse()) {\n+                responseToken = createSaslToken(new byte[0], sc, learnerLogin);\n+            }\n+            send(dout, responseToken);\n+            QuorumAuthPacket authPacket = receive(din);\n+            QuorumAuth.Status qpStatus = QuorumAuth.Status\n+                    .getStatus(authPacket.getStatus());\n+            while (!sc.isComplete()) {\n+                switch (qpStatus) {\n+                case SUCCESS:\n+                    responseToken = createSaslToken(authPacket.getToken(), sc,\n+                            learnerLogin);\n+                    // we're done; don't expect to send another BIND\n+                    if (responseToken != null) {\n+                        throw new SaslException(\"Protocol error: attempting to send response after completion\");\n+                    }\n+                    break;\n+                case IN_PROGRESS:\n+                    responseToken = createSaslToken(authPacket.getToken(), sc,\n+                            learnerLogin);\n+                    send(dout, responseToken);\n+                    authPacket = receive(din);\n+                    qpStatus = QuorumAuth.Status\n+                            .getStatus(authPacket.getStatus());\n+                    break;\n+                case ERROR:\n+                    throw new SaslException(\n+                            \"Authentication failed against server addr: \"\n+                                    + sock.getRemoteSocketAddress());\n+                default:\n+                    LOG.warn(\"Unknown status:{}!\", qpStatus);\n+                    throw new SaslException(\n+                            \"Authentication failed against server addr: \"\n+                                    + sock.getRemoteSocketAddress());\n+                }\n+            }\n+\n+            // Validate status code at the end of authentication exchange.\n+            checkAuthStatus(sock, qpStatus);\n+        } finally {\n+            if (sc != null) {\n+                try {\n+                    sc.dispose();\n+                } catch (SaslException e) {\n+                    LOG.error(\"SaslClient dispose() failed\", e);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    private void checkAuthStatus(Socket sock, QuorumAuth.Status qpStatus)\n+            throws SaslException {\n+        if (qpStatus == QuorumAuth.Status.SUCCESS) {\n+            LOG.info(\"Successfully completed the authentication using SASL. server addr: {}, status: {}\",\n+                    sock.getRemoteSocketAddress(), qpStatus);\n+        } else {\n+            throw new SaslException(\"Authentication failed against server addr: \"\n+                            + sock.getRemoteSocketAddress() + \", qpStatus: \"\n+                            + qpStatus);\n+        }\n+    }\n+\n+    private QuorumAuthPacket receive(DataInputStream din) throws IOException {\n+        QuorumAuthPacket authPacket = new QuorumAuthPacket();\n+        BinaryInputArchive bia = BinaryInputArchive.getArchive(din);\n+        authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        return authPacket;\n+    }\n+\n+    private void send(DataOutputStream dout, byte[] response)\n+            throws IOException {\n+        QuorumAuthPacket authPacket;\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        if (response != null && response.length < 0) {\n+            throw new IOException(\"Response length < 0\");\n+        } else if (response == null) {\n+            authPacket = QuorumAuth.createPacket(\n+                    QuorumAuth.Status.IN_PROGRESS, response);\n+        } else {\n+            authPacket = QuorumAuth.createPacket(\n+                    QuorumAuth.Status.IN_PROGRESS, response);\n+        }\n+\n+        boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        bufferedOutput.flush();\n+    }\n+\n+    // TODO: need to consolidate the #createSaslToken() implementation between ZooKeeperSaslClient#createSaslToken().\n+    private byte[] createSaslToken(final byte[] saslToken,\n+            final SaslClient saslClient, final Login login)\n+                    throws SaslException {\n+        if (saslToken == null) {\n+            throw new SaslException(\n+                    \"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n+        }\n+        if (login.getSubject() != null) {\n+            synchronized (login) {\n+                try {\n+                    final byte[] retval = Subject.doAs(login.getSubject(),\n+                            new PrivilegedExceptionAction<byte[]>() {\n+                                public byte[] run() throws SaslException {\n+                                    LOG.debug(\"saslClient.evaluateChallenge(len=\"\n+                                                    + saslToken.length + \")\");\n+                                    return saslClient.evaluateChallenge(saslToken);\n+                                }\n+                            });\n+                    return retval;\n+                } catch (PrivilegedActionException e) {\n+                    String error = \"An error: (\" + e\n+                            + \") occurred when evaluating Zookeeper Quorum Member's \"\n+                            + \" received SASL token.\";\n+                    // Try to provide hints to use about what went wrong so they\n+                    // can fix their configuration.\n+                    // TODO: introspect about e: look for GSS information.\n+                    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n+                    if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n+                        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\"\n+                                + \" hostname correctly. You may want to try to adding\"\n+                                + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n+                    }\n+                    LOG.error(error);\n+                    throw new SaslException(error);\n+                }\n+            }\n+        } else {\n+            throw new SaslException(\n+                    \"Cannot make SASL token without subject defined. \"\n+                            + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n+        }\n+    }\n+}"
        },
        {
            "sha": "8430da20deda927c91727932265e9fc4bf667ccc",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumAuthServer.java",
            "status": "added",
            "additions": 180,
            "deletions": 0,
            "changes": 180,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,180 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.util.Set;\n+\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+\n+import org.apache.jute.BinaryInputArchive;\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+import org.apache.zookeeper.util.SecurityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SaslQuorumAuthServer implements QuorumAuthServer {\n+\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(SaslQuorumAuthServer.class);\n+\n+    private final static int MAX_RETRIES = 5;\n+    private final Login serverLogin;\n+    private final boolean quorumRequireSasl;\n+\n+    public SaslQuorumAuthServer(boolean quorumRequireSasl, String loginContext, Set<String> authzHosts)\n+            throws SaslException {\n+        this.quorumRequireSasl = quorumRequireSasl;\n+        try {\n+            AppConfigurationEntry entries[] = Configuration.getConfiguration()\n+                    .getAppConfigurationEntry(loginContext);\n+            if (entries == null || entries.length == 0) {\n+                throw new LoginException(\"SASL-authentication failed\"\n+                        + \" because the specified JAAS configuration \"\n+                        + \"section '\" + loginContext + \"' could not be found.\");\n+            }\n+            SaslQuorumServerCallbackHandler saslServerCallbackHandler = new SaslQuorumServerCallbackHandler(\n+                    Configuration.getConfiguration(), loginContext, authzHosts);\n+            serverLogin = new Login(loginContext, saslServerCallbackHandler);\n+            serverLogin.startThreadIfNeeded();\n+        } catch (Throwable e) {\n+            throw new SaslException(\n+                    \"Failed to initialize authentication mechanism using SASL\",\n+                    e);\n+        }\n+    }\n+\n+    @Override\n+    public void authenticate(Socket sock, DataInputStream din)\n+            throws SaslException {\n+        DataOutputStream dout = null;\n+        SaslServer ss = null;\n+        try {\n+            if (!QuorumAuth.nextPacketIsAuth(din)) {\n+                if (quorumRequireSasl) {\n+                    throw new SaslException(\"Learner not trying to authenticate\"\n+                                            + \" and authentication is required\");\n+                } else {\n+                    // let it through, we don't require auth\n+                    return;\n+                }\n+            }\n+\n+            byte[] token = receive(din);\n+            int tries = 0;\n+            dout = new DataOutputStream(sock.getOutputStream());\n+            byte[] challenge = null;\n+            ss = SecurityUtils.createSaslServer(serverLogin.getSubject(),\n+                    QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME,\n+                    QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler,\n+                    LOG);\n+            while (!ss.isComplete()) {\n+                challenge = ss.evaluateResponse(token);\n+                if (!ss.isComplete()) {\n+                    // limited number of retries.\n+                    if (++tries > MAX_RETRIES) {\n+                        send(dout, challenge, QuorumAuth.Status.ERROR);\n+                        LOG.warn(\"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\",\n+                                sock.getRemoteSocketAddress(), tries);\n+                        break;\n+                    }\n+                    send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n+                    token = receive(din);\n+                }\n+            }\n+            // Authentication exchange has completed\n+            if (ss.isComplete()) {\n+                send(dout, challenge, QuorumAuth.Status.SUCCESS);\n+                LOG.info(\"Successfully completed the authentication using SASL. learner addr: {}\",\n+                        sock.getRemoteSocketAddress());\n+            }\n+        } catch (Exception e) {\n+            try {\n+                if (dout != null) {\n+                    // send error message to the learner\n+                    send(dout, new byte[0], QuorumAuth.Status.ERROR);\n+                }\n+            } catch (IOException ioe) {\n+                LOG.warn(\"Exception while sending failed status\", ioe);\n+            }\n+            // If sasl is not required, when a server initializes a\n+            // connection it will try to log in, but it will also\n+            // accept connections that do not start with a sasl\n+            // handshake.\n+            if (quorumRequireSasl) {\n+                LOG.error(\"Failed to authenticate using SASL\", e);\n+                throw new SaslException(\n+                        \"Failed to authenticate using SASL: \" + e.getMessage());\n+            } else {\n+                LOG.warn(\"Failed to authenticate using SASL\", e);\n+                LOG.warn(\"Maintaining learner connection despite SASL authentication failure.\"\n+                                + \" server addr: {}, {}: {}\",\n+                        new Object[] { sock.getRemoteSocketAddress(),\n+                                QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED,\n+                                quorumRequireSasl });\n+                return; // let it through, we don't require auth\n+            }\n+        } finally {\n+            if (ss != null) {\n+                try {\n+                    ss.dispose();\n+                } catch (SaslException e) {\n+                    LOG.error(\"SaslServer dispose() failed\", e);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    private byte[] receive(DataInputStream din) throws IOException {\n+        QuorumAuthPacket authPacket = new QuorumAuthPacket();\n+        BinaryInputArchive bia = BinaryInputArchive.getArchive(din);\n+        authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        return authPacket.getToken();\n+    }\n+\n+    private void send(DataOutputStream dout, byte[] challenge,\n+            QuorumAuth.Status s) throws IOException {\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        QuorumAuthPacket authPacket;\n+        if (challenge != null && challenge.length < 0) {\n+            throw new IOException(\"Response length < 0\");\n+        } else if (challenge == null && s != QuorumAuth.Status.SUCCESS) {\n+            authPacket = QuorumAuth.createPacket(\n+                    QuorumAuth.Status.IN_PROGRESS, challenge);\n+        } else {\n+            authPacket = QuorumAuth.createPacket(s, challenge);\n+        }\n+\n+        boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        bufferedOutput.flush();\n+    }\n+}"
        },
        {
            "sha": "3e71bb1774b0209ffc508c1da099d8dae708917b",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumServerCallbackHandler.java",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is used by the SASL mechanisms to get further information to complete\n+ * the authentication. For example, a SASL mechanism might use this callback\n+ * handler to do verification operation. This is used by the QuorumServer to\n+ * perform the mutual quorum peer authentication.\n+ */\n+public class SaslQuorumServerCallbackHandler implements CallbackHandler {\n+    private static final String USER_PREFIX = \"user_\";\n+    private static final Logger LOG = LoggerFactory.getLogger(SaslQuorumServerCallbackHandler.class);\n+\n+    private String userName;\n+    private final Map<String,String> credentials = new HashMap<String,String>();\n+    private final Set<String> authzHosts;\n+\n+    public SaslQuorumServerCallbackHandler(Configuration configuration,\n+            String serverSection, Set<String> authzHosts) throws IOException {\n+        AppConfigurationEntry configurationEntries[] = configuration.getAppConfigurationEntry(serverSection);\n+\n+        if (configurationEntries == null) {\n+            String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n+            LOG.error(errorMessage);\n+            throw new IOException(errorMessage);\n+        }\n+        credentials.clear();\n+        for(AppConfigurationEntry entry: configurationEntries) {\n+            Map<String,?> options = entry.getOptions();\n+            // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"QuorumServer\" section.\n+            // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n+            for(Map.Entry<String, ?> pair : options.entrySet()) {\n+                String key = pair.getKey();\n+                if (key.startsWith(USER_PREFIX)) {\n+                    String userName = key.substring(USER_PREFIX.length());\n+                    credentials.put(userName,(String)pair.getValue());\n+                }\n+            }\n+        }\n+\n+        // authorized host lists\n+        this.authzHosts = authzHosts;\n+    }\n+\n+    public void handle(Callback[] callbacks) throws UnsupportedCallbackException {\n+        for (Callback callback : callbacks) {\n+            if (callback instanceof NameCallback) {\n+                handleNameCallback((NameCallback) callback);\n+            } else if (callback instanceof PasswordCallback) {\n+                handlePasswordCallback((PasswordCallback) callback);\n+            } else if (callback instanceof RealmCallback) {\n+                handleRealmCallback((RealmCallback) callback);\n+            } else if (callback instanceof AuthorizeCallback) {\n+                handleAuthorizeCallback((AuthorizeCallback) callback);\n+            }\n+        }\n+    }\n+\n+    private void handleNameCallback(NameCallback nc) {\n+        // check to see if this user is in the user password database.\n+        if (credentials.get(nc.getDefaultName()) == null) {\n+            LOG.warn(\"User '{}' not found in list of DIGEST-MD5 authenticateable users.\",\n+                    nc.getDefaultName());\n+            return;\n+        }\n+        nc.setName(nc.getDefaultName());\n+        userName = nc.getDefaultName();\n+    }\n+\n+    private void handlePasswordCallback(PasswordCallback pc) {\n+        if (credentials.containsKey(userName) ) {\n+            pc.setPassword(credentials.get(userName).toCharArray());\n+        } else {\n+            LOG.warn(\"No password found for user: {}\", userName);\n+        }\n+    }\n+\n+    private void handleRealmCallback(RealmCallback rc) {\n+        LOG.debug(\"QuorumLearner supplied realm: {}\", rc.getDefaultText());\n+        rc.setText(rc.getDefaultText());\n+    }\n+\n+    private void handleAuthorizeCallback(AuthorizeCallback ac) {\n+        String authenticationID = ac.getAuthenticationID();\n+        String authorizationID = ac.getAuthorizationID();\n+\n+        boolean authzFlag = false;\n+        // 1. Matches authenticationID and authorizationID\n+        authzFlag = authenticationID.equals(authorizationID);\n+\n+        // 2. Verify whether the connecting host is present in authorized hosts.\n+        // If not exists, then connecting peer is not authorized to join the\n+        // ensemble and will reject it.\n+        if (authzFlag) {\n+            String[] components = authorizationID.split(\"[/@]\");\n+            if (components.length == 3) {\n+                authzFlag = authzHosts.contains(components[1]);\n+            }\n+            if (!authzFlag) {\n+                LOG.error(\"SASL authorization completed, {} is not authorized to connect\",\n+                        components[1]);\n+            }\n+        }\n+\n+        // Sets authorization flag\n+        ac.setAuthorized(authzFlag);\n+        if (ac.isAuthorized()) {\n+            ac.setAuthorizedID(authorizationID);\n+            LOG.info(\"Successfully authenticated learner: authenticationID={};  authorizationID={}.\",\n+                    authenticationID, authorizationID);\n+        }\n+        LOG.debug(\"SASL authorization completed, authorized flag set to {}\", ac.isAuthorized());\n+    }\n+}"
        },
        {
            "sha": "67484e4e03fac588a7a5bb34f33b37bac44f3c97",
            "filename": "src/java/main/org/apache/zookeeper/util/SecurityUtils.java",
            "status": "added",
            "additions": 298,
            "deletions": 0,
            "changes": 298,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.util;\n+\n+import java.security.Principal;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n+import org.apache.zookeeper.server.auth.KerberosName;\n+import org.ietf.jgss.GSSContext;\n+import org.ietf.jgss.GSSCredential;\n+import org.ietf.jgss.GSSException;\n+import org.ietf.jgss.GSSManager;\n+import org.ietf.jgss.GSSName;\n+import org.ietf.jgss.Oid;\n+import org.slf4j.Logger;\n+\n+public final class SecurityUtils {\n+\n+    public static final String QUORUM_HOSTNAME_PATTERN = \"_HOST\";\n+\n+    /**\n+     * Create an instance of a SaslClient. It will return null if there is an exception.\n+     *\n+     * @param subject subject\n+     * @param servicePrincipal principal\n+     * @param protocol name of the protocol for which the authentication is being performed\n+     * @param serverName name of the server to authenticate to\n+     * @param LOG logger\n+     * @param entity can be either zookeeper client or quorum learner\n+     *\n+     * @return saslclient object\n+     * @throws SaslException\n+     */\n+    public static SaslClient createSaslClient(final Subject subject,\n+            final String servicePrincipal, final String protocol,\n+            final String serverName, final Logger LOG, final String entity) throws SaslException {\n+        SaslClient saslClient;\n+        // Use subject.getPrincipals().isEmpty() as an indication of which SASL\n+        // mechanism to use: if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n+        if (subject.getPrincipals().isEmpty()) {\n+            // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n+            // instead.\n+            LOG.info(\"{} will use DIGEST-MD5 as SASL mechanism.\", entity);\n+            String[] mechs = { \"DIGEST-MD5\" };\n+            String username = (String) (subject.getPublicCredentials()\n+                    .toArray()[0]);\n+            String password = (String) (subject.getPrivateCredentials()\n+                    .toArray()[0]);\n+            // 'domain' parameter is hard-wired between the server and client\n+            saslClient = Sasl.createSaslClient(mechs, username, protocol,\n+                    serverName, null, new SaslClientCallbackHandler(password, entity));\n+            return saslClient;\n+        } else { // GSSAPI.\n+            final Object[] principals = subject.getPrincipals().toArray();\n+            // determine client principal from subject.\n+            final Principal clientPrincipal = (Principal) principals[0];\n+            boolean usingNativeJgss = Boolean\n+                    .getBoolean(\"sun.security.jgss.native\");\n+            if (usingNativeJgss) {\n+                // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n+                // \"\"\"\n+                // In addition, when performing operations as a particular\n+                // Subject, e.g. Subject.doAs(...) or\n+                // Subject.doAsPrivileged(...),\n+                // the to-be-used GSSCredential should be added to Subject's\n+                // private credential set. Otherwise, the GSS operations will\n+                // fail since no credential is found.\n+                // \"\"\"\n+                try {\n+                    GSSManager manager = GSSManager.getInstance();\n+                    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n+                    GSSCredential cred = manager.createCredential(null,\n+                            GSSContext.DEFAULT_LIFETIME, krb5Mechanism,\n+                            GSSCredential.INITIATE_ONLY);\n+                    subject.getPrivateCredentials().add(cred);\n+                    LOG.debug(\"Added private credential to {} principal name: '{}'\",\n+                            entity, clientPrincipal);\n+                } catch (GSSException ex) {\n+                    LOG.warn(\"Cannot add private credential to subject; \"\n+                                    + \"authentication at the server may fail\", ex);\n+                }\n+            }\n+            final KerberosName clientKerberosName = new KerberosName(\n+                    clientPrincipal.getName());\n+            // assume that server and client are in the same realm (by default;\n+            // unless the system property\n+            // \"zookeeper.server.realm\" is set).\n+            String serverRealm = System.getProperty(\"zookeeper.server.realm\",\n+                    clientKerberosName.getRealm());\n+            KerberosName serviceKerberosName = new KerberosName(\n+                    servicePrincipal + \"@\" + serverRealm);\n+            final String serviceName = serviceKerberosName.getServiceName();\n+            final String serviceHostname = serviceKerberosName.getHostName();\n+            final String clientPrincipalName = clientKerberosName.toString();\n+            try {\n+                saslClient = Subject.doAs(subject,\n+                        new PrivilegedExceptionAction<SaslClient>() {\n+                            public SaslClient run() throws SaslException {\n+                                LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n+                                String[] mechs = { \"GSSAPI\" };\n+                                LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\",\n+                                        new Object[] { entity, clientPrincipalName, serviceName, serviceHostname });\n+                                SaslClient saslClient = Sasl.createSaslClient(\n+                                        mechs, clientPrincipalName, serviceName,\n+                                        serviceHostname, null,\n+                                        new SaslClientCallbackHandler(null, entity));\n+                                return saslClient;\n+                            }\n+                        });\n+                return saslClient;\n+            } catch (Exception e) {\n+                LOG.error(\"Exception while trying to create SASL client\", e);\n+                return null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an instance of a SaslServer. It will return null if there is an exception.\n+     *\n+     * @param subject subject\n+     * @param protocol protocol\n+     * @param serverName server name\n+     * @param callbackHandler login callback handler\n+     * @param LOG logger\n+     * @return sasl server object\n+     */\n+    public static SaslServer createSaslServer(final Subject subject,\n+            final String protocol, final String serverName,\n+            final CallbackHandler callbackHandler, final Logger LOG) {\n+        if (subject != null) {\n+            // server is using a JAAS-authenticated subject: determine service\n+            // principal name and hostname from zk server's subject.\n+            if (subject.getPrincipals().size() > 0) {\n+                try {\n+                    final Object[] principals = subject.getPrincipals()\n+                            .toArray();\n+                    final Principal servicePrincipal = (Principal) principals[0];\n+\n+                    // e.g. servicePrincipalNameAndHostname :=\n+                    // \"zookeeper/myhost.foo.com@FOO.COM\"\n+                    final String servicePrincipalNameAndHostname = servicePrincipal\n+                            .getName();\n+\n+                    int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n+\n+                    // e.g. servicePrincipalName := \"zookeeper\"\n+                    final String servicePrincipalName = servicePrincipalNameAndHostname\n+                            .substring(0, indexOf);\n+\n+                    // e.g. serviceHostnameAndKerbDomain :=\n+                    // \"myhost.foo.com@FOO.COM\"\n+                    final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname\n+                            .substring(indexOf + 1,\n+                                    servicePrincipalNameAndHostname.length());\n+\n+                    indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n+                    // e.g. serviceHostname := \"myhost.foo.com\"\n+                    final String serviceHostname = serviceHostnameAndKerbDomain\n+                            .substring(0, indexOf);\n+\n+                    // TODO: should depend on zoo.cfg specified mechs, but if\n+                    // subject is non-null, it can be assumed to be GSSAPI.\n+                    final String mech = \"GSSAPI\";\n+\n+                    LOG.debug(\"serviceHostname is '\" + serviceHostname + \"'\");\n+                    LOG.debug(\"servicePrincipalName is '\" + servicePrincipalName\n+                            + \"'\");\n+                    LOG.debug(\"SASL mechanism(mech) is '\" + mech + \"'\");\n+\n+                    boolean usingNativeJgss = Boolean\n+                            .getBoolean(\"sun.security.jgss.native\");\n+                    if (usingNativeJgss) {\n+                        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n+                        // \"\"\"\n+                        // In addition, when performing operations as a\n+                        // particular\n+                        // Subject, e.g. Subject.doAs(...) or\n+                        // Subject.doAsPrivileged(...), the to-be-used\n+                        // GSSCredential should be added to Subject's\n+                        // private credential set. Otherwise, the GSS operations\n+                        // will fail since no credential is found.\n+                        // \"\"\"\n+                        try {\n+                            GSSManager manager = GSSManager.getInstance();\n+                            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n+                            GSSName gssName = manager.createName(\n+                                    servicePrincipalName + \"@\"\n+                                            + serviceHostname,\n+                                    GSSName.NT_HOSTBASED_SERVICE);\n+                            GSSCredential cred = manager.createCredential(\n+                                    gssName, GSSContext.DEFAULT_LIFETIME,\n+                                    krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n+                            subject.getPrivateCredentials().add(cred);\n+                            LOG.debug(\"Added private credential to service principal name: '{}',\"\n+                                            + \" GSSCredential name: {}\", servicePrincipalName, cred.getName());\n+                        } catch (GSSException ex) {\n+                            LOG.warn(\"Cannot add private credential to subject; \"\n+                                            + \"clients authentication may fail\", ex);\n+                        }\n+                    }\n+                    try {\n+                        return Subject.doAs(subject,\n+                                new PrivilegedExceptionAction<SaslServer>() {\n+                                    public SaslServer run() {\n+                                        try {\n+                                            SaslServer saslServer;\n+                                            saslServer = Sasl.createSaslServer(\n+                                                    mech, servicePrincipalName,\n+                                                    serviceHostname, null,\n+                                                    callbackHandler);\n+                                            return saslServer;\n+                                        } catch (SaslException e) {\n+                                            LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: \", e);\n+                                            return null;\n+                                        }\n+                                    }\n+                                });\n+                    } catch (PrivilegedActionException e) {\n+                        // TODO: exit server at this point(?)\n+                        LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context:\", e);\n+                    }\n+                } catch (IndexOutOfBoundsException e) {\n+                    LOG.error(\"server principal name/hostname determination error: \", e);\n+                }\n+            } else {\n+                // JAAS non-GSSAPI authentication: assuming and supporting only\n+                // DIGEST-MD5 mechanism for now.\n+                // TODO: use 'authMech=' value in zoo.cfg.\n+                try {\n+                    SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\",\n+                            protocol, serverName, null, callbackHandler);\n+                    return saslServer;\n+                } catch (SaslException e) {\n+                    LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert Kerberos principal name pattern to valid Kerberos principal name.\n+     * If the principal name contains hostname pattern \"_HOST\" then it replaces\n+     * with the given hostname, which should be fully-qualified domain name.\n+     *\n+     * @param principalConfig\n+     *            the Kerberos principal name conf value to convert\n+     * @param hostname\n+     *            the fully-qualified domain name used for substitution\n+     * @return converted Kerberos principal name\n+     */\n+    public static String getServerPrincipal(String principalConfig,\n+            String hostname) {\n+        String[] components = getComponents(principalConfig);\n+        if (components == null || components.length != 2\n+                || !components[1].equals(QUORUM_HOSTNAME_PATTERN)) {\n+            return principalConfig;\n+        } else {\n+            return replacePattern(components, hostname);\n+        }\n+    }\n+\n+    private static String[] getComponents(String principalConfig) {\n+        if (principalConfig == null)\n+            return null;\n+        return principalConfig.split(\"[/]\");\n+    }\n+\n+    private static String replacePattern(String[] components, String hostname) {\n+        return components[0] + \"/\" + hostname.toLowerCase();\n+    }\n+}"
        },
        {
            "sha": "43ec7c4c4e9e2687e21218f752c9b25a3cf699e2",
            "filename": "src/java/test/data/kerberos/minikdc-krb5.conf",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,30 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+# This resource is originally from HDFS, see the similarly named files there\n+# in case of bug fixing, history, etc.\n+# Branch : trunk\n+# Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+#\n+[libdefaults]\n+    default_realm = {0}\n+    udp_preference_limit = 1\n+\n+[realms]\n+    {0} = '{'\n+        kdc = {1}:{2}\n+    '}'\n\\ No newline at end of file"
        },
        {
            "sha": "20c8d7759ae52a24a9f5b2213794f40e9ac98302",
            "filename": "src/java/test/data/kerberos/minikdc.ldiff",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,52 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+# This resource is originally from HDFS, see the similarly named files there\n+# in case of bug fixing, history, etc.\n+# Branch : trunk\n+# Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+#\n+dn: ou=users,dc=${0},dc=${1}\n+objectClass: organizationalUnit\n+objectClass: top\n+ou: users\n+\n+dn: uid=krbtgt,ou=users,dc=${0},dc=${1}\n+objectClass: top\n+objectClass: person\n+objectClass: inetOrgPerson\n+objectClass: krb5principal\n+objectClass: krb5kdcentry\n+cn: KDC Service\n+sn: Service\n+uid: krbtgt\n+userPassword: secret\n+krb5PrincipalName: krbtgt/${2}.${3}@${2}.${3}\n+krb5KeyVersionNumber: 0\n+\n+dn: uid=ldap,ou=users,dc=${0},dc=${1}\n+objectClass: top\n+objectClass: person\n+objectClass: inetOrgPerson\n+objectClass: krb5principal\n+objectClass: krb5kdcentry\n+cn: LDAP\n+sn: Service\n+uid: ldap\n+userPassword: secret\n+krb5PrincipalName: ldap/${4}@${2}.${3}\n+krb5KeyVersionNumber: 0\n\\ No newline at end of file"
        },
        {
            "sha": "a82a728e26e49f12f3263d6e7985cf5be3688d8d",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/CnxManagerTest.java",
            "status": "modified",
            "additions": 9,
            "deletions": 6,
            "changes": 15,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCnxManagerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCnxManagerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FCnxManagerTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -87,7 +87,7 @@ class CnxManagerThread extends Thread {\n         public void run(){\n             try {\n                 QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2);\n-                QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+                QuorumCnxManager cnxManager = peer.createCnxnManager();\n                 QuorumCnxManager.Listener listener = cnxManager.listener;\n                 if(listener != null){\n                     listener.start();\n@@ -131,7 +131,7 @@ public void testCnxManager() throws Exception {\n         thread.start();\n         \n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -175,7 +175,7 @@ public void testCnxManagerTimeout() throws Exception {\n         peerTmpdir[2] = ClientBase.createTmpDir();\n     \n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -202,7 +202,7 @@ public void testCnxManagerTimeout() throws Exception {\n     @Test\n     public void testCnxManagerSpinLock() throws Exception {               \n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -258,7 +258,10 @@ public void testCnxManagerSpinLock() throws Exception {\n     class TestCnxManager extends QuorumCnxManager {\n \n         TestCnxManager(QuorumPeer self) {\n-            super(self);\n+            super(self.getId(), self.getView(), self.authServer,\n+                    self.authLearner, self.tickTime * self.syncLimit,\n+                    self.getQuorumListenOnAllIPs(),\n+                    self.quorumCnxnThreadsSize, false);\n         }\n         \n         boolean senderWorkerMapContains(Long l){\n@@ -359,7 +362,7 @@ public void testCnxFromFutureVersion() throws Exception {\n     @Test\n     public void testSocketTimeout() throws Exception {\n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();"
        },
        {
            "sha": "c0ab3eaaf6d2bf6490da4553bf377bf0f0f6cab0",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -113,7 +113,7 @@ public void testBackwardElectionRound() throws Exception {\n          * Start mock server 1\n          */\n         QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2);\n-        cnxManagers[0] = new QuorumCnxManager(mockPeer);\n+        cnxManagers[0] = mockPeer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManagers[0].listener;\n         listener.start();\n \n@@ -124,7 +124,7 @@ public void testBackwardElectionRound() throws Exception {\n          * Start mock server 2\n          */\n         mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2);\n-        cnxManagers[1] = new QuorumCnxManager(mockPeer);\n+        cnxManagers[1] = mockPeer.createCnxnManager();\n         listener = cnxManagers[1].listener;\n         listener.start();\n "
        },
        {
            "sha": "f1c04cad763bd908f0a35049c0c18aa1c6c49190",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLECompatibilityTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLECompatibilityTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLECompatibilityTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLECompatibilityTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -288,7 +288,7 @@ public void testBackwardCompatibility()\n         \n         QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2);\n         peer.setPeerState(ServerState.LOOKING);\n-        QuorumCnxManager mng = new QuorumCnxManager(peer);\n+        QuorumCnxManager mng = peer.createCnxnManager();\n         \n         /*\n          * Check that it generates an internal notification correctly\n@@ -325,7 +325,7 @@ public void testForwardCompatibility()\n \n         QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2);\n         peer.setPeerState(ServerState.LOOKING);\n-        QuorumCnxManager mng = new QuorumCnxManager(peer);\n+        QuorumCnxManager mng = peer.createCnxnManager();\n         \n         /*\n          * Check that it generates an internal notification correctly"
        },
        {
            "sha": "3d4a02c2bad6cea414619acfcbbf7257fd1183d6",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLEDontCareTest.java",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEDontCareTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEDontCareTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEDontCareTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -90,7 +90,7 @@ public void tearDown(){\n \n     @Test\n     public void testDontCare() {\n-        MockFLE fle = new MockFLE(peer, new QuorumCnxManager(peer));\n+        MockFLE fle = new MockFLE(peer, peer.createCnxnManager());\n \n         HashMap<Long, Vote> votes = new HashMap<Long, Vote>();\n         votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 2, ServerState.FOLLOWING));\n@@ -104,7 +104,7 @@ public void testDontCare() {\n \n     @Test\n     public void testDontCareVersion() {\n-        MockFLE fle = new MockFLE(peer, new QuorumCnxManager(peer));\n+        MockFLE fle = new MockFLE(peer, peer.createCnxnManager());\n \n         HashMap<Long, Vote> votes = new HashMap<Long, Vote>();\n         votes.put(0L, new Vote(0x1, 4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.FOLLOWING));\n@@ -118,7 +118,7 @@ public void testDontCareVersion() {\n \n     @Test\n     public void testLookingNormal() {\n-        MockFLE fle = new MockFLE(peer, new QuorumCnxManager(peer));\n+        MockFLE fle = new MockFLE(peer, peer.createCnxnManager());\n \n         HashMap<Long, Vote> votes = new HashMap<Long, Vote>();\n         votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(2, 1), 1, 1, ServerState.LOOKING));\n@@ -132,7 +132,7 @@ public void testLookingNormal() {\n \n     @Test\n     public void testLookingDiffRounds() {\n-        MockFLE fle = new MockFLE(peer, new QuorumCnxManager(peer));\n+        MockFLE fle = new MockFLE(peer, peer.createCnxnManager());\n \n         HashMap<Long, Vote> votes = new HashMap<Long, Vote>();\n         votes.put(0L, new Vote(4L, ZxidUtils.makeZxid(1, 1), 1, 1, ServerState.LOOKING));\n@@ -188,7 +188,7 @@ FastLeaderElection.Notification genNotification(int version,\n \n     @Test\n     public void testOutofElection() {\n-        MockFLE fle = new MockFLE(peer, new QuorumCnxManager(peer));\n+        MockFLE fle = new MockFLE(peer, peer.createCnxnManager());\n         HashMap<Long,Vote> outofelection = new HashMap<Long,Vote>();\n \n         /*"
        },
        {
            "sha": "190785c4217537f508075796f57bcbeac8231977",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -101,7 +101,7 @@ void mockServer() throws InterruptedException, IOException {\n          * Create an instance of the connection manager\n          */\n         QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2);\n-        cnxManager = new QuorumCnxManager(peer);\n+        cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         listener.start();\n "
        },
        {
            "sha": "fd08d21339dc2beb28406d70e9e92ef320a3eb44",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/LearnerTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -69,8 +69,8 @@ public void startup() {\n \t}\n \tclass SimpleLearner extends Learner {\n \t\tSimpleLearner(FileTxnSnapLog ftsl) throws IOException {\n-\t\t\tself = new QuorumPeer();\n-\t\t\tzk = new SimpleLearnerZooKeeperServer(ftsl, self);\n+            self = QuorumPeer.testingQuorumPeer();\n+            zk = new SimpleLearnerZooKeeperServer(ftsl, self);\n \t\t\t((SimpleLearnerZooKeeperServer)zk).learner = this;\n \t\t}\n \t}"
        },
        {
            "sha": "6b6c0b4c3310fce0a11aa5b7dcdcc595b672bd21",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/QuorumCnxManagerTest.java",
            "status": "added",
            "additions": 925,
            "deletions": 0,
            "changes": 925,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManagerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManagerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManagerTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,925 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum;\n+\n+import java.io.BufferedInputStream;\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.File;\n+import java.io.FileNotFoundException;\n+import java.io.FileOutputStream;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.lang.reflect.Field;\n+import java.net.InetSocketAddress;\n+import java.net.ServerSocket;\n+import java.net.Socket;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.concurrent.CountDownLatch;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadPoolExecutor;\n+import java.util.concurrent.TimeUnit;\n+\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZKTestCase;\n+import org.apache.zookeeper.server.ServerCnxn;\n+import org.apache.zookeeper.server.ServerCnxnFactory;\n+import org.apache.zookeeper.server.ZKDatabase;\n+import org.apache.zookeeper.server.ZooKeeperServer;\n+import org.apache.zookeeper.server.persistence.FileTxnSnapLog;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuth;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class QuorumCnxManagerTest extends ZKTestCase {\n+    private static final Logger LOG = LoggerFactory.getLogger(QuorumCnxManagerTest.class);\n+    private int count;\n+    private HashMap<Long,QuorumServer> peers;\n+    private int peerQuorumPort[];\n+    private int peerClientPort[];\n+    private ThreadPoolExecutor executor;\n+    /**\n+     * The maximum number of threads to allow in the connectionExecutors thread\n+     * pool which will be used to initiate quorum server connections. Defaulting to 20.\n+     * TODO: Need to tune this param.\n+     */\n+    private final int quorumCnxnThreadsSize = 20;\n+    private Set<String> authzHosts;\n+\n+    private static File saslConfigFile = null;\n+\n+    @BeforeClass\n+    public static void setupSasl() throws Exception {\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       user_test=\\\"mypassword\\\";\\n\"\n+                + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"mypassword\\\";\\n\"\n+                + \"};\\n\"\n+                + \"QuorumLearnerInvalid {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"invalid\\\";\\n\"\n+                + \"};\\n\");\n+\n+        saslConfigFile = File.createTempFile(\"jaas.\", \".conf\");\n+        FileWriter fwriter = new FileWriter(saslConfigFile);\n+        fwriter.write(jaasEntries);\n+        fwriter.close();\n+        System.setProperty(\"java.security.auth.login.config\",\n+                           saslConfigFile.getAbsolutePath());\n+    }\n+\n+    @AfterClass\n+    public static void cleanupSasl() throws Exception {\n+        if (saslConfigFile != null) {\n+            saslConfigFile.delete();\n+        }\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        this.count = 3;\n+        this.peers = new HashMap<Long,QuorumServer>(count);\n+        peerQuorumPort = new int[count];\n+        peerClientPort = new int[count];\n+        authzHosts = new HashSet<String>();\n+        for(int i = 0; i < count; i++) {\n+            peerQuorumPort[i] = PortAssignment.unique();\n+            peerClientPort[i] = PortAssignment.unique();\n+            QuorumServer qs = new QuorumServer(i, \"0.0.0.0\",\n+                    peerQuorumPort[i], PortAssignment.unique(), null);\n+            peers.put(Long.valueOf(i), qs);\n+            authzHosts.add(qs.hostname);\n+        }\n+        executor = new ThreadPoolExecutor(3, 10,\n+                60, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        if (executor != null) {\n+            executor.shutdownNow();\n+        }\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testNoAuthConnection() throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0);\n+        QuorumCnxManager peer1 = createAndStartManager(1);\n+\n+        peer0.connectOne(1);\n+        assertEventuallyConnected(peer0, 1);\n+    }\n+\n+    @Test(timeout = 30000)\n+    public void testAuthConnection() throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0, \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        peer0.connectOne(1);\n+        assertEventuallyConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * Peer0 has no auth configured, Peer1 has auth configured.\n+     * Peer1 connects to peer0, because null auth server sees an auth packet and connection succeeds.\n+     * Peer0 connects to peer1, but connection isn't initiated because\n+     * peer0's sid is lower than peer1's\n+     */\n+    @Test(timeout = 30000)\n+    public void testClientAuthAgainstNoAuthServerWithLowerSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                                                       \"QuorumLearner\", false, false);\n+        peer1.connectOne(0);\n+        peer0.connectOne(1);\n+        assertEventuallyConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * Peer0 has auth configured, Peer1 has no auth configured.\n+     * Peer1 connects to peer0, but is disconnected, because peer1's sid is\n+     * higher than peer0.\n+     * Peer0 connects to peer1, but is disconnected, because peer1 cannot\n+     * handle auth.\n+     */\n+    @Test(timeout = 30000)\n+    public void testClientAuthAgainstNoAuthServerWithHigherSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0, \"QuorumServer\",\n+                                                       \"QuorumLearner\", false, false);\n+        QuorumCnxManager peer1 = createAndStartManager(1);\n+        peer0.connectOne(1);\n+        peer1.connectOne(0);\n+        assertEventuallyConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * No auth learner connects to a server that requires auth, when the server\n+     * has a higher sid.\n+     * The connection should fail in both directions.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoAuthLearnerConnectToAuthRequiredServerWithLowerSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0, \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        QuorumCnxManager peer1 = createAndStartManager(1);\n+        peer0.connectOne(1);\n+        peer1.connectOne(0);\n+        assertEventuallyNotConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * No auth learner connects to a server that requires auth, when the server\n+     * has a higher sid.\n+     * The connection should fail in both directions.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoAuthLearnerConnectToAuthRequiredServerWithHigherSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        peer0.connectOne(1);\n+        peer1.connectOne(0);\n+        assertEventuallyNotConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * An auth learner connects to a auth server, but the credentials are bad.\n+     * The peer with the higher sid has the bad credentials.\n+     * The connection will be denied.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerBadCredToAuthRequiredServerWithLowerSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0,  \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                                                       \"QuorumLearnerInvalid\", true, true);\n+        peer0.connectOne(1);\n+        peer1.connectOne(0);\n+\n+        assertEventuallyNotConnected(peer0, 1);\n+    }\n+\n+    /**\n+     * An auth learner connects to a auth server, but the credentials are bad.\n+     * The peer with the lower sid has the bad credentials.\n+     * The connection will work, because peer1 is connecting to peer0.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerBadCredToAuthRequiredServerWithHigherSid()\n+            throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0,  \"QuorumServer\",\n+                                                       \"QuorumLearnerInvalid\", true, true);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                                                       \"QuorumLearner\", true, true);\n+        peer0.connectOne(1);\n+        peer1.connectOne(0);\n+        assertEventuallyConnected(peer0, 1);\n+        assertEventuallyConnected(peer1, 0);\n+    }\n+\n+    /**\n+     * An auth learner connects to a auth server, but the credentials are bad.\n+     * The connection should fail in both directions.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerBadCredToNoAuthServerWithHigherSid() throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0, \"QuorumServer\",\n+                \"QuorumLearner\", false, false);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                \"QuorumLearnerInvalid\", true, true);\n+        peer1.connectOne(0);\n+        assertEventuallyNotConnected(peer1, 0);\n+    }\n+\n+    /**\n+     * An auth learner connects to a auth server, but the credentials are bad.\n+     * The peer with the lower sid has the bad credentials.\n+     * The connection will work, because peer0 is connecting to peer1 and peer1\n+     * server doesn't require sasl\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerBadCredToNoAuthServerWithLowerSid() throws Exception {\n+        QuorumCnxManager peer0 = createAndStartManager(0, \"QuorumServer\",\n+                \"QuorumLearnerInvalid\", true, true);\n+        QuorumCnxManager peer1 = createAndStartManager(1, \"QuorumServer\",\n+                \"QuorumLearner\", false, true);\n+        peer0.connectOne(1);\n+        assertEventuallyConnected(peer0, 1);\n+        assertEventuallyConnected(peer1, 0);\n+    }\n+\n+    /**\n+     * Test verifies that the LearnerHandler should authenticate the connecting\n+     * quorumpeer. Here its simulating authentication failure and it should throw\n+     * SaslException\n+     */\n+    @Test(timeout = 30000)\n+    public void testLearnerHandlerAuthFailed() throws Exception {\n+        File testData = ClientBase.createTmpDir();\n+        Socket leaderSocket = getSocketPair();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testData);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, true, false, true,\n+                \"QuorumLearner\", \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        leader = createLeader(tmpDir, peer);\n+        peer.leader = leader;\n+\n+        // authentication failed as qpserver didn't get auth packet from qpclient.\n+        try {\n+            new LearnerHandler(leaderSocket,\n+                    new BufferedInputStream(leaderSocket.getInputStream()), leader);\n+            Assert.fail(\"Must throw exception as there is an authentication failure\");\n+        } catch (SaslException e){\n+            Assert.assertEquals(\"Mistakely added to learners\", 0,\n+                    leader.getLearners().size());\n+        }\n+        ClientBase.recursiveDelete(testData);\n+    }\n+\n+    /**\n+     * Test verifies that the Leader should authenticate the connecting learner\n+     * quorumpeer. After the successful authentication it should add this\n+     * learner to the learnerHandler list.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerConnectsToServerWithAuthRequired()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, true, true,\n+                \"QuorumLearner\", \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, true, true, true, \"QuorumLearner\",\n+                \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+        String hostname = getLeaderHostname(peer);\n+        sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+        // wait till leader socket soTimeout period\n+        Assert.assertTrue(\"Leader should accept the auth learner connection\",\n+                learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 1000,\n+                        TimeUnit.MILLISECONDS));\n+        Assert.assertEquals(\"Failed to added the learner\", 1,\n+                leader.getLearners().size());\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    private String getLeaderHostname(QuorumPeer peer) {\n+        String hostname = null;\n+        for (QuorumServer p : peer.getView().values()) {\n+            if (p.id == peer.getId()) {\n+                hostname = p.hostname;\n+                break;\n+            }\n+        }\n+        Assert.assertNotNull(\"Didn't find leader\", hostname);\n+        return hostname;\n+    }\n+\n+    /**\n+     * Test verifies that the Leader should authenticate the connecting learner\n+     * quorumpeer. After the successful authentication it should add this\n+     * learner to the learnerHandler list.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerConnectsToServerWithAuthNotRequired()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, true, true,\n+                \"QuorumLearner\", \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, true, true, false, \"QuorumLearner\",\n+                \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+        String hostname = getLeaderHostname(peer);\n+        sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+        // wait till leader socket soTimeout period\n+        Assert.assertTrue(\"Leader should accept the auth learner connection\",\n+                learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 1000,\n+                        TimeUnit.MILLISECONDS));\n+        Assert.assertEquals(\"Failed to added the learner\", 1,\n+                leader.getLearners().size());\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    private void startLearnerCnxAcceptorThread(Leader leader)\n+            throws InterruptedException {\n+        final CountDownLatch cnxAcceptorWatcher = new CountDownLatch(1);\n+        leader.cnxAcceptor = leader.new LearnerCnxAcceptor(){\n+            @Override\n+            public void run() {\n+                cnxAcceptorWatcher.countDown();\n+                super.run();\n+            }\n+        };\n+        leader.cnxAcceptor.start();\n+        // waiting to start the thread\n+        Assert.assertTrue(\"Failed to start leader.cnxAcceptor thread!\",\n+                cnxAcceptorWatcher.await(15, TimeUnit.SECONDS));\n+        LOG.info(\"Started leader.cnxAcceptor:{} thread, state:{}\",\n+                leader.cnxAcceptor.getName(), leader.cnxAcceptor.getState());\n+    }\n+\n+    /**\n+     * Test verifies that the Auth enabled Learner is connecting to a Null Auth\n+     * Leader server. Learner is failing to get an auth response from Null Auth\n+     * Leader and fails the connection establishment.\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerConnectsToNullAuthServer()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, true, true,\n+                \"QuorumLearner\", \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, false, false, false,\n+                \"QuorumLearner\", \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+\n+        try {\n+            String hostname = getLeaderHostname(peer);\n+            sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+            Assert.fail(\"Must throw exception as server doesn't supports authentication\");\n+        } catch (IOException e) {\n+            // expected\n+            Assert.assertTrue(\"Leader should accept the auth learner connection\",\n+                    learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 500,\n+                            TimeUnit.MILLISECONDS));\n+        }\n+\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    /**\n+     * Test verifies that the No Auth enabled Learner is connecting to a No Auth\n+     * Leader server. Learner should be able to establish a connection with\n+     * Leader as auth is not required.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoAuthLearnerConnectsToServerWithAuthNotRequired()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, false, false,\n+                \"QuorumLearner\", \"QuorumServer\", \"\");\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, true, false, false, \"QuorumLearner\",\n+                \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+        String hostname = getLeaderHostname(peer);\n+        sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+\n+        Assert.assertTrue(\"Leader should accept no auth learner connection\",\n+                learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 1000,\n+                        TimeUnit.MILLISECONDS));\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    /**\n+     * Test verifies that the No Auth enabled Learner is connecting to a No Auth\n+     * Leader server. Learner shouldn't be able to establish a connection with\n+     * Leader as auth as auth is required.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoAuthLearnerConnectsToServerWithAuthRequired()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, false, false,\n+                \"QuorumLearner\", \"QuorumServer\", \"\");\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, true, true, true, \"QuorumLearner\",\n+                \"QuorumServer\",\n+                QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE);\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+        String hostname = getLeaderHostname(peer);\n+        sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+        Assert.assertFalse(\"Leader shouldn't accept no auth learner connection\",\n+                learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 1000,\n+                        TimeUnit.MILLISECONDS));\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    /**\n+     * Test verifies that the No Auth enabled Learner is connecting to a No Auth\n+     * Leader server. Learner should be able to establish a connection with\n+     * Leader as auth is not required.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNoAuthLearnerConnectsToNullAuthServer()\n+            throws Exception {\n+        File testDataLearner = ClientBase.createTmpDir();\n+        File tmpDir = File.createTempFile(\"test\", \".dir\", testDataLearner);\n+        tmpDir.delete();\n+        FileTxnSnapLog ftsl = new FileTxnSnapLog(tmpDir, tmpDir);\n+        QuorumPeer learnerPeer = createQuorumPeer(tmpDir, true, false, false,\n+                \"QuorumLearner\", \"QuorumServer\", \"\");\n+        SimpleLearner sl = new SimpleLearner(ftsl, learnerPeer);\n+\n+        File testDataLeader = ClientBase.createTmpDir();\n+        tmpDir = File.createTempFile(\"test\", \".dir\", testDataLeader);\n+        tmpDir.delete();\n+        tmpDir.mkdir();\n+        Leader leader = null;\n+        QuorumPeer peer = createQuorumPeer(tmpDir, false, false, false, \"\", \"\",\n+                \"\");\n+        CountDownLatch learnerLatch = new CountDownLatch(1);\n+        leader = createSimpleLeader(tmpDir, peer, learnerLatch);\n+        peer.leader = leader;\n+\n+        startLearnerCnxAcceptorThread(leader);\n+        LOG.info(\"Start establishing a connection with the Leader\");\n+        String hostname = getLeaderHostname(peer);\n+        sl.connectToLeader(peer.getQuorumAddress(), hostname);\n+\n+        Assert.assertTrue(\"Leader should accept no auth learner connection\",\n+                learnerLatch.await(leader.self.tickTime * leader.self.initLimit + 1000,\n+                        TimeUnit.MILLISECONDS));\n+        ClientBase.recursiveDelete(testDataLearner);\n+        ClientBase.recursiveDelete(testDataLeader);\n+    }\n+\n+    /**\n+     * SaslQuorumAuthServer throws exception on receiving an invalid quorum\n+     * auth packet.\n+     */\n+    @Test(timeout = 30000)\n+    public void testSaslQuorumAuthServerWithInvalidQuorumAuthPacket()\n+            throws Exception {\n+        Socket socket = getSocketPair();\n+        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        QuorumAuthPacket authPacket = QuorumAuth\n+                .createPacket(QuorumAuth.Status.IN_PROGRESS, null);\n+        authPacket.setMagic(Long.MAX_VALUE); // invalid magic number\n+        boa.writeRecord(authPacket, null);\n+        bufferedOutput.flush();\n+        QuorumAuthServer authServer = new SaslQuorumAuthServer(true,\n+                \"QuorumServer\", authzHosts);\n+        BufferedInputStream is = new BufferedInputStream(\n+                socket.getInputStream());\n+        try {\n+            authServer.authenticate(socket, new DataInputStream(is));\n+            Assert.fail(\"Must throw exception as QuorumAuthPacket is invalid\");\n+        } catch (SaslException e) {\n+            // expected\n+        }\n+    }\n+\n+    /**\n+     * NullQuorumAuthServer should return true when no auth quorum packet\n+     * received and timed out.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNullQuorumAuthServerShouldReturnTrue()\n+            throws Exception {\n+        Socket socket = getSocketPair();\n+        QuorumAuthServer authServer = new NullQuorumAuthServer();\n+        BufferedInputStream is = new BufferedInputStream(\n+                socket.getInputStream());\n+        // It will throw exception and fail the\n+        // test if any unexpected error. Not adding any extra assertion.\n+        authServer.authenticate(socket, new DataInputStream(is));\n+    }\n+\n+    /**\n+     * NullQuorumAuthServer should return true on receiving a valid quorum auth\n+     * packet.\n+     */\n+    @Test(timeout = 30000)\n+    public void testNullQuorumAuthServerWithValidQuorumAuthPacket()\n+            throws Exception {\n+        Socket socket = getSocketPair();\n+        DataOutputStream dout = new DataOutputStream(socket.getOutputStream());\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        QuorumAuthPacket authPacket = QuorumAuth\n+                .createPacket(QuorumAuth.Status.IN_PROGRESS, null);\n+        boa.writeRecord(authPacket, null);\n+        bufferedOutput.flush();\n+        QuorumAuthServer authServer = new NullQuorumAuthServer();\n+        BufferedInputStream is = new BufferedInputStream(\n+                socket.getInputStream());\n+        // It will throw exception and fail the\n+        // test if any unexpected error. Not adding any extra assertion.\n+        authServer.authenticate(socket, new DataInputStream(is));\n+    }\n+\n+    private QuorumCnxManager createAndStartManager(long sid) {\n+        QuorumCnxManager peer = new QuorumCnxManager(sid, peers,\n+                new NullQuorumAuthServer(), new NullQuorumAuthLearner(), 10000,\n+                false, quorumCnxnThreadsSize, false);\n+        executor.submit(peer.listener);\n+        InetSocketAddress electionAddr = peer.view.get(sid).electionAddr;\n+        waitForElectionAddrBinding(electionAddr, 15);\n+        return peer;\n+    }\n+\n+    private QuorumCnxManager createAndStartManager(long sid,\n+                                                   String serverLoginContext,\n+                                                   String learnerLoginContext,\n+                                                   boolean serverRequireSasl,\n+                                                   boolean learnerRequireSasl)\n+            throws Exception {\n+        QuorumAuthLearner authClient = new SaslQuorumAuthLearner(learnerRequireSasl,\n+                \"NOT_USING_KRB_PRINCIPAL\", learnerLoginContext);\n+        QuorumAuthServer authServer = new SaslQuorumAuthServer(serverRequireSasl,\n+                serverLoginContext, authzHosts);\n+        QuorumCnxManager peer = new QuorumCnxManager(sid, peers,\n+                authServer, authClient, 10000, false, quorumCnxnThreadsSize, true);\n+        executor.submit(peer.listener);\n+        InetSocketAddress electionAddr = peer.view.get(sid).electionAddr;\n+        waitForElectionAddrBinding(electionAddr, 15);\n+        return peer;\n+    }\n+\n+    private void waitForElectionAddrBinding(InetSocketAddress electionAddr,\n+            int retries) {\n+        boolean success = false;\n+        while (retries > 0) {\n+            Socket sock = new Socket();\n+            try {\n+                sock.setTcpNoDelay(true);\n+                sock.setSoTimeout(5000);\n+                sock.connect(electionAddr, 5000);\n+                success = true;\n+            } catch (IOException e) {\n+                LOG.error(\"IOException while checking election addr\", e);\n+            } finally {\n+                cleanup(sock);\n+            }\n+            try {\n+                Thread.sleep(500);\n+            } catch (InterruptedException e) {\n+                // ignore\n+            }\n+            retries--;\n+        }\n+        Assert.assertTrue(\"Did not connect to election port\", success);\n+    }\n+\n+    private void cleanup(Socket sock) {\n+        try {\n+            sock.close();\n+        } catch (IOException ie) {\n+            LOG.error(\"Exception while closing socket\", ie);\n+        }\n+    }\n+\n+    private void assertEventuallyConnected(QuorumCnxManager peer, long sid)\n+            throws Exception {\n+        for (int i = 0; i < 20 && !peer.connectedToPeer(sid); i++) {\n+            Thread.sleep(1000);\n+        }\n+        Assert.assertTrue(\"Not connected to peer\", peer.connectedToPeer(sid));\n+    }\n+\n+    private void assertEventuallyNotConnected(QuorumCnxManager peer, long sid)\n+            throws Exception {\n+        for (int i = 0; i < 3 && !peer.connectedToPeer(sid); i++) {\n+            Thread.sleep(1000);\n+        }\n+        Assert.assertFalse(\"Connected to peer (shouldn't be)\",\n+                           peer.connectedToPeer(sid));\n+    }\n+\n+    private QuorumPeer createQuorumPeer(File tmpDir,\n+            boolean isQuorumAuthEnabled, boolean isQuorumLearnerAuthRequired,\n+            boolean isQuorumServerAuthRequired, String quorumLearnerLoginContext,\n+            String quorumServerLoginContext, String quorumServicePrincipal)\n+                    throws IOException, FileNotFoundException {\n+        QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n+        peer.syncLimit = 2;\n+        peer.initLimit = 2;\n+        peer.tickTime = 2000;\n+        peer.quorumPeers = new HashMap<Long, QuorumServer>();\n+        peer.quorumPeers.put(0L,\n+                new QuorumServer(0, \"0.0.0.0\", PortAssignment.unique(), null, null));\n+        peer.quorumPeers.put(1L,\n+                new QuorumServer(1, \"0.0.0.0\", PortAssignment.unique(), null, null));\n+        peer.setQuorumVerifier(new QuorumMaj(3));\n+        peer.setCnxnFactory(new NullServerCnxnFactory());\n+        // auth\n+        if (isQuorumAuthEnabled) {\n+            peer.authServer = new SaslQuorumAuthServer(\n+                    isQuorumServerAuthRequired, quorumServerLoginContext, authzHosts);\n+            peer.authLearner = new SaslQuorumAuthLearner(\n+                    isQuorumLearnerAuthRequired, quorumServicePrincipal,\n+                    quorumLearnerLoginContext);\n+        }\n+        File version2 = new File(tmpDir, \"version-2\");\n+        version2.mkdir();\n+        FileOutputStream fos;\n+        fos = new FileOutputStream(new File(version2, \"currentEpoch\"));\n+        fos.write(\"0\\n\".getBytes());\n+        fos.close();\n+        fos = new FileOutputStream(new File(version2, \"acceptedEpoch\"));\n+        fos.write(\"0\\n\".getBytes());\n+        fos.close();\n+        return peer;\n+    }\n+\n+    private static final class NullServerCnxnFactory extends ServerCnxnFactory {\n+        public void startup(ZooKeeperServer zkServer)\n+                throws IOException, InterruptedException {\n+        }\n+\n+        public void start() {\n+        }\n+\n+        public void shutdown() {\n+        }\n+\n+        public void setMaxClientCnxnsPerHost(int max) {\n+        }\n+\n+        public void join() throws InterruptedException {\n+        }\n+\n+        public int getMaxClientCnxnsPerHost() {\n+            return 0;\n+        }\n+\n+        public int getLocalPort() {\n+            return 0;\n+        }\n+\n+        public InetSocketAddress getLocalAddress() {\n+            return null;\n+        }\n+\n+        public Iterable<ServerCnxn> getConnections() {\n+            return null;\n+        }\n+\n+        public void configure(InetSocketAddress addr, int maxClientCnxns)\n+                throws IOException {\n+        }\n+\n+        public void closeSession(long sessionId) {\n+        }\n+\n+        public void closeAll() {\n+        }\n+\n+        @Override\n+        public int getNumAliveConnections() {\n+            return 0;\n+        }\n+    }\n+\n+    private static Socket getSocketPair() throws IOException {\n+        ServerSocket ss = new ServerSocket();\n+        ss.bind(null);\n+        InetSocketAddress endPoint = (InetSocketAddress) ss\n+                .getLocalSocketAddress();\n+        Socket s = new Socket(endPoint.getAddress(), endPoint.getPort());\n+        s.setSoTimeout(5000);\n+        return s;\n+    }\n+\n+    private Leader createLeader(File tmpDir, QuorumPeer peer) throws IOException,\n+                    NoSuchFieldException, IllegalAccessException {\n+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);\n+        return new Leader(peer, zk);\n+    }\n+\n+    private Leader createSimpleLeader(File tmpDir, QuorumPeer peer,\n+            CountDownLatch learnerLatch) throws IOException,\n+                    NoSuchFieldException, IllegalAccessException {\n+        LeaderZooKeeperServer zk = prepareLeader(tmpDir, peer);\n+        return new SimpleLeader(peer, zk, learnerLatch);\n+    }\n+\n+    class SimpleLeader extends Leader {\n+        final CountDownLatch learnerLatch;\n+\n+        SimpleLeader(QuorumPeer self, LeaderZooKeeperServer zk,\n+                CountDownLatch latch) throws IOException {\n+            super(self, zk);\n+            this.learnerLatch = latch;\n+        }\n+\n+        @Override\n+        void addLearnerHandler(LearnerHandler learner) {\n+            super.addLearnerHandler(learner);\n+            learnerLatch.countDown();\n+        }\n+    }\n+\n+    private LeaderZooKeeperServer prepareLeader(File tmpDir, QuorumPeer peer)\n+            throws IOException, NoSuchFieldException, IllegalAccessException {\n+        FileTxnSnapLog logFactory = new FileTxnSnapLog(tmpDir, tmpDir);\n+        peer.setTxnFactory(logFactory);\n+        Field addrField = peer.getClass().getDeclaredField(\"myQuorumAddr\");\n+        addrField.setAccessible(true);\n+        addrField.set(peer, new InetSocketAddress(PortAssignment.unique()));\n+        ZKDatabase zkDb = new ZKDatabase(logFactory);\n+        LeaderZooKeeperServer zk = new LeaderZooKeeperServer(logFactory, peer,\n+                new ZooKeeperServer.BasicDataTreeBuilder(), zkDb);\n+        return zk;\n+    }\n+\n+    class SimpleLearnerZooKeeperServer extends LearnerZooKeeperServer {\n+        boolean startupCalled;\n+\n+        public SimpleLearnerZooKeeperServer(FileTxnSnapLog ftsl,\n+                QuorumPeer self) throws IOException {\n+            super(ftsl, 2000, 2000, 2000, null, new ZKDatabase(ftsl), self);\n+        }\n+\n+        Learner learner;\n+\n+        @Override\n+        public Learner getLearner() {\n+            return learner;\n+        }\n+\n+        @Override\n+        public void startup() {\n+            startupCalled = true;\n+        }\n+    }\n+\n+    class SimpleLearner extends Learner {\n+        SimpleLearner(FileTxnSnapLog ftsl, QuorumPeer learner)\n+                throws IOException {\n+            self = learner;\n+            zk = new SimpleLearnerZooKeeperServer(ftsl, self);\n+            ((SimpleLearnerZooKeeperServer) zk).learner = this;\n+        }\n+    }\n+}"
        },
        {
            "sha": "6d5eb47c45cabe6a628e5243b03c5131eb85ed34",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java",
            "status": "modified",
            "additions": 58,
            "deletions": 7,
            "changes": 65,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -24,6 +24,10 @@\n import java.io.File;\n import java.io.FileWriter;\n import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.concurrent.CountDownLatch;\n \n import org.apache.zookeeper.WatchedEvent;\n@@ -42,6 +46,8 @@ public class QuorumPeerTestBase extends ZKTestCase implements Watcher {\n     protected static final Logger LOG = LoggerFactory\n             .getLogger(QuorumPeerTestBase.class);\n \n+    public static final int TIMEOUT = 5000;\n+\n     public void process(WatchedEvent event) {\n         // ignore for this test\n     }\n@@ -60,20 +66,29 @@ public static class MainThread implements Runnable {\n         volatile TestQPMain main;\n         final File dataDir;\n         CountDownLatch mainFailed;\n-\n-        public MainThread(int myid, int clientPort, String quorumCfgSection)\n-                throws IOException {\n-            File tmpDir = ClientBase.createTmpDir();\n-            LOG.info(\"id = \" + myid + \" tmpDir = \" + tmpDir + \" clientPort = \"\n+        File baseDir;\n+        private final int myid;\n+        private final int clientPort;\n+        private final String quorumCfgSection;\n+        private final Map<String, String> otherConfigs;\n+\n+        public MainThread(int myid, int clientPort, String quorumCfgSection,\n+                Map<String, String> otherConfigs) throws IOException {\n+            baseDir = ClientBase.createTmpDir();\n+            this.myid = myid;\n+            this.clientPort = clientPort;\n+            this.quorumCfgSection = quorumCfgSection;\n+            this.otherConfigs = otherConfigs;\n+            LOG.info(\"id = \" + myid + \" tmpDir = \" + baseDir + \" clientPort = \"\n                     + clientPort);\n-            confFile = new File(tmpDir, \"zoo.cfg\");\n+            confFile = new File(baseDir, \"zoo.cfg\");\n \n             FileWriter fwriter = new FileWriter(confFile);\n             fwriter.write(\"tickTime=4000\\n\");\n             fwriter.write(\"initLimit=10\\n\");\n             fwriter.write(\"syncLimit=5\\n\");\n \n-            dataDir = new File(tmpDir, \"data\");\n+            dataDir = new File(baseDir, \"data\");\n             if (!dataDir.mkdir()) {\n                 throw new IOException(\"Unable to mkdir \" + dataDir);\n             }\n@@ -87,6 +102,13 @@ public MainThread(int myid, int clientPort, String quorumCfgSection)\n             fwriter.write(\"dataDir=\" + dir + \"\\n\");\n \n             fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n+\n+            // write extra configurations\n+            Set<Entry<String, String>> entrySet = otherConfigs.entrySet();\n+            for (Entry<String, String> entry : entrySet) {\n+                fwriter.write(entry.getKey() + \"=\" + entry.getValue() + \"\\n\");\n+            }\n+\n             fwriter.write(quorumCfgSection + \"\\n\");\n             fwriter.flush();\n             fwriter.close();\n@@ -98,6 +120,12 @@ public MainThread(int myid, int clientPort, String quorumCfgSection)\n             fwriter.close();\n         }\n \n+        public MainThread(int myid, int clientPort, String quorumCfgSection)\n+                throws IOException {\n+            this(myid, clientPort, quorumCfgSection,\n+                    new HashMap<String, String>());\n+        }\n+\n         Thread currentThread;\n \n         synchronized public void start() {\n@@ -151,5 +179,28 @@ public QuorumPeer getQuorumPeer() {\n             return main.quorumPeer;\n         }\n \n+        public void deleteBaseDir() {\n+            ClientBase.recursiveDelete(baseDir);\n+        }\n+\n+        public int getMyid() {\n+            return myid;\n+        }\n+\n+        public int getClientPort() {\n+            return clientPort;\n+        }\n+\n+        public String getQuorumCfgSection() {\n+            return quorumCfgSection;\n+        }\n+\n+        public Map<String, String> getOtherConfigs() {\n+            return otherConfigs;\n+        }\n+\n+        public File getConfFile() {\n+            return confFile;\n+        }\n     }\n }"
        },
        {
            "sha": "52e7d279c7e50efc029fd56e3e798f8f0a86a7fc",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java",
            "status": "modified",
            "additions": 26,
            "deletions": 18,
            "changes": 44,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -20,6 +20,7 @@\n \n import static org.junit.Assert.assertEquals;\n \n+import java.io.BufferedInputStream;\n import java.io.BufferedReader;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n@@ -367,7 +368,9 @@ public void testLeaderConversation(LeaderConversation conversation) throws Excep\n                 Thread.sleep(20);\n             }\n             \n-            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);\n+            LearnerHandler lh = new LearnerHandler(leaderSocket,\n+                    new BufferedInputStream(leaderSocket.getInputStream()),\n+                    leader);\n             lh.start();\n             leaderSocket.setSoTimeout(4000);\n \n@@ -435,8 +438,10 @@ public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversa\n             while(leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {\n                 Thread.sleep(20);\n             }\n-            \n-            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);\n+\n+            LearnerHandler lh = new LearnerHandler(leaderSocket,\n+                    new BufferedInputStream(leaderSocket.getInputStream()),\n+                    leader);\n             lh.start();\n             leaderSocket.setSoTimeout(4000);\n \n@@ -458,7 +463,6 @@ public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversa\n         }\n     }\n     \n-    \n     public void testFollowerConversation(FollowerConversation conversation) throws Exception {\n         File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n         tmpDir.delete();\n@@ -473,7 +477,9 @@ public void testFollowerConversation(FollowerConversation conversation) throws E\n             \n             ServerSocket ss = new ServerSocket();\n             ss.bind(null);\n-            follower.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());\n+            QuorumServer leaderQS = new QuorumServer(1,\n+                    (InetSocketAddress) ss.getLocalSocketAddress());\n+            follower.setLeaderQuorumServer(leaderQS);\n             final Follower followerForThread = follower;\n             \n             followerThread = new Thread() {\n@@ -526,7 +532,9 @@ public void testObserverConversation(ObserverConversation conversation) throws E\n \n             ServerSocket ss = new ServerSocket();\n             ss.bind(null);\n-            observer.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());\n+            QuorumServer leaderQS = new QuorumServer(1,\n+                    (InetSocketAddress) ss.getLocalSocketAddress());\n+            observer.setLeaderQuorumServer(leaderQS);\n             final Observer observerForThread = observer;\n \n             observerThread = new Thread() {\n@@ -1338,14 +1346,14 @@ static class ConversableFollower extends Follower {\n             super(self, zk);\n         }\n \n-        InetSocketAddress leaderAddr;\n-        public void setLeaderSocketAddress(InetSocketAddress addr) {\n-            leaderAddr = addr;\n+        QuorumServer leaderQuorumServer;\n+        public void setLeaderQuorumServer(QuorumServer quorumServer) {\n+            leaderQuorumServer = quorumServer;\n         }\n         \n         @Override\n-        protected InetSocketAddress findLeader() {\n-            return leaderAddr;\n+        protected QuorumServer findLeader() {\n+            return leaderQuorumServer;\n         }\n     }\n     private ConversableFollower createFollower(File tmpDir, QuorumPeer peer)\n@@ -1364,14 +1372,14 @@ static class ConversableObserver extends Observer {\n             super(self, zk);\n         }\n         \n-        InetSocketAddress leaderAddr;\n-        public void setLeaderSocketAddress(InetSocketAddress addr) {\n-            leaderAddr = addr;\n+        QuorumServer leaderQuorumServer;\n+        public void setLeaderQuorumServer(QuorumServer quorumServer) {\n+            leaderQuorumServer = quorumServer;\n         }\n         \n         @Override\n-        protected InetSocketAddress findLeader() {\n-            return leaderAddr;\n+        protected QuorumServer findLeader() {\n+            return leaderQuorumServer;\n         }\n     }\n         \n@@ -1389,7 +1397,7 @@ private ConversableObserver createObserver(File tmpDir, QuorumPeer peer)\n     \n     private QuorumPeer createQuorumPeer(File tmpDir) throws IOException,\n             FileNotFoundException {\n-        QuorumPeer peer = new QuorumPeer();\n+        QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n         peer.syncLimit = SYNC_LIMIT;\n         peer.initLimit = 2;\n         peer.tickTime = 2000;\n@@ -1435,7 +1443,7 @@ public void testInitialAcceptedCurrent() throws Exception {\n             logFactory.append(req);\n             logFactory.commit();\n             ZKDatabase zkDb = new ZKDatabase(logFactory);\n-            QuorumPeer peer = new QuorumPeer();\n+            QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n             peer.setZKDatabase(zkDb);\n             peer.setTxnFactory(logFactory);\n             peer.getLastLoggedZxid();"
        },
        {
            "sha": "9617c70b332acb4a7839ed8eb5c0e685ec055d2f",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/KerberosSecurityTestcase.java",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,120 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/*\n+ * This code is originally from HDFS, see the similarly named file there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+ */\n+\n+/**\n+ * KerberosSecurityTestcase provides a base class for using MiniKdc with other\n+ * test cases. KerberosSecurityTestcase starts the MiniKdc (@Before) before\n+ * running tests, and stop the MiniKdc (@After) after the testcases, using\n+ * default settings (working dir and kdc configurations).\n+ * <p>\n+ * Users can directly inherit this class and implement their own test functions\n+ * using the default settings, or override functions getTestDir() and\n+ * createMiniKdcConf() to provide new settings.\n+ */\n+public class KerberosSecurityTestcase extends QuorumAuthTestBase {\n+    private static MiniKdc kdc;\n+    private static File workDir;\n+    private static Properties conf;\n+\n+    @BeforeClass\n+    public static void setUpSasl() throws Exception {\n+        startMiniKdc();\n+    }\n+\n+    @AfterClass\n+    public static void tearDownSasl() throws Exception {\n+        stopMiniKdc();\n+        FileUtils.deleteQuietly(workDir);\n+    }\n+\n+    public static void startMiniKdc() throws Exception {\n+        createTestDir();\n+        createMiniKdcConf();\n+\n+        kdc = new MiniKdc(conf, workDir);\n+        kdc.start();\n+    }\n+\n+    /**\n+     * Create a working directory, it should be the build directory. Under this\n+     * directory an ApacheDS working directory will be created, this directory\n+     * will be deleted when the MiniKdc stops.\n+     *\n+     * @throws IOException\n+     */\n+    public static void createTestDir() throws IOException {\n+        workDir = createTmpDir(\n+                new File(System.getProperty(\"build.test.dir\", \"build\")));\n+    }\n+\n+    static File createTmpDir(File parentDir) throws IOException {\n+        File tmpFile = File.createTempFile(\"test\", \".junit\", parentDir);\n+        // don't delete tmpFile - this ensures we don't attempt to create\n+        // a tmpDir with a duplicate name\n+        File tmpDir = new File(tmpFile + \".dir\");\n+        // never true if tmpfile does it's job\n+        Assert.assertFalse(tmpDir.exists());\n+        Assert.assertTrue(tmpDir.mkdirs());\n+        return tmpDir;\n+    }\n+\n+    /**\n+     * Create a Kdc configuration\n+     */\n+    public static void createMiniKdcConf() {\n+        conf = MiniKdc.createConf();\n+    }\n+\n+    public static void stopMiniKdc() {\n+        if (kdc != null) {\n+            kdc.stop();\n+        }\n+    }\n+\n+    public static MiniKdc getKdc() {\n+        return kdc;\n+    }\n+\n+    public static File getWorkDir() {\n+        return workDir;\n+    }\n+\n+    public static Properties getConf() {\n+        return conf;\n+    }\n+}"
        },
        {
            "sha": "4a75f8336c102b412b1fc06bb189ff3d7132616f",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/KerberosTestUtils.java",
            "status": "added",
            "additions": 76,
            "deletions": 0,
            "changes": 76,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.UUID;\n+\n+import org.apache.zookeeper.util.SecurityUtils;\n+\n+public class KerberosTestUtils {\n+    private static String keytabFile = new File(System.getProperty(\"test.dir\", \"build\"), UUID.randomUUID().toString())\n+            .getAbsolutePath();\n+\n+    public static String getRealm() {\n+        return \"EXAMPLE.COM\";\n+    }\n+\n+    public static String getLearnerPrincipal() {\n+        return \"learner@EXAMPLE.COM\";\n+    }\n+\n+    public static String getServerPrincipal() {\n+        return \"zkquorum/localhost@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostLearnerPrincipal() {\n+        return \"learner/_HOST@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostServerPrincipal() {\n+        return \"zkquorum/_HOST@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostNamedLearnerPrincipal(String myHostname) {\n+        return \"learner/\" + myHostname + \"@EXAMPLE.COM\";\n+    }\n+\n+    public static String getKeytabFile() {\n+        return keytabFile;\n+    }\n+\n+    public static String replaceHostPattern(String principal) {\n+        String[] components = principal.split(\"[/@]\");\n+        if (components == null || components.length < 2\n+                || !components[1].equals(SecurityUtils.QUORUM_HOSTNAME_PATTERN)) {\n+            return principal;\n+        } else {\n+            return replacePattern(components, \"localhost\");\n+        }\n+    }\n+\n+    public static String replacePattern(String[] components, String hostname) {\n+        if (components.length == 3) {\n+            return components[0] + \"/\" + hostname.toLowerCase() + \"@\"\n+                    + components[2];\n+        } else {\n+            return components[0] + \"/\" + hostname.toLowerCase();\n+        }\n+    }\n+}"
        },
        {
            "sha": "4afef41eadc7143181cf1ddc7e1e9bc3f935b984",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/MiniKdc.java",
            "status": "added",
            "additions": 418,
            "deletions": 0,
            "changes": 418,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+import org.apache.commons.io.Charsets;\n+import org.apache.kerby.kerberos.kerb.KrbException;\n+import org.apache.kerby.kerberos.kerb.server.KdcConfigKey;\n+import org.apache.kerby.kerberos.kerb.server.SimpleKdcServer;\n+import org.apache.kerby.util.IOUtil;\n+import org.apache.kerby.util.NetworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Mini KDC based on Apache Directory Server that can be embedded in testcases\n+ * or used from command line as a standalone KDC.\n+ * <p>\n+ * <b>From within testcases:</b>\n+ * <p>\n+ * MiniKdc sets one System property when started and un-set when stopped:\n+ * <ul>\n+ *   <li>sun.security.krb5.debug: set to the debug value provided in the\n+ *   configuration</li>\n+ * </ul>\n+ * Because of this, multiple MiniKdc instances cannot be started in parallel.\n+ * For example, running testcases in parallel that start a KDC each. To\n+ * accomplish this a single MiniKdc should be used for all testcases running\n+ * in parallel.\n+ * <p>\n+ * MiniKdc default configuration values are:\n+ * <ul>\n+ *   <li>org.name=EXAMPLE (used to create the REALM)</li>\n+ *   <li>org.domain=COM (used to create the REALM)</li>\n+ *   <li>kdc.bind.address=localhost</li>\n+ *   <li>kdc.port=0 (ephemeral port)</li>\n+ *   <li>instance=DefaultKrbServer</li>\n+ *   <li>max.ticket.lifetime=86400000 (1 day)</li>\n+ *   <li>max.renewable.lifetime=604800000 (7 days)</li>\n+ *   <li>transport=TCP</li>\n+ *   <li>debug=false</li>\n+ * </ul>\n+ * The generated krb5.conf forces TCP connections.\n+ */\n+/*\n+ * This code is originally from HDFS, see the file name MiniKdc there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 916140604ffef59466ba30832478311d3e6249bd\n+ */\n+public class MiniKdc {\n+\n+    public static final String JAVA_SECURITY_KRB5_CONF =\n+            \"java.security.krb5.conf\";\n+    public static final String SUN_SECURITY_KRB5_DEBUG =\n+            \"sun.security.krb5.debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 4) {\n+            System.out.println(\"Arguments: <WORKDIR> <MINIKDCPROPERTIES> \" +\n+                    \"<KEYTABFILE> [<PRINCIPALS>]+\");\n+            System.exit(1);\n+        }\n+        File workDir = new File(args[0]);\n+        if (!workDir.exists()) {\n+            throw new RuntimeException(\"Specified work directory does not exists: \"\n+                    + workDir.getAbsolutePath());\n+        }\n+        Properties conf = createConf();\n+        File file = new File(args[1]);\n+        if (!file.exists()) {\n+            throw new RuntimeException(\"Specified configuration does not exists: \"\n+                    + file.getAbsolutePath());\n+        }\n+        Properties userConf = new Properties();\n+        InputStreamReader r = null;\n+        try {\n+            r = new InputStreamReader(new FileInputStream(file), Charsets.UTF_8);\n+            userConf.load(r);\n+        } finally {\n+            if (r != null) {\n+                r.close();\n+            }\n+        }\n+        for (Map.Entry<?, ?> entry : userConf.entrySet()) {\n+            conf.put(entry.getKey(), entry.getValue());\n+        }\n+        final MiniKdc miniKdc = new MiniKdc(conf, workDir);\n+        miniKdc.start();\n+        File krb5conf = new File(workDir, \"krb5.conf\");\n+        if (miniKdc.getKrb5conf().renameTo(krb5conf)) {\n+            File keytabFile = new File(args[2]).getAbsoluteFile();\n+            String[] principals = new String[args.length - 3];\n+            System.arraycopy(args, 3, principals, 0, args.length - 3);\n+            miniKdc.createPrincipal(keytabFile, principals);\n+            System.out.println();\n+            System.out.println(\"Standalone MiniKdc Running\");\n+            System.out.println(\"---------------------------------------------------\");\n+            System.out.println(\"  Realm           : \" + miniKdc.getRealm());\n+            System.out.println(\"  Running at      : \" + miniKdc.getHost() + \":\" +\n+                    miniKdc.getHost());\n+            System.out.println(\"  krb5conf        : \" + krb5conf);\n+            System.out.println();\n+            System.out.println(\"  created keytab  : \" + keytabFile);\n+            System.out.println(\"  with principals : \" + Arrays.asList(principals));\n+            System.out.println();\n+            System.out.println(\" Do <CTRL-C> or kill <PID> to stop it\");\n+            System.out.println(\"---------------------------------------------------\");\n+            System.out.println();\n+            Runtime.getRuntime().addShutdownHook(new Thread() {\n+                @Override\n+                public void run() {\n+                    miniKdc.stop();\n+                }\n+            });\n+        } else {\n+            throw new RuntimeException(\"Cannot rename KDC's krb5conf to \"\n+                    + krb5conf.getAbsolutePath());\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MiniKdc.class);\n+\n+    public static final String ORG_NAME = \"org.name\";\n+    public static final String ORG_DOMAIN = \"org.domain\";\n+    public static final String KDC_BIND_ADDRESS = \"kdc.bind.address\";\n+    public static final String KDC_PORT = \"kdc.port\";\n+    public static final String INSTANCE = \"instance\";\n+    public static final String MAX_TICKET_LIFETIME = \"max.ticket.lifetime\";\n+    public static final String MAX_RENEWABLE_LIFETIME = \"max.renewable.lifetime\";\n+    public static final String TRANSPORT = \"transport\";\n+    public static final String DEBUG = \"debug\";\n+\n+    private static final Set<String> PROPERTIES = new HashSet<String>();\n+    private static final Properties DEFAULT_CONFIG = new Properties();\n+\n+    static {\n+        PROPERTIES.add(ORG_NAME);\n+        PROPERTIES.add(ORG_DOMAIN);\n+        PROPERTIES.add(KDC_BIND_ADDRESS);\n+        PROPERTIES.add(KDC_BIND_ADDRESS);\n+        PROPERTIES.add(KDC_PORT);\n+        PROPERTIES.add(INSTANCE);\n+        PROPERTIES.add(TRANSPORT);\n+        PROPERTIES.add(MAX_TICKET_LIFETIME);\n+        PROPERTIES.add(MAX_RENEWABLE_LIFETIME);\n+\n+        DEFAULT_CONFIG.setProperty(KDC_BIND_ADDRESS, \"localhost\");\n+        DEFAULT_CONFIG.setProperty(KDC_PORT, \"0\");\n+        DEFAULT_CONFIG.setProperty(INSTANCE, \"DefaultKrbServer\");\n+        DEFAULT_CONFIG.setProperty(ORG_NAME, \"EXAMPLE\");\n+        DEFAULT_CONFIG.setProperty(ORG_DOMAIN, \"COM\");\n+        DEFAULT_CONFIG.setProperty(TRANSPORT, \"TCP\");\n+        DEFAULT_CONFIG.setProperty(MAX_TICKET_LIFETIME, \"86400000\");\n+        DEFAULT_CONFIG.setProperty(MAX_RENEWABLE_LIFETIME, \"604800000\");\n+        DEFAULT_CONFIG.setProperty(DEBUG, \"false\");\n+    }\n+\n+    /**\n+     * Convenience method that returns MiniKdc default configuration.\n+     * <p>\n+     * The returned configuration is a copy, it can be customized before using\n+     * it to create a MiniKdc.\n+     * @return a MiniKdc default configuration.\n+     */\n+    public static Properties createConf() {\n+        return (Properties) DEFAULT_CONFIG.clone();\n+    }\n+\n+    private Properties conf;\n+    private SimpleKdcServer simpleKdc;\n+    private int port;\n+    private String realm;\n+    private File workDir;\n+    private File krb5conf;\n+    private String transport;\n+    private boolean krb5Debug;\n+\n+    public void setTransport(String transport) {\n+        this.transport = transport;\n+    }\n+    /**\n+     * Creates a MiniKdc.\n+     *\n+     * @param conf MiniKdc configuration.\n+     * @param workDir working directory, it should be the build directory. Under\n+     * this directory an ApacheDS working directory will be created, this\n+     * directory will be deleted when the MiniKdc stops.\n+     * @throws Exception thrown if the MiniKdc could not be created.\n+     */\n+    public MiniKdc(Properties conf, File workDir) throws Exception {\n+        if (!conf.keySet().containsAll(PROPERTIES)) {\n+            Set<String> missingProperties = new HashSet<String>(PROPERTIES);\n+            missingProperties.removeAll(conf.keySet());\n+            throw new IllegalArgumentException(\"Missing configuration properties: \"\n+                    + missingProperties);\n+        }\n+        this.workDir = new File(workDir, Long.toString(System.currentTimeMillis()));\n+        if (!this.workDir.exists()\n+                && !this.workDir.mkdirs()) {\n+            throw new RuntimeException(\"Cannot create directory \" + this.workDir);\n+        }\n+        LOG.info(\"Configuration:\");\n+        LOG.info(\"---------------------------------------------------------------\");\n+        for (Map.Entry<?, ?> entry : conf.entrySet()) {\n+            LOG.info(\"  {}: {}\", entry.getKey(), entry.getValue());\n+        }\n+        LOG.info(\"---------------------------------------------------------------\");\n+        this.conf = conf;\n+        port = Integer.parseInt(conf.getProperty(KDC_PORT));\n+        String orgName= conf.getProperty(ORG_NAME);\n+        String orgDomain = conf.getProperty(ORG_DOMAIN);\n+        realm = orgName.toUpperCase(Locale.ENGLISH) + \".\"\n+                + orgDomain.toUpperCase(Locale.ENGLISH);\n+    }\n+\n+    /**\n+     * Returns the port of the MiniKdc.\n+     *\n+     * @return the port of the MiniKdc.\n+     */\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    /**\n+     * Returns the host of the MiniKdc.\n+     *\n+     * @return the host of the MiniKdc.\n+     */\n+    public String getHost() {\n+        return conf.getProperty(KDC_BIND_ADDRESS);\n+    }\n+\n+    /**\n+     * Returns the realm of the MiniKdc.\n+     *\n+     * @return the realm of the MiniKdc.\n+     */\n+    public String getRealm() {\n+        return realm;\n+    }\n+\n+    public File getKrb5conf() {\n+        krb5conf = new File(System.getProperty(JAVA_SECURITY_KRB5_CONF));\n+        return krb5conf;\n+    }\n+\n+    /**\n+     * Starts the MiniKdc.\n+     *\n+     * @throws Exception thrown if the MiniKdc could not be started.\n+     */\n+    public synchronized void start() throws Exception {\n+        if (simpleKdc != null) {\n+            throw new RuntimeException(\"Already started\");\n+        }\n+        simpleKdc = new SimpleKdcServer();\n+        prepareKdcServer();\n+        simpleKdc.init();\n+        resetDefaultRealm();\n+        simpleKdc.start();\n+        LOG.info(\"MiniKdc stated.\");\n+    }\n+\n+    private void resetDefaultRealm() throws IOException {\n+        InputStream templateResource = new FileInputStream(\n+                getKrb5conf().getAbsolutePath());\n+        String content = IOUtil.readInput(templateResource);\n+        content = content.replaceAll(\"default_realm = .*\\n\",\n+                \"default_realm = \" + getRealm() + \"\\n\");\n+        IOUtil.writeFile(content, getKrb5conf());\n+    }\n+\n+    private void prepareKdcServer() throws Exception {\n+        // transport\n+        simpleKdc.setWorkDir(workDir);\n+        simpleKdc.setKdcHost(getHost());\n+        simpleKdc.setKdcRealm(realm);\n+        if (transport == null) {\n+            transport = conf.getProperty(TRANSPORT);\n+        }\n+        if (port == 0) {\n+            port = NetworkUtil.getServerPort();\n+        }\n+        if (transport != null) {\n+            if (transport.trim().equals(\"TCP\")) {\n+                simpleKdc.setKdcTcpPort(port);\n+                simpleKdc.setAllowUdp(false);\n+            } else if (transport.trim().equals(\"UDP\")) {\n+                simpleKdc.setKdcUdpPort(port);\n+                simpleKdc.setAllowTcp(false);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid transport: \" + transport);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Need to set transport!\");\n+        }\n+        simpleKdc.getKdcConfig().setString(KdcConfigKey.KDC_SERVICE_NAME,\n+                conf.getProperty(INSTANCE));\n+        if (conf.getProperty(DEBUG) != null) {\n+            krb5Debug = getAndSet(SUN_SECURITY_KRB5_DEBUG, conf.getProperty(DEBUG));\n+        }\n+    }\n+\n+    /**\n+     * Stops the MiniKdc\n+     */\n+    public synchronized void stop() {\n+        if (simpleKdc != null) {\n+            try {\n+                simpleKdc.stop();\n+            } catch (KrbException e) {\n+                e.printStackTrace();\n+            } finally {\n+                if(conf.getProperty(DEBUG) != null) {\n+                    System.setProperty(SUN_SECURITY_KRB5_DEBUG,\n+                            Boolean.toString(krb5Debug));\n+                }\n+            }\n+        }\n+        delete(workDir);\n+        try {\n+            // Will be fixed in next Kerby version.\n+            Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        LOG.info(\"MiniKdc stopped.\");\n+    }\n+\n+    private void delete(File f) {\n+        if (f.isFile()) {\n+            if (! f.delete()) {\n+                LOG.warn(\"WARNING: cannot delete file \" + f.getAbsolutePath());\n+            }\n+        } else {\n+            for (File c: f.listFiles()) {\n+                delete(c);\n+            }\n+            if (! f.delete()) {\n+                LOG.warn(\"WARNING: cannot delete directory \" + f.getAbsolutePath());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a principal in the KDC with the specified user and password.\n+     *\n+     * @param principal principal name, do not include the domain.\n+     * @param password password.\n+     * @throws Exception thrown if the principal could not be created.\n+     */\n+    public synchronized void createPrincipal(String principal, String password)\n+            throws Exception {\n+        simpleKdc.createPrincipal(principal, password);\n+    }\n+\n+    /**\n+     * Creates multiple principals in the KDC and adds them to a keytab file.\n+     *\n+     * @param keytabFile keytab file to add the created principals.\n+     * @param principals principals to add to the KDC, do not include the domain.\n+     * @throws Exception thrown if the principals or the keytab file could not be\n+     * created.\n+     */\n+    public synchronized void createPrincipal(File keytabFile,\n+                                             String ... principals)\n+            throws Exception {\n+        simpleKdc.createPrincipals(principals);\n+        if (keytabFile.exists() && !keytabFile.delete()) {\n+            LOG.error(\"Failed to delete keytab file: \" + keytabFile);\n+        }\n+        for (String principal : principals) {\n+            simpleKdc.getKadmin().exportKeytab(keytabFile, principal);\n+        }\n+    }\n+\n+    /**\n+     * Set the System property; return the old value for caching.\n+     *\n+     * @param sysprop property\n+     * @param debug true or false\n+     * @return the previous value\n+     */\n+    private boolean getAndSet(String sysprop, String debug) {\n+        boolean old = Boolean.getBoolean(sysprop);\n+        System.setProperty(sysprop, debug);\n+        return old;\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "a7bbf7feb93cfbcaaddded6e99a30755989ab996",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/MiniKdcTest.java",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,184 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.kerberos.KerberosPrincipal;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginContext;\n+import java.io.File;\n+import java.security.Principal;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Map;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.util.Arrays;\n+\n+/*\n+ * This code is originally from HDFS, see the file name TestMiniKdc there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 916140604ffef59466ba30832478311d3e6249bd\n+ */\n+public class MiniKdcTest extends KerberosSecurityTestcase {\n+    private static final boolean IBM_JAVA = System.getProperty(\"java.vendor\")\n+            .contains(\"IBM\");\n+\n+    @Test(timeout = 60000)\n+    public void testMiniKdcStart() {\n+        MiniKdc kdc = getKdc();\n+        Assert.assertNotSame(0, kdc.getPort());\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testKeytabGen() throws Exception {\n+        MiniKdc kdc = getKdc();\n+        File workDir = getWorkDir();\n+\n+        kdc.createPrincipal(new File(workDir, \"keytab\"), \"foo/bar\", \"bar/foo\");\n+        List<PrincipalName> principalNameList =\n+                Keytab.loadKeytab(new File(workDir, \"keytab\")).getPrincipals();\n+\n+        Set<String> principals = new HashSet<String>();\n+        for (PrincipalName principalName : principalNameList) {\n+          principals.add(principalName.getName());\n+        }\n+\n+        Assert.assertEquals(new HashSet<String>(Arrays.asList(\n+                \"foo/bar@\" + kdc.getRealm(), \"bar/foo@\" + kdc.getRealm())),\n+                principals);\n+      }\n+\n+    private static class KerberosConfiguration extends Configuration {\n+        private String principal;\n+        private String keytab;\n+        private boolean isInitiator;\n+\n+        private KerberosConfiguration(String principal, File keytab,\n+                boolean client) {\n+            this.principal = principal;\n+            this.keytab = keytab.getAbsolutePath();\n+            this.isInitiator = client;\n+        }\n+\n+        public static Configuration createClientConfig(String principal,\n+                File keytab) {\n+            return new KerberosConfiguration(principal, keytab, true);\n+        }\n+\n+        public static Configuration createServerConfig(String principal,\n+                File keytab) {\n+            return new KerberosConfiguration(principal, keytab, false);\n+        }\n+\n+        private static String getKrb5LoginModuleName() {\n+            return System.getProperty(\"java.vendor\").contains(\"IBM\")\n+                    ? \"com.ibm.security.auth.module.Krb5LoginModule\"\n+                    : \"com.sun.security.auth.module.Krb5LoginModule\";\n+        }\n+\n+        @Override\n+        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {\n+            Map<String, String> options = new HashMap<String, String>();\n+            options.put(\"principal\", principal);\n+            options.put(\"refreshKrb5Config\", \"true\");\n+            if (IBM_JAVA) {\n+                options.put(\"useKeytab\", keytab);\n+                options.put(\"credsType\", \"both\");\n+            } else {\n+                options.put(\"keyTab\", keytab);\n+                options.put(\"useKeyTab\", \"true\");\n+                options.put(\"storeKey\", \"true\");\n+                options.put(\"doNotPrompt\", \"true\");\n+                options.put(\"useTicketCache\", \"true\");\n+                options.put(\"renewTGT\", \"true\");\n+                options.put(\"isInitiator\", Boolean.toString(isInitiator));\n+            }\n+            String ticketCache = System.getenv(\"KRB5CCNAME\");\n+            if (ticketCache != null) {\n+                options.put(\"ticketCache\", ticketCache);\n+            }\n+            options.put(\"debug\", \"true\");\n+\n+            return new AppConfigurationEntry[] {\n+                    new AppConfigurationEntry(getKrb5LoginModuleName(),\n+                            AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+                            options) };\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testKerberosLogin() throws Exception {\n+        MiniKdc kdc = getKdc();\n+        File workDir = getWorkDir();\n+        LoginContext loginContext = null;\n+        try {\n+            String principal = \"foo\";\n+            File keytab = new File(workDir, \"foo.keytab\");\n+            kdc.createPrincipal(keytab, principal);\n+\n+            Set<Principal> principals = new HashSet<Principal>();\n+            principals.add(new KerberosPrincipal(principal));\n+\n+            // client login\n+            Subject subject = new Subject(false, principals,\n+                    new HashSet<Object>(), new HashSet<Object>());\n+            loginContext = new LoginContext(\"\", subject, null,\n+                    KerberosConfiguration.createClientConfig(principal,\n+                            keytab));\n+            loginContext.login();\n+            subject = loginContext.getSubject();\n+            Assert.assertEquals(1, subject.getPrincipals().size());\n+            Assert.assertEquals(KerberosPrincipal.class,\n+                    subject.getPrincipals().iterator().next().getClass());\n+            Assert.assertEquals(principal + \"@\" + kdc.getRealm(),\n+                    subject.getPrincipals().iterator().next().getName());\n+            loginContext.logout();\n+\n+            // server login\n+            subject = new Subject(false, principals, new HashSet<Object>(),\n+                    new HashSet<Object>());\n+            loginContext = new LoginContext(\"\", subject, null,\n+                    KerberosConfiguration.createServerConfig(principal,\n+                            keytab));\n+            loginContext.login();\n+            subject = loginContext.getSubject();\n+            Assert.assertEquals(1, subject.getPrincipals().size());\n+            Assert.assertEquals(KerberosPrincipal.class,\n+                    subject.getPrincipals().iterator().next().getClass());\n+            Assert.assertEquals(principal + \"@\" + kdc.getRealm(),\n+                    subject.getPrincipals().iterator().next().getName());\n+            loginContext.logout();\n+\n+        } finally {\n+            if (loginContext != null) {\n+                loginContext.logout();\n+            }\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "8978d170f26272cf02d899d2a52c6350eab72006",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumAuthTestBase.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,146 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZKTestCase;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.junit.Assert;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * QuorumAuthTestBase provides a base class for testing quorum peer mutual\n+ * authentication using SASL mechanisms.\n+ */\n+public class QuorumAuthTestBase extends ZKTestCase {\n+    protected static final Logger LOG = LoggerFactory.getLogger(QuorumAuthTestBase.class);\n+    protected List<MainThread> mt = new ArrayList<MainThread>();\n+    protected static File jaasConfigDir;\n+\n+    public static void setupJaasConfig(String jaasEntries) {\n+        try {\n+            jaasConfigDir = ClientBase.createTmpDir();\n+            File saslConfFile = new File(jaasConfigDir, \"jaas.conf\");\n+            FileWriter fwriter = new FileWriter(saslConfFile);\n+            fwriter.write(jaasEntries);\n+            fwriter.close();\n+            System.setProperty(\"java.security.auth.login.config\",\n+                    saslConfFile.getAbsolutePath());\n+        } catch (IOException ioe) {\n+            LOG.error(\"Failed to create tmp directory to hold JAAS conf file\", ioe);\n+            // could not create tmp directory to hold JAAS conf file : test will\n+            // fail now.\n+        }\n+    }\n+\n+    public static void cleanupJaasConfig() {\n+        if (jaasConfigDir != null) {\n+            FileUtils.deleteQuietly(jaasConfigDir);\n+        }\n+    }\n+\n+    protected String startQuorum(final int serverCount,\n+            Map<String, String> authConfigs, int authServerCount) throws IOException {\n+        StringBuilder connectStr = new StringBuilder();\n+        final int[] clientPorts = startQuorum(serverCount, connectStr,\n+                authConfigs, authServerCount);\n+        for (int i = 0; i < serverCount; i++) {\n+            Assert.assertTrue(\"waiting for server \" + i + \" being up\",\n+                    ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i],\n+                            ClientBase.CONNECTION_TIMEOUT));\n+        }\n+        return connectStr.toString();\n+    }\n+\n+    protected int[] startQuorum(final int serverCount, StringBuilder connectStr,\n+            Map<String, String> authConfigs, int authServerCount) throws IOException {\n+        final int clientPorts[] = new int[serverCount];\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < serverCount; i++) {\n+            clientPorts[i] = PortAssignment.unique();\n+            String server = String.format(\n+                    \"server.%d=localhost:%d:%d:participant\", i,\n+                    PortAssignment.unique(), PortAssignment.unique());\n+            sb.append(server + \"\\n\");\n+            connectStr.append(\"127.0.0.1:\" + clientPorts[i]);\n+            if (i < serverCount - 1) {\n+                connectStr.append(\",\");\n+            }\n+        }\n+        String quorumCfg = sb.toString();\n+        // servers with authentication interfaces configured\n+        int i = 0;\n+        for (; i < authServerCount; i++) {\n+            startServer(authConfigs, clientPorts, quorumCfg, i);\n+        }\n+        // servers without any authentication configured\n+        for (int j = 0; j < serverCount - authServerCount; j++, i++) {\n+            MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg);\n+            mt.add(mthread);\n+            mthread.start();\n+        }\n+        return clientPorts;\n+    }\n+\n+    private void startServer(Map<String, String> authConfigs,\n+            final int[] clientPorts, String quorumCfg, int i)\n+                    throws IOException {\n+        MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg,\n+                authConfigs);\n+        mt.add(mthread);\n+        mthread.start();\n+    }\n+\n+    protected void startServer(MainThread restartPeer,\n+            Map<String, String> authConfigs) throws IOException {\n+        MainThread mthread = new MainThread(restartPeer.getMyid(),\n+                restartPeer.getClientPort(), restartPeer.getQuorumCfgSection(),\n+                authConfigs);\n+        mt.add(mthread);\n+        mthread.start();\n+    }\n+\n+    void shutdownAll() {\n+        for (int i = 0; i < mt.size(); i++) {\n+            shutdown(i);\n+        }\n+    }\n+\n+    MainThread shutdown(int index) {\n+        MainThread mainThread = mt.get(index);\n+        try {\n+            mainThread.shutdown();\n+        } catch (InterruptedException e) {\n+        } finally {\n+            mt.remove(index);\n+        }\n+        mainThread.deleteBaseDir();\n+        return mainThread;\n+    }\n+}"
        },
        {
            "sha": "359324549e27124bda12b9cd78fdf27f3e047577",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumAuthUpgradeTest.java",
            "status": "added",
            "additions": 239,
            "deletions": 0,
            "changes": 239,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,239 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientTest;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Rolling upgrade should do in three steps:\n+ *\n+ * step-1) Stop the server and set the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false and quorum.auth.serverRequireSasl=false\n+ * Ensure that all the servers should complete this step. Now, move to next step.\n+ *\n+ * step-2) Stop the server one by one and change the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=false\n+ * Ensure that all the servers should complete this step. Now, move to next step.\n+ *\n+ * step-3) Stop the server one by one and change the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=true\n+ * Now, all the servers are fully upgraded and running in secured mode.\n+ */\n+public class QuorumAuthUpgradeTest extends QuorumAuthTestBase {\n+    static {\n+        String jaasEntries = new String(\"\" + \"QuorumServer {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       user_test=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"mypassword\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        shutdownAll();\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to start without any authentication.\n+     * peer0 -> quorum.auth.enableSasl=false\n+     * peer1 -> quorum.auth.enableSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testNullAuthLearnerServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 0);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     * peer1 -> quorum.auth.enableSasl=false, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerAgainstNullAuthServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 1);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     * peer1 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerAgainstNoAuthRequiredServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 2);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+     * peer1 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 2);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Rolling upgrade should do in three steps:\n+     *\n+     * step-1) Stop the server and set the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false and quorum.auth.serverRequireSasl=false\n+     * Ensure that all the servers should complete this step. Now, move to next step.\n+     *\n+     * step-2) Stop the server one by one and change the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=false\n+     * Ensure that all the servers should complete this step. Now, move to next step.\n+     *\n+     * step-3) Stop the server one by one and change the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=true\n+     * Now, all the servers are fully upgraded and running in secured mode.\n+     */\n+    @Test(timeout = 90000)\n+    public void testRollingUpgrade() throws Exception {\n+        // Start peer0,1,2 servers with quorum.auth.enableSasl=false and\n+        // quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+        // Assume this is an existing cluster.\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        String connectStr = startQuorum(3, authConfigs, 0);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT_SEQUENTIAL);\n+\n+        //1. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //2. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=false\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //3. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //4. Restart peer2 with quorum.auth.learnerEnableSasl=false and\n+        // quorum.auth.serverRequireSasl=false. It should fail to join the\n+        // quorum as this needs auth.\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+        MainThread m = shutdown(2);\n+        startServer(m, authConfigs);\n+        Assert.assertFalse(\"waiting for server 2 being up\", ClientBase\n+                .waitForServerUp(\"127.0.0.1:\" + m.getClientPort(), 5000));\n+    }\n+\n+    private void restartServer(Map<String, String> authConfigs, int index,\n+            ZooKeeper zk, CountdownWatcher watcher) throws IOException,\n+                    KeeperException, InterruptedException, TimeoutException {\n+        LOG.info(\"Restarting server myid=\" + index);\n+        MainThread m = shutdown(index);\n+        startServer(m, authConfigs);\n+        Assert.assertTrue(\"waiting for server\" + index + \"being up\",\n+                ClientBase.waitForServerUp(\"127.0.0.1:\" + m.getClientPort(),\n+                        ClientBase.CONNECTION_TIMEOUT));\n+        watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT_SEQUENTIAL);\n+    }\n+}"
        },
        {
            "sha": "4d66beb72d62998cbd0b0113cbf0bc0aade14470",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumDigestAuthTest.java",
            "status": "added",
            "additions": 221,
            "deletions": 0,
            "changes": 221,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,221 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerMain;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;\n+import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class QuorumDigestAuthTest extends QuorumAuthTestBase {\n+\n+    static {\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       user_test=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearnerInvalid {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"invalid\\\";\\n\" + \"};\" + \"\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup(){\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 30000)\n+    public void testValidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with invalid credentials if\n+     * the configuration is set to quorum.auth.serverRequireSasl=false.\n+     * Quorum will talk each other even if the authentication is not succeeded\n+     */\n+    @Test(timeout = 30000)\n+    public void testSaslNotRequiredWithInvalidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, \"QuorumLearnerInvalid\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that server shouldn't start with invalid credentials\n+     * if the configuration is set to quorum.auth.serverRequireSasl=true,\n+     * quorum.auth.learnerRequireSasl=true\n+     */\n+    @Test(timeout = 30000)\n+    public void testSaslRequiredInvalidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, \"QuorumLearnerInvalid\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        int serverCount = 2;\n+        final int[] clientPorts = startQuorum(serverCount, new StringBuilder(),\n+                authConfigs, serverCount);\n+        for (int i = 0; i < serverCount; i++) {\n+            boolean waitForServerUp = ClientBase.waitForServerUp(\n+                    \"127.0.0.1:\" + clientPorts[i], QuorumPeerTestBase.TIMEOUT);\n+            Assert.assertFalse(\"Shouldn't start server with invalid credentials\",\n+                    waitForServerUp);\n+        }\n+    }\n+\n+    /**\n+     * If quorumpeer learner is not auth enabled then self won't be able to join\n+     * quorum. So this test is ensuring that the quorumpeer learner is also auth\n+     * enabled while enabling quorum server require sasl.\n+     */\n+    @Test(timeout = 10000)\n+    public void testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl()\n+            throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearner\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        MainThread mthread = new MainThread(1, PortAssignment.unique(), \"\",\n+                authConfigs);\n+        String args[] = new String[1];\n+        args[0] = mthread.getConfFile().toString();\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorumpeer learner is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     * If quorumpeer learner is not auth enabled then self won't be able to join\n+     * quorum. So this test is ensuring that the quorumpeer learner is also auth\n+     * enabled while enabling quorum server require sasl.\n+     */\n+    @Test(timeout = 10000)\n+    public void testEnableQuorumAuthenticationConfigurations()\n+            throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearner\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        // case-1) 'quorum.auth.enableSasl' is off. Tries to enable server sasl.\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        MainThread mthread = new MainThread(1, PortAssignment.unique(), \"\",\n+                authConfigs);\n+        String args[] = new String[1];\n+        args[0] = mthread.getConfFile().toString();\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorum sasl is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+\n+        // case-1) 'quorum.auth.enableSasl' is off. Tries to enable learner sasl.\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorum sasl is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+    }\n+}"
        },
        {
            "sha": "2cc56a7679458d0abd1ef7f0767ee20db85f9294",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumKerberosAuthTest.java",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class QuorumKerberosAuthTest extends KerberosSecurityTestcase {\n+    private static File keytabFile;\n+    static {\n+        String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.getServerPrincipal() + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.getLearnerPrincipal() + \"\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        // create keytab\n+        keytabFile = new File(KerberosTestUtils.getKeytabFile());\n+        String learnerPrincipal = KerberosTestUtils.getLearnerPrincipal();\n+        String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n+        learnerPrincipal = learnerPrincipal.substring(0, learnerPrincipal.lastIndexOf(\"@\"));\n+        serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n+        getKdc().createPrincipal(keytabFile, learnerPrincipal, serverPrincipal);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        if(keytabFile != null){\n+            FileUtils.deleteQuietly(keytabFile);\n+        }\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 120000)\n+    public void testValidCredentials() throws Exception {\n+        String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n+        serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+}"
        },
        {
            "sha": "fcb76919f1b5cdbc42ae75ecc11d698dad0723be",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumKerberosHostBasedAuthTest.java",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -0,0 +1,184 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import junit.framework.Assert;\n+\n+public class QuorumKerberosHostBasedAuthTest extends KerberosSecurityTestcase {\n+    private static File keytabFile;\n+    private static String hostServerPrincipal = KerberosTestUtils.getHostServerPrincipal();\n+    private static String hostLearnerPrincipal = KerberosTestUtils.getHostLearnerPrincipal();\n+    private static String hostNamedLearnerPrincipal = KerberosTestUtils.getHostNamedLearnerPrincipal(\"myHost\");\n+    static {\n+        setupJaasConfigEntries(hostServerPrincipal, hostLearnerPrincipal, hostNamedLearnerPrincipal);\n+    }\n+\n+    private static void setupJaasConfigEntries(String hostServerPrincipal,\n+            String hostLearnerPrincipal, String hostNamedLearnerPrincipal) {\n+        String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.replaceHostPattern(hostServerPrincipal) + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.replaceHostPattern(hostLearnerPrincipal) + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearnerMyHost {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + hostNamedLearnerPrincipal + \"\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @BeforeClass\n+    public static void setUp() throws Exception {\n+        // create keytab\n+        keytabFile = new File(KerberosTestUtils.getKeytabFile());\n+\n+        // Creates principals in the KDC and adds them to a keytab file.\n+        String learnerPrincipal = hostLearnerPrincipal.substring(0, hostLearnerPrincipal.lastIndexOf(\"@\"));\n+        learnerPrincipal = KerberosTestUtils.replaceHostPattern(learnerPrincipal);\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        serverPrincipal = KerberosTestUtils.replaceHostPattern(serverPrincipal);\n+\n+        // learner with ipaddress in principal\n+        String learnerPrincipal2 = hostNamedLearnerPrincipal.substring(0, hostNamedLearnerPrincipal.lastIndexOf(\"@\"));\n+        getKdc().createPrincipal(keytabFile, learnerPrincipal, learnerPrincipal2, serverPrincipal);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        if(keytabFile != null){\n+            FileUtils.deleteQuietly(keytabFile);\n+        }\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 120000)\n+    public void testValidCredentials() throws Exception {\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that the bad server connection to the quorum should be rejected.\n+     */\n+    @Test(timeout = 120000)\n+    public void testConnectBadServer() throws Exception {\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+\n+        String quorumCfgSection = mt.get(0).getQuorumCfgSection();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(quorumCfgSection);\n+\n+        int myid = mt.size() + 1;\n+        final int clientPort = PortAssignment.unique();\n+        String server = String.format(\"server.%d=localhost:%d:%d:participant\",\n+                myid, PortAssignment.unique(), PortAssignment.unique());\n+        sb.append(server + \"\\n\");\n+        quorumCfgSection = sb.toString();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearnerMyHost\");\n+        MainThread badServer = new MainThread(myid, clientPort, quorumCfgSection,\n+                authConfigs);\n+        badServer.start();\n+        watcher = new CountdownWatcher();\n+        connectStr = \"127.0.0.1:\" + clientPort;\n+        zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        try{\n+            watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT/3);\n+            Assert.fail(\"Must throw exception as the myHost is not an authorized one!\");\n+        } catch (TimeoutException e){\n+            // expected\n+        } finally {\n+            zk.close();\n+            badServer.shutdown();\n+            badServer.deleteBaseDir();\n+        }\n+    }\n+}"
        },
        {
            "sha": "0ecac6e6c74b607cd757fec070ae6a0582218851",
            "filename": "src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -41,7 +41,7 @@ public class FLEPredicateTest extends ZKTestCase {\n     \n     class MockFLE extends FastLeaderElection {\n         MockFLE(QuorumPeer peer){\n-            super(peer, new QuorumCnxManager(peer));\n+            super(peer, peer.createCnxnManager());\n         }\n         \n         boolean predicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch){"
        },
        {
            "sha": "27a5a7ed44f62faa04af275bf6352d5ce971bb89",
            "filename": "src/zookeeper.jute",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/zookeeper/blob/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fzookeeper.jute",
            "raw_url": "https://github.com/apache/zookeeper/raw/8a06bd1ccef382461c7b0a63f2012f4aeac90753/src%2Fzookeeper.jute",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fzookeeper.jute?ref=8a06bd1ccef382461c7b0a63f2012f4aeac90753",
            "patch": "@@ -220,6 +220,11 @@ module org.apache.zookeeper.server.quorum {\n         buffer data; // Only significant when type is request\n         vector<org.apache.zookeeper.data.Id> authinfo;\n     }\n+    class QuorumAuthPacket {\n+        long magic;\n+        int status;\n+        buffer token;\n+    }\n }\n \n module org.apache.zookeeper.server.persistence {"
        }
    ]
}
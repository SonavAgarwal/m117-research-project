{
    "sha": "75411ab34a3d53c43c2d508b12314a9788aa417d",
    "node_id": "MDY6Q29tbWl0MTYwOTk5Ojc1NDExYWIzNGEzZDUzYzQzYzJkNTA4YjEyMzE0YTk3ODhhYTQxN2Q=",
    "commit": {
        "author": {
            "name": "Abraham Fine",
            "email": "afine@apache.org",
            "date": "2017-11-27T23:10:13Z"
        },
        "committer": {
            "name": "Patrick Hunt",
            "email": "phunt@apache.org",
            "date": "2017-11-27T23:10:13Z"
        },
        "message": "ZOOKEEPER-2935: [QP MutualAuth]: Port ZOOKEEPER-1045 implementation from branch-3.5 to trunk\n\nAuthor: Abraham Fine <afine@apache.org>\n\nReviewers: phunt@apache.org\n\nCloses #417 from afine/ZOOKEEPER-2935 and squashes the following commits:\n\n99bfbe94 [Abraham Fine] Add debugging line and improve ivy.xml by removing unnecessary excludes\n1d6c7de5 [Abraham Fine] Fix missing test.data.kerberos.dir in build.xml\n06d0b6fa [Abraham Fine] ZOOKEEPER-2935: [QP MutualAuth]: Port ZOOKEEPER-1045 implementation from  branch-3.5 to trunk.\n\nChange-Id: I2b88221c0006e4336a39f74fd5a87d1aded68c90",
        "tree": {
            "sha": "19f5173a744a232fe26202401aea5d9180d512fa",
            "url": "https://api.github.com/repos/apache/zookeeper/git/trees/19f5173a744a232fe26202401aea5d9180d512fa"
        },
        "url": "https://api.github.com/repos/apache/zookeeper/git/commits/75411ab34a3d53c43c2d508b12314a9788aa417d",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/zookeeper/commits/75411ab34a3d53c43c2d508b12314a9788aa417d",
    "html_url": "https://github.com/apache/zookeeper/commit/75411ab34a3d53c43c2d508b12314a9788aa417d",
    "comments_url": "https://api.github.com/repos/apache/zookeeper/commits/75411ab34a3d53c43c2d508b12314a9788aa417d/comments",
    "author": {
        "login": "afine",
        "id": 223386,
        "node_id": "MDQ6VXNlcjIyMzM4Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/223386?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/afine",
        "html_url": "https://github.com/afine",
        "followers_url": "https://api.github.com/users/afine/followers",
        "following_url": "https://api.github.com/users/afine/following{/other_user}",
        "gists_url": "https://api.github.com/users/afine/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/afine/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/afine/subscriptions",
        "organizations_url": "https://api.github.com/users/afine/orgs",
        "repos_url": "https://api.github.com/users/afine/repos",
        "events_url": "https://api.github.com/users/afine/events{/privacy}",
        "received_events_url": "https://api.github.com/users/afine/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "phunt",
        "id": 15702,
        "node_id": "MDQ6VXNlcjE1NzAy",
        "avatar_url": "https://avatars.githubusercontent.com/u/15702?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/phunt",
        "html_url": "https://github.com/phunt",
        "followers_url": "https://api.github.com/users/phunt/followers",
        "following_url": "https://api.github.com/users/phunt/following{/other_user}",
        "gists_url": "https://api.github.com/users/phunt/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/phunt/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/phunt/subscriptions",
        "organizations_url": "https://api.github.com/users/phunt/orgs",
        "repos_url": "https://api.github.com/users/phunt/repos",
        "events_url": "https://api.github.com/users/phunt/events{/privacy}",
        "received_events_url": "https://api.github.com/users/phunt/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "748585d200da3a137f6ee37ee543d4f32c30d9c6",
            "url": "https://api.github.com/repos/apache/zookeeper/commits/748585d200da3a137f6ee37ee543d4f32c30d9c6",
            "html_url": "https://github.com/apache/zookeeper/commit/748585d200da3a137f6ee37ee543d4f32c30d9c6"
        }
    ],
    "stats": {
        "total": 4151,
        "additions": 3755,
        "deletions": 396
    },
    "files": [
        {
            "sha": "e61f7d748328eaa6f718efa2fccf118f516c87f9",
            "filename": "build.xml",
            "status": "modified",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/build.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/build.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/build.xml?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -79,6 +79,7 @@ xmlns:cs=\"antlib:com.puppycrawl.tools.checkstyle.ant\">\n     <property name=\"test.data.dir\" value=\"${test.java.build.dir}/data\" />\n     <property name=\"test.data.invalid.dir\" value=\"${test.data.dir}/invalidsnap\" />\n     <property name=\"test.data.buffersize.dir\" value=\"${test.data.dir}/buffersize\" />\n+    <property name=\"test.data.kerberos.dir\" value=\"${test.data.dir}/kerberos\" />\n     <property name=\"test.data.ssl.dir\" value=\"${test.data.dir}/ssl\" />\n     <property name=\"test.cppunit.dir\" value=\"${test.java.build.dir}/test-cppunit\"/>\n     <property name=\"test.tmp.dir\" value=\"${test.java.build.dir}/tmp\" />\n@@ -226,6 +227,9 @@ xmlns:cs=\"antlib:com.puppycrawl.tools.checkstyle.ant\">\n     <property name=\"jackson-mapper-asl.version\" value=\"1.9.11\"/>\n     <property name=\"dependency-check-ant.version\" value=\"2.1.0\"/>\n \n+    <property name=\"commons-io.version\" value=\"2.4\"/>\n+    <property name=\"kerby.version\" value=\"1.0.0-RC2\"/>\n+\n     <!-- ====================================================== -->\n     <!-- Macro definitions                                      -->\n     <!-- ====================================================== -->\n@@ -1165,6 +1169,7 @@ xmlns:cs=\"antlib:com.puppycrawl.tools.checkstyle.ant\">\n         <delete dir=\"${test.tmp.dir}\" />\n         <delete dir=\"${test.data.invalid.dir}\" />\n         <delete dir=\"${test.data.buffersize.dir}\" />\n+        <delete dir=\"${test.data.kerberos.dir}\" />\n         <delete dir=\"${test.data.ssl.dir}\" />\n         <delete dir=\"${test.data.dir}\" />\n         <mkdir dir=\"${test.log.dir}\" />\n@@ -1182,6 +1187,10 @@ xmlns:cs=\"antlib:com.puppycrawl.tools.checkstyle.ant\">\n         <copy todir=\"${test.data.ssl.dir}\">\n             <fileset dir=\"${basedir}/src/java/test/data/ssl\"/>\n         </copy>\n+        <mkdir dir=\"${test.data.kerberos.dir}\" />\n+        <copy todir=\"${test.data.kerberos.dir}\">\n+            <fileset dir=\"${basedir}/src/java/test/data/kerberos\"/>\n+        </copy>\n     </target>\n \n     <target name=\"junit-init\" depends=\"test-category\">"
        },
        {
            "sha": "4298aa9f2bb6436ec1c04c917e84137cd534c8a2",
            "filename": "ivy.xml",
            "status": "modified",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/ivy.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/ivy.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/ivy.xml?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -90,6 +90,39 @@\n     <dependency org=\"org.owasp\" name=\"dependency-check-ant\"\n                 rev=\"${dependency-check-ant.version}\" conf=\"owasp->default\"/>\n \n+    <dependency org=\"commons-io\" name=\"commons-io\"\n+                rev=\"${commons-io.version}\" conf=\"test->default\"/>\n+\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-config\" rev=\"${kerby.version}\" conf=\"test->default\">\n+          <exclude org=\"org.slf4j\" module=\"slf4j-api\"/>\n+          <exclude org=\"org.slf4j\" module=\"slf4j-log4j12\"/>\n+    </dependency>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-simplekdc\" rev=\"${kerby.version}\" conf=\"test->default\">\n+        <exclude org=\"org.slf4j\" module=\"slf4j-api\"/>\n+    </dependency>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-core\"\n+                rev=\"${kerby.version}\" conf=\"test->default\">\n+        <exclude org=\"org.slf4j\" module=\"slf4j-api\"/>\n+    </dependency>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-server\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-common\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-admin\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-identity\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-client\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-util\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerb-crypto\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-util\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+    <dependency org=\"org.apache.kerby\" name=\"kerby-asn1\"\n+                rev=\"${kerby.version}\" conf=\"test->default\"/>\n+\n     <dependency org=\"net.java.dev.javacc\" name=\"javacc\" rev=\"${javacc.version}\"\n                 conf=\"javacc->default\" />\n "
        },
        {
            "sha": "d97d6c1fde4eacec2fa4c90e29a439da5c45ca10",
            "filename": "src/java/main/org/apache/zookeeper/Login.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FLogin.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -299,7 +299,7 @@ private synchronized LoginContext login(final String loginContextName) throws Lo\n         }\n         LoginContext loginContext = new LoginContext(loginContextName,callbackHandler);\n         loginContext.login();\n-        LOG.info(\"successfully logged in.\");\n+        LOG.info(\"{} successfully logged in.\", loginContextName);\n         return loginContext;\n     }\n "
        },
        {
            "sha": "d6f554955f05e2015d7c7f3c253be122f4ff45d2",
            "filename": "src/java/main/org/apache/zookeeper/SaslClientCallbackHandler.java",
            "status": "added",
            "additions": 104,
            "deletions": 0,
            "changes": 104,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2FSaslClientCallbackHandler.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,104 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is used by the SASL mechanisms to get further information to complete\n+ * the authentication. For example, a SASL mechanism might use this callback\n+ * handler to do verification operation. The CallbackHandler interface here\n+ * refers to javax.security.auth.callback.CallbackHandler. It should not be\n+ * confused with ZooKeeper packet callbacks like\n+ * org.apache.zookeeper.server.auth.SaslServerCallbackHandler.\n+ */\n+public class SaslClientCallbackHandler implements CallbackHandler {\n+    private String password = null;\n+    private static final Logger LOG = LoggerFactory.getLogger(SaslClientCallbackHandler.class);\n+    private final String entity;\n+    public SaslClientCallbackHandler(String password, String client) {\n+        this.password = password;\n+        this.entity = client;\n+    }\n+\n+    public void handle(Callback[] callbacks) throws UnsupportedCallbackException {\n+        for (Callback callback : callbacks) {\n+            if (callback instanceof NameCallback) {\n+                NameCallback nc = (NameCallback) callback;\n+                nc.setName(nc.getDefaultName());\n+            }\n+            else {\n+                if (callback instanceof PasswordCallback) {\n+                    PasswordCallback pc = (PasswordCallback)callback;\n+                    if (password != null) {\n+                        pc.setPassword(this.password.toCharArray());\n+                    } else {\n+                        LOG.warn(\"Could not login: the {} is being asked for a password, but the ZooKeeper {}\" +\n+                          \" code does not currently support obtaining a password from the user.\" +\n+                          \" Make sure that the {} is configured to use a ticket cache (using\" +\n+                          \" the JAAS configuration setting 'useTicketCache=true)' and restart the {}. If\" +\n+                          \" you still get this message after that, the TGT in the ticket cache has expired and must\" +\n+                          \" be manually refreshed. To do so, first determine if you are using a password or a\" +\n+                          \" keytab. If the former, run kinit in a Unix shell in the environment of the user who\" +\n+                          \" is running this Zookeeper {} using the command\" +\n+                          \" 'kinit <princ>' (where <princ> is the name of the {}'s Kerberos principal).\" +\n+                          \" If the latter, do\" +\n+                          \" 'kinit -k -t <keytab> <princ>' (where <princ> is the name of the Kerberos principal, and\" +\n+                          \" <keytab> is the location of the keytab file). After manually refreshing your cache,\" +\n+                          \" restart this {}. If you continue to see this message after manually refreshing\" +\n+                          \" your cache, ensure that your KDC host's clock is in sync with this host's clock.\",\n+                          new Object[]{entity, entity, entity, entity, entity, entity, entity});\n+                    }\n+                }\n+                else {\n+                    if (callback instanceof RealmCallback) {\n+                        RealmCallback rc = (RealmCallback) callback;\n+                        rc.setText(rc.getDefaultText());\n+                    }\n+                    else {\n+                        if (callback instanceof AuthorizeCallback) {\n+                            AuthorizeCallback ac = (AuthorizeCallback) callback;\n+                            String authid = ac.getAuthenticationID();\n+                            String authzid = ac.getAuthorizationID();\n+                            if (authid.equals(authzid)) {\n+                                ac.setAuthorized(true);\n+                            } else {\n+                                ac.setAuthorized(false);\n+                            }\n+                            if (ac.isAuthorized()) {\n+                                ac.setAuthorizedID(authzid);\n+                            }\n+                        }\n+                        else {\n+                            throw new UnsupportedCallbackException(callback, \"Unrecognized SASL \" + entity + \"Callback\");\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "855062629875a253887694c97ace5c586bac46da",
            "filename": "src/java/main/org/apache/zookeeper/client/ZooKeeperSaslClient.java",
            "status": "modified",
            "additions": 6,
            "deletions": 158,
            "changes": 164,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fclient%2FZooKeeperSaslClient.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -19,40 +19,27 @@\n package org.apache.zookeeper.client;\n \n import java.io.IOException;\n-import java.security.Principal;\n import java.security.PrivilegedActionException;\n import java.security.PrivilegedExceptionAction;\n \n import javax.security.auth.Subject;\n-import javax.security.auth.callback.Callback;\n-import javax.security.auth.callback.CallbackHandler;\n-import javax.security.auth.callback.NameCallback;\n-import javax.security.auth.callback.PasswordCallback;\n-import javax.security.auth.callback.UnsupportedCallbackException;\n import javax.security.auth.login.AppConfigurationEntry;\n import javax.security.auth.login.Configuration;\n import javax.security.auth.login.LoginException;\n-import javax.security.sasl.AuthorizeCallback;\n-import javax.security.sasl.RealmCallback;\n-import javax.security.sasl.Sasl;\n import javax.security.sasl.SaslClient;\n import javax.security.sasl.SaslException;\n \n import org.apache.zookeeper.AsyncCallback;\n import org.apache.zookeeper.ClientCnxn;\n import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n import org.apache.zookeeper.Watcher.Event.KeeperState;\n import org.apache.zookeeper.ZooDefs;\n-import org.apache.zookeeper.common.ZKConfig;\n import org.apache.zookeeper.data.Stat;\n import org.apache.zookeeper.proto.GetSASLRequest;\n import org.apache.zookeeper.proto.SetSASLResponse;\n-import org.apache.zookeeper.server.auth.KerberosName;\n-import org.ietf.jgss.GSSContext;\n-import org.ietf.jgss.GSSCredential;\n-import org.ietf.jgss.GSSException;\n-import org.ietf.jgss.GSSManager;\n-import org.ietf.jgss.Oid;\n+\n+import org.apache.zookeeper.util.SecurityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -259,84 +246,14 @@ private SaslClient createSaslClient(final String servicePrincipal, final String\n                         }\n                         // note that the login object is static: it's shared amongst all zookeeper-related connections.\n                         // in order to ensure the login is initialized only once, it must be synchronized the code snippet.\n-                        login = new Login(loginContext, new ClientCallbackHandler(null), clientConfig);\n+                        login = new Login(loginContext, new SaslClientCallbackHandler(null, \"Client\"), clientConfig);\n                         login.startThreadIfNeeded();\n                         initializedLogin = true;\n                     }\n                 }\n             }\n-            Subject subject = login.getSubject();\n-            SaslClient saslClient;\n-            // Use subject.getPrincipals().isEmpty() as an indication of which SASL mechanism to use:\n-            // if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n-            if (subject.getPrincipals().isEmpty()) {\n-                // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism instead.\n-                LOG.info(\"Client will use DIGEST-MD5 as SASL mechanism.\");\n-                String[] mechs = {\"DIGEST-MD5\"};\n-                String username = (String)(subject.getPublicCredentials().toArray()[0]);\n-                String password = (String)(subject.getPrivateCredentials().toArray()[0]);\n-                // \"zk-sasl-md5\" is a hard-wired 'domain' parameter shared with zookeeper server code (see ServerCnxnFactory.java)\n-                saslClient = Sasl.createSaslClient(mechs, username, \"zookeeper\", \"zk-sasl-md5\", null, new ClientCallbackHandler(password));\n-                return saslClient;\n-            }\n-            else { // GSSAPI.\n-                boolean usingNativeJgss = clientConfig.getBoolean(ZKConfig.JGSS_NATIVE);\n-            \tif (usingNativeJgss) {\n-            \t\t// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n-            \t\t// \"\"\"\n-            \t\t// In addition, when performing operations as a particular\n-            \t\t// Subject, e.g. Subject.doAs(...) or Subject.doAsPrivileged(...),\n-            \t\t// the to-be-used GSSCredential should be added to Subject's\n-            \t\t// private credential set. Otherwise, the GSS operations will\n-            \t\t// fail since no credential is found.\n-            \t\t// \"\"\"\n-            \t\ttry {\n-            \t\t\tGSSManager manager = GSSManager.getInstance();\n-            \t\t\tOid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n-            \t\t\tGSSCredential cred = manager.createCredential(null,\n-            \t\t\t\t\tGSSContext.DEFAULT_LIFETIME,\n-            \t\t\t\t\tkrb5Mechanism,\n-            \t\t\t\t\tGSSCredential.INITIATE_ONLY);\n-            \t\t\tsubject.getPrivateCredentials().add(cred);\n-            \t\t\tif (LOG.isDebugEnabled()) {\n-            \t\t\t\tLOG.debug(\"Added private credential to subject: \" + cred);\n-            \t\t\t}\n-            \t\t} catch (GSSException ex) {\n-            \t\t\tLOG.warn(\"Cannot add private credential to subject; \" +\n-            \t\t\t\t\t\"authentication at the server may fail\", ex);\n-            \t\t}\n-            \t}\n-                final Object[] principals = subject.getPrincipals().toArray();\n-                // determine client principal from subject.\n-                final Principal clientPrincipal = (Principal)principals[0];\n-                final KerberosName clientKerberosName = new KerberosName(clientPrincipal.getName());\n-                // assume that server and client are in the same realm (by default; unless the system property\n-                // \"zookeeper.server.realm\" is set).\n-                String serverRealm = clientConfig.getProperty(\n-                        ZKClientConfig.ZOOKEEPER_SERVER_REALM,\n-                        clientKerberosName.getRealm());\n-                KerberosName serviceKerberosName = new KerberosName(servicePrincipal+\"@\"+serverRealm);\n-                final String serviceName = serviceKerberosName.getServiceName();\n-                final String serviceHostname = serviceKerberosName.getHostName();\n-                final String clientPrincipalName = clientKerberosName.toString();\n-                try {\n-                    saslClient = Subject.doAs(subject,new PrivilegedExceptionAction<SaslClient>() {\n-                        public SaslClient run() throws SaslException {\n-                            LOG.info(\"Client will use GSSAPI as SASL mechanism.\");\n-                            String[] mechs = {\"GSSAPI\"};\n-                            LOG.debug(\"creating sasl client: client=\"+clientPrincipalName+\";service=\"+serviceName+\";serviceHostname=\"+serviceHostname);\n-                            SaslClient saslClient = Sasl.createSaslClient(mechs,clientPrincipalName,serviceName,serviceHostname,null,new ClientCallbackHandler(null));\n-                            return saslClient;\n-                        }\n-                    });\n-                    return saslClient;\n-                }\n-                catch (Exception e) {\n-                \tLOG.error(\"Exception while trying to create SASL client\", e);\n-                    e.printStackTrace();\n-                    return null;\n-                }\n-            }\n+            return SecurityUtils.createSaslClient(login.getSubject(),\n+                    servicePrincipal, \"zookeeper\", \"zk-sasl-md5\", LOG, \"Client\");\n         } catch (LoginException e) {\n             // We throw LoginExceptions...\n             throw e;\n@@ -505,75 +422,6 @@ public void initialize(ClientCnxn cnxn) throws SaslException {\n         }\n     }\n \n-    // The CallbackHandler interface here refers to\n-    // javax.security.auth.callback.CallbackHandler.\n-    // It should not be confused with Zookeeper packet callbacks like\n-    //  org.apache.zookeeper.server.auth.SaslServerCallbackHandler.\n-    public static class ClientCallbackHandler implements CallbackHandler {\n-        private String password = null;\n-\n-        public ClientCallbackHandler(String password) {\n-            this.password = password;\n-        }\n-\n-        public void handle(Callback[] callbacks) throws\n-          UnsupportedCallbackException {\n-            for (Callback callback : callbacks) {\n-                if (callback instanceof NameCallback) {\n-                    NameCallback nc = (NameCallback) callback;\n-                    nc.setName(nc.getDefaultName());\n-                }\n-                else {\n-                    if (callback instanceof PasswordCallback) {\n-                        PasswordCallback pc = (PasswordCallback)callback;\n-                        if (password != null) {\n-                            pc.setPassword(this.password.toCharArray());\n-                        } else {\n-                            LOG.warn(\"Could not login: the client is being asked for a password, but the Zookeeper\" +\n-                              \" client code does not currently support obtaining a password from the user.\" +\n-                              \" Make sure that the client is configured to use a ticket cache (using\" +\n-                              \" the JAAS configuration setting 'useTicketCache=true)' and restart the client. If\" +\n-                              \" you still get this message after that, the TGT in the ticket cache has expired and must\" +\n-                              \" be manually refreshed. To do so, first determine if you are using a password or a\" +\n-                              \" keytab. If the former, run kinit in a Unix shell in the environment of the user who\" +\n-                              \" is running this Zookeeper client using the command\" +\n-                              \" 'kinit <princ>' (where <princ> is the name of the client's Kerberos principal).\" +\n-                              \" If the latter, do\" +\n-                              \" 'kinit -k -t <keytab> <princ>' (where <princ> is the name of the Kerberos principal, and\" +\n-                              \" <keytab> is the location of the keytab file). After manually refreshing your cache,\" +\n-                              \" restart this client. If you continue to see this message after manually refreshing\" +\n-                              \" your cache, ensure that your KDC host's clock is in sync with this host's clock.\");\n-                        }\n-                    }\n-                    else {\n-                        if (callback instanceof RealmCallback) {\n-                            RealmCallback rc = (RealmCallback) callback;\n-                            rc.setText(rc.getDefaultText());\n-                        }\n-                        else {\n-                            if (callback instanceof AuthorizeCallback) {\n-                                AuthorizeCallback ac = (AuthorizeCallback) callback;\n-                                String authid = ac.getAuthenticationID();\n-                                String authzid = ac.getAuthorizationID();\n-                                if (authid.equals(authzid)) {\n-                                    ac.setAuthorized(true);\n-                                } else {\n-                                    ac.setAuthorized(false);\n-                                }\n-                                if (ac.isAuthorized()) {\n-                                    ac.setAuthorizedID(authzid);\n-                                }\n-                            }\n-                            else {\n-                                throw new UnsupportedCallbackException(callback,\"Unrecognized SASL ClientCallback\");\n-                            }\n-                        }\n-                    }\n-                }\n-            }\n-        }\n-    }\n-\n     public boolean clientTunneledAuthenticationInProgress() {\n     \tif (!isSASLConfigured) {\n     \t    return false;"
        },
        {
            "sha": "f8a90cfda2c3913890c2c82d36bad55c648ee720",
            "filename": "src/java/main/org/apache/zookeeper/server/ServerCnxn.java",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxn.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxn.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FServerCnxn.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -24,7 +24,13 @@\n import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n import java.security.cert.Certificate;\n-import java.util.*;\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Date;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ConcurrentHashMap;\n import java.util.concurrent.atomic.AtomicLong;\n "
        },
        {
            "sha": "af19e5d2b2c3410b8d0e8eaed1a6f0dc6eea1c75",
            "filename": "src/java/main/org/apache/zookeeper/server/ZooKeeperSaslServer.java",
            "status": "modified",
            "additions": 3,
            "deletions": 118,
            "changes": 121,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperSaslServer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -18,22 +18,12 @@\n \n package org.apache.zookeeper.server;\n \n-import java.security.Principal;\n-import java.security.PrivilegedActionException;\n-import java.security.PrivilegedExceptionAction;\n-\n import javax.security.auth.Subject;\n-import javax.security.sasl.Sasl;\n import javax.security.sasl.SaslException;\n import javax.security.sasl.SaslServer;\n \n import org.apache.zookeeper.Login;\n-import org.ietf.jgss.GSSContext;\n-import org.ietf.jgss.GSSCredential;\n-import org.ietf.jgss.GSSException;\n-import org.ietf.jgss.GSSManager;\n-import org.ietf.jgss.GSSName;\n-import org.ietf.jgss.Oid;\n+import org.apache.zookeeper.util.SecurityUtils;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n@@ -51,114 +41,9 @@ public class ZooKeeperSaslServer {\n     private SaslServer createSaslServer(final Login login) {\n         synchronized (login) {\n             Subject subject = login.getSubject();\n-            if (subject != null) {\n-                // server is using a JAAS-authenticated subject: determine service principal name and hostname from zk server's subject.\n-                if (subject.getPrincipals().size() > 0) {\n-                    try {\n-                        final Object[] principals = subject.getPrincipals().toArray();\n-                        final Principal servicePrincipal = (Principal)principals[0];\n-\n-                        // e.g. servicePrincipalNameAndHostname := \"zookeeper/myhost.foo.com@FOO.COM\"\n-                        final String servicePrincipalNameAndHostname = servicePrincipal.getName();\n-\n-                        int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n-\n-                        // e.g. serviceHostnameAndKerbDomain := \"myhost.foo.com@FOO.COM\"\n-                        final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname.substring(indexOf+1,servicePrincipalNameAndHostname.length());\n-\n-                        int indexOfAt = serviceHostnameAndKerbDomain.indexOf(\"@\");\n-\n-                        // Handle Kerberos Service as well as User Principal Names\n-                        final String servicePrincipalName, serviceHostname;\n-                        if (indexOf > 0){\n-                            // e.g. servicePrincipalName := \"zookeeper\"\n-                            servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOf);\n-                            // e.g. serviceHostname := \"myhost.foo.com\"\n-                            serviceHostname = serviceHostnameAndKerbDomain.substring(0, indexOfAt);\n-                        } else {\n-                            servicePrincipalName = servicePrincipalNameAndHostname.substring(0, indexOfAt);\n-                            serviceHostname = null;\n-                        }\n-                        \n-                        final String mech = \"GSSAPI\";   // TODO: should depend on zoo.cfg specified mechs, but if subject is non-null, it can be assumed to be GSSAPI.\n-\n-                        LOG.debug(\"serviceHostname is '\"+ serviceHostname + \"'\");\n-                        LOG.debug(\"servicePrincipalName is '\"+ servicePrincipalName + \"'\");\n-                        LOG.debug(\"SASL mechanism(mech) is '\"+ mech +\"'\");\n-\n-                        boolean usingNativeJgss =\n-                        \t\tBoolean.getBoolean(\"sun.security.jgss.native\");\n-                        if (usingNativeJgss) {\n-                        \t// http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n-                        \t// \"\"\"\n-                        \t// In addition, when performing operations as a particular\n-                        \t// Subject, e.g. Subject.doAs(...) or\n-                        \t// Subject.doAsPrivileged(...), the to-be-used\n-                        \t// GSSCredential should be added to Subject's\n-                        \t// private credential set. Otherwise, the GSS operations\n-                        \t// will fail since no credential is found.\n-                        \t// \"\"\"\n-                        \ttry {\n-                        \t\tGSSManager manager = GSSManager.getInstance();\n-                        \t\tOid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n-                        \t\tGSSName gssName = manager.createName(\n-                        \t\t\t\tservicePrincipalName + \"@\" + serviceHostname,\n-                        \t\t\t\tGSSName.NT_HOSTBASED_SERVICE);\n-                        \t\tGSSCredential cred = manager.createCredential(gssName,\n-                        \t\t\t\tGSSContext.DEFAULT_LIFETIME,\n-                        \t\t\t\tkrb5Mechanism,\n-                        \t\t\t\tGSSCredential.ACCEPT_ONLY);\n-                        \t\tsubject.getPrivateCredentials().add(cred);\n-                        \t\tif (LOG.isDebugEnabled()) {\n-                        \t\t\tLOG.debug(\"Added private credential to subject: \" + cred);\n-                        \t\t}\n-                        \t} catch (GSSException ex) {\n-                        \t\tLOG.warn(\"Cannot add private credential to subject; \" +\n-                        \t\t\t\t\"clients authentication may fail\", ex);\n-                        \t}\n-                        }\n-                        try {\n-                            return Subject.doAs(subject,new PrivilegedExceptionAction<SaslServer>() {\n-                                public SaslServer run() {\n-                                    try {\n-                                        SaslServer saslServer;\n-                                        saslServer = Sasl.createSaslServer(mech, servicePrincipalName, serviceHostname, null, login.callbackHandler);\n-                                        return saslServer;\n-                                    }\n-                                    catch (SaslException e) {\n-                                        LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: \" + e);\n-                                        e.printStackTrace();\n-                                        return null;\n-                                    }\n-                                }\n-                            }\n-                            );\n-                        }\n-                        catch (PrivilegedActionException e) {\n-                            // TODO: exit server at this point(?)\n-                            LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context:\" + e);\n-                            e.printStackTrace();\n-                        }\n-                    }\n-                    catch (IndexOutOfBoundsException e) {\n-                        LOG.error(\"server principal name/hostname determination error: \", e);\n-                    }\n-                }\n-                else {\n-                    // JAAS non-GSSAPI authentication: assuming and supporting only DIGEST-MD5 mechanism for now.\n-                    // TODO: use 'authMech=' value in zoo.cfg.\n-                    try {\n-                        SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\",\"zookeeper\",\"zk-sasl-md5\",null, login.callbackHandler);\n-                        return saslServer;\n-                    }\n-                    catch (SaslException e) {\n-                        LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n-                    }\n-                }\n-            }\n+            return SecurityUtils.createSaslServer(subject, \"zookeeper\",\n+                    \"zk-sasl-md5\", login.callbackHandler, LOG);\n         }\n-        LOG.error(\"failed to create saslServer object.\");\n-        return null;\n     }\n \n     public byte[] evaluateResponse(byte[] response) throws SaslException {"
        },
        {
            "sha": "3ac1ddda4363172f006f630973a61148f713fd9f",
            "filename": "src/java/main/org/apache/zookeeper/server/ZooKeeperServer.java",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2FZooKeeperServer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -61,6 +61,7 @@\n import org.apache.zookeeper.server.ServerCnxn.CloseRequestException;\n import org.apache.zookeeper.server.SessionTracker.Session;\n import org.apache.zookeeper.server.SessionTracker.SessionExpirer;\n+import org.apache.zookeeper.server.auth.AuthenticationProvider;\n import org.apache.zookeeper.server.auth.ProviderRegistry;\n import org.apache.zookeeper.server.auth.ServerAuthenticationProvider;\n import org.apache.zookeeper.server.persistence.FileTxnSnapLog;"
        },
        {
            "sha": "9f53a4d1c17d843ee3785bb4d520bd8bf55baf06",
            "filename": "src/java/main/org/apache/zookeeper/server/auth/SaslServerCallbackHandler.java",
            "status": "modified",
            "additions": 6,
            "deletions": 4,
            "changes": 10,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fauth%2FSaslServerCallbackHandler.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -46,13 +46,15 @@ public class SaslServerCallbackHandler implements CallbackHandler {\n     private String userName;\n     private final Map<String,String> credentials = new HashMap<String,String>();\n \n-    public SaslServerCallbackHandler(Configuration configuration) throws IOException {\n-        String serverSection = System.getProperty(ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY,\n-                                                  ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n+    public SaslServerCallbackHandler(Configuration configuration)\n+            throws IOException {\n+        String serverSection = System.getProperty(\n+                ZooKeeperSaslServer.LOGIN_CONTEXT_NAME_KEY,\n+                ZooKeeperSaslServer.DEFAULT_LOGIN_CONTEXT_NAME);\n         AppConfigurationEntry configurationEntries[] = configuration.getAppConfigurationEntry(serverSection);\n \n         if (configurationEntries == null) {\n-            String errorMessage = \"Could not find a 'Server' entry in this configuration: Server cannot start.\";\n+            String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n             LOG.error(errorMessage);\n             throw new IOException(errorMessage);\n         }"
        },
        {
            "sha": "f1112b7753f8fac54335f204109faf8b3cd9c6d3",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/FastLeaderElection.java",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFastLeaderElection.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -1078,6 +1078,8 @@ && checkLeader(outofelection, n.leader, IGNOREVALUE)) {\n                 LOG.warn(\"Failed to unregister with JMX\", e);\n             }\n             self.jmxLeaderElectionBean = null;\n+            LOG.debug(\"Number of connection processing threads: {}\",\n+                    manager.getConnectionThreadCount());\n         }\n     }\n }"
        },
        {
            "sha": "84d29c8ae7e20fef2a56d61c1eb13f109ac73c08",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Follower.java",
            "status": "modified",
            "additions": 3,
            "deletions": 2,
            "changes": 5,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFollower.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -27,6 +27,7 @@\n import org.apache.zookeeper.common.Time;\n import org.apache.zookeeper.server.Request;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.util.SerializeUtils;\n import org.apache.zookeeper.server.util.ZxidUtils;\n import org.apache.zookeeper.txn.SetDataTxn;\n@@ -71,9 +72,9 @@ void followLeader() throws InterruptedException {\n         self.end_fle = 0;\n         fzk.registerJMX(new FollowerBean(this, zk), self.jmxLocalPeerBean);\n         try {\n-            InetSocketAddress addr = findLeader();            \n+            QuorumServer leaderServer = findLeader();\n             try {\n-                connectToLeader(addr);\n+                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                 long newEpochZxid = registerWithLeader(Leader.FOLLOWERINFO);\n                 if (self.isReconfigStateChange())\n                    throw new Exception(\"learned about role change\");"
        },
        {
            "sha": "cebf2e3c9a1a1dbaa0ab04c310bab67475fe0a3b",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Leader.java",
            "status": "modified",
            "additions": 9,
            "deletions": 1,
            "changes": 10,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLeader.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -19,6 +19,7 @@\n package org.apache.zookeeper.server.quorum;\n \n import java.io.ByteArrayOutputStream;\n+import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.net.BindException;\n import java.net.ServerSocket;\n@@ -39,6 +40,8 @@\n import java.util.concurrent.ConcurrentLinkedQueue;\n import java.util.concurrent.ConcurrentMap;\n \n+import javax.security.sasl.SaslException;\n+\n import org.apache.jute.BinaryOutputArchive;\n import org.apache.zookeeper.ZooDefs.OpCode;\n import org.apache.zookeeper.common.Time;\n@@ -367,7 +370,10 @@ public void run() {\n                         // in LearnerHandler switch to the syncLimit\n                         s.setSoTimeout(self.tickTime * self.initLimit);\n                         s.setTcpNoDelay(nodelay);\n-                        LearnerHandler fh = new LearnerHandler(s, Leader.this);\n+\n+                        BufferedInputStream is = new BufferedInputStream(\n+                                s.getInputStream());\n+                        LearnerHandler fh = new LearnerHandler(s, is, Leader.this);\n                         fh.start();\n                     } catch (SocketException e) {\n                         if (stop) {\n@@ -381,6 +387,8 @@ public void run() {\n                         } else {\n                             throw e;\n                         }\n+                    } catch (SaslException e){\n+                        LOG.error(\"Exception while connecting to quorum learner\", e);\n                     }\n                 }\n             } catch (Exception e) {"
        },
        {
            "sha": "a37cc93247acd2b259ebb1d9590e136afb860684",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Learner.java",
            "status": "modified",
            "additions": 12,
            "deletions": 6,
            "changes": 18,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearner.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -50,6 +50,8 @@\n import org.apache.zookeeper.server.util.ZxidUtils;\n import org.apache.zookeeper.txn.SetDataTxn;\n import org.apache.zookeeper.txn.TxnHeader;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n \n /**\n  * This class is the superclass of two of the three main actors in a ZK\n@@ -193,21 +195,21 @@ void request(Request request) throws IOException {\n     /**\n      * Returns the address of the node we think is the leader.\n      */\n-    protected InetSocketAddress findLeader() {\n-        InetSocketAddress addr = null;\n+    protected QuorumServer findLeader() {\n+        QuorumServer leaderServer = null;\n         // Find the leader by id\n         Vote current = self.getCurrentVote();\n         for (QuorumServer s : self.getView().values()) {\n             if (s.id == current.getId()) {\n-                addr = s.addr;\n+                leaderServer = s;\n                 break;\n             }\n         }\n-        if (addr == null) {\n+        if (leaderServer == null) {\n             LOG.warn(\"Couldn't find the leader with id = \"\n                     + current.getId());\n         }\n-        return addr;\n+        return leaderServer;\n     }\n    \n     /**\n@@ -232,10 +234,11 @@ protected void sockConnect(Socket sock, InetSocketAddress addr, int timeout)\n      * until either initLimit time has elapsed or 5 tries have happened. \n      * @param addr - the address of the Leader to connect to.\n      * @throws IOException - if the socket connection fails on the 5th attempt\n+     * <li>if there is an authentication failure while connecting to leader</li>\n      * @throws ConnectException\n      * @throws InterruptedException\n      */\n-    protected void connectToLeader(InetSocketAddress addr) \n+    protected void connectToLeader(InetSocketAddress addr, String hostname)\n     throws IOException, ConnectException, InterruptedException {\n         sock = new Socket();        \n         sock.setSoTimeout(self.tickTime * self.initLimit);\n@@ -279,6 +282,9 @@ protected void connectToLeader(InetSocketAddress addr)\n             }\n             Thread.sleep(1000);\n         }\n+\n+        self.authLearner.authenticate(sock, hostname);\n+\n         leaderIs = BinaryInputArchive.getArchive(new BufferedInputStream(\n                 sock.getInputStream()));\n         bufferedOutput = new BufferedOutputStream(sock.getOutputStream());"
        },
        {
            "sha": "7247f5cbbd9f5f41e3360bfe11227bec5da0222c",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/LearnerHandler.java",
            "status": "modified",
            "additions": 23,
            "deletions": 4,
            "changes": 27,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandler.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -33,6 +33,8 @@\n import java.util.concurrent.locks.ReentrantReadWriteLock;\n import java.util.concurrent.locks.ReentrantReadWriteLock.ReadLock;\n \n+import javax.security.sasl.SaslException;\n+\n import org.apache.jute.BinaryInputArchive;\n import org.apache.jute.BinaryOutputArchive;\n import org.apache.jute.Record;\n@@ -155,6 +157,7 @@ public synchronized boolean check(long time) {\n \n     private BinaryOutputArchive oa;\n \n+    private final BufferedInputStream bufferedInput;\n     private BufferedOutputStream bufferedOutput;\n     \n     /**\n@@ -179,11 +182,27 @@ public synchronized boolean check(long time) {\n      */\n     private long leaderLastZxid;\n \n-    LearnerHandler(Socket sock, Leader leader) throws IOException {\n+    LearnerHandler(Socket sock, BufferedInputStream bufferedInput,Leader leader) throws IOException {\n         super(\"LearnerHandler-\" + sock.getRemoteSocketAddress());\n         this.sock = sock;\n         this.leader = leader;\n-        leader.addLearnerHandler(this);\n+        this.bufferedInput = bufferedInput;\n+\n+        try {\n+            if (leader.self != null) {\n+                leader.self.authServer.authenticate(sock,\n+                        new DataInputStream(bufferedInput));\n+            }\n+        } catch (IOException e) {\n+            LOG.error(\"Server failed to authenticate quorum learner, addr: {}, closing connection\",\n+                    sock.getRemoteSocketAddress(), e);\n+            try {\n+                sock.close();\n+            } catch (IOException ie) {\n+                LOG.error(\"Exception while closing socket\", ie);\n+            }\n+            throw new SaslException(\"Authentication failure: \" + e.getMessage());\n+        }\n     }\n \n     @Override\n@@ -343,11 +362,11 @@ static public String packetToString(QuorumPacket p) {\n     @Override\n     public void run() {\n         try {\n+            leader.addLearnerHandler(this);\n             tickOfNextAckDeadline = leader.self.tick.get()\n                     + leader.self.initLimit + leader.self.syncLimit;\n \n-            ia = BinaryInputArchive.getArchive(new BufferedInputStream(sock\n-                    .getInputStream()));\n+            ia = BinaryInputArchive.getArchive(bufferedInput);\n             bufferedOutput = new BufferedOutputStream(sock.getOutputStream());\n             oa = BinaryOutputArchive.getArchive(bufferedOutput);\n "
        },
        {
            "sha": "f0f724e5e6f27e6888b8908fc23c92cccf859198",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/Observer.java",
            "status": "modified",
            "additions": 4,
            "deletions": 4,
            "changes": 8,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FObserver.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -19,12 +19,12 @@\n package org.apache.zookeeper.server.quorum;\n \n import java.io.IOException;\n-import java.net.InetSocketAddress;\n import java.nio.ByteBuffer;\n \n import org.apache.jute.Record;\n import org.apache.zookeeper.server.ObserverBean;\n import org.apache.zookeeper.server.Request;\n+import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n import org.apache.zookeeper.server.util.SerializeUtils;\n import org.apache.zookeeper.txn.SetDataTxn;\n@@ -63,10 +63,10 @@ void observeLeader() throws Exception {\n         zk.registerJMX(new ObserverBean(this, zk), self.jmxLocalPeerBean);\n \n         try {\n-            InetSocketAddress addr = findLeader();\n-            LOG.info(\"Observing \" + addr);\n+            QuorumServer leaderServer = findLeader();\n+            LOG.info(\"Observing \" + leaderServer.addr);\n             try {\n-                connectToLeader(addr);\n+                connectToLeader(leaderServer.addr, leaderServer.hostname);\n                 long newLeaderZxid = registerWithLeader(Leader.OBSERVERINFO);\n                 if (self.isReconfigStateChange())\n                    throw new Exception(\"learned about role change\");"
        },
        {
            "sha": "09da63a48a39d81dc5c4a50d03ccefd5e419826f",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumCnxManager.java",
            "status": "modified",
            "additions": 267,
            "deletions": 33,
            "changes": 300,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumCnxManager.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -18,6 +18,7 @@\n \n package org.apache.zookeeper.server.quorum;\n \n+import java.io.BufferedInputStream;\n import java.io.BufferedOutputStream;\n import java.io.DataInputStream;\n import java.io.DataOutputStream;\n@@ -30,15 +31,24 @@\n import java.nio.BufferUnderflowException;\n import java.nio.ByteBuffer;\n import java.nio.channels.UnresolvedAddressException;\n+import java.util.Collections;\n import java.util.Enumeration;\n+import java.util.HashSet;\n import java.util.Map;\n+import java.util.Set;\n import java.util.concurrent.ArrayBlockingQueue;\n import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.SynchronousQueue;\n+import java.util.concurrent.ThreadFactory;\n+import java.util.concurrent.ThreadPoolExecutor;\n import java.util.concurrent.TimeUnit;\n import java.util.NoSuchElementException;\n import java.util.concurrent.atomic.AtomicInteger;\n+import java.util.concurrent.atomic.AtomicLong;\n \n import org.apache.zookeeper.server.ZooKeeperThread;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n@@ -79,8 +89,8 @@ public class QuorumCnxManager {\n     /*\n      * Negative counter for observer server ids.\n      */\n-    \n-    private long observerCounter = -1;\n+\n+    private AtomicLong observerCounter = new AtomicLong(-1);\n \n     /*\n      * Protocol identifier used among peers\n@@ -97,11 +107,26 @@ public class QuorumCnxManager {\n      */\n     \n     private int cnxTO = 5000;\n-    \n+\n+    final QuorumPeer self;\n+\n     /*\n      * Local IP address\n      */\n-    final QuorumPeer self;\n+    final long mySid;\n+    final int socketTimeout;\n+    final Map<Long, QuorumPeer.QuorumServer> view;\n+    final boolean listenOnAllIPs;\n+    private ThreadPoolExecutor connectionExecutor;\n+    private final Set<Long> inprogressConnections = Collections\n+            .synchronizedSet(new HashSet<Long>());\n+    private QuorumAuthServer authServer;\n+    private QuorumAuthLearner authLearner;\n+    private boolean quorumSaslAuthEnabled;\n+    /*\n+     * Counter to count connection processing threads.\n+     */\n+    private AtomicInteger connectionThreadCnt = new AtomicInteger(0);\n \n     /*\n      * Mapping from Peer to Thread number\n@@ -217,7 +242,15 @@ static public InitialMessage parse(Long protocolVersion, DataInputStream din)\n         }\n     }\n \n-    public QuorumCnxManager(QuorumPeer self) {\n+    public QuorumCnxManager(QuorumPeer self,\n+                            final long mySid,\n+                            Map<Long,QuorumPeer.QuorumServer> view,\n+                            QuorumAuthServer authServer,\n+                            QuorumAuthLearner authLearner,\n+                            int socketTimeout,\n+                            boolean listenOnAllIPs,\n+                            int quorumCnxnThreadsSize,\n+                            boolean quorumSaslAuthEnabled) {\n         this.recvQueue = new ArrayBlockingQueue<Message>(RECV_CAPACITY);\n         this.queueSendMap = new ConcurrentHashMap<Long, ArrayBlockingQueue<ByteBuffer>>();\n         this.senderWorkerMap = new ConcurrentHashMap<Long, SendWorker>();\n@@ -230,11 +263,54 @@ public QuorumCnxManager(QuorumPeer self) {\n         \n         this.self = self;\n \n-        // Starts listener thread that waits for connection requests \n+        this.mySid = mySid;\n+        this.socketTimeout = socketTimeout;\n+        this.view = view;\n+        this.listenOnAllIPs = listenOnAllIPs;\n+\n+        initializeAuth(mySid, authServer, authLearner, quorumCnxnThreadsSize,\n+                quorumSaslAuthEnabled);\n+\n+        // Starts listener thread that waits for connection requests\n         listener = new Listener();\n         listener.setName(\"QuorumPeerListener\");\n     }\n \n+    private void initializeAuth(final long mySid,\n+                                final QuorumAuthServer authServer,\n+                                final QuorumAuthLearner authLearner,\n+                                final int quorumCnxnThreadsSize,\n+                                final boolean quorumSaslAuthEnabled) {\n+        this.authServer = authServer;\n+        this.authLearner = authLearner;\n+        this.quorumSaslAuthEnabled = quorumSaslAuthEnabled;\n+        if (!this.quorumSaslAuthEnabled) {\n+            LOG.debug(\"Not initializing connection executor as quorum sasl auth is disabled\");\n+            return;\n+        }\n+\n+        // init connection executors\n+        final AtomicInteger threadIndex = new AtomicInteger(1);\n+        SecurityManager s = System.getSecurityManager();\n+        final ThreadGroup group = (s != null) ? s.getThreadGroup()\n+                : Thread.currentThread().getThreadGroup();\n+        ThreadFactory daemonThFactory = new ThreadFactory() {\n+\n+            @Override\n+            public Thread newThread(Runnable r) {\n+                Thread t = new Thread(group, r, \"QuorumConnectionThread-\"\n+                        + \"[myid=\" + mySid + \"]-\"\n+                        + threadIndex.getAndIncrement());\n+                return t;\n+            }\n+        };\n+        this.connectionExecutor = new ThreadPoolExecutor(3,\n+                quorumCnxnThreadsSize, 60, TimeUnit.SECONDS,\n+                new SynchronousQueue<Runnable>(), daemonThFactory);\n+        this.connectionExecutor.allowCoreThreadTimeOut(true);\n+    }\n+\n+\n     /**\n      * Invokes initiateConnection for testing purposes\n      * \n@@ -247,17 +323,80 @@ public void testInitiateConnection(long sid) throws Exception {\n         sock.connect(self.getVotingView().get(sid).electionAddr, cnxTO);\n         initiateConnection(sock, sid);\n     }\n-    \n+\n     /**\n      * If this server has initiated the connection, then it gives up on the\n      * connection if it loses challenge. Otherwise, it keeps the connection.\n      */\n-    public boolean initiateConnection(Socket sock, Long sid) {\n+    public void initiateConnection(final Socket sock, final Long sid) {\n+        try {\n+            startConnection(sock, sid);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception while connecting, id: {}, addr: {}, closing learner connection\",\n+                    new Object[] { sid, sock.getRemoteSocketAddress() }, e);\n+            closeSocket(sock);\n+            return;\n+        }\n+    }\n+\n+    /**\n+     * Server will initiate the connection request to its peer server\n+     * asynchronously via separate connection thread.\n+     */\n+    public void initiateConnectionAsync(final Socket sock, final Long sid) {\n+        if(!inprogressConnections.add(sid)){\n+            // simply return as there is a connection request to\n+            // server 'sid' already in progress.\n+            LOG.debug(\"Connection request to server id: {} is already in progress, so skipping this request\",\n+                    sid);\n+            closeSocket(sock);\n+            return;\n+        }\n+        try {\n+            connectionExecutor.execute(\n+                    new QuorumConnectionReqThread(sock, sid));\n+            connectionThreadCnt.incrementAndGet();\n+        } catch (Throwable e) {\n+            // Imp: Safer side catching all type of exceptions and remove 'sid'\n+            // from inprogress connections. This is to avoid blocking further\n+            // connection requests from this 'sid' in case of errors.\n+            inprogressConnections.remove(sid);\n+            LOG.error(\"Exception while submitting quorum connection request\", e);\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Thread to send connection request to peer server.\n+     */\n+    private class QuorumConnectionReqThread extends ZooKeeperThread {\n+        final Socket sock;\n+        final Long sid;\n+        QuorumConnectionReqThread(final Socket sock, final Long sid) {\n+            super(\"QuorumConnectionReqThread-\" + sid);\n+            this.sock = sock;\n+            this.sid = sid;\n+        }\n+\n+        @Override\n+        public void run() {\n+            try{\n+                initiateConnection(sock, sid);\n+            } finally {\n+                inprogressConnections.remove(sid);\n+            }\n+        }\n+    }\n+\n+    private boolean startConnection(Socket sock, Long sid)\n+            throws IOException {\n+        DataOutputStream dout = null;\n+        DataInputStream din = null;\n         try {\n             // Use BufferedOutputStream to reduce the number of IP packets. This is\n             // important for x-DC scenarios.\n             BufferedOutputStream buf = new BufferedOutputStream(sock.getOutputStream());\n-            DataOutputStream dout = new DataOutputStream(buf);\n+            dout = new DataOutputStream(buf);\n \n             // Sending id and challenge\n \n@@ -269,12 +408,22 @@ public boolean initiateConnection(Socket sock, Long sid) {\n             dout.writeInt(addr_bytes.length);\n             dout.write(addr_bytes);\n             dout.flush();\n+\n+            din = new DataInputStream(\n+                    new BufferedInputStream(sock.getInputStream()));\n         } catch (IOException e) {\n             LOG.warn(\"Ignoring exception reading or writing challenge: \", e);\n             closeSocket(sock);\n             return false;\n         }\n-        \n+\n+        // authenticate learner\n+        QuorumPeer.QuorumServer qps = self.getVotingView().get(sid);\n+        if (qps != null) {\n+            // TODO - investigate why reconfig makes qps null.\n+            authLearner.authenticate(sock, qps.hostname);\n+        }\n+\n         // If lost the challenge, then drop the new connection\n         if (sid > self.getId()) {\n             LOG.info(\"Have smaller server identifier, so dropping the \" +\n@@ -283,7 +432,7 @@ public boolean initiateConnection(Socket sock, Long sid) {\n             // Otherwise proceed with the connection\n         } else {\n             SendWorker sw = new SendWorker(sock, sid);\n-            RecvWorker rw = new RecvWorker(sock, sid, sw);\n+            RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n             sw.setRecv(rw);\n \n             SendWorker vsw = senderWorkerMap.get(sid);\n@@ -312,13 +461,58 @@ public boolean initiateConnection(Socket sock, Long sid) {\n      * possible long value to lose the challenge.\n      *\n      */\n-    public void receiveConnection(Socket sock) {\n+    public void receiveConnection(final Socket sock) {\n+        DataInputStream din = null;\n+        try {\n+            din = new DataInputStream(\n+                    new BufferedInputStream(sock.getInputStream()));\n+\n+            handleConnection(sock, din);\n+        } catch (IOException e) {\n+            LOG.error(\"Exception handling connection, addr: {}, closing server connection\",\n+                    sock.getRemoteSocketAddress());\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Server receives a connection request and handles it asynchronously via\n+     * separate thread.\n+     */\n+    public void receiveConnectionAsync(final Socket sock) {\n+        try {\n+            connectionExecutor.execute(\n+                    new QuorumConnectionReceiverThread(sock));\n+            connectionThreadCnt.incrementAndGet();\n+        } catch (Throwable e) {\n+            LOG.error(\"Exception handling connection, addr: {}, closing server connection\",\n+                    sock.getRemoteSocketAddress());\n+            closeSocket(sock);\n+        }\n+    }\n+\n+    /**\n+     * Thread to receive connection request from peer server.\n+     */\n+    private class QuorumConnectionReceiverThread extends ZooKeeperThread {\n+        private final Socket sock;\n+        QuorumConnectionReceiverThread(final Socket sock) {\n+            super(\"QuorumConnectionReceiverThread-\" + sock.getRemoteSocketAddress());\n+            this.sock = sock;\n+        }\n+\n+        @Override\n+        public void run() {\n+            receiveConnection(sock);\n+        }\n+    }\n+\n+    private void handleConnection(Socket sock, DataInputStream din)\n+            throws IOException {\n         Long sid = null, protocolVersion = null;\n         InetSocketAddress electionAddr = null;\n \n         try {\n-            DataInputStream din = new DataInputStream(sock.getInputStream());\n-\n             protocolVersion = din.readLong();\n             if (protocolVersion >= 0) { // this is a server id and not a protocol version\n                 sid = protocolVersion;\n@@ -339,16 +533,18 @@ public void receiveConnection(Socket sock) {\n                  * Choose identifier at random. We need a value to identify\n                  * the connection.\n                  */\n-                \n-                sid = observerCounter--;\n-                LOG.info(\"Setting arbitrary identifier to observer: {}\", sid);\n+                sid = observerCounter.getAndDecrement();\n+                LOG.info(\"Setting arbitrary identifier to observer: \" + sid);\n             }\n         } catch (IOException e) {\n             closeSocket(sock);\n             LOG.warn(\"Exception reading or writing challenge: {}\", e.toString());\n             return;\n         }\n-        \n+\n+        // do authenticating learner\n+        authServer.authenticate(sock, din);\n+\n         //If wins the challenge, then close the new connection.\n         if (sid < self.getId()) {\n             /*\n@@ -375,7 +571,7 @@ public void receiveConnection(Socket sock) {\n \n         } else { // Otherwise start worker threads to receive data.\n             SendWorker sw = new SendWorker(sock, sid);\n-            RecvWorker rw = new RecvWorker(sock, sid, sw);\n+            RecvWorker rw = new RecvWorker(sock, din, sid, sw);\n             sw.setRecv(rw);\n \n             SendWorker vsw = senderWorkerMap.get(sid);\n@@ -402,7 +598,7 @@ public void toSend(Long sid, ByteBuffer b) {\n         /*\n          * If sending message to myself, then simply enqueue it (loopback).\n          */\n-        if (self.getId() == sid) {\n+        if (this.mySid == sid) {\n              b.position(0);\n              addToRecvQueue(new Message(b.duplicate(), sid));\n             /*\n@@ -444,7 +640,15 @@ synchronized private boolean connectOne(long sid, InetSocketAddress electionAddr\n              setSockOpts(sock);\n              sock.connect(electionAddr, cnxTO);\n              LOG.debug(\"Connected to server \" + sid);\n-             initiateConnection(sock, sid);\n+            // Sends connection request asynchronously if the quorum\n+            // sasl authentication is enabled. This is required because\n+            // sasl server authentication process may take few seconds to\n+            // finish, this may delay next peer connection requests.\n+            if (quorumSaslAuthEnabled) {\n+                initiateConnectionAsync(sock, sid);\n+            } else {\n+                initiateConnection(sock, sid);\n+            }\n              return true;\n          } catch (UnresolvedAddressException e) {\n              // Sun doesn't include the address that causes this\n@@ -547,6 +751,13 @@ public void halt() {\n             LOG.warn(\"Got interrupted before joining the listener\", ex);\n         }\n         softHalt();\n+\n+        // clear data structures used for auth\n+        if (connectionExecutor != null) {\n+            connectionExecutor.shutdown();\n+        }\n+        inprogressConnections.clear();\n+        resetConnectionThreadCount();\n     }\n    \n     /**\n@@ -595,11 +806,19 @@ private void closeSocket(Socket sock) {\n     public long getThreadCount() {\n         return threadCnt.get();\n     }\n+\n+    /**\n+     * Return number of connection processing threads.\n+     */\n+    public long getConnectionThreadCount() {\n+        return connectionThreadCnt.get();\n+    }\n+\n     /**\n-     * Return reference to QuorumPeer\n+     * Reset the value of connection processing threads count to zero.\n      */\n-    public QuorumPeer getQuorumPeer() {\n-        return self;\n+    private void resetConnectionThreadCount() {\n+        connectionThreadCnt.set(0);\n     }\n \n     /**\n@@ -645,7 +864,16 @@ public void run() {\n                             setSockOpts(client);\n                             LOG.info(\"Received connection request \"\n                                      + client.getRemoteSocketAddress());\n-                            receiveConnection(client);\n+                            // Receive and handle the connection request\n+                            // asynchronously if the quorum sasl authentication is\n+                            // enabled. This is required because sasl server\n+                            // authentication process may take few seconds to finish,\n+                            // this may delay next peer connection requests.\n+                            if (quorumSaslAuthEnabled) {\n+                                receiveConnectionAsync(client);\n+                            } else {\n+                                receiveConnection(client);\n+                            }\n                             numRetries = 0;\n                         } catch (SocketTimeoutException e) {\n                             LOG.warn(\"The socket is listening for the election accepted \"\n@@ -695,7 +923,8 @@ void halt(){\n             try{\n                 LOG.debug(\"Trying to close listener: \" + ss);\n                 if(ss != null) {\n-                    LOG.debug(\"Closing listener: \" + self.getId());\n+                    LOG.debug(\"Closing listener: \"\n+                              + QuorumCnxManager.this.mySid);\n                     ss.close();\n                 }\n             } catch (IOException e){\n@@ -847,8 +1076,9 @@ public void run() {\n                     }\n                 }\n             } catch (Exception e) {\n-                LOG.warn(\"Exception when using channel: for id \" + sid + \" my id = \" + \n-                        self.getId() + \" error = \" + e);\n+                LOG.warn(\"Exception when using channel: for id \" + sid\n+                         + \" my id = \" + QuorumCnxManager.this.mySid\n+                         + \" error = \" + e);\n             }\n             this.finish();\n             LOG.warn(\"Send worker leaving thread \" + \" id \" + sid + \" my id = \" + self.getId());\n@@ -863,16 +1093,16 @@ class RecvWorker extends ZooKeeperThread {\n         Long sid;\n         Socket sock;\n         volatile boolean running = true;\n-        DataInputStream din;\n+        final DataInputStream din;\n         final SendWorker sw;\n \n-        RecvWorker(Socket sock, Long sid, SendWorker sw) {\n+        RecvWorker(Socket sock, DataInputStream din, Long sid, SendWorker sw) {\n             super(\"RecvWorker:\" + sid);\n             this.sid = sid;\n             this.sock = sock;\n             this.sw = sw;\n+            this.din = din;\n             try {\n-                din = new DataInputStream(sock.getInputStream());\n                 // OK to wait until socket disconnects while reading.\n                 sock.setSoTimeout(0);\n             } catch (IOException e) {\n@@ -925,8 +1155,8 @@ public void run() {\n                     addToRecvQueue(new Message(message.duplicate(), sid));\n                 }\n             } catch (Exception e) {\n-                LOG.warn(\"Connection broken for id \" + sid + \", my id = \" + \n-                        self.getId() + \", error = \" , e);\n+                LOG.warn(\"Connection broken for id \" + sid + \", my id = \"\n+                         + QuorumCnxManager.this.mySid + \", error = \" , e);\n             } finally {\n                 LOG.warn(\"Interrupting SendWorker\");\n                 sw.finish();\n@@ -1046,4 +1276,8 @@ public Message pollRecvQueue(long timeout, TimeUnit unit)\n        throws InterruptedException {\n        return recvQueue.poll(timeout, unit);\n     }\n+\n+    public boolean connectedToPeer(long peerSid) {\n+        return senderWorkerMap.get(peerSid) != null;\n+    }\n }"
        },
        {
            "sha": "45f32b94392796dffea7dfd82306c1baca05b05f",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeer.java",
            "status": "modified",
            "additions": 175,
            "deletions": 23,
            "changes": 198,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -42,6 +42,8 @@\n import java.util.Set;\n import java.util.concurrent.atomic.AtomicInteger;\n \n+import javax.security.sasl.SaslException;\n+\n import org.apache.zookeeper.KeeperException.BadArgumentsException;\n import org.apache.zookeeper.common.AtomicFileWritingIdiom;\n import org.apache.zookeeper.common.AtomicFileWritingIdiom.WriterStatement;\n@@ -52,6 +54,13 @@\n import org.apache.zookeeper.server.ZKDatabase;\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.ZooKeeperThread;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuth;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.SaslQuorumAuthServer;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthLearner;\n+import org.apache.zookeeper.server.quorum.auth.NullQuorumAuthServer;\n import org.apache.zookeeper.server.admin.AdminServer;\n import org.apache.zookeeper.server.admin.AdminServer.AdminServerException;\n import org.apache.zookeeper.server.admin.AdminServerFactory;\n@@ -98,6 +107,8 @@ public class QuorumPeer extends ZooKeeperThread implements QuorumStats.Provider\n     private Map<Long, RemotePeerBean> jmxRemotePeerBean;\n     LeaderElectionBean jmxLeaderElectionBean;\n     private QuorumCnxManager qcm;\n+    QuorumAuthServer authServer;\n+    QuorumAuthLearner authLearner;\n \n     /**\n      * ZKDatabase is a top level member of quorumpeer\n@@ -116,6 +127,8 @@ public static class QuorumServer {\n         public InetSocketAddress clientAddr = null;\n         \n         public long id;\n+\n+        public String hostname;\n         \n         public LearnerType type = LearnerType.PARTICIPANT;\n         \n@@ -131,6 +144,7 @@ public QuorumServer(long id, InetSocketAddress addr,\n             this(id, addr, electionAddr, (InetSocketAddress)null, LearnerType.PARTICIPANT);\n         }\n \n+        // VisibleForTesting\n         public QuorumServer(long id, InetSocketAddress addr) {\n             this(id, addr, (InetSocketAddress)null, (InetSocketAddress)null, LearnerType.PARTICIPANT);\n         }\n@@ -217,7 +231,7 @@ public QuorumServer(long sid, String addressStr) throws ConfigException {\n                 }\n \n                 // is client_config a host:port or just a port\n-                String hostname = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n+                hostname = (clientParts.length == 2) ? clientParts[0] : \"0.0.0.0\";\n                 try {\n                     clientAddr = new InetSocketAddress(hostname,\n                             Integer.parseInt(clientParts[clientParts.length - 1]));\n@@ -245,6 +259,8 @@ public QuorumServer(long sid, String addressStr) throws ConfigException {\n                 setType(serverParts[3]);\n             }\n \n+            this.hostname = serverParts[0];\n+            \n             setMyAddrs();\n         }\n \n@@ -528,6 +544,50 @@ public synchronized void setCurrentVote(Vote v){\n      */\n     private long electionTimeTaken = -1;\n \n+    /**\n+     * Enable/Disables quorum authentication using sasl. Defaulting to false.\n+     */\n+    protected boolean quorumSaslEnableAuth;\n+\n+    /**\n+     * If this is false, quorum peer server will accept another quorum peer client\n+     * connection even if the authentication did not succeed. This can be used while\n+     * upgrading ZooKeeper server. Defaulting to false (required).\n+     */\n+    protected boolean quorumServerSaslAuthRequired;\n+\n+    /**\n+     * If this is false, quorum peer learner will talk to quorum peer server\n+     * without authentication. This can be used while upgrading ZooKeeper\n+     * server. Defaulting to false (required).\n+     */\n+    protected boolean quorumLearnerSaslAuthRequired;\n+\n+    /**\n+     * Kerberos quorum service principal. Defaulting to 'zkquorum/localhost'.\n+     */\n+    protected String quorumServicePrincipal;\n+\n+    /**\n+     * Quorum learner login context name in jaas-conf file to read the kerberos\n+     * security details. Defaulting to 'QuorumLearner'.\n+     */\n+    protected String quorumLearnerLoginContext;\n+\n+    /**\n+     * Quorum server login context name in jaas-conf file to read the kerberos\n+     * security details. Defaulting to 'QuorumServer'.\n+     */\n+    protected String quorumServerLoginContext;\n+\n+    // TODO: need to tune the default value of thread size\n+    private static final int QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE = 20;\n+    /**\n+     * The maximum number of threads to allow in the connectionExecutors thread\n+     * pool which will be used to initiate quorum server connections.\n+     */\n+    protected int quorumCnxnThreadsSize = QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE;\n+\n     /**\n      * @deprecated As of release 3.4.0, this class has been deprecated, since\n      * it is used with one of the udp-based versions of leader election, which\n@@ -717,14 +777,18 @@ public void setClientAddress(InetSocketAddress addr){\n \n     AdminServer adminServer;\n \n-    public QuorumPeer() {\n+    public static QuorumPeer testingQuorumPeer() throws SaslException {\n+        return new QuorumPeer();\n+    }\n+\n+    public QuorumPeer() throws SaslException {\n         super(\"QuorumPeer\");\n         quorumStats = new QuorumStats(this);\n         jmxRemotePeerBean = new HashMap<Long, RemotePeerBean>();\n         adminServer = AdminServerFactory.createAdminServer();\n+        initialize();\n     }\n \n-\n     /**\n      * For backward compatibility purposes, we instantiate QuorumMaj by default.\n      */\n@@ -759,6 +823,23 @@ public QuorumPeer(Map<Long, QuorumServer> quorumPeers, File dataDir,\n         adminServer = AdminServerFactory.createAdminServer();\n     }\n \n+    public void initialize() throws SaslException {\n+        // init quorum auth server & learner\n+        if (isQuorumSaslAuthEnabled()) {\n+            Set<String> authzHosts = new HashSet<String>();\n+            for (QuorumServer qs : getView().values()) {\n+                authzHosts.add(qs.hostname);\n+            }\n+            authServer = new SaslQuorumAuthServer(isQuorumServerSaslAuthRequired(),\n+                    quorumServerLoginContext, authzHosts);\n+            authLearner = new SaslQuorumAuthLearner(isQuorumLearnerSaslAuthRequired(),\n+                    quorumServicePrincipal, quorumLearnerLoginContext);\n+        } else {\n+            authServer = new NullQuorumAuthServer();\n+            authLearner = new NullQuorumAuthLearner();\n+        }\n+    }\n+\n     QuorumStats quorumStats() {\n         return quorumStats;\n     }\n@@ -939,26 +1020,26 @@ protected Election createElectionAlgorithm(int electionAlgorithm){\n \n         //TODO: use a factory rather than a switch\n         switch (electionAlgorithm) {\n-            case 1:\n-                le = new AuthFastLeaderElection(this);\n-                break;\n-            case 2:\n-                le = new AuthFastLeaderElection(this, true);\n-                break;\n-            case 3:\n-                qcm = new QuorumCnxManager(this);\n-                QuorumCnxManager.Listener listener = qcm.listener;\n-                if(listener != null){\n-                    listener.start();\n-                    FastLeaderElection fle = new FastLeaderElection(this, qcm);\n-                    fle.start();\n-                    le = fle;\n-                } else {\n-                    LOG.error(\"Null listener when initializing cnx manager\");\n-                }\n-                break;\n-            default:\n-                assert false;\n+        case 1:\n+            le = new AuthFastLeaderElection(this);\n+            break;\n+        case 2:\n+            le = new AuthFastLeaderElection(this, true);\n+            break;\n+        case 3:\n+            qcm = createCnxnManager();\n+            QuorumCnxManager.Listener listener = qcm.listener;\n+            if(listener != null){\n+                listener.start();\n+                FastLeaderElection fle = new FastLeaderElection(this, qcm);\n+                fle.start();\n+                le = fle;\n+            } else {\n+                LOG.error(\"Null listener when initializing cnx manager\");\n+            }\n+            break;\n+        default:\n+            assert false;\n         }\n         return le;\n     }\n@@ -1921,4 +2002,75 @@ void setElectionTimeTaken(long electionTimeTaken) {\n     long getElectionTimeTaken() {\n         return electionTimeTaken;\n     }\n+\n+    void setQuorumServerSaslRequired(boolean serverSaslRequired) {\n+        quorumServerSaslAuthRequired = serverSaslRequired;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED,\n+                serverSaslRequired);\n+    }\n+\n+    void setQuorumLearnerSaslRequired(boolean learnerSaslRequired) {\n+        quorumLearnerSaslAuthRequired = learnerSaslRequired;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED,\n+                learnerSaslRequired);\n+    }\n+\n+    void setQuorumSaslEnabled(boolean enableAuth) {\n+        quorumSaslEnableAuth = enableAuth;\n+        if (!quorumSaslEnableAuth) {\n+            LOG.info(\"QuorumPeer communication is not secured!\");\n+        } else {\n+            LOG.info(\"{} set to {}\",\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED, enableAuth);\n+        }\n+    }\n+\n+    void setQuorumServicePrincipal(String servicePrincipal) {\n+        quorumServicePrincipal = servicePrincipal;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL,\n+                quorumServicePrincipal);\n+    }\n+\n+    void setQuorumLearnerLoginContext(String learnerContext) {\n+        quorumLearnerLoginContext = learnerContext;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                quorumLearnerLoginContext);\n+    }\n+\n+    void setQuorumServerLoginContext(String serverContext) {\n+        quorumServerLoginContext = serverContext;\n+        LOG.info(\"{} set to {}\", QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT,\n+                quorumServerLoginContext);\n+    }\n+\n+    void setQuorumCnxnThreadsSize(int qCnxnThreadsSize) {\n+        if (qCnxnThreadsSize > QUORUM_CNXN_THREADS_SIZE_DEFAULT_VALUE) {\n+            quorumCnxnThreadsSize = qCnxnThreadsSize;\n+        }\n+        LOG.info(\"quorum.cnxn.threads.size set to {}\", quorumCnxnThreadsSize);\n+    }\n+\n+    boolean isQuorumSaslAuthEnabled() {\n+        return quorumSaslEnableAuth;\n+    }\n+\n+    private boolean isQuorumServerSaslAuthRequired() {\n+        return quorumServerSaslAuthRequired;\n+    }\n+\n+    private boolean isQuorumLearnerSaslAuthRequired() {\n+        return quorumLearnerSaslAuthRequired;\n+    }\n+\n+    public QuorumCnxManager createCnxnManager() {\n+        return new QuorumCnxManager(this,\n+                this.getId(),\n+                this.getView(),\n+                this.authServer,\n+                this.authLearner,\n+                this.tickTime * this.syncLimit,\n+                this.getQuorumListenOnAllIPs(),\n+                this.quorumCnxnThreadsSize,\n+                this.isQuorumSaslAuthEnabled());\n+    }\n }"
        },
        {
            "sha": "715913947f9ab485ab467096e27a94363af4119a",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerConfig.java",
            "status": "modified",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerConfig.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -49,6 +49,7 @@\n import org.apache.zookeeper.server.ZooKeeperServer;\n import org.apache.zookeeper.server.quorum.QuorumPeer.LearnerType;\n import org.apache.zookeeper.server.quorum.QuorumPeer.QuorumServer;\n+import org.apache.zookeeper.server.quorum.auth.QuorumAuth;\n import org.apache.zookeeper.server.quorum.flexible.QuorumHierarchical;\n import org.apache.zookeeper.server.quorum.flexible.QuorumMaj;\n import org.apache.zookeeper.server.quorum.flexible.QuorumVerifier;\n@@ -93,6 +94,17 @@ public class QuorumPeerConfig {\n \n     protected LearnerType peerType = LearnerType.PARTICIPANT;\n \n+    /**\n+     * Configurations for the quorumpeer-to-quorumpeer sasl authentication\n+     */\n+    protected boolean quorumServerRequireSasl = false;\n+    protected boolean quorumLearnerRequireSasl = false;\n+    protected boolean quorumEnableSasl = false;\n+    protected String quorumServicePrincipal = QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE;\n+    protected String quorumLearnerLoginContext = QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;\n+    protected String quorumServerLoginContext = QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT_DFAULT_VALUE;\n+    protected int quorumCnxnThreadsSize;\n+\n     /**\n      * Minimum snapshot retain count.\n      * @see org.apache.zookeeper.server.PurgeTxnLog#purge(File, File, int)\n@@ -296,11 +308,47 @@ public void parseProperties(Properties zkProp)\n                 }\n             } else if ((key.startsWith(\"server.\") || key.startsWith(\"group\") || key.startsWith(\"weight\")) && zkProp.containsKey(\"dynamicConfigFile\")) {\n                 throw new ConfigException(\"parameter: \" + key + \" must be in a separate dynamic config file\");\n+            } else if (key.equals(QuorumAuth.QUORUM_SASL_AUTH_ENABLED)) {\n+                quorumEnableSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED)) {\n+                quorumServerRequireSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED)) {\n+                quorumLearnerRequireSasl = Boolean.parseBoolean(value);\n+            } else if (key.equals(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT)) {\n+                quorumLearnerLoginContext = value;\n+            } else if (key.equals(QuorumAuth.QUORUM_SERVER_SASL_LOGIN_CONTEXT)) {\n+                quorumServerLoginContext = value;\n+            } else if (key.equals(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL)) {\n+                quorumServicePrincipal = value;\n+            } else if (key.equals(\"quorum.cnxn.threads.size\")) {\n+                quorumCnxnThreadsSize = Integer.parseInt(value);\n             } else {\n                 System.setProperty(\"zookeeper.\" + key, value);\n             }\n         }\n \n+        if (!quorumEnableSasl && quorumServerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED\n+                            + \" is disabled, so cannot enable \"\n+                            + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n+        }\n+        if (!quorumEnableSasl && quorumLearnerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_SASL_AUTH_ENABLED\n+                            + \" is disabled, so cannot enable \"\n+                            + QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED);\n+        }\n+        // If quorumpeer learner is not auth enabled then self won't be able to\n+        // join quorum. So this condition is ensuring that the quorumpeer learner\n+        // is also auth enabled while enabling quorum server require sasl.\n+        if (!quorumLearnerRequireSasl && quorumServerRequireSasl) {\n+            throw new IllegalArgumentException(\n+                    QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED\n+                            + \" is disabled, so cannot enable \"\n+                            + QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED);\n+        }\n+\n         // Reset to MIN_SNAP_RETAIN_COUNT if invalid (less than 3)\n         // PurgeTxnLog.purge(File, File, int) will not allow to purge less\n         // than 3."
        },
        {
            "sha": "3da6e20edd49aed66ea6fc84c9f7dc0938c11b75",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/QuorumPeerMain.java",
            "status": "modified",
            "additions": 14,
            "deletions": 1,
            "changes": 15,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerMain.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -20,6 +20,7 @@\n import java.io.IOException;\n \n import javax.management.JMException;\n+import javax.security.sasl.SaslException;\n \n import org.apache.yetus.audience.InterfaceAudience;\n import org.slf4j.Logger;\n@@ -183,6 +184,18 @@ public void runFromConfig(QuorumPeerConfig config)\n           quorumPeer.setLearnerType(config.getPeerType());\n           quorumPeer.setSyncEnabled(config.getSyncEnabled());\n           quorumPeer.setQuorumListenOnAllIPs(config.getQuorumListenOnAllIPs());\n+\n+          // sets quorum sasl authentication configurations\n+          quorumPeer.setQuorumSaslEnabled(config.quorumEnableSasl);\n+          if(quorumPeer.isQuorumSaslAuthEnabled()){\n+              quorumPeer.setQuorumServerSaslRequired(config.quorumServerRequireSasl);\n+              quorumPeer.setQuorumLearnerSaslRequired(config.quorumLearnerRequireSasl);\n+              quorumPeer.setQuorumServicePrincipal(config.quorumServicePrincipal);\n+              quorumPeer.setQuorumServerLoginContext(config.quorumServerLoginContext);\n+              quorumPeer.setQuorumLearnerLoginContext(config.quorumLearnerLoginContext);\n+          }\n+          quorumPeer.setQuorumCnxnThreadsSize(config.quorumCnxnThreadsSize);\n+          quorumPeer.initialize();\n           \n           quorumPeer.start();\n           quorumPeer.join();\n@@ -193,7 +206,7 @@ public void runFromConfig(QuorumPeerConfig config)\n     }\n \n     // @VisibleForTesting\n-    protected QuorumPeer getQuorumPeer() {\n+    protected QuorumPeer getQuorumPeer() throws SaslException {\n         return new QuorumPeer();\n     }\n }"
        },
        {
            "sha": "0af891c55e1faf829aa756eb091ca494a67a545f",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/NullQuorumAuthLearner.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthLearner.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,33 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.net.Socket;\n+\n+/**\n+ * This class represents no authentication learner, it just return\n+ * without performing any authentication.\n+ */\n+public class NullQuorumAuthLearner implements QuorumAuthLearner {\n+\n+    @Override\n+    public void authenticate(Socket sock, String hostname) {\n+        return; // simply return don't require auth\n+    }\n+}"
        },
        {
            "sha": "b26a54a81ea2ec0dfadcc655b3f8a2f2a188caff",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/NullQuorumAuthServer.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FNullQuorumAuthServer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.net.Socket;\n+\n+/**\n+ * This class represents no authentication server, it just return\n+ * without performing any authentication.\n+ */\n+public class NullQuorumAuthServer implements QuorumAuthServer {\n+\n+    @Override\n+    public void authenticate(final Socket sock, final DataInputStream din) {\n+        return; // simply return don't require auth\n+    }\n+}"
        },
        {
            "sha": "8bfa394deccaaefbbfff6054c53f374164ffcf04",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuth.java",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuth.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,96 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import org.apache.jute.BinaryInputArchive;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+\n+public class QuorumAuth {\n+    private static final Logger LOG = LoggerFactory.getLogger(QuorumAuth.class);\n+\n+    public static final String QUORUM_SASL_AUTH_ENABLED = \"quorum.auth.enableSasl\";\n+    public static final String QUORUM_SERVER_SASL_AUTH_REQUIRED = \"quorum.auth.serverRequireSasl\";\n+    public static final String QUORUM_LEARNER_SASL_AUTH_REQUIRED = \"quorum.auth.learnerRequireSasl\";\n+\n+    public static final String QUORUM_KERBEROS_SERVICE_PRINCIPAL = \"quorum.auth.kerberos.servicePrincipal\";\n+    public static final String QUORUM_KERBEROS_SERVICE_PRINCIPAL_DEFAULT_VALUE = \"zkquorum/localhost\";\n+\n+    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT = \"quorum.auth.learner.saslLoginContext\";\n+    public static final String QUORUM_LEARNER_SASL_LOGIN_CONTEXT_DFAULT_VALUE = \"QuorumLearner\";\n+\n+    public static final String QUORUM_SERVER_SASL_LOGIN_CONTEXT = \"quorum.auth.server.saslLoginContext\";\n+    public static final String QUORUM_SERVER_SASL_LOGIN_CONTEXT_DFAULT_VALUE = \"QuorumServer\";\n+\n+    static final String QUORUM_SERVER_PROTOCOL_NAME = \"zookeeper-quorum\";\n+    static final String QUORUM_SERVER_SASL_DIGEST = \"zk-quorum-sasl-md5\";\n+    static final String QUORUM_AUTH_MESSAGE_TAG = \"qpconnect\";\n+\n+    // this is negative, so that if a learner that does auth, connects to a\n+    // server, it'll think the received packet is an authentication packet\n+    public static final long QUORUM_AUTH_MAGIC_NUMBER = -0xa0dbcafecafe1234L;\n+\n+    public enum Status {\n+         IN_PROGRESS(0), SUCCESS(1), ERROR(-1);\n+        private int status;\n+\n+        Status(int status) {\n+            this.status = status;\n+        }\n+\n+        static Status getStatus(int status) {\n+            switch (status) {\n+            case 0:\n+                return IN_PROGRESS;\n+            case 1:\n+                return SUCCESS;\n+            case -1:\n+                return ERROR;\n+            default:\n+                LOG.error(\"Unknown status:{}!\", status);\n+                assert false : \"Unknown status!\";\n+                return ERROR;\n+            }\n+        }\n+\n+        int status() {\n+            return status;\n+        }\n+    }\n+\n+    public static QuorumAuthPacket createPacket(Status status, byte[] response) {\n+        return new QuorumAuthPacket(QUORUM_AUTH_MAGIC_NUMBER,\n+                                    status.status(), response);\n+    }\n+\n+    public static boolean nextPacketIsAuth(DataInputStream din)\n+            throws IOException {\n+        din.mark(32);\n+        BinaryInputArchive bia = new BinaryInputArchive(din);\n+        boolean firstIsAuth = (bia.readLong(\"NO_TAG\")\n+                               == QuorumAuth.QUORUM_AUTH_MAGIC_NUMBER);\n+        din.reset();\n+        return firstIsAuth;\n+    }\n+}"
        },
        {
            "sha": "af71257480232b1abdfc1da0e5c9edd9fcf35c68",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuthLearner.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthLearner.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,40 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.net.Socket;\n+\n+/**\n+ * Interface for quorum learner authentication mechanisms.\n+ */\n+public interface QuorumAuthLearner {\n+\n+    /**\n+     * Performs an authentication step for the given socket connection.\n+     *\n+     * @param sock\n+     *            socket connection to other quorum peer server\n+     * @param hostname\n+     *            host name of other quorum peer server\n+     * @throws IOException\n+     *             if there is an authentication failure\n+     */\n+    public void authenticate(Socket sock, String hostname) throws IOException;\n+}"
        },
        {
            "sha": "e9de8f00a5a8d1cbf37d4129f7727b718793539d",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/QuorumAuthServer.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthServer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,41 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.DataInputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+\n+/**\n+ * Interface for quorum server authentication mechanisms.\n+ */\n+public interface QuorumAuthServer {\n+\n+    /**\n+     * Performs an authentication step for the given socket connection.\n+     *\n+     * @param sock\n+     *            socket connection to other quorum peer\n+     * @param din\n+     *            stream used to read auth data send by the quorum learner\n+     * @throws IOException if the server fails to authenticate connecting quorum learner\n+     */\n+    public void authenticate(Socket sock, DataInputStream din)\n+            throws IOException;\n+}"
        },
        {
            "sha": "31f4f55c81f06407d20b7be31f74b5cdc89397a4",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumAuthLearner.java",
            "status": "added",
            "additions": 223,
            "deletions": 0,
            "changes": 223,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthLearner.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,223 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslException;\n+\n+import org.apache.jute.BinaryInputArchive;\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n+import org.apache.zookeeper.common.ZKConfig;\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+import org.apache.zookeeper.util.SecurityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SaslQuorumAuthLearner implements QuorumAuthLearner {\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(SaslQuorumAuthLearner.class);\n+\n+    private final Login learnerLogin;\n+    private final boolean quorumRequireSasl;\n+    private final String quorumServicePrincipal;\n+\n+    public SaslQuorumAuthLearner(boolean quorumRequireSasl,\n+            String quorumServicePrincipal, String loginContext)\n+                    throws SaslException {\n+        this.quorumRequireSasl = quorumRequireSasl;\n+        this.quorumServicePrincipal = quorumServicePrincipal;\n+        try {\n+            AppConfigurationEntry entries[] = Configuration\n+                .getConfiguration()\n+                .getAppConfigurationEntry(loginContext);\n+            if (entries == null || entries.length == 0) {\n+                throw new LoginException(\"SASL-authentication failed because\"\n+                                         + \" the specified JAAS configuration \"\n+                                         + \"section '\" + loginContext\n+                                         + \"' could not be found.\");\n+            }\n+            this.learnerLogin = new Login(loginContext,\n+                                    new SaslClientCallbackHandler(null, \"QuorumLearner\"), new ZKConfig());\n+            this.learnerLogin.startThreadIfNeeded();\n+        } catch (LoginException e) {\n+            throw new SaslException(\"Failed to initialize authentication mechanism using SASL\", e);\n+        }\n+    }\n+\n+    @Override\n+    public void authenticate(Socket sock, String hostName) throws IOException {\n+        if (!quorumRequireSasl) { // let it through, we don't require auth\n+            LOG.info(\"Skipping SASL authentication as {}={}\",\n+                    QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED,\n+                    quorumRequireSasl);\n+            return;\n+        }\n+        SaslClient sc = null;\n+        String principalConfig = SecurityUtils\n+                .getServerPrincipal(quorumServicePrincipal, hostName);\n+        try {\n+            DataOutputStream dout = new DataOutputStream(\n+                    sock.getOutputStream());\n+            DataInputStream din = new DataInputStream(sock.getInputStream());\n+            byte[] responseToken = new byte[0];\n+            sc = SecurityUtils.createSaslClient(learnerLogin.getSubject(),\n+                    principalConfig,\n+                    QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME,\n+                    QuorumAuth.QUORUM_SERVER_SASL_DIGEST, LOG, \"QuorumLearner\");\n+\n+            if (sc.hasInitialResponse()) {\n+                responseToken = createSaslToken(new byte[0], sc, learnerLogin);\n+            }\n+            send(dout, responseToken);\n+            QuorumAuthPacket authPacket = receive(din);\n+            QuorumAuth.Status qpStatus = QuorumAuth.Status\n+                    .getStatus(authPacket.getStatus());\n+            while (!sc.isComplete()) {\n+                switch (qpStatus) {\n+                case SUCCESS:\n+                    responseToken = createSaslToken(authPacket.getToken(), sc,\n+                            learnerLogin);\n+                    // we're done; don't expect to send another BIND\n+                    if (responseToken != null) {\n+                        throw new SaslException(\"Protocol error: attempting to send response after completion\");\n+                    }\n+                    break;\n+                case IN_PROGRESS:\n+                    responseToken = createSaslToken(authPacket.getToken(), sc,\n+                            learnerLogin);\n+                    send(dout, responseToken);\n+                    authPacket = receive(din);\n+                    qpStatus = QuorumAuth.Status\n+                            .getStatus(authPacket.getStatus());\n+                    break;\n+                case ERROR:\n+                    throw new SaslException(\n+                            \"Authentication failed against server addr: \"\n+                                    + sock.getRemoteSocketAddress());\n+                default:\n+                    LOG.warn(\"Unknown status:{}!\", qpStatus);\n+                    throw new SaslException(\n+                            \"Authentication failed against server addr: \"\n+                                    + sock.getRemoteSocketAddress());\n+                }\n+            }\n+\n+            // Validate status code at the end of authentication exchange.\n+            checkAuthStatus(sock, qpStatus);\n+        } finally {\n+            if (sc != null) {\n+                try {\n+                    sc.dispose();\n+                } catch (SaslException e) {\n+                    LOG.error(\"SaslClient dispose() failed\", e);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    private void checkAuthStatus(Socket sock, QuorumAuth.Status qpStatus)\n+            throws SaslException {\n+        if (qpStatus == QuorumAuth.Status.SUCCESS) {\n+            LOG.info(\"Successfully completed the authentication using SASL. server addr: {}, status: {}\",\n+                    sock.getRemoteSocketAddress(), qpStatus);\n+        } else {\n+            throw new SaslException(\"Authentication failed against server addr: \"\n+                            + sock.getRemoteSocketAddress() + \", qpStatus: \"\n+                            + qpStatus);\n+        }\n+    }\n+\n+    private QuorumAuthPacket receive(DataInputStream din) throws IOException {\n+        QuorumAuthPacket authPacket = new QuorumAuthPacket();\n+        BinaryInputArchive bia = BinaryInputArchive.getArchive(din);\n+        authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        return authPacket;\n+    }\n+\n+    private void send(DataOutputStream dout, byte[] response)\n+            throws IOException {\n+        QuorumAuthPacket authPacket;\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        authPacket = QuorumAuth.createPacket(\n+                QuorumAuth.Status.IN_PROGRESS, response);\n+        boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        bufferedOutput.flush();\n+    }\n+\n+    // TODO: need to consolidate the #createSaslToken() implementation between ZooKeeperSaslClient#createSaslToken().\n+    private byte[] createSaslToken(final byte[] saslToken,\n+            final SaslClient saslClient, final Login login)\n+                    throws SaslException {\n+        if (saslToken == null) {\n+            throw new SaslException(\n+                    \"Error in authenticating with a Zookeeper Quorum member: the quorum member's saslToken is null.\");\n+        }\n+        if (login.getSubject() != null) {\n+            synchronized (login) {\n+                try {\n+                    final byte[] retval = Subject.doAs(login.getSubject(),\n+                            new PrivilegedExceptionAction<byte[]>() {\n+                                public byte[] run() throws SaslException {\n+                                    LOG.debug(\"saslClient.evaluateChallenge(len=\"\n+                                                    + saslToken.length + \")\");\n+                                    return saslClient.evaluateChallenge(saslToken);\n+                                }\n+                            });\n+                    return retval;\n+                } catch (PrivilegedActionException e) {\n+                    String error = \"An error: (\" + e\n+                            + \") occurred when evaluating Zookeeper Quorum Member's \"\n+                            + \" received SASL token.\";\n+                    // Try to provide hints to use about what went wrong so they\n+                    // can fix their configuration.\n+                    // TODO: introspect about e: look for GSS information.\n+                    final String UNKNOWN_SERVER_ERROR_TEXT = \"(Mechanism level: Server not found in Kerberos database (7) - UNKNOWN_SERVER)\";\n+                    if (e.toString().indexOf(UNKNOWN_SERVER_ERROR_TEXT) > -1) {\n+                        error += \" This may be caused by Java's being unable to resolve the Zookeeper Quorum Member's\"\n+                                + \" hostname correctly. You may want to try to adding\"\n+                                + \" '-Dsun.net.spi.nameservice.provider.1=dns,sun' to your server's JVMFLAGS environment.\";\n+                    }\n+                    LOG.error(error);\n+                    throw new SaslException(error);\n+                }\n+            }\n+        } else {\n+            throw new SaslException(\n+                    \"Cannot make SASL token without subject defined. \"\n+                            + \"For diagnosis, please look for WARNs and ERRORs in your log related to the Login class.\");\n+        }\n+    }\n+}"
        },
        {
            "sha": "fc5e3b6b73605112fcf5fff74d48165082f4ea33",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumAuthServer.java",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumAuthServer.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,179 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.BufferedOutputStream;\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+import java.net.Socket;\n+import java.util.Set;\n+\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginException;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+\n+import org.apache.jute.BinaryInputArchive;\n+import org.apache.jute.BinaryOutputArchive;\n+import org.apache.zookeeper.Login;\n+import org.apache.zookeeper.common.ZKConfig;\n+import org.apache.zookeeper.server.quorum.QuorumAuthPacket;\n+import org.apache.zookeeper.util.SecurityUtils;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+public class SaslQuorumAuthServer implements QuorumAuthServer {\n+\n+    private static final Logger LOG = LoggerFactory\n+            .getLogger(SaslQuorumAuthServer.class);\n+\n+    private final static int MAX_RETRIES = 5;\n+    private final Login serverLogin;\n+    private final boolean quorumRequireSasl;\n+\n+    public SaslQuorumAuthServer(boolean quorumRequireSasl, String loginContext, Set<String> authzHosts)\n+            throws SaslException {\n+        this.quorumRequireSasl = quorumRequireSasl;\n+        try {\n+            AppConfigurationEntry entries[] = Configuration.getConfiguration()\n+                    .getAppConfigurationEntry(loginContext);\n+            if (entries == null || entries.length == 0) {\n+                throw new LoginException(\"SASL-authentication failed\"\n+                        + \" because the specified JAAS configuration \"\n+                        + \"section '\" + loginContext + \"' could not be found.\");\n+            }\n+            SaslQuorumServerCallbackHandler saslServerCallbackHandler = new SaslQuorumServerCallbackHandler(\n+                    Configuration.getConfiguration(), loginContext, authzHosts);\n+            serverLogin = new Login(loginContext, saslServerCallbackHandler, new ZKConfig());\n+            serverLogin.startThreadIfNeeded();\n+        } catch (Throwable e) {\n+            throw new SaslException(\n+                    \"Failed to initialize authentication mechanism using SASL\",\n+                    e);\n+        }\n+    }\n+\n+    @Override\n+    public void authenticate(Socket sock, DataInputStream din)\n+            throws SaslException {\n+        DataOutputStream dout = null;\n+        SaslServer ss = null;\n+        try {\n+            if (!QuorumAuth.nextPacketIsAuth(din)) {\n+                if (quorumRequireSasl) {\n+                    throw new SaslException(\"Learner not trying to authenticate\"\n+                                            + \" and authentication is required\");\n+                } else {\n+                    // let it through, we don't require auth\n+                    return;\n+                }\n+            }\n+\n+            byte[] token = receive(din);\n+            int tries = 0;\n+            dout = new DataOutputStream(sock.getOutputStream());\n+            byte[] challenge = null;\n+            ss = SecurityUtils.createSaslServer(serverLogin.getSubject(),\n+                    QuorumAuth.QUORUM_SERVER_PROTOCOL_NAME,\n+                    QuorumAuth.QUORUM_SERVER_SASL_DIGEST, serverLogin.callbackHandler,\n+                    LOG);\n+            while (!ss.isComplete()) {\n+                challenge = ss.evaluateResponse(token);\n+                if (!ss.isComplete()) {\n+                    // limited number of retries.\n+                    if (++tries > MAX_RETRIES) {\n+                        send(dout, challenge, QuorumAuth.Status.ERROR);\n+                        LOG.warn(\"Failed to authenticate using SASL, server addr: {}, retries={} exceeded.\",\n+                                sock.getRemoteSocketAddress(), tries);\n+                        break;\n+                    }\n+                    send(dout, challenge, QuorumAuth.Status.IN_PROGRESS);\n+                    token = receive(din);\n+                }\n+            }\n+            // Authentication exchange has completed\n+            if (ss.isComplete()) {\n+                send(dout, challenge, QuorumAuth.Status.SUCCESS);\n+                LOG.info(\"Successfully completed the authentication using SASL. learner addr: {}\",\n+                        sock.getRemoteSocketAddress());\n+            }\n+        } catch (Exception e) {\n+            try {\n+                if (dout != null) {\n+                    // send error message to the learner\n+                    send(dout, new byte[0], QuorumAuth.Status.ERROR);\n+                }\n+            } catch (IOException ioe) {\n+                LOG.warn(\"Exception while sending failed status\", ioe);\n+            }\n+            // If sasl is not required, when a server initializes a\n+            // connection it will try to log in, but it will also\n+            // accept connections that do not start with a sasl\n+            // handshake.\n+            if (quorumRequireSasl) {\n+                LOG.error(\"Failed to authenticate using SASL\", e);\n+                throw new SaslException(\n+                        \"Failed to authenticate using SASL: \" + e.getMessage());\n+            } else {\n+                LOG.warn(\"Failed to authenticate using SASL\", e);\n+                LOG.warn(\"Maintaining learner connection despite SASL authentication failure.\"\n+                                + \" server addr: {}, {}: {}\",\n+                        new Object[] { sock.getRemoteSocketAddress(),\n+                                QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED,\n+                                quorumRequireSasl });\n+                return; // let it through, we don't require auth\n+            }\n+        } finally {\n+            if (ss != null) {\n+                try {\n+                    ss.dispose();\n+                } catch (SaslException e) {\n+                    LOG.error(\"SaslServer dispose() failed\", e);\n+                }\n+            }\n+        }\n+        return;\n+    }\n+\n+    private byte[] receive(DataInputStream din) throws IOException {\n+        QuorumAuthPacket authPacket = new QuorumAuthPacket();\n+        BinaryInputArchive bia = BinaryInputArchive.getArchive(din);\n+        authPacket.deserialize(bia, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        return authPacket.getToken();\n+    }\n+\n+    private void send(DataOutputStream dout, byte[] challenge,\n+            QuorumAuth.Status s) throws IOException {\n+        BufferedOutputStream bufferedOutput = new BufferedOutputStream(dout);\n+        BinaryOutputArchive boa = BinaryOutputArchive\n+                .getArchive(bufferedOutput);\n+        QuorumAuthPacket authPacket;\n+        if (challenge == null && s != QuorumAuth.Status.SUCCESS) {\n+            authPacket = QuorumAuth.createPacket(\n+                    QuorumAuth.Status.IN_PROGRESS, null);\n+        } else {\n+            authPacket = QuorumAuth.createPacket(s, challenge);\n+        }\n+\n+        boa.writeRecord(authPacket, QuorumAuth.QUORUM_AUTH_MESSAGE_TAG);\n+        bufferedOutput.flush();\n+    }\n+}"
        },
        {
            "sha": "3e71bb1774b0209ffc508c1da099d8dae708917b",
            "filename": "src/java/main/org/apache/zookeeper/server/quorum/auth/SaslQuorumServerCallbackHandler.java",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FSaslQuorumServerCallbackHandler.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,148 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Set;\n+\n+import javax.security.auth.callback.Callback;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.auth.callback.NameCallback;\n+import javax.security.auth.callback.PasswordCallback;\n+import javax.security.auth.callback.UnsupportedCallbackException;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.sasl.AuthorizeCallback;\n+import javax.security.sasl.RealmCallback;\n+\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * This is used by the SASL mechanisms to get further information to complete\n+ * the authentication. For example, a SASL mechanism might use this callback\n+ * handler to do verification operation. This is used by the QuorumServer to\n+ * perform the mutual quorum peer authentication.\n+ */\n+public class SaslQuorumServerCallbackHandler implements CallbackHandler {\n+    private static final String USER_PREFIX = \"user_\";\n+    private static final Logger LOG = LoggerFactory.getLogger(SaslQuorumServerCallbackHandler.class);\n+\n+    private String userName;\n+    private final Map<String,String> credentials = new HashMap<String,String>();\n+    private final Set<String> authzHosts;\n+\n+    public SaslQuorumServerCallbackHandler(Configuration configuration,\n+            String serverSection, Set<String> authzHosts) throws IOException {\n+        AppConfigurationEntry configurationEntries[] = configuration.getAppConfigurationEntry(serverSection);\n+\n+        if (configurationEntries == null) {\n+            String errorMessage = \"Could not find a '\" + serverSection + \"' entry in this configuration: Server cannot start.\";\n+            LOG.error(errorMessage);\n+            throw new IOException(errorMessage);\n+        }\n+        credentials.clear();\n+        for(AppConfigurationEntry entry: configurationEntries) {\n+            Map<String,?> options = entry.getOptions();\n+            // Populate DIGEST-MD5 user -> password map with JAAS configuration entries from the \"QuorumServer\" section.\n+            // Usernames are distinguished from other options by prefixing the username with a \"user_\" prefix.\n+            for(Map.Entry<String, ?> pair : options.entrySet()) {\n+                String key = pair.getKey();\n+                if (key.startsWith(USER_PREFIX)) {\n+                    String userName = key.substring(USER_PREFIX.length());\n+                    credentials.put(userName,(String)pair.getValue());\n+                }\n+            }\n+        }\n+\n+        // authorized host lists\n+        this.authzHosts = authzHosts;\n+    }\n+\n+    public void handle(Callback[] callbacks) throws UnsupportedCallbackException {\n+        for (Callback callback : callbacks) {\n+            if (callback instanceof NameCallback) {\n+                handleNameCallback((NameCallback) callback);\n+            } else if (callback instanceof PasswordCallback) {\n+                handlePasswordCallback((PasswordCallback) callback);\n+            } else if (callback instanceof RealmCallback) {\n+                handleRealmCallback((RealmCallback) callback);\n+            } else if (callback instanceof AuthorizeCallback) {\n+                handleAuthorizeCallback((AuthorizeCallback) callback);\n+            }\n+        }\n+    }\n+\n+    private void handleNameCallback(NameCallback nc) {\n+        // check to see if this user is in the user password database.\n+        if (credentials.get(nc.getDefaultName()) == null) {\n+            LOG.warn(\"User '{}' not found in list of DIGEST-MD5 authenticateable users.\",\n+                    nc.getDefaultName());\n+            return;\n+        }\n+        nc.setName(nc.getDefaultName());\n+        userName = nc.getDefaultName();\n+    }\n+\n+    private void handlePasswordCallback(PasswordCallback pc) {\n+        if (credentials.containsKey(userName) ) {\n+            pc.setPassword(credentials.get(userName).toCharArray());\n+        } else {\n+            LOG.warn(\"No password found for user: {}\", userName);\n+        }\n+    }\n+\n+    private void handleRealmCallback(RealmCallback rc) {\n+        LOG.debug(\"QuorumLearner supplied realm: {}\", rc.getDefaultText());\n+        rc.setText(rc.getDefaultText());\n+    }\n+\n+    private void handleAuthorizeCallback(AuthorizeCallback ac) {\n+        String authenticationID = ac.getAuthenticationID();\n+        String authorizationID = ac.getAuthorizationID();\n+\n+        boolean authzFlag = false;\n+        // 1. Matches authenticationID and authorizationID\n+        authzFlag = authenticationID.equals(authorizationID);\n+\n+        // 2. Verify whether the connecting host is present in authorized hosts.\n+        // If not exists, then connecting peer is not authorized to join the\n+        // ensemble and will reject it.\n+        if (authzFlag) {\n+            String[] components = authorizationID.split(\"[/@]\");\n+            if (components.length == 3) {\n+                authzFlag = authzHosts.contains(components[1]);\n+            }\n+            if (!authzFlag) {\n+                LOG.error(\"SASL authorization completed, {} is not authorized to connect\",\n+                        components[1]);\n+            }\n+        }\n+\n+        // Sets authorization flag\n+        ac.setAuthorized(authzFlag);\n+        if (ac.isAuthorized()) {\n+            ac.setAuthorizedID(authorizationID);\n+            LOG.info(\"Successfully authenticated learner: authenticationID={};  authorizationID={}.\",\n+                    authenticationID, authorizationID);\n+        }\n+        LOG.debug(\"SASL authorization completed, authorized flag set to {}\", ac.isAuthorized());\n+    }\n+}"
        },
        {
            "sha": "67484e4e03fac588a7a5bb34f33b37bac44f3c97",
            "filename": "src/java/main/org/apache/zookeeper/util/SecurityUtils.java",
            "status": "added",
            "additions": 298,
            "deletions": 0,
            "changes": 298,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Fmain%2Forg%2Fapache%2Fzookeeper%2Futil%2FSecurityUtils.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,298 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.util;\n+\n+import java.security.Principal;\n+import java.security.PrivilegedActionException;\n+import java.security.PrivilegedExceptionAction;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.callback.CallbackHandler;\n+import javax.security.sasl.Sasl;\n+import javax.security.sasl.SaslClient;\n+import javax.security.sasl.SaslException;\n+import javax.security.sasl.SaslServer;\n+\n+import org.apache.zookeeper.SaslClientCallbackHandler;\n+import org.apache.zookeeper.server.auth.KerberosName;\n+import org.ietf.jgss.GSSContext;\n+import org.ietf.jgss.GSSCredential;\n+import org.ietf.jgss.GSSException;\n+import org.ietf.jgss.GSSManager;\n+import org.ietf.jgss.GSSName;\n+import org.ietf.jgss.Oid;\n+import org.slf4j.Logger;\n+\n+public final class SecurityUtils {\n+\n+    public static final String QUORUM_HOSTNAME_PATTERN = \"_HOST\";\n+\n+    /**\n+     * Create an instance of a SaslClient. It will return null if there is an exception.\n+     *\n+     * @param subject subject\n+     * @param servicePrincipal principal\n+     * @param protocol name of the protocol for which the authentication is being performed\n+     * @param serverName name of the server to authenticate to\n+     * @param LOG logger\n+     * @param entity can be either zookeeper client or quorum learner\n+     *\n+     * @return saslclient object\n+     * @throws SaslException\n+     */\n+    public static SaslClient createSaslClient(final Subject subject,\n+            final String servicePrincipal, final String protocol,\n+            final String serverName, final Logger LOG, final String entity) throws SaslException {\n+        SaslClient saslClient;\n+        // Use subject.getPrincipals().isEmpty() as an indication of which SASL\n+        // mechanism to use: if empty, use DIGEST-MD5; otherwise, use GSSAPI.\n+        if (subject.getPrincipals().isEmpty()) {\n+            // no principals: must not be GSSAPI: use DIGEST-MD5 mechanism\n+            // instead.\n+            LOG.info(\"{} will use DIGEST-MD5 as SASL mechanism.\", entity);\n+            String[] mechs = { \"DIGEST-MD5\" };\n+            String username = (String) (subject.getPublicCredentials()\n+                    .toArray()[0]);\n+            String password = (String) (subject.getPrivateCredentials()\n+                    .toArray()[0]);\n+            // 'domain' parameter is hard-wired between the server and client\n+            saslClient = Sasl.createSaslClient(mechs, username, protocol,\n+                    serverName, null, new SaslClientCallbackHandler(password, entity));\n+            return saslClient;\n+        } else { // GSSAPI.\n+            final Object[] principals = subject.getPrincipals().toArray();\n+            // determine client principal from subject.\n+            final Principal clientPrincipal = (Principal) principals[0];\n+            boolean usingNativeJgss = Boolean\n+                    .getBoolean(\"sun.security.jgss.native\");\n+            if (usingNativeJgss) {\n+                // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n+                // \"\"\"\n+                // In addition, when performing operations as a particular\n+                // Subject, e.g. Subject.doAs(...) or\n+                // Subject.doAsPrivileged(...),\n+                // the to-be-used GSSCredential should be added to Subject's\n+                // private credential set. Otherwise, the GSS operations will\n+                // fail since no credential is found.\n+                // \"\"\"\n+                try {\n+                    GSSManager manager = GSSManager.getInstance();\n+                    Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n+                    GSSCredential cred = manager.createCredential(null,\n+                            GSSContext.DEFAULT_LIFETIME, krb5Mechanism,\n+                            GSSCredential.INITIATE_ONLY);\n+                    subject.getPrivateCredentials().add(cred);\n+                    LOG.debug(\"Added private credential to {} principal name: '{}'\",\n+                            entity, clientPrincipal);\n+                } catch (GSSException ex) {\n+                    LOG.warn(\"Cannot add private credential to subject; \"\n+                                    + \"authentication at the server may fail\", ex);\n+                }\n+            }\n+            final KerberosName clientKerberosName = new KerberosName(\n+                    clientPrincipal.getName());\n+            // assume that server and client are in the same realm (by default;\n+            // unless the system property\n+            // \"zookeeper.server.realm\" is set).\n+            String serverRealm = System.getProperty(\"zookeeper.server.realm\",\n+                    clientKerberosName.getRealm());\n+            KerberosName serviceKerberosName = new KerberosName(\n+                    servicePrincipal + \"@\" + serverRealm);\n+            final String serviceName = serviceKerberosName.getServiceName();\n+            final String serviceHostname = serviceKerberosName.getHostName();\n+            final String clientPrincipalName = clientKerberosName.toString();\n+            try {\n+                saslClient = Subject.doAs(subject,\n+                        new PrivilegedExceptionAction<SaslClient>() {\n+                            public SaslClient run() throws SaslException {\n+                                LOG.info(\"{} will use GSSAPI as SASL mechanism.\", entity);\n+                                String[] mechs = { \"GSSAPI\" };\n+                                LOG.debug(\"creating sasl client: {}={};service={};serviceHostname={}\",\n+                                        new Object[] { entity, clientPrincipalName, serviceName, serviceHostname });\n+                                SaslClient saslClient = Sasl.createSaslClient(\n+                                        mechs, clientPrincipalName, serviceName,\n+                                        serviceHostname, null,\n+                                        new SaslClientCallbackHandler(null, entity));\n+                                return saslClient;\n+                            }\n+                        });\n+                return saslClient;\n+            } catch (Exception e) {\n+                LOG.error(\"Exception while trying to create SASL client\", e);\n+                return null;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Create an instance of a SaslServer. It will return null if there is an exception.\n+     *\n+     * @param subject subject\n+     * @param protocol protocol\n+     * @param serverName server name\n+     * @param callbackHandler login callback handler\n+     * @param LOG logger\n+     * @return sasl server object\n+     */\n+    public static SaslServer createSaslServer(final Subject subject,\n+            final String protocol, final String serverName,\n+            final CallbackHandler callbackHandler, final Logger LOG) {\n+        if (subject != null) {\n+            // server is using a JAAS-authenticated subject: determine service\n+            // principal name and hostname from zk server's subject.\n+            if (subject.getPrincipals().size() > 0) {\n+                try {\n+                    final Object[] principals = subject.getPrincipals()\n+                            .toArray();\n+                    final Principal servicePrincipal = (Principal) principals[0];\n+\n+                    // e.g. servicePrincipalNameAndHostname :=\n+                    // \"zookeeper/myhost.foo.com@FOO.COM\"\n+                    final String servicePrincipalNameAndHostname = servicePrincipal\n+                            .getName();\n+\n+                    int indexOf = servicePrincipalNameAndHostname.indexOf(\"/\");\n+\n+                    // e.g. servicePrincipalName := \"zookeeper\"\n+                    final String servicePrincipalName = servicePrincipalNameAndHostname\n+                            .substring(0, indexOf);\n+\n+                    // e.g. serviceHostnameAndKerbDomain :=\n+                    // \"myhost.foo.com@FOO.COM\"\n+                    final String serviceHostnameAndKerbDomain = servicePrincipalNameAndHostname\n+                            .substring(indexOf + 1,\n+                                    servicePrincipalNameAndHostname.length());\n+\n+                    indexOf = serviceHostnameAndKerbDomain.indexOf(\"@\");\n+                    // e.g. serviceHostname := \"myhost.foo.com\"\n+                    final String serviceHostname = serviceHostnameAndKerbDomain\n+                            .substring(0, indexOf);\n+\n+                    // TODO: should depend on zoo.cfg specified mechs, but if\n+                    // subject is non-null, it can be assumed to be GSSAPI.\n+                    final String mech = \"GSSAPI\";\n+\n+                    LOG.debug(\"serviceHostname is '\" + serviceHostname + \"'\");\n+                    LOG.debug(\"servicePrincipalName is '\" + servicePrincipalName\n+                            + \"'\");\n+                    LOG.debug(\"SASL mechanism(mech) is '\" + mech + \"'\");\n+\n+                    boolean usingNativeJgss = Boolean\n+                            .getBoolean(\"sun.security.jgss.native\");\n+                    if (usingNativeJgss) {\n+                        // http://docs.oracle.com/javase/6/docs/technotes/guides/security/jgss/jgss-features.html\n+                        // \"\"\"\n+                        // In addition, when performing operations as a\n+                        // particular\n+                        // Subject, e.g. Subject.doAs(...) or\n+                        // Subject.doAsPrivileged(...), the to-be-used\n+                        // GSSCredential should be added to Subject's\n+                        // private credential set. Otherwise, the GSS operations\n+                        // will fail since no credential is found.\n+                        // \"\"\"\n+                        try {\n+                            GSSManager manager = GSSManager.getInstance();\n+                            Oid krb5Mechanism = new Oid(\"1.2.840.113554.1.2.2\");\n+                            GSSName gssName = manager.createName(\n+                                    servicePrincipalName + \"@\"\n+                                            + serviceHostname,\n+                                    GSSName.NT_HOSTBASED_SERVICE);\n+                            GSSCredential cred = manager.createCredential(\n+                                    gssName, GSSContext.DEFAULT_LIFETIME,\n+                                    krb5Mechanism, GSSCredential.ACCEPT_ONLY);\n+                            subject.getPrivateCredentials().add(cred);\n+                            LOG.debug(\"Added private credential to service principal name: '{}',\"\n+                                            + \" GSSCredential name: {}\", servicePrincipalName, cred.getName());\n+                        } catch (GSSException ex) {\n+                            LOG.warn(\"Cannot add private credential to subject; \"\n+                                            + \"clients authentication may fail\", ex);\n+                        }\n+                    }\n+                    try {\n+                        return Subject.doAs(subject,\n+                                new PrivilegedExceptionAction<SaslServer>() {\n+                                    public SaslServer run() {\n+                                        try {\n+                                            SaslServer saslServer;\n+                                            saslServer = Sasl.createSaslServer(\n+                                                    mech, servicePrincipalName,\n+                                                    serviceHostname, null,\n+                                                    callbackHandler);\n+                                            return saslServer;\n+                                        } catch (SaslException e) {\n+                                            LOG.error(\"Zookeeper Server failed to create a SaslServer to interact with a client during session initiation: \", e);\n+                                            return null;\n+                                        }\n+                                    }\n+                                });\n+                    } catch (PrivilegedActionException e) {\n+                        // TODO: exit server at this point(?)\n+                        LOG.error(\"Zookeeper Quorum member experienced a PrivilegedActionException exception while creating a SaslServer using a JAAS principal context:\", e);\n+                    }\n+                } catch (IndexOutOfBoundsException e) {\n+                    LOG.error(\"server principal name/hostname determination error: \", e);\n+                }\n+            } else {\n+                // JAAS non-GSSAPI authentication: assuming and supporting only\n+                // DIGEST-MD5 mechanism for now.\n+                // TODO: use 'authMech=' value in zoo.cfg.\n+                try {\n+                    SaslServer saslServer = Sasl.createSaslServer(\"DIGEST-MD5\",\n+                            protocol, serverName, null, callbackHandler);\n+                    return saslServer;\n+                } catch (SaslException e) {\n+                    LOG.error(\"Zookeeper Quorum member failed to create a SaslServer to interact with a client during session initiation\", e);\n+                }\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Convert Kerberos principal name pattern to valid Kerberos principal name.\n+     * If the principal name contains hostname pattern \"_HOST\" then it replaces\n+     * with the given hostname, which should be fully-qualified domain name.\n+     *\n+     * @param principalConfig\n+     *            the Kerberos principal name conf value to convert\n+     * @param hostname\n+     *            the fully-qualified domain name used for substitution\n+     * @return converted Kerberos principal name\n+     */\n+    public static String getServerPrincipal(String principalConfig,\n+            String hostname) {\n+        String[] components = getComponents(principalConfig);\n+        if (components == null || components.length != 2\n+                || !components[1].equals(QUORUM_HOSTNAME_PATTERN)) {\n+            return principalConfig;\n+        } else {\n+            return replacePattern(components, hostname);\n+        }\n+    }\n+\n+    private static String[] getComponents(String principalConfig) {\n+        if (principalConfig == null)\n+            return null;\n+        return principalConfig.split(\"[/]\");\n+    }\n+\n+    private static String replacePattern(String[] components, String hostname) {\n+        return components[0] + \"/\" + hostname.toLowerCase();\n+    }\n+}"
        },
        {
            "sha": "5c29155f668aad7756679199bbe914bf660582a8",
            "filename": "src/java/test/config/findbugsExcludeFile.xml",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fconfig%2FfindbugsExcludeFile.xml?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -66,6 +66,11 @@\n        <Bug code=\"EI2, EI\" />\n   </Match>\n \n+  <Match>\n+      <Class name=\"org.apache.zookeeper.server.quorum.QuorumAuthPacket\" />\n+      <Bug code=\"EI2, EI\" />\n+  </Match>\n+\n   <Match>\n     <Class name=\"org.apache.zookeeper.ClientCnxn\"/>\n       <Bug code=\"EI, EI2\" />"
        },
        {
            "sha": "43ec7c4c4e9e2687e21218f752c9b25a3cf699e2",
            "filename": "src/java/test/data/kerberos/minikdc-krb5.conf",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc-krb5.conf?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,30 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+# This resource is originally from HDFS, see the similarly named files there\n+# in case of bug fixing, history, etc.\n+# Branch : trunk\n+# Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+#\n+[libdefaults]\n+    default_realm = {0}\n+    udp_preference_limit = 1\n+\n+[realms]\n+    {0} = '{'\n+        kdc = {1}:{2}\n+    '}'\n\\ No newline at end of file"
        },
        {
            "sha": "20c8d7759ae52a24a9f5b2213794f40e9ac98302",
            "filename": "src/java/test/data/kerberos/minikdc.ldiff",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Fdata%2Fkerberos%2Fminikdc.ldiff?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,52 @@\n+#\n+# Licensed to the Apache Software Foundation (ASF) under one\n+# or more contributor license agreements.  See the NOTICE file\n+# distributed with this work for additional information\n+# regarding copyright ownership.  The ASF licenses this file\n+# to you under the Apache License, Version 2.0 (the\n+# \"License\"); you may not use this file except in compliance\n+# with the License.  You may obtain a copy of the License at\n+#\n+#     http://www.apache.org/licenses/LICENSE-2.0\n+#\n+# Unless required by applicable law or agreed to in writing, software\n+# distributed under the License is distributed on an \"AS IS\" BASIS,\n+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+# See the License for the specific language governing permissions and\n+# limitations under the License.\n+#\n+# This resource is originally from HDFS, see the similarly named files there\n+# in case of bug fixing, history, etc.\n+# Branch : trunk\n+# Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+#\n+dn: ou=users,dc=${0},dc=${1}\n+objectClass: organizationalUnit\n+objectClass: top\n+ou: users\n+\n+dn: uid=krbtgt,ou=users,dc=${0},dc=${1}\n+objectClass: top\n+objectClass: person\n+objectClass: inetOrgPerson\n+objectClass: krb5principal\n+objectClass: krb5kdcentry\n+cn: KDC Service\n+sn: Service\n+uid: krbtgt\n+userPassword: secret\n+krb5PrincipalName: krbtgt/${2}.${3}@${2}.${3}\n+krb5KeyVersionNumber: 0\n+\n+dn: uid=ldap,ou=users,dc=${0},dc=${1}\n+objectClass: top\n+objectClass: person\n+objectClass: inetOrgPerson\n+objectClass: krb5principal\n+objectClass: krb5kdcentry\n+cn: LDAP\n+sn: Service\n+uid: ldap\n+userPassword: secret\n+krb5PrincipalName: ldap/${4}@${2}.${3}\n+krb5KeyVersionNumber: 0\n\\ No newline at end of file"
        },
        {
            "sha": "9edb4be69f51f2a0d5ca8a7ed8e635166ac0425f",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/EphemeralNodeDeletionTest.java",
            "status": "modified",
            "additions": 7,
            "deletions": 1,
            "changes": 8,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FEphemeralNodeDeletionTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -38,6 +38,8 @@\n import org.junit.Assert;\n import org.junit.Test;\n \n+import javax.security.sasl.SaslException;\n+\n public class EphemeralNodeDeletionTest extends QuorumPeerTestBase {\n     private static int SERVER_COUNT = 3;\n     private MainThread[] mt = new MainThread[SERVER_COUNT];\n@@ -181,6 +183,10 @@ private QuorumPeer getByServerState(MainThread[] mt, ServerState state) {\n     static class CustomQuorumPeer extends QuorumPeer {\n         private boolean injectError = false;\n \n+        public CustomQuorumPeer() throws SaslException {\n+\n+        }\n+\n         @Override\n         protected Follower makeFollower(FileTxnSnapLog logFactory)\n                 throws IOException {\n@@ -215,7 +221,7 @@ public void setInjectError(boolean injectError) {\n \n     static class MockTestQPMain extends TestQPMain {\n         @Override\n-        protected QuorumPeer getQuorumPeer() {\n+        protected QuorumPeer getQuorumPeer() throws SaslException {\n             return new CustomQuorumPeer();\n         }\n     }"
        },
        {
            "sha": "f50d0bb0aff527be840890871b11d48dc84dd7d7",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLEBackwardElectionRoundTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLEBackwardElectionRoundTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -115,7 +115,7 @@ public void testBackwardElectionRound() throws Exception {\n          * Start mock server 1\n          */\n         QuorumPeer mockPeer = new QuorumPeer(peers, tmpdir[1], tmpdir[1], port[1], 3, 1, 1000, 2, 2);\n-        cnxManagers[0] = new QuorumCnxManager(mockPeer);\n+        cnxManagers[0] = mockPeer.createCnxnManager();\n         cnxManagers[0].listener.start();\n \n         cnxManagers[0].toSend(0l, initialMsg0);\n@@ -124,7 +124,7 @@ public void testBackwardElectionRound() throws Exception {\n          * Start mock server 2\n          */\n         mockPeer = new QuorumPeer(peers, tmpdir[2], tmpdir[2], port[2], 3, 2, 1000, 2, 2);\n-        cnxManagers[1] = new QuorumCnxManager(mockPeer);\n+        cnxManagers[1] = mockPeer.createCnxnManager();\n         cnxManagers[1].listener.start();\n \n         cnxManagers[1].toSend(0l, initialMsg1);"
        },
        {
            "sha": "6583f9071dad75a93a95d6db2f6effe3710add0d",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/FLELostMessageTest.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FFLELostMessageTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -95,7 +95,7 @@ public void testLostMessage() throws Exception {\n \n     void mockServer() throws InterruptedException, IOException {\n         QuorumPeer peer = new QuorumPeer(peers, tmpdir[0], tmpdir[0], port[0], 3, 0, 1000, 2, 2);\n-        cnxManager = new QuorumCnxManager(peer);\n+        cnxManager = peer.createCnxnManager();\n         cnxManager.listener.start();\n \n         cnxManager.toSend(1l, FLETestUtils.createMsg(ServerState.LOOKING.ordinal(), 0, 0, 0));"
        },
        {
            "sha": "f2389714b9c3806bca83575221e6d64878869268",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/LearnerHandlerTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 1,
            "changes": 3,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandlerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandlerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerHandlerTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -24,6 +24,7 @@\n import static org.mockito.Mockito.mock;\n import static org.mockito.Mockito.when;\n \n+import java.io.BufferedInputStream;\n import java.io.IOException;\n import java.net.Socket;\n import java.util.Iterator;\n@@ -55,7 +56,7 @@ class MockLearnerHandler extends LearnerHandler {\n         boolean threadStarted = false;\n \n         MockLearnerHandler(Socket sock, Leader leader) throws IOException {\n-            super(sock, leader);\n+            super(sock, new BufferedInputStream(sock.getInputStream()), leader);\n         }\n \n         protected void startSendingPackets() {"
        },
        {
            "sha": "17935505ca7f41445ea21824818a969568bfdf13",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/LearnerTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FLearnerTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -110,7 +110,7 @@ public void connectionRetryTimeoutTest() throws Exception {\n         InetSocketAddress addr = new InetSocketAddress(1111);\n \n         // we expect this to throw an IOException since we're faking socket connect errors every time\n-        learner.connectToLeader(addr);\n+        learner.connectToLeader(addr, \"\");\n     }\n     @Test\n     public void connectionInitLimitTimeoutTest() throws Exception {\n@@ -130,7 +130,7 @@ public void connectionInitLimitTimeoutTest() throws Exception {\n \n         // we expect this to throw an IOException since we're faking socket connect errors every time\n         try {\n-            learner.connectToLeader(addr);\n+            learner.connectToLeader(addr, \"\");\n             Assert.fail(\"should have thrown IOException!\");\n         } catch (IOException e) {\n             //good, wanted to see that, let's make sure we ran out of time"
        },
        {
            "sha": "21aa81911e578147eb9a3ee5d65a00b3c455d9f1",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/QuorumPeerTestBase.java",
            "status": "modified",
            "additions": 91,
            "deletions": 6,
            "changes": 97,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FQuorumPeerTestBase.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -26,6 +26,10 @@\n import java.io.FileWriter;\n import java.io.FilenameFilter;\n import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.Map.Entry;\n+import java.util.Set;\n import java.util.Properties;\n \n import org.slf4j.Logger;\n@@ -47,7 +51,7 @@ public class QuorumPeerTestBase extends ZKTestCase implements Watcher {\n     protected static final Logger LOG = LoggerFactory\n             .getLogger(QuorumPeerTestBase.class);\n \n-    public static final int TIMEOUT = 3000;\n+    public static final int TIMEOUT = 5000;\n \n     public void process(WatchedEvent event) {\n         // ignore for this test\n@@ -72,6 +76,60 @@ public static class MainThread implements Runnable {\n \n         volatile TestQPMain main;\n \n+        File baseDir;\n+        private int myid;\n+        private int clientPort;\n+        private String quorumCfgSection;\n+        private Map<String, String> otherConfigs;\n+\n+        public MainThread(int myid, int clientPort, String quorumCfgSection,\n+                          Map<String, String> otherConfigs) throws IOException {\n+            baseDir = ClientBase.createTmpDir();\n+            this.myid = myid;\n+            this.clientPort = clientPort;\n+            this.quorumCfgSection = quorumCfgSection;\n+            this.otherConfigs = otherConfigs;\n+            LOG.info(\"id = \" + myid + \" tmpDir = \" + baseDir + \" clientPort = \"\n+                    + clientPort);\n+            confFile = new File(baseDir, \"zoo.cfg\");\n+\n+            FileWriter fwriter = new FileWriter(confFile);\n+            fwriter.write(\"tickTime=4000\\n\");\n+            fwriter.write(\"initLimit=10\\n\");\n+            fwriter.write(\"syncLimit=5\\n\");\n+\n+            tmpDir = new File(baseDir, \"data\");\n+            if (!tmpDir.mkdir()) {\n+                throw new IOException(\"Unable to mkdir \" + tmpDir);\n+            }\n+\n+            // Convert windows path to UNIX to avoid problems with \"\\\"\n+            String dir = tmpDir.toString();\n+            String osname = java.lang.System.getProperty(\"os.name\");\n+            if (osname.toLowerCase().contains(\"windows\")) {\n+                dir = dir.replace('\\\\', '/');\n+            }\n+            fwriter.write(\"dataDir=\" + dir + \"\\n\");\n+\n+            fwriter.write(\"clientPort=\" + clientPort + \"\\n\");\n+\n+            // write extra configurations\n+            Set<Entry<String, String>> entrySet = otherConfigs.entrySet();\n+            for (Entry<String, String> entry : entrySet) {\n+                fwriter.write(entry.getKey() + \"=\" + entry.getValue() + \"\\n\");\n+            }\n+\n+            fwriter.write(quorumCfgSection + \"\\n\");\n+            fwriter.flush();\n+            fwriter.close();\n+\n+            File myidFile = new File(tmpDir, \"myid\");\n+            fwriter = new FileWriter(myidFile);\n+            fwriter.write(Integer.toString(myid));\n+            fwriter.flush();\n+            fwriter.close();\n+        }\n+\n         public MainThread(int myid, String quorumCfgSection) throws IOException {\n             this(myid, quorumCfgSection, true);\n         }\n@@ -87,11 +145,6 @@ public MainThread(int myid, String quorumCfgSection, boolean writeDynamicConfigF\n             this(myid, UNSET_STATIC_CLIENTPORT, quorumCfgSection, writeDynamicConfigFile);\n         }\n \n-        public MainThread(int myid, int clientPort, String quorumCfgSection)\n-                throws IOException {\n-            this(myid, clientPort, JettyAdminServer.DEFAULT_PORT, quorumCfgSection, null, null, true);\n-        }\n-\n         public MainThread(int myid, int clientPort, String quorumCfgSection, boolean writeDynamicConfigFile)\n                 throws IOException {\n             this(myid, clientPort, JettyAdminServer.DEFAULT_PORT, quorumCfgSection, null, null, writeDynamicConfigFile);\n@@ -237,6 +290,12 @@ public void writeTempDynamicConfigFile(String nextQuorumCfgSection, String versi\n             fwriter.close();\n         }\n \n+        public MainThread(int myid, int clientPort, String quorumCfgSection)\n+                throws IOException {\n+            this(myid, clientPort, quorumCfgSection,\n+                    new HashMap<String, String>());\n+        }\n+\n         Thread currentThread;\n \n         synchronized public void start() {\n@@ -301,5 +360,31 @@ public String getPropFromStaticFile(String key) throws IOException {\n         public QuorumPeer getQuorumPeer() {\n             return main.quorumPeer;\n         }\n+\n+\n+        public void deleteBaseDir() {\n+            ClientBase.recursiveDelete(baseDir);\n+        }\n+\n+        public int getMyid() {\n+            return myid;\n+        }\n+\n+        public int getClientPort() {\n+            return clientPort;\n+        }\n+\n+        public String getQuorumCfgSection() {\n+            return quorumCfgSection;\n+        }\n+\n+        public Map<String, String> getOtherConfigs() {\n+            return otherConfigs;\n+        }\n+\n+        public File getConfFile() {\n+            return confFile;\n+        }\n+\n     }\n }"
        },
        {
            "sha": "e96d2736581bf75fe99e235ac3e42e25ca04f1b9",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/RaceConditionTest.java",
            "status": "modified",
            "additions": 6,
            "deletions": 1,
            "changes": 7,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FRaceConditionTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FRaceConditionTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FRaceConditionTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -42,6 +42,8 @@\n import org.slf4j.Logger;\n import org.slf4j.LoggerFactory;\n \n+import javax.security.sasl.SaslException;\n+\n /**\n  * This test class contains test cases related to race condition in complete\n  * ZooKeeper\n@@ -156,6 +158,9 @@ private void shutdownFollowers(MainThread[] mt) {\n     private static class CustomQuorumPeer extends QuorumPeer {\n         private boolean stopPing;\n \n+        public CustomQuorumPeer() throws SaslException {\n+        }\n+\n         public void setStopPing(boolean stopPing) {\n             this.stopPing = stopPing;\n         }\n@@ -239,7 +244,7 @@ public MockProposalRequestProcessor(LeaderZooKeeperServer zks, RequestProcessor\n     private static class MockTestQPMain extends TestQPMain {\n \n         @Override\n-        protected QuorumPeer getQuorumPeer() {\n+        protected QuorumPeer getQuorumPeer() throws SaslException {\n             return new CustomQuorumPeer();\n         }\n     }"
        },
        {
            "sha": "10ec1ea5ba8c3c46c1685b924c488ef372c91f02",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/Zab1_0Test.java",
            "status": "modified",
            "additions": 26,
            "deletions": 19,
            "changes": 45,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2FZab1_0Test.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -23,6 +23,7 @@\n import static org.mockito.Mockito.spy;\n import static org.mockito.Mockito.verify;\n \n+import java.io.BufferedInputStream;\n import java.io.BufferedReader;\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n@@ -386,7 +387,9 @@ public void testLeaderConversation(LeaderConversation conversation) throws Excep\n                 Thread.sleep(20);\n             }\n             \n-            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);\n+            LearnerHandler lh = new LearnerHandler(leaderSocket,\n+                    new BufferedInputStream(leaderSocket.getInputStream()),\n+                    leader);\n             lh.start();\n             leaderSocket.setSoTimeout(4000);\n \n@@ -454,8 +457,10 @@ public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversa\n             while(leader.cnxAcceptor == null || !leader.cnxAcceptor.isAlive()) {\n                 Thread.sleep(20);\n             }\n-            \n-            LearnerHandler lh = new LearnerHandler(leaderSocket, leader);\n+\n+            LearnerHandler lh = new LearnerHandler(leaderSocket,\n+                    new BufferedInputStream(leaderSocket.getInputStream()),\n+                    leader);\n             lh.start();\n             leaderSocket.setSoTimeout(4000);\n \n@@ -477,7 +482,6 @@ public void testPopulatedLeaderConversation(PopulatedLeaderConversation conversa\n         }\n     }\n     \n-    \n     public void testFollowerConversation(FollowerConversation conversation) throws Exception {\n         File tmpDir = File.createTempFile(\"test\", \"dir\", testData);\n         tmpDir.delete();\n@@ -491,8 +495,10 @@ public void testFollowerConversation(FollowerConversation conversation) throws E\n             peer.follower = follower;\n             \n             ServerSocket ss =\n-                new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n-            follower.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());\n+                    new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n+            QuorumServer leaderQS = new QuorumServer(1,\n+                    (InetSocketAddress) ss.getLocalSocketAddress());\n+            follower.setLeaderQuorumServer(leaderQS);\n             final Follower followerForThread = follower;\n             \n             followerThread = new Thread() {\n@@ -545,7 +551,8 @@ public void testObserverConversation(ObserverConversation conversation) throws E\n \n             ServerSocket ss =\n                 new ServerSocket(0, 50, InetAddress.getByName(\"127.0.0.1\"));\n-            observer.setLeaderSocketAddress((InetSocketAddress)ss.getLocalSocketAddress());\n+            QuorumServer leaderQS = new QuorumServer(1, (InetSocketAddress) ss.getLocalSocketAddress());\n+            observer.setLeaderQuorumServer(leaderQS);\n             final Observer observerForThread = observer;\n \n             observerThread = new Thread() {\n@@ -1272,14 +1279,14 @@ static class ConversableFollower extends Follower {\n             super(self, zk);\n         }\n \n-        InetSocketAddress leaderAddr;\n-        public void setLeaderSocketAddress(InetSocketAddress addr) {\n-            leaderAddr = addr;\n+        QuorumServer leaderQuorumServer;\n+        public void setLeaderQuorumServer(QuorumServer quorumServer) {\n+            leaderQuorumServer = quorumServer;\n         }\n         \n         @Override\n-        protected InetSocketAddress findLeader() {\n-            return leaderAddr;\n+        protected QuorumServer findLeader() {\n+            return leaderQuorumServer;\n         }\n     }\n     private ConversableFollower createFollower(File tmpDir, QuorumPeer peer)\n@@ -1298,14 +1305,14 @@ static class ConversableObserver extends Observer {\n             super(self, zk);\n         }\n \n-        InetSocketAddress leaderAddr;\n-        public void setLeaderSocketAddress(InetSocketAddress addr) {\n-            leaderAddr = addr;\n+        QuorumServer leaderQuorumServer;\n+        public void setLeaderQuorumServer(QuorumServer quorumServer) {\n+            leaderQuorumServer = quorumServer;\n         }\n \n         @Override\n-        protected InetSocketAddress findLeader() {\n-            return leaderAddr;\n+        protected QuorumServer findLeader() {\n+            return leaderQuorumServer;\n         }\n     }\n \n@@ -1321,7 +1328,7 @@ private ConversableObserver createObserver(File tmpDir, QuorumPeer peer)\n \n     private QuorumPeer createQuorumPeer(File tmpDir) throws IOException, FileNotFoundException {\n         HashMap<Long, QuorumServer> peers = new HashMap<Long, QuorumServer>();\n-        QuorumPeer peer = new QuorumPeer();\n+        QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n         peer.syncLimit = SYNC_LIMIT;\n         peer.initLimit = 2;\n         peer.tickTime = 2000;\n@@ -1374,7 +1381,7 @@ public void testInitialAcceptedCurrent() throws Exception {\n                     new ErrorTxn(1), zxid));\n             logFactory.commit();\n             ZKDatabase zkDb = new ZKDatabase(logFactory);\n-            QuorumPeer peer = new QuorumPeer();\n+            QuorumPeer peer = QuorumPeer.testingQuorumPeer();\n             peer.setZKDatabase(zkDb);\n             peer.setTxnFactory(logFactory);\n             peer.getLastLoggedZxid();"
        },
        {
            "sha": "9617c70b332acb4a7839ed8eb5c0e685ec055d2f",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/KerberosSecurityTestcase.java",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosSecurityTestcase.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,120 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Before;\n+import org.junit.BeforeClass;\n+\n+import java.io.File;\n+import java.io.IOException;\n+import java.util.Properties;\n+\n+/*\n+ * This code is originally from HDFS, see the similarly named file there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 1d1ab587e4e92ce3aea4cb144811f69145cb3b33\n+ */\n+\n+/**\n+ * KerberosSecurityTestcase provides a base class for using MiniKdc with other\n+ * test cases. KerberosSecurityTestcase starts the MiniKdc (@Before) before\n+ * running tests, and stop the MiniKdc (@After) after the testcases, using\n+ * default settings (working dir and kdc configurations).\n+ * <p>\n+ * Users can directly inherit this class and implement their own test functions\n+ * using the default settings, or override functions getTestDir() and\n+ * createMiniKdcConf() to provide new settings.\n+ */\n+public class KerberosSecurityTestcase extends QuorumAuthTestBase {\n+    private static MiniKdc kdc;\n+    private static File workDir;\n+    private static Properties conf;\n+\n+    @BeforeClass\n+    public static void setUpSasl() throws Exception {\n+        startMiniKdc();\n+    }\n+\n+    @AfterClass\n+    public static void tearDownSasl() throws Exception {\n+        stopMiniKdc();\n+        FileUtils.deleteQuietly(workDir);\n+    }\n+\n+    public static void startMiniKdc() throws Exception {\n+        createTestDir();\n+        createMiniKdcConf();\n+\n+        kdc = new MiniKdc(conf, workDir);\n+        kdc.start();\n+    }\n+\n+    /**\n+     * Create a working directory, it should be the build directory. Under this\n+     * directory an ApacheDS working directory will be created, this directory\n+     * will be deleted when the MiniKdc stops.\n+     *\n+     * @throws IOException\n+     */\n+    public static void createTestDir() throws IOException {\n+        workDir = createTmpDir(\n+                new File(System.getProperty(\"build.test.dir\", \"build\")));\n+    }\n+\n+    static File createTmpDir(File parentDir) throws IOException {\n+        File tmpFile = File.createTempFile(\"test\", \".junit\", parentDir);\n+        // don't delete tmpFile - this ensures we don't attempt to create\n+        // a tmpDir with a duplicate name\n+        File tmpDir = new File(tmpFile + \".dir\");\n+        // never true if tmpfile does it's job\n+        Assert.assertFalse(tmpDir.exists());\n+        Assert.assertTrue(tmpDir.mkdirs());\n+        return tmpDir;\n+    }\n+\n+    /**\n+     * Create a Kdc configuration\n+     */\n+    public static void createMiniKdcConf() {\n+        conf = MiniKdc.createConf();\n+    }\n+\n+    public static void stopMiniKdc() {\n+        if (kdc != null) {\n+            kdc.stop();\n+        }\n+    }\n+\n+    public static MiniKdc getKdc() {\n+        return kdc;\n+    }\n+\n+    public static File getWorkDir() {\n+        return workDir;\n+    }\n+\n+    public static Properties getConf() {\n+        return conf;\n+    }\n+}"
        },
        {
            "sha": "4a75f8336c102b412b1fc06bb189ff3d7132616f",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/KerberosTestUtils.java",
            "status": "added",
            "additions": 76,
            "deletions": 0,
            "changes": 76,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FKerberosTestUtils.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,76 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.UUID;\n+\n+import org.apache.zookeeper.util.SecurityUtils;\n+\n+public class KerberosTestUtils {\n+    private static String keytabFile = new File(System.getProperty(\"test.dir\", \"build\"), UUID.randomUUID().toString())\n+            .getAbsolutePath();\n+\n+    public static String getRealm() {\n+        return \"EXAMPLE.COM\";\n+    }\n+\n+    public static String getLearnerPrincipal() {\n+        return \"learner@EXAMPLE.COM\";\n+    }\n+\n+    public static String getServerPrincipal() {\n+        return \"zkquorum/localhost@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostLearnerPrincipal() {\n+        return \"learner/_HOST@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostServerPrincipal() {\n+        return \"zkquorum/_HOST@EXAMPLE.COM\";\n+    }\n+\n+    public static String getHostNamedLearnerPrincipal(String myHostname) {\n+        return \"learner/\" + myHostname + \"@EXAMPLE.COM\";\n+    }\n+\n+    public static String getKeytabFile() {\n+        return keytabFile;\n+    }\n+\n+    public static String replaceHostPattern(String principal) {\n+        String[] components = principal.split(\"[/@]\");\n+        if (components == null || components.length < 2\n+                || !components[1].equals(SecurityUtils.QUORUM_HOSTNAME_PATTERN)) {\n+            return principal;\n+        } else {\n+            return replacePattern(components, \"localhost\");\n+        }\n+    }\n+\n+    public static String replacePattern(String[] components, String hostname) {\n+        if (components.length == 3) {\n+            return components[0] + \"/\" + hostname.toLowerCase() + \"@\"\n+                    + components[2];\n+        } else {\n+            return components[0] + \"/\" + hostname.toLowerCase();\n+        }\n+    }\n+}"
        },
        {
            "sha": "4afef41eadc7143181cf1ddc7e1e9bc3f935b984",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/MiniKdc.java",
            "status": "added",
            "additions": 418,
            "deletions": 0,
            "changes": 418,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdc.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,418 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+import org.apache.commons.io.Charsets;\n+import org.apache.kerby.kerberos.kerb.KrbException;\n+import org.apache.kerby.kerberos.kerb.server.KdcConfigKey;\n+import org.apache.kerby.kerberos.kerb.server.SimpleKdcServer;\n+import org.apache.kerby.util.IOUtil;\n+import org.apache.kerby.util.NetworkUtil;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+import java.io.File;\n+import java.io.FileInputStream;\n+import java.io.InputStream;\n+import java.io.InputStreamReader;\n+import java.io.IOException;\n+import java.util.Arrays;\n+import java.util.HashSet;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.Set;\n+\n+/**\n+ * Mini KDC based on Apache Directory Server that can be embedded in testcases\n+ * or used from command line as a standalone KDC.\n+ * <p>\n+ * <b>From within testcases:</b>\n+ * <p>\n+ * MiniKdc sets one System property when started and un-set when stopped:\n+ * <ul>\n+ *   <li>sun.security.krb5.debug: set to the debug value provided in the\n+ *   configuration</li>\n+ * </ul>\n+ * Because of this, multiple MiniKdc instances cannot be started in parallel.\n+ * For example, running testcases in parallel that start a KDC each. To\n+ * accomplish this a single MiniKdc should be used for all testcases running\n+ * in parallel.\n+ * <p>\n+ * MiniKdc default configuration values are:\n+ * <ul>\n+ *   <li>org.name=EXAMPLE (used to create the REALM)</li>\n+ *   <li>org.domain=COM (used to create the REALM)</li>\n+ *   <li>kdc.bind.address=localhost</li>\n+ *   <li>kdc.port=0 (ephemeral port)</li>\n+ *   <li>instance=DefaultKrbServer</li>\n+ *   <li>max.ticket.lifetime=86400000 (1 day)</li>\n+ *   <li>max.renewable.lifetime=604800000 (7 days)</li>\n+ *   <li>transport=TCP</li>\n+ *   <li>debug=false</li>\n+ * </ul>\n+ * The generated krb5.conf forces TCP connections.\n+ */\n+/*\n+ * This code is originally from HDFS, see the file name MiniKdc there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 916140604ffef59466ba30832478311d3e6249bd\n+ */\n+public class MiniKdc {\n+\n+    public static final String JAVA_SECURITY_KRB5_CONF =\n+            \"java.security.krb5.conf\";\n+    public static final String SUN_SECURITY_KRB5_DEBUG =\n+            \"sun.security.krb5.debug\";\n+\n+    public static void main(String[] args) throws Exception {\n+        if (args.length < 4) {\n+            System.out.println(\"Arguments: <WORKDIR> <MINIKDCPROPERTIES> \" +\n+                    \"<KEYTABFILE> [<PRINCIPALS>]+\");\n+            System.exit(1);\n+        }\n+        File workDir = new File(args[0]);\n+        if (!workDir.exists()) {\n+            throw new RuntimeException(\"Specified work directory does not exists: \"\n+                    + workDir.getAbsolutePath());\n+        }\n+        Properties conf = createConf();\n+        File file = new File(args[1]);\n+        if (!file.exists()) {\n+            throw new RuntimeException(\"Specified configuration does not exists: \"\n+                    + file.getAbsolutePath());\n+        }\n+        Properties userConf = new Properties();\n+        InputStreamReader r = null;\n+        try {\n+            r = new InputStreamReader(new FileInputStream(file), Charsets.UTF_8);\n+            userConf.load(r);\n+        } finally {\n+            if (r != null) {\n+                r.close();\n+            }\n+        }\n+        for (Map.Entry<?, ?> entry : userConf.entrySet()) {\n+            conf.put(entry.getKey(), entry.getValue());\n+        }\n+        final MiniKdc miniKdc = new MiniKdc(conf, workDir);\n+        miniKdc.start();\n+        File krb5conf = new File(workDir, \"krb5.conf\");\n+        if (miniKdc.getKrb5conf().renameTo(krb5conf)) {\n+            File keytabFile = new File(args[2]).getAbsoluteFile();\n+            String[] principals = new String[args.length - 3];\n+            System.arraycopy(args, 3, principals, 0, args.length - 3);\n+            miniKdc.createPrincipal(keytabFile, principals);\n+            System.out.println();\n+            System.out.println(\"Standalone MiniKdc Running\");\n+            System.out.println(\"---------------------------------------------------\");\n+            System.out.println(\"  Realm           : \" + miniKdc.getRealm());\n+            System.out.println(\"  Running at      : \" + miniKdc.getHost() + \":\" +\n+                    miniKdc.getHost());\n+            System.out.println(\"  krb5conf        : \" + krb5conf);\n+            System.out.println();\n+            System.out.println(\"  created keytab  : \" + keytabFile);\n+            System.out.println(\"  with principals : \" + Arrays.asList(principals));\n+            System.out.println();\n+            System.out.println(\" Do <CTRL-C> or kill <PID> to stop it\");\n+            System.out.println(\"---------------------------------------------------\");\n+            System.out.println();\n+            Runtime.getRuntime().addShutdownHook(new Thread() {\n+                @Override\n+                public void run() {\n+                    miniKdc.stop();\n+                }\n+            });\n+        } else {\n+            throw new RuntimeException(\"Cannot rename KDC's krb5conf to \"\n+                    + krb5conf.getAbsolutePath());\n+        }\n+    }\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(MiniKdc.class);\n+\n+    public static final String ORG_NAME = \"org.name\";\n+    public static final String ORG_DOMAIN = \"org.domain\";\n+    public static final String KDC_BIND_ADDRESS = \"kdc.bind.address\";\n+    public static final String KDC_PORT = \"kdc.port\";\n+    public static final String INSTANCE = \"instance\";\n+    public static final String MAX_TICKET_LIFETIME = \"max.ticket.lifetime\";\n+    public static final String MAX_RENEWABLE_LIFETIME = \"max.renewable.lifetime\";\n+    public static final String TRANSPORT = \"transport\";\n+    public static final String DEBUG = \"debug\";\n+\n+    private static final Set<String> PROPERTIES = new HashSet<String>();\n+    private static final Properties DEFAULT_CONFIG = new Properties();\n+\n+    static {\n+        PROPERTIES.add(ORG_NAME);\n+        PROPERTIES.add(ORG_DOMAIN);\n+        PROPERTIES.add(KDC_BIND_ADDRESS);\n+        PROPERTIES.add(KDC_BIND_ADDRESS);\n+        PROPERTIES.add(KDC_PORT);\n+        PROPERTIES.add(INSTANCE);\n+        PROPERTIES.add(TRANSPORT);\n+        PROPERTIES.add(MAX_TICKET_LIFETIME);\n+        PROPERTIES.add(MAX_RENEWABLE_LIFETIME);\n+\n+        DEFAULT_CONFIG.setProperty(KDC_BIND_ADDRESS, \"localhost\");\n+        DEFAULT_CONFIG.setProperty(KDC_PORT, \"0\");\n+        DEFAULT_CONFIG.setProperty(INSTANCE, \"DefaultKrbServer\");\n+        DEFAULT_CONFIG.setProperty(ORG_NAME, \"EXAMPLE\");\n+        DEFAULT_CONFIG.setProperty(ORG_DOMAIN, \"COM\");\n+        DEFAULT_CONFIG.setProperty(TRANSPORT, \"TCP\");\n+        DEFAULT_CONFIG.setProperty(MAX_TICKET_LIFETIME, \"86400000\");\n+        DEFAULT_CONFIG.setProperty(MAX_RENEWABLE_LIFETIME, \"604800000\");\n+        DEFAULT_CONFIG.setProperty(DEBUG, \"false\");\n+    }\n+\n+    /**\n+     * Convenience method that returns MiniKdc default configuration.\n+     * <p>\n+     * The returned configuration is a copy, it can be customized before using\n+     * it to create a MiniKdc.\n+     * @return a MiniKdc default configuration.\n+     */\n+    public static Properties createConf() {\n+        return (Properties) DEFAULT_CONFIG.clone();\n+    }\n+\n+    private Properties conf;\n+    private SimpleKdcServer simpleKdc;\n+    private int port;\n+    private String realm;\n+    private File workDir;\n+    private File krb5conf;\n+    private String transport;\n+    private boolean krb5Debug;\n+\n+    public void setTransport(String transport) {\n+        this.transport = transport;\n+    }\n+    /**\n+     * Creates a MiniKdc.\n+     *\n+     * @param conf MiniKdc configuration.\n+     * @param workDir working directory, it should be the build directory. Under\n+     * this directory an ApacheDS working directory will be created, this\n+     * directory will be deleted when the MiniKdc stops.\n+     * @throws Exception thrown if the MiniKdc could not be created.\n+     */\n+    public MiniKdc(Properties conf, File workDir) throws Exception {\n+        if (!conf.keySet().containsAll(PROPERTIES)) {\n+            Set<String> missingProperties = new HashSet<String>(PROPERTIES);\n+            missingProperties.removeAll(conf.keySet());\n+            throw new IllegalArgumentException(\"Missing configuration properties: \"\n+                    + missingProperties);\n+        }\n+        this.workDir = new File(workDir, Long.toString(System.currentTimeMillis()));\n+        if (!this.workDir.exists()\n+                && !this.workDir.mkdirs()) {\n+            throw new RuntimeException(\"Cannot create directory \" + this.workDir);\n+        }\n+        LOG.info(\"Configuration:\");\n+        LOG.info(\"---------------------------------------------------------------\");\n+        for (Map.Entry<?, ?> entry : conf.entrySet()) {\n+            LOG.info(\"  {}: {}\", entry.getKey(), entry.getValue());\n+        }\n+        LOG.info(\"---------------------------------------------------------------\");\n+        this.conf = conf;\n+        port = Integer.parseInt(conf.getProperty(KDC_PORT));\n+        String orgName= conf.getProperty(ORG_NAME);\n+        String orgDomain = conf.getProperty(ORG_DOMAIN);\n+        realm = orgName.toUpperCase(Locale.ENGLISH) + \".\"\n+                + orgDomain.toUpperCase(Locale.ENGLISH);\n+    }\n+\n+    /**\n+     * Returns the port of the MiniKdc.\n+     *\n+     * @return the port of the MiniKdc.\n+     */\n+    public int getPort() {\n+        return port;\n+    }\n+\n+    /**\n+     * Returns the host of the MiniKdc.\n+     *\n+     * @return the host of the MiniKdc.\n+     */\n+    public String getHost() {\n+        return conf.getProperty(KDC_BIND_ADDRESS);\n+    }\n+\n+    /**\n+     * Returns the realm of the MiniKdc.\n+     *\n+     * @return the realm of the MiniKdc.\n+     */\n+    public String getRealm() {\n+        return realm;\n+    }\n+\n+    public File getKrb5conf() {\n+        krb5conf = new File(System.getProperty(JAVA_SECURITY_KRB5_CONF));\n+        return krb5conf;\n+    }\n+\n+    /**\n+     * Starts the MiniKdc.\n+     *\n+     * @throws Exception thrown if the MiniKdc could not be started.\n+     */\n+    public synchronized void start() throws Exception {\n+        if (simpleKdc != null) {\n+            throw new RuntimeException(\"Already started\");\n+        }\n+        simpleKdc = new SimpleKdcServer();\n+        prepareKdcServer();\n+        simpleKdc.init();\n+        resetDefaultRealm();\n+        simpleKdc.start();\n+        LOG.info(\"MiniKdc stated.\");\n+    }\n+\n+    private void resetDefaultRealm() throws IOException {\n+        InputStream templateResource = new FileInputStream(\n+                getKrb5conf().getAbsolutePath());\n+        String content = IOUtil.readInput(templateResource);\n+        content = content.replaceAll(\"default_realm = .*\\n\",\n+                \"default_realm = \" + getRealm() + \"\\n\");\n+        IOUtil.writeFile(content, getKrb5conf());\n+    }\n+\n+    private void prepareKdcServer() throws Exception {\n+        // transport\n+        simpleKdc.setWorkDir(workDir);\n+        simpleKdc.setKdcHost(getHost());\n+        simpleKdc.setKdcRealm(realm);\n+        if (transport == null) {\n+            transport = conf.getProperty(TRANSPORT);\n+        }\n+        if (port == 0) {\n+            port = NetworkUtil.getServerPort();\n+        }\n+        if (transport != null) {\n+            if (transport.trim().equals(\"TCP\")) {\n+                simpleKdc.setKdcTcpPort(port);\n+                simpleKdc.setAllowUdp(false);\n+            } else if (transport.trim().equals(\"UDP\")) {\n+                simpleKdc.setKdcUdpPort(port);\n+                simpleKdc.setAllowTcp(false);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid transport: \" + transport);\n+            }\n+        } else {\n+            throw new IllegalArgumentException(\"Need to set transport!\");\n+        }\n+        simpleKdc.getKdcConfig().setString(KdcConfigKey.KDC_SERVICE_NAME,\n+                conf.getProperty(INSTANCE));\n+        if (conf.getProperty(DEBUG) != null) {\n+            krb5Debug = getAndSet(SUN_SECURITY_KRB5_DEBUG, conf.getProperty(DEBUG));\n+        }\n+    }\n+\n+    /**\n+     * Stops the MiniKdc\n+     */\n+    public synchronized void stop() {\n+        if (simpleKdc != null) {\n+            try {\n+                simpleKdc.stop();\n+            } catch (KrbException e) {\n+                e.printStackTrace();\n+            } finally {\n+                if(conf.getProperty(DEBUG) != null) {\n+                    System.setProperty(SUN_SECURITY_KRB5_DEBUG,\n+                            Boolean.toString(krb5Debug));\n+                }\n+            }\n+        }\n+        delete(workDir);\n+        try {\n+            // Will be fixed in next Kerby version.\n+            Thread.sleep(1000);\n+        } catch (InterruptedException e) {\n+            e.printStackTrace();\n+        }\n+        LOG.info(\"MiniKdc stopped.\");\n+    }\n+\n+    private void delete(File f) {\n+        if (f.isFile()) {\n+            if (! f.delete()) {\n+                LOG.warn(\"WARNING: cannot delete file \" + f.getAbsolutePath());\n+            }\n+        } else {\n+            for (File c: f.listFiles()) {\n+                delete(c);\n+            }\n+            if (! f.delete()) {\n+                LOG.warn(\"WARNING: cannot delete directory \" + f.getAbsolutePath());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Creates a principal in the KDC with the specified user and password.\n+     *\n+     * @param principal principal name, do not include the domain.\n+     * @param password password.\n+     * @throws Exception thrown if the principal could not be created.\n+     */\n+    public synchronized void createPrincipal(String principal, String password)\n+            throws Exception {\n+        simpleKdc.createPrincipal(principal, password);\n+    }\n+\n+    /**\n+     * Creates multiple principals in the KDC and adds them to a keytab file.\n+     *\n+     * @param keytabFile keytab file to add the created principals.\n+     * @param principals principals to add to the KDC, do not include the domain.\n+     * @throws Exception thrown if the principals or the keytab file could not be\n+     * created.\n+     */\n+    public synchronized void createPrincipal(File keytabFile,\n+                                             String ... principals)\n+            throws Exception {\n+        simpleKdc.createPrincipals(principals);\n+        if (keytabFile.exists() && !keytabFile.delete()) {\n+            LOG.error(\"Failed to delete keytab file: \" + keytabFile);\n+        }\n+        for (String principal : principals) {\n+            simpleKdc.getKadmin().exportKeytab(keytabFile, principal);\n+        }\n+    }\n+\n+    /**\n+     * Set the System property; return the old value for caching.\n+     *\n+     * @param sysprop property\n+     * @param debug true or false\n+     * @return the previous value\n+     */\n+    private boolean getAndSet(String sysprop, String debug) {\n+        boolean old = Boolean.getBoolean(sysprop);\n+        System.setProperty(sysprop, debug);\n+        return old;\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "69dbcd1e57f5d902827521b391ed56c55284b386",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/MiniKdcTest.java",
            "status": "added",
            "additions": 185,
            "deletions": 0,
            "changes": 185,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FMiniKdcTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,185 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import org.apache.kerby.kerberos.kerb.keytab.Keytab;\n+import org.apache.kerby.kerberos.kerb.type.base.PrincipalName;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+import javax.security.auth.Subject;\n+import javax.security.auth.kerberos.KerberosPrincipal;\n+import javax.security.auth.login.AppConfigurationEntry;\n+import javax.security.auth.login.Configuration;\n+import javax.security.auth.login.LoginContext;\n+import java.io.File;\n+import java.security.Principal;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.Map;\n+import java.util.HashSet;\n+import java.util.HashMap;\n+import java.util.Arrays;\n+\n+/*\n+ * This code is originally from HDFS, see the file name TestMiniKdc there\n+ * in case of bug fixing, history, etc.\n+ *\n+ * Branch : trunk\n+ * Github Revision: 916140604ffef59466ba30832478311d3e6249bd\n+ */\n+public class MiniKdcTest extends KerberosSecurityTestcase {\n+    private static final boolean IBM_JAVA = System.getProperty(\"java.vendor\")\n+            .contains(\"IBM\");\n+\n+    @Test(timeout = 60000)\n+    public void testMiniKdcStart() {\n+        MiniKdc kdc = getKdc();\n+        Assert.assertNotSame(0, kdc.getPort());\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testKeytabGen() throws Exception {\n+        MiniKdc kdc = getKdc();\n+        File workDir = getWorkDir();\n+\n+        kdc.createPrincipal(new File(workDir, \"keytab\"), \"foo/bar\", \"bar/foo\");\n+        List<PrincipalName> principalNameList =\n+                Keytab.loadKeytab(new File(workDir, \"keytab\")).getPrincipals();\n+\n+        Set<String> principals = new HashSet<String>();\n+        for (PrincipalName principalName : principalNameList) {\n+          principals.add(principalName.getName());\n+        }\n+\n+        Assert.assertEquals(new HashSet<String>(Arrays.asList(\n+                \"foo/bar@\" + kdc.getRealm(), \"bar/foo@\" + kdc.getRealm())),\n+                principals);\n+      }\n+\n+    private static class KerberosConfiguration extends Configuration {\n+        private String principal;\n+        private String keytab;\n+        private boolean isInitiator;\n+\n+        private KerberosConfiguration(String principal, File keytab,\n+                boolean client) {\n+            this.principal = principal;\n+            this.keytab = keytab.getAbsolutePath();\n+            this.isInitiator = client;\n+        }\n+\n+        public static Configuration createClientConfig(String principal,\n+                File keytab) {\n+            return new KerberosConfiguration(principal, keytab, true);\n+        }\n+\n+        public static Configuration createServerConfig(String principal,\n+                File keytab) {\n+            return new KerberosConfiguration(principal, keytab, false);\n+        }\n+\n+        private static String getKrb5LoginModuleName() {\n+            return System.getProperty(\"java.vendor\").contains(\"IBM\")\n+                    ? \"com.ibm.security.auth.module.Krb5LoginModule\"\n+                    : \"com.sun.security.auth.module.Krb5LoginModule\";\n+        }\n+\n+        @Override\n+        public AppConfigurationEntry[] getAppConfigurationEntry(String name) {\n+            Map<String, String> options = new HashMap<String, String>();\n+            options.put(\"principal\", principal);\n+            options.put(\"refreshKrb5Config\", \"true\");\n+            if (IBM_JAVA) {\n+                options.put(\"useKeytab\", keytab);\n+                options.put(\"credsType\", \"both\");\n+            } else {\n+                options.put(\"keyTab\", keytab);\n+                options.put(\"useKeyTab\", \"true\");\n+                options.put(\"storeKey\", \"true\");\n+                options.put(\"doNotPrompt\", \"true\");\n+                options.put(\"useTicketCache\", \"true\");\n+                options.put(\"renewTGT\", \"true\");\n+                options.put(\"isInitiator\", Boolean.toString(isInitiator));\n+            }\n+            String ticketCache = System.getenv(\"KRB5CCNAME\");\n+            if (ticketCache != null) {\n+                options.put(\"ticketCache\", ticketCache);\n+            }\n+            options.put(\"debug\", \"true\");\n+\n+            return new AppConfigurationEntry[] {\n+                    new AppConfigurationEntry(getKrb5LoginModuleName(),\n+                            AppConfigurationEntry.LoginModuleControlFlag.REQUIRED,\n+                            options) };\n+        }\n+    }\n+\n+    @Test(timeout = 60000)\n+    public void testKerberosLogin() throws Exception {\n+        MiniKdc kdc = getKdc();\n+        File workDir = getWorkDir();\n+        LoginContext loginContext = null;\n+        try {\n+            String principal = \"foo\";\n+            File keytab = new File(workDir, \"foo.keytab\");\n+            kdc.createPrincipal(keytab, principal);\n+\n+            Set<Principal> principals = new HashSet<Principal>();\n+            principals.add(new KerberosPrincipal(principal));\n+\n+            // client login\n+            Subject subject = new Subject(false, principals,\n+                    new HashSet<Object>(), new HashSet<Object>());\n+            loginContext = new LoginContext(\"\", subject, null,\n+                    KerberosConfiguration.createClientConfig(principal,\n+                            keytab));\n+            loginContext.login();\n+            subject = loginContext.getSubject();\n+            Assert.assertEquals(1, subject.getPrincipals().size());\n+            Assert.assertEquals(KerberosPrincipal.class,\n+                    subject.getPrincipals().iterator().next().getClass());\n+            Assert.assertEquals(principal + \"@\" + kdc.getRealm(),\n+                    subject.getPrincipals().iterator().next().getName());\n+            loginContext.logout();\n+\n+            // server login\n+            subject = new Subject(false, principals, new HashSet<Object>(),\n+                    new HashSet<Object>());\n+            loginContext = new LoginContext(\"\", subject, null,\n+                    KerberosConfiguration.createServerConfig(principal,\n+                            keytab));\n+            loginContext.login();\n+            subject = loginContext.getSubject();\n+            Assert.assertEquals(1, subject.getPrincipals().size());\n+            Assert.assertEquals(KerberosPrincipal.class,\n+                    subject.getPrincipals().iterator().next().getClass());\n+            Assert.assertEquals(principal + \"@\" + kdc.getRealm(),\n+                    subject.getPrincipals().iterator().next().getName());\n+            loginContext.logout();\n+\n+        } finally {\n+            if (loginContext != null && loginContext.getSubject() != null\n+                    && !loginContext.getSubject().getPrincipals().isEmpty()) {\n+                loginContext.logout();\n+            }\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "8978d170f26272cf02d899d2a52c6350eab72006",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumAuthTestBase.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthTestBase.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,146 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.io.FileWriter;\n+import java.io.IOException;\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Map;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZKTestCase;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.junit.Assert;\n+import org.slf4j.Logger;\n+import org.slf4j.LoggerFactory;\n+\n+/**\n+ * QuorumAuthTestBase provides a base class for testing quorum peer mutual\n+ * authentication using SASL mechanisms.\n+ */\n+public class QuorumAuthTestBase extends ZKTestCase {\n+    protected static final Logger LOG = LoggerFactory.getLogger(QuorumAuthTestBase.class);\n+    protected List<MainThread> mt = new ArrayList<MainThread>();\n+    protected static File jaasConfigDir;\n+\n+    public static void setupJaasConfig(String jaasEntries) {\n+        try {\n+            jaasConfigDir = ClientBase.createTmpDir();\n+            File saslConfFile = new File(jaasConfigDir, \"jaas.conf\");\n+            FileWriter fwriter = new FileWriter(saslConfFile);\n+            fwriter.write(jaasEntries);\n+            fwriter.close();\n+            System.setProperty(\"java.security.auth.login.config\",\n+                    saslConfFile.getAbsolutePath());\n+        } catch (IOException ioe) {\n+            LOG.error(\"Failed to create tmp directory to hold JAAS conf file\", ioe);\n+            // could not create tmp directory to hold JAAS conf file : test will\n+            // fail now.\n+        }\n+    }\n+\n+    public static void cleanupJaasConfig() {\n+        if (jaasConfigDir != null) {\n+            FileUtils.deleteQuietly(jaasConfigDir);\n+        }\n+    }\n+\n+    protected String startQuorum(final int serverCount,\n+            Map<String, String> authConfigs, int authServerCount) throws IOException {\n+        StringBuilder connectStr = new StringBuilder();\n+        final int[] clientPorts = startQuorum(serverCount, connectStr,\n+                authConfigs, authServerCount);\n+        for (int i = 0; i < serverCount; i++) {\n+            Assert.assertTrue(\"waiting for server \" + i + \" being up\",\n+                    ClientBase.waitForServerUp(\"127.0.0.1:\" + clientPorts[i],\n+                            ClientBase.CONNECTION_TIMEOUT));\n+        }\n+        return connectStr.toString();\n+    }\n+\n+    protected int[] startQuorum(final int serverCount, StringBuilder connectStr,\n+            Map<String, String> authConfigs, int authServerCount) throws IOException {\n+        final int clientPorts[] = new int[serverCount];\n+        StringBuilder sb = new StringBuilder();\n+        for (int i = 0; i < serverCount; i++) {\n+            clientPorts[i] = PortAssignment.unique();\n+            String server = String.format(\n+                    \"server.%d=localhost:%d:%d:participant\", i,\n+                    PortAssignment.unique(), PortAssignment.unique());\n+            sb.append(server + \"\\n\");\n+            connectStr.append(\"127.0.0.1:\" + clientPorts[i]);\n+            if (i < serverCount - 1) {\n+                connectStr.append(\",\");\n+            }\n+        }\n+        String quorumCfg = sb.toString();\n+        // servers with authentication interfaces configured\n+        int i = 0;\n+        for (; i < authServerCount; i++) {\n+            startServer(authConfigs, clientPorts, quorumCfg, i);\n+        }\n+        // servers without any authentication configured\n+        for (int j = 0; j < serverCount - authServerCount; j++, i++) {\n+            MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg);\n+            mt.add(mthread);\n+            mthread.start();\n+        }\n+        return clientPorts;\n+    }\n+\n+    private void startServer(Map<String, String> authConfigs,\n+            final int[] clientPorts, String quorumCfg, int i)\n+                    throws IOException {\n+        MainThread mthread = new MainThread(i, clientPorts[i], quorumCfg,\n+                authConfigs);\n+        mt.add(mthread);\n+        mthread.start();\n+    }\n+\n+    protected void startServer(MainThread restartPeer,\n+            Map<String, String> authConfigs) throws IOException {\n+        MainThread mthread = new MainThread(restartPeer.getMyid(),\n+                restartPeer.getClientPort(), restartPeer.getQuorumCfgSection(),\n+                authConfigs);\n+        mt.add(mthread);\n+        mthread.start();\n+    }\n+\n+    void shutdownAll() {\n+        for (int i = 0; i < mt.size(); i++) {\n+            shutdown(i);\n+        }\n+    }\n+\n+    MainThread shutdown(int index) {\n+        MainThread mainThread = mt.get(index);\n+        try {\n+            mainThread.shutdown();\n+        } catch (InterruptedException e) {\n+        } finally {\n+            mt.remove(index);\n+        }\n+        mainThread.deleteBaseDir();\n+        return mainThread;\n+    }\n+}"
        },
        {
            "sha": "359324549e27124bda12b9cd78fdf27f3e047577",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumAuthUpgradeTest.java",
            "status": "added",
            "additions": 239,
            "deletions": 0,
            "changes": 239,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumAuthUpgradeTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,239 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.KeeperException;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientTest;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+/**\n+ * Rolling upgrade should do in three steps:\n+ *\n+ * step-1) Stop the server and set the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false and quorum.auth.serverRequireSasl=false\n+ * Ensure that all the servers should complete this step. Now, move to next step.\n+ *\n+ * step-2) Stop the server one by one and change the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=false\n+ * Ensure that all the servers should complete this step. Now, move to next step.\n+ *\n+ * step-3) Stop the server one by one and change the flags and restart the server.\n+ * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=true\n+ * Now, all the servers are fully upgraded and running in secured mode.\n+ */\n+public class QuorumAuthUpgradeTest extends QuorumAuthTestBase {\n+    static {\n+        String jaasEntries = new String(\"\" + \"QuorumServer {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       user_test=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"mypassword\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        shutdownAll();\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to start without any authentication.\n+     * peer0 -> quorum.auth.enableSasl=false\n+     * peer1 -> quorum.auth.enableSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testNullAuthLearnerServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 0);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     * peer1 -> quorum.auth.enableSasl=false, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerAgainstNullAuthServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 1);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     * peer1 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerAgainstNoAuthRequiredServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 2);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that servers are able to form quorum.\n+     * peer0 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+     * peer1 -> quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+     */\n+    @Test(timeout = 30000)\n+    public void testAuthLearnerServer() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+\n+        String connectStr = startQuorum(2, authConfigs, 2);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT);\n+        zk.close();\n+    }\n+\n+    /**\n+     * Rolling upgrade should do in three steps:\n+     *\n+     * step-1) Stop the server and set the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=false and quorum.auth.serverRequireSasl=false\n+     * Ensure that all the servers should complete this step. Now, move to next step.\n+     *\n+     * step-2) Stop the server one by one and change the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=false\n+     * Ensure that all the servers should complete this step. Now, move to next step.\n+     *\n+     * step-3) Stop the server one by one and change the flags and restart the server.\n+     * quorum.auth.enableSasl=true, quorum.auth.learnerRequireSasl=true and quorum.auth.serverRequireSasl=true\n+     * Now, all the servers are fully upgraded and running in secured mode.\n+     */\n+    @Test(timeout = 90000)\n+    public void testRollingUpgrade() throws Exception {\n+        // Start peer0,1,2 servers with quorum.auth.enableSasl=false and\n+        // quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+        // Assume this is an existing cluster.\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        String connectStr = startQuorum(3, authConfigs, 0);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT_SEQUENTIAL);\n+\n+        //1. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=false, quorum.auth.serverRequireSasl=false\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //2. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=false\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //3. Upgrade peer0,1,2 with quorum.auth.enableSasl=true and\n+        // quorum.auth.learnerRequireSasl=true, quorum.auth.serverRequireSasl=true\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        restartServer(authConfigs, 0, zk, watcher);\n+        restartServer(authConfigs, 1, zk, watcher);\n+        restartServer(authConfigs, 2, zk, watcher);\n+\n+        //4. Restart peer2 with quorum.auth.learnerEnableSasl=false and\n+        // quorum.auth.serverRequireSasl=false. It should fail to join the\n+        // quorum as this needs auth.\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+        MainThread m = shutdown(2);\n+        startServer(m, authConfigs);\n+        Assert.assertFalse(\"waiting for server 2 being up\", ClientBase\n+                .waitForServerUp(\"127.0.0.1:\" + m.getClientPort(), 5000));\n+    }\n+\n+    private void restartServer(Map<String, String> authConfigs, int index,\n+            ZooKeeper zk, CountdownWatcher watcher) throws IOException,\n+                    KeeperException, InterruptedException, TimeoutException {\n+        LOG.info(\"Restarting server myid=\" + index);\n+        MainThread m = shutdown(index);\n+        startServer(m, authConfigs);\n+        Assert.assertTrue(\"waiting for server\" + index + \"being up\",\n+                ClientBase.waitForServerUp(\"127.0.0.1:\" + m.getClientPort(),\n+                        ClientBase.CONNECTION_TIMEOUT));\n+        watcher.waitForConnected(ClientTest.CONNECTION_TIMEOUT);\n+        zk.create(\"/foo\", new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                CreateMode.PERSISTENT_SEQUENTIAL);\n+    }\n+}"
        },
        {
            "sha": "5eebdb335c02cd82321afdba6748c06f1324bc87",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumDigestAuthTest.java",
            "status": "added",
            "additions": 222,
            "deletions": 0,
            "changes": 222,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumDigestAuthTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,222 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.IOException;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.admin.AdminServer;\n+import org.apache.zookeeper.server.quorum.QuorumPeerMain;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase;\n+import org.apache.zookeeper.server.quorum.QuorumPeerConfig.ConfigException;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Assert;\n+import org.junit.Test;\n+\n+public class QuorumDigestAuthTest extends QuorumAuthTestBase {\n+\n+    static {\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       user_test=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"mypassword\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearnerInvalid {\\n\"\n+                + \"       org.apache.zookeeper.server.auth.DigestLoginModule required\\n\"\n+                + \"       username=\\\"test\\\"\\n\"\n+                + \"       password=\\\"invalid\\\";\\n\" + \"};\" + \"\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup(){\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 30000)\n+    public void testValidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with invalid credentials if\n+     * the configuration is set to quorum.auth.serverRequireSasl=false.\n+     * Quorum will talk each other even if the authentication is not succeeded\n+     */\n+    @Test(timeout = 30000)\n+    public void testSaslNotRequiredWithInvalidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, \"QuorumLearnerInvalid\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT,\n+                watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE,\n+                    CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that server shouldn't start with invalid credentials\n+     * if the configuration is set to quorum.auth.serverRequireSasl=true,\n+     * quorum.auth.learnerRequireSasl=true\n+     */\n+    @Test(timeout = 30000)\n+    public void testSaslRequiredInvalidCredentials() throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT, \"QuorumLearnerInvalid\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        int serverCount = 2;\n+        final int[] clientPorts = startQuorum(serverCount, new StringBuilder(),\n+                authConfigs, serverCount);\n+        for (int i = 0; i < serverCount; i++) {\n+            boolean waitForServerUp = ClientBase.waitForServerUp(\n+                    \"127.0.0.1:\" + clientPorts[i], QuorumPeerTestBase.TIMEOUT);\n+            Assert.assertFalse(\"Shouldn't start server with invalid credentials\",\n+                    waitForServerUp);\n+        }\n+    }\n+\n+    /**\n+     * If quorumpeer learner is not auth enabled then self won't be able to join\n+     * quorum. So this test is ensuring that the quorumpeer learner is also auth\n+     * enabled while enabling quorum server require sasl.\n+     */\n+    @Test(timeout = 10000)\n+    public void testEnableQuorumServerRequireSaslWithoutQuorumLearnerRequireSasl()\n+            throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearner\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        MainThread mthread = new MainThread(1, PortAssignment.unique(), \"\",\n+                authConfigs);\n+        String args[] = new String[1];\n+        args[0] = mthread.getConfFile().toString();\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException, AdminServer.AdminServerException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorumpeer learner is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+    }\n+\n+\n+    /**\n+     * If quorumpeer learner is not auth enabled then self won't be able to join\n+     * quorum. So this test is ensuring that the quorumpeer learner is also auth\n+     * enabled while enabling quorum server require sasl.\n+     */\n+    @Test(timeout = 10000)\n+    public void testEnableQuorumAuthenticationConfigurations()\n+            throws Exception {\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearner\");\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"false\");\n+\n+        // case-1) 'quorum.auth.enableSasl' is off. Tries to enable server sasl.\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"false\");\n+        MainThread mthread = new MainThread(1, PortAssignment.unique(), \"\",\n+                authConfigs);\n+        String args[] = new String[1];\n+        args[0] = mthread.getConfFile().toString();\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException, AdminServer.AdminServerException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorum sasl is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+\n+        // case-1) 'quorum.auth.enableSasl' is off. Tries to enable learner sasl.\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"false\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        try {\n+            new QuorumPeerMain() {\n+                @Override\n+                protected void initializeAndRun(String[] args)\n+                        throws ConfigException, IOException, AdminServer.AdminServerException {\n+                    super.initializeAndRun(args);\n+                }\n+            }.initializeAndRun(args);\n+            Assert.fail(\"Must throw exception as quorum sasl is not enabled!\");\n+        } catch (ConfigException e) {\n+            // expected\n+        }\n+    }\n+}"
        },
        {
            "sha": "2cc56a7679458d0abd1ef7f0767ee20db85f9294",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumKerberosAuthTest.java",
            "status": "added",
            "additions": 110,
            "deletions": 0,
            "changes": 110,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosAuthTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,110 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.Before;\n+import org.junit.Test;\n+\n+public class QuorumKerberosAuthTest extends KerberosSecurityTestcase {\n+    private static File keytabFile;\n+    static {\n+        String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.getServerPrincipal() + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.getLearnerPrincipal() + \"\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @Before\n+    public void setUp() throws Exception {\n+        // create keytab\n+        keytabFile = new File(KerberosTestUtils.getKeytabFile());\n+        String learnerPrincipal = KerberosTestUtils.getLearnerPrincipal();\n+        String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n+        learnerPrincipal = learnerPrincipal.substring(0, learnerPrincipal.lastIndexOf(\"@\"));\n+        serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n+        getKdc().createPrincipal(keytabFile, learnerPrincipal, serverPrincipal);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        if(keytabFile != null){\n+            FileUtils.deleteQuietly(keytabFile);\n+        }\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 120000)\n+    public void testValidCredentials() throws Exception {\n+        String serverPrincipal = KerberosTestUtils.getServerPrincipal();\n+        serverPrincipal = serverPrincipal.substring(0, serverPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+}"
        },
        {
            "sha": "fcb76919f1b5cdbc42ae75ecc11d698dad0723be",
            "filename": "src/java/test/org/apache/zookeeper/server/quorum/auth/QuorumKerberosHostBasedAuthTest.java",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Fserver%2Fquorum%2Fauth%2FQuorumKerberosHostBasedAuthTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -0,0 +1,184 @@\n+/**\n+ * Licensed to the Apache Software Foundation (ASF) under one\n+ * or more contributor license agreements.  See the NOTICE file\n+ * distributed with this work for additional information\n+ * regarding copyright ownership.  The ASF licenses this file\n+ * to you under the Apache License, Version 2.0 (the\n+ * \"License\"); you may not use this file except in compliance\n+ * with the License.  You may obtain a copy of the License at\n+ *\n+ *     http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package org.apache.zookeeper.server.quorum.auth;\n+\n+import java.io.File;\n+import java.util.HashMap;\n+import java.util.Map;\n+import java.util.concurrent.TimeoutException;\n+\n+import org.apache.commons.io.FileUtils;\n+import org.apache.commons.io.FilenameUtils;\n+import org.apache.zookeeper.CreateMode;\n+import org.apache.zookeeper.PortAssignment;\n+import org.apache.zookeeper.ZooDefs.Ids;\n+import org.apache.zookeeper.ZooKeeper;\n+import org.apache.zookeeper.server.quorum.QuorumPeerTestBase.MainThread;\n+import org.apache.zookeeper.test.ClientBase;\n+import org.apache.zookeeper.test.ClientBase.CountdownWatcher;\n+import org.junit.After;\n+import org.junit.AfterClass;\n+import org.junit.BeforeClass;\n+import org.junit.Test;\n+\n+import junit.framework.Assert;\n+\n+public class QuorumKerberosHostBasedAuthTest extends KerberosSecurityTestcase {\n+    private static File keytabFile;\n+    private static String hostServerPrincipal = KerberosTestUtils.getHostServerPrincipal();\n+    private static String hostLearnerPrincipal = KerberosTestUtils.getHostLearnerPrincipal();\n+    private static String hostNamedLearnerPrincipal = KerberosTestUtils.getHostNamedLearnerPrincipal(\"myHost\");\n+    static {\n+        setupJaasConfigEntries(hostServerPrincipal, hostLearnerPrincipal, hostNamedLearnerPrincipal);\n+    }\n+\n+    private static void setupJaasConfigEntries(String hostServerPrincipal,\n+            String hostLearnerPrincipal, String hostNamedLearnerPrincipal) {\n+        String keytabFilePath = FilenameUtils.normalize(KerberosTestUtils.getKeytabFile(), true);\n+        String jaasEntries = new String(\"\"\n+                + \"QuorumServer {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.replaceHostPattern(hostServerPrincipal) + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearner {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + KerberosTestUtils.replaceHostPattern(hostLearnerPrincipal) + \"\\\";\\n\" + \"};\\n\"\n+                + \"QuorumLearnerMyHost {\\n\"\n+                + \"       com.sun.security.auth.module.Krb5LoginModule required\\n\"\n+                + \"       useKeyTab=true\\n\"\n+                + \"       keyTab=\\\"\" + keytabFilePath + \"\\\"\\n\"\n+                + \"       storeKey=true\\n\"\n+                + \"       useTicketCache=false\\n\"\n+                + \"       debug=false\\n\"\n+                + \"       principal=\\\"\" + hostNamedLearnerPrincipal + \"\\\";\\n\" + \"};\\n\");\n+        setupJaasConfig(jaasEntries);\n+    }\n+\n+    @BeforeClass\n+    public static void setUp() throws Exception {\n+        // create keytab\n+        keytabFile = new File(KerberosTestUtils.getKeytabFile());\n+\n+        // Creates principals in the KDC and adds them to a keytab file.\n+        String learnerPrincipal = hostLearnerPrincipal.substring(0, hostLearnerPrincipal.lastIndexOf(\"@\"));\n+        learnerPrincipal = KerberosTestUtils.replaceHostPattern(learnerPrincipal);\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        serverPrincipal = KerberosTestUtils.replaceHostPattern(serverPrincipal);\n+\n+        // learner with ipaddress in principal\n+        String learnerPrincipal2 = hostNamedLearnerPrincipal.substring(0, hostNamedLearnerPrincipal.lastIndexOf(\"@\"));\n+        getKdc().createPrincipal(keytabFile, learnerPrincipal, learnerPrincipal2, serverPrincipal);\n+    }\n+\n+    @After\n+    public void tearDown() throws Exception {\n+        for (MainThread mainThread : mt) {\n+            mainThread.shutdown();\n+            mainThread.deleteBaseDir();\n+        }\n+    }\n+\n+    @AfterClass\n+    public static void cleanup() {\n+        if(keytabFile != null){\n+            FileUtils.deleteQuietly(keytabFile);\n+        }\n+        cleanupJaasConfig();\n+    }\n+\n+    /**\n+     * Test to verify that server is able to start with valid credentials\n+     */\n+    @Test(timeout = 120000)\n+    public void testValidCredentials() throws Exception {\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+    }\n+\n+    /**\n+     * Test to verify that the bad server connection to the quorum should be rejected.\n+     */\n+    @Test(timeout = 120000)\n+    public void testConnectBadServer() throws Exception {\n+        String serverPrincipal = hostServerPrincipal.substring(0, hostServerPrincipal.lastIndexOf(\"@\"));\n+        Map<String, String> authConfigs = new HashMap<String, String>();\n+        authConfigs.put(QuorumAuth.QUORUM_SASL_AUTH_ENABLED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_SERVER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_AUTH_REQUIRED, \"true\");\n+        authConfigs.put(QuorumAuth.QUORUM_KERBEROS_SERVICE_PRINCIPAL, serverPrincipal);\n+        String connectStr = startQuorum(3, authConfigs, 3);\n+        CountdownWatcher watcher = new CountdownWatcher();\n+        ZooKeeper zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT);\n+        for (int i = 0; i < 10; i++) {\n+            zk.create(\"/\" + i, new byte[0], Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);\n+        }\n+        zk.close();\n+\n+        String quorumCfgSection = mt.get(0).getQuorumCfgSection();\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(quorumCfgSection);\n+\n+        int myid = mt.size() + 1;\n+        final int clientPort = PortAssignment.unique();\n+        String server = String.format(\"server.%d=localhost:%d:%d:participant\",\n+                myid, PortAssignment.unique(), PortAssignment.unique());\n+        sb.append(server + \"\\n\");\n+        quorumCfgSection = sb.toString();\n+        authConfigs.put(QuorumAuth.QUORUM_LEARNER_SASL_LOGIN_CONTEXT,\n+                \"QuorumLearnerMyHost\");\n+        MainThread badServer = new MainThread(myid, clientPort, quorumCfgSection,\n+                authConfigs);\n+        badServer.start();\n+        watcher = new CountdownWatcher();\n+        connectStr = \"127.0.0.1:\" + clientPort;\n+        zk = new ZooKeeper(connectStr, ClientBase.CONNECTION_TIMEOUT, watcher);\n+        try{\n+            watcher.waitForConnected(ClientBase.CONNECTION_TIMEOUT/3);\n+            Assert.fail(\"Must throw exception as the myHost is not an authorized one!\");\n+        } catch (TimeoutException e){\n+            // expected\n+        } finally {\n+            zk.close();\n+            badServer.shutdown();\n+            badServer.deleteBaseDir();\n+        }\n+    }\n+}"
        },
        {
            "sha": "3cee7ba4be203ba4f1c0496494f269a528ac68fa",
            "filename": "src/java/test/org/apache/zookeeper/test/CnxManagerTest.java",
            "status": "modified",
            "additions": 6,
            "deletions": 6,
            "changes": 12,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FCnxManagerTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FCnxManagerTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FCnxManagerTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -110,7 +110,7 @@ class CnxManagerThread extends Thread {\n         public void run(){\n             try {\n                 QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[0], peerTmpdir[0], peerClientPort[0], 3, 0, 1000, 2, 2);\n-                QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+                QuorumCnxManager cnxManager = peer.createCnxnManager();\n                 QuorumCnxManager.Listener listener = cnxManager.listener;\n                 if(listener != null){\n                     listener.start();\n@@ -154,7 +154,7 @@ public void testCnxManager() throws Exception {\n         thread.start();\n \n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -201,7 +201,7 @@ public void testCnxManagerTimeout() throws Exception {\n         peerTmpdir[2] = ClientBase.createTmpDir();\n \n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -229,7 +229,7 @@ public void testCnxManagerTimeout() throws Exception {\n     @Test\n     public void testCnxManagerSpinLock() throws Exception {\n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();\n@@ -294,7 +294,7 @@ public void testCnxManagerNPE() throws Exception {\n         peers.get(2L).type = LearnerType.OBSERVER;\n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1],\n                 peerClientPort[1], 3, 1, 1000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if (listener != null) {\n             listener.start();\n@@ -341,7 +341,7 @@ public void testCnxManagerNPE() throws Exception {\n     @Test\n     public void testSocketTimeout() throws Exception {\n         QuorumPeer peer = new QuorumPeer(peers, peerTmpdir[1], peerTmpdir[1], peerClientPort[1], 3, 1, 2000, 2, 2);\n-        QuorumCnxManager cnxManager = new QuorumCnxManager(peer);\n+        QuorumCnxManager cnxManager = peer.createCnxnManager();\n         QuorumCnxManager.Listener listener = cnxManager.listener;\n         if(listener != null){\n             listener.start();"
        },
        {
            "sha": "bc437754e762483434c3c4a0b442dcbb2dedc69d",
            "filename": "src/java/test/org/apache/zookeeper/test/FLEPredicateTest.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fjava%2Ftest%2Forg%2Fapache%2Fzookeeper%2Ftest%2FFLEPredicateTest.java?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -41,7 +41,7 @@ public class FLEPredicateTest extends ZKTestCase {\n     \n     class MockFLE extends FastLeaderElection {\n         MockFLE(QuorumPeer peer){\n-            super(peer, new QuorumCnxManager(peer));\n+            super(peer, peer.createCnxnManager());\n         }\n         \n         boolean predicate(long newId, long newZxid, long newEpoch, long curId, long curZxid, long curEpoch){"
        },
        {
            "sha": "2533ddf8d11b9d3f07406982818e25e9468004a5",
            "filename": "src/zookeeper.jute",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/apache/zookeeper/blob/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fzookeeper.jute",
            "raw_url": "https://github.com/apache/zookeeper/raw/75411ab34a3d53c43c2d508b12314a9788aa417d/src%2Fzookeeper.jute",
            "contents_url": "https://api.github.com/repos/apache/zookeeper/contents/src%2Fzookeeper.jute?ref=75411ab34a3d53c43c2d508b12314a9788aa417d",
            "patch": "@@ -236,6 +236,11 @@ module org.apache.zookeeper.server.quorum {\n         buffer data; // Only significant when type is request\n         vector<org.apache.zookeeper.data.Id> authinfo;\n     }\n+    class QuorumAuthPacket {\n+        long magic;\n+        int status;\n+        buffer token;\n+    }\n }\n \n module org.apache.zookeeper.server.persistence {"
        }
    ]
}
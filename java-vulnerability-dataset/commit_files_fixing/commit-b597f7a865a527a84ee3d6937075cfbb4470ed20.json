{
    "sha": "b597f7a865a527a84ee3d6937075cfbb4470ed20",
    "node_id": "MDY6Q29tbWl0NDYyNTEyMDQ6YjU5N2Y3YTg2NWE1MjdhODRlZTNkNjkzNzA3NWNmYmI0NDcwZWQyMA==",
    "commit": {
        "author": {
            "name": "Trustin Lee",
            "email": "t@motd.kr",
            "date": "2019-12-05T09:35:47Z"
        },
        "committer": {
            "name": "GitHub",
            "email": "noreply@github.com",
            "date": "2019-12-05T09:35:47Z"
        },
        "message": "Merge pull request from GHSA-35fr-h7jr-hh86\n\nMotivation:\n\nAn `HttpService` can produce a malformed HTTP response when a user\nspecified a malformed HTTP header values, such as:\n\n    ResponseHeaders.of(HttpStatus.OK\n                       \"my-header\", \"foo\\r\\nbad-header: bar\");\n\nModification:\n\n- Add strict header value validation to `HttpHeadersBase`\n- Add strict header name validation to `HttpHeaderNames.of()`, which is\n  used by `HttpHeadersBase`.\n\nResult:\n\n- It is not possible anymore to send a bad header value which can be\n  misused for sending additional headers or injecting arbitrary content.",
        "tree": {
            "sha": "226d202e92f9c22a049400090fc332dc4bb7d10b",
            "url": "https://api.github.com/repos/line/armeria/git/trees/226d202e92f9c22a049400090fc332dc4bb7d10b"
        },
        "url": "https://api.github.com/repos/line/armeria/git/commits/b597f7a865a527a84ee3d6937075cfbb4470ed20",
        "comment_count": 0,
        "verification": {
            "verified": true,
            "reason": "valid",
            "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJd6M9zCRBK7hj4Ov3rIwAAdHIIABsMZCek5DVmDiMW/rVe0GyO\n06NhjZG2/Ka3EQoJ2g9PJU+8CTF3pxy6os5ppyHmDlF2R2R3Y1lxGVtySarIuOMM\nhq/VlHBcJzF5d5HRRSKeofTJiCa0nREyAK04lIUYu76QNnuhFbJ+ri4Y4XvCexay\nYvkpATjInNGD08P1iYeW2fay/LiMzrMtRuOebPrl1xk68llrZC/TQpJSkP893fX3\nRHCQTH9DG8dpTG1iCwJqyzYYVpaqSLOViynQ7i1ymmuNTVuSyHEtDs9kwetdXfqd\npzGNx/fX9a226WOv4DG3UD3wopy0xYT1kq9VpWRM3IveX0oAme3OpVZi19bV8dg=\n=1FCk\n-----END PGP SIGNATURE-----\n",
            "payload": "tree 226d202e92f9c22a049400090fc332dc4bb7d10b\nparent 80310b36196b6fa6efd15af61635d2aa48c44418\nauthor Trustin Lee <t@motd.kr> 1575538547 +0900\ncommitter GitHub <noreply@github.com> 1575538547 +0900\n\nMerge pull request from GHSA-35fr-h7jr-hh86\n\nMotivation:\n\nAn `HttpService` can produce a malformed HTTP response when a user\nspecified a malformed HTTP header values, such as:\n\n    ResponseHeaders.of(HttpStatus.OK\n                       \"my-header\", \"foo\\r\\nbad-header: bar\");\n\nModification:\n\n- Add strict header value validation to `HttpHeadersBase`\n- Add strict header name validation to `HttpHeaderNames.of()`, which is\n  used by `HttpHeadersBase`.\n\nResult:\n\n- It is not possible anymore to send a bad header value which can be\n  misused for sending additional headers or injecting arbitrary content.",
            "verified_at": "2024-11-07T23:00:58Z"
        }
    },
    "url": "https://api.github.com/repos/line/armeria/commits/b597f7a865a527a84ee3d6937075cfbb4470ed20",
    "html_url": "https://github.com/line/armeria/commit/b597f7a865a527a84ee3d6937075cfbb4470ed20",
    "comments_url": "https://api.github.com/repos/line/armeria/commits/b597f7a865a527a84ee3d6937075cfbb4470ed20/comments",
    "author": {
        "login": "trustin",
        "id": 173918,
        "node_id": "MDQ6VXNlcjE3MzkxOA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/173918?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/trustin",
        "html_url": "https://github.com/trustin",
        "followers_url": "https://api.github.com/users/trustin/followers",
        "following_url": "https://api.github.com/users/trustin/following{/other_user}",
        "gists_url": "https://api.github.com/users/trustin/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/trustin/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/trustin/subscriptions",
        "organizations_url": "https://api.github.com/users/trustin/orgs",
        "repos_url": "https://api.github.com/users/trustin/repos",
        "events_url": "https://api.github.com/users/trustin/events{/privacy}",
        "received_events_url": "https://api.github.com/users/trustin/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "web-flow",
        "id": 19864447,
        "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/web-flow",
        "html_url": "https://github.com/web-flow",
        "followers_url": "https://api.github.com/users/web-flow/followers",
        "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
        "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
        "organizations_url": "https://api.github.com/users/web-flow/orgs",
        "repos_url": "https://api.github.com/users/web-flow/repos",
        "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
        "received_events_url": "https://api.github.com/users/web-flow/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "80310b36196b6fa6efd15af61635d2aa48c44418",
            "url": "https://api.github.com/repos/line/armeria/commits/80310b36196b6fa6efd15af61635d2aa48c44418",
            "html_url": "https://github.com/line/armeria/commit/80310b36196b6fa6efd15af61635d2aa48c44418"
        }
    ],
    "stats": {
        "total": 479,
        "additions": 395,
        "deletions": 84
    },
    "files": [
        {
            "sha": "dc3cca97e4230445aa24d6d49e3c9f74522807d6",
            "filename": "core/src/main/java/com/linecorp/armeria/common/HttpHeaderNames.java",
            "status": "modified",
            "additions": 90,
            "deletions": 4,
            "changes": 94,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNames.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNames.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNames.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -32,10 +32,12 @@\n \n import java.lang.reflect.Field;\n import java.lang.reflect.Modifier;\n+import java.util.BitSet;\n import java.util.Map;\n \n import com.google.common.base.Ascii;\n import com.google.common.collect.ImmutableMap;\n+import com.google.common.math.IntMath;\n \n import io.netty.util.AsciiString;\n \n@@ -65,6 +67,35 @@ public final class HttpHeaderNames {\n     //   - Sec-Fetch-User\n     //   - Sec-Metadata\n \n+    private static final int PROHIBITED_NAME_CHAR_MASK = ~63;\n+    private static final BitSet PROHIBITED_NAME_CHARS = new BitSet(~PROHIBITED_NAME_CHAR_MASK + 1);\n+    private static final String[] PROHIBITED_NAME_CHAR_NAMES = new String[~PROHIBITED_NAME_CHAR_MASK + 1];\n+\n+    static {\n+        PROHIBITED_NAME_CHARS.set(0);\n+        PROHIBITED_NAME_CHARS.set('\\t');\n+        PROHIBITED_NAME_CHARS.set('\\n');\n+        PROHIBITED_NAME_CHARS.set(0xB);\n+        PROHIBITED_NAME_CHARS.set('\\f');\n+        PROHIBITED_NAME_CHARS.set('\\r');\n+        PROHIBITED_NAME_CHARS.set(' ');\n+        PROHIBITED_NAME_CHARS.set(',');\n+        PROHIBITED_NAME_CHARS.set(':');\n+        PROHIBITED_NAME_CHARS.set(';');\n+        PROHIBITED_NAME_CHARS.set('=');\n+        PROHIBITED_NAME_CHAR_NAMES[0] = \"<NUL>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\t'] = \"<TAB>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\n'] = \"<LF>\";\n+        PROHIBITED_NAME_CHAR_NAMES[0xB] = \"<VT>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\f'] = \"<FF>\";\n+        PROHIBITED_NAME_CHAR_NAMES['\\r'] = \"<CR>\";\n+        PROHIBITED_NAME_CHAR_NAMES[' '] = \"<SP>\";\n+        PROHIBITED_NAME_CHAR_NAMES[','] = \",\";\n+        PROHIBITED_NAME_CHAR_NAMES[':'] = \":\";\n+        PROHIBITED_NAME_CHAR_NAMES[';'] = \";\";\n+        PROHIBITED_NAME_CHAR_NAMES['='] = \"=\";\n+    }\n+\n     // Pseudo-headers\n \n     /**\n@@ -564,10 +595,16 @@ public final class HttpHeaderNames {\n         map = builder.build();\n     }\n \n+    private static AsciiString create(String name) {\n+        return AsciiString.cached(Ascii.toLowerCase(name));\n+    }\n+\n     /**\n      * Lower-cases and converts the specified header name into an {@link AsciiString}. If {@code \"name\"} is\n      * a known header name, this method will return a pre-instantiated {@link AsciiString} to reduce\n      * the allocation rate of {@link AsciiString}.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code name} is not a valid header name.\n      */\n     public static AsciiString of(CharSequence name) {\n         if (name instanceof AsciiString) {\n@@ -576,22 +613,71 @@ public static AsciiString of(CharSequence name) {\n \n         final String lowerCased = Ascii.toLowerCase(requireNonNull(name, \"name\"));\n         final AsciiString cached = map.get(lowerCased);\n-        return cached != null ? cached : AsciiString.cached(lowerCased);\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        return validate(AsciiString.cached(lowerCased));\n     }\n \n     /**\n      * Lower-cases and converts the specified header name into an {@link AsciiString}. If {@code \"name\"} is\n      * a known header name, this method will return a pre-instantiated {@link AsciiString} to reduce\n      * the allocation rate of {@link AsciiString}.\n+     *\n+     * @throws IllegalArgumentException if the specified {@code name} is not a valid header name.\n      */\n     public static AsciiString of(AsciiString name) {\n         final AsciiString lowerCased = name.toLowerCase();\n         final AsciiString cached = map.get(lowerCased);\n-        return cached != null ? cached : lowerCased;\n+        if (cached != null) {\n+            return cached;\n+        }\n+\n+        return validate(lowerCased);\n     }\n \n-    private static AsciiString create(String name) {\n-        return AsciiString.cached(Ascii.toLowerCase(name));\n+    private static AsciiString validate(AsciiString name) {\n+        if (name.isEmpty()) {\n+            throw new IllegalArgumentException(\"malformed header name: <EMPTY>\");\n+        }\n+\n+        final int lastIndex;\n+        try {\n+            lastIndex = name.forEachByte(value -> {\n+                if ((value & PROHIBITED_NAME_CHAR_MASK) != 0) { // value >= 64\n+                    return true;\n+                }\n+\n+                // value < 64\n+                return !PROHIBITED_NAME_CHARS.get(value);\n+            });\n+        } catch (Exception e) {\n+            throw new Error(e);\n+        }\n+\n+        if (lastIndex >= 0) {\n+            throw new IllegalArgumentException(malformedHeaderNameMessage(name));\n+        }\n+\n+        return name;\n+    }\n+\n+    private static String malformedHeaderNameMessage(AsciiString name) {\n+        final StringBuilder buf = new StringBuilder(IntMath.saturatedAdd(name.length(), 64));\n+        buf.append(\"malformed header name: \");\n+\n+        final int nameLength = name.length();\n+        for (int i = 0; i < nameLength; i++) {\n+            final char ch = name.charAt(i);\n+            if (PROHIBITED_NAME_CHARS.get(ch)) {\n+                buf.append(PROHIBITED_NAME_CHAR_NAMES[ch]);\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+\n+        return buf.toString();\n     }\n \n     private HttpHeaderNames() {}"
        },
        {
            "sha": "fdefda780261d3b2331311b893b7029a52910cf0",
            "filename": "core/src/main/java/com/linecorp/armeria/common/HttpHeadersBase.java",
            "status": "modified",
            "additions": 62,
            "deletions": 16,
            "changes": 78,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBase.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBase.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBase.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -29,7 +29,6 @@\n  */\n package com.linecorp.armeria.common;\n \n-import static com.google.common.base.Preconditions.checkArgument;\n import static com.google.common.base.Preconditions.checkState;\n import static com.linecorp.armeria.internal.ArmeriaHttpUtil.isAbsoluteUri;\n import static io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName.hasPseudoHeaderFormat;\n@@ -41,6 +40,7 @@\n import java.net.URI;\n import java.net.URISyntaxException;\n import java.util.Arrays;\n+import java.util.BitSet;\n import java.util.Date;\n import java.util.Iterator;\n import java.util.List;\n@@ -58,6 +58,7 @@\n import com.google.common.collect.ImmutableList;\n import com.google.common.collect.ImmutableSet;\n import com.google.common.collect.Iterators;\n+import com.google.common.math.IntMath;\n \n import io.netty.handler.codec.DateFormatter;\n import io.netty.util.AsciiString;\n@@ -67,6 +68,23 @@\n  */\n class HttpHeadersBase implements HttpHeaderGetters {\n \n+    private static final int PROHIBITED_VALUE_CHAR_MASK = ~15;\n+    private static final BitSet PROHIBITED_VALUE_CHARS = new BitSet(~PROHIBITED_VALUE_CHAR_MASK + 1);\n+    private static final String[] PROHIBITED_VALUE_CHAR_NAMES = new String[~PROHIBITED_VALUE_CHAR_MASK + 1];\n+\n+    static {\n+        PROHIBITED_VALUE_CHARS.set(0);\n+        PROHIBITED_VALUE_CHARS.set('\\n');\n+        PROHIBITED_VALUE_CHARS.set(0xB);\n+        PROHIBITED_VALUE_CHARS.set('\\f');\n+        PROHIBITED_VALUE_CHARS.set('\\r');\n+        PROHIBITED_VALUE_CHAR_NAMES[0] = \"<NUL>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\n'] = \"<LF>\";\n+        PROHIBITED_VALUE_CHAR_NAMES[0xB] = \"<VT>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\f'] = \"<FF>\";\n+        PROHIBITED_VALUE_CHAR_NAMES['\\r'] = \"<CR>\";\n+    }\n+\n     static final int DEFAULT_SIZE_HINT = 16;\n \n     /**\n@@ -545,15 +563,15 @@ final long getTimeMillisAndRemove(CharSequence name, long defaultValue) {\n     }\n \n     final void add(CharSequence name, String value) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(value, \"value\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n         add0(h, i, normalizedName, value);\n     }\n \n     final void add(CharSequence name, Iterable<String> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -564,7 +582,7 @@ final void add(CharSequence name, Iterable<String> values) {\n     }\n \n     final void add(CharSequence name, String... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -590,7 +608,7 @@ final void addObject(CharSequence name, Object value) {\n     }\n \n     final void addObject(CharSequence name, Iterable<?> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         for (Object v : values) {\n             requireNonNullElement(values, v);\n@@ -599,7 +617,7 @@ final void addObject(CharSequence name, Iterable<?> values) {\n     }\n \n     final void addObject(CharSequence name, Object... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n         for (Object v : values) {\n             requireNonNullElement(values, v);\n@@ -638,7 +656,7 @@ final void addTimeMillis(CharSequence name, long value) {\n     }\n \n     final void set(CharSequence name, String value) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(value, \"value\");\n         final int h = normalizedName.hashCode();\n         final int i = index(h);\n@@ -647,7 +665,7 @@ final void set(CharSequence name, String value) {\n     }\n \n     final void set(CharSequence name, Iterable<String> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -661,7 +679,7 @@ final void set(CharSequence name, Iterable<String> values) {\n     }\n \n     final void set(CharSequence name, String... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -739,7 +757,7 @@ final void setObject(CharSequence name, Object value) {\n     }\n \n     final void setObject(CharSequence name, Iterable<?> values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -753,7 +771,7 @@ final void setObject(CharSequence name, Iterable<?> values) {\n     }\n \n     final void setObject(CharSequence name, Object... values) {\n-        final AsciiString normalizedName = normalizeName(name);\n+        final AsciiString normalizedName = HttpHeaderNames.of(name);\n         requireNonNull(values, \"values\");\n \n         final int h = normalizedName.hashCode();\n@@ -813,11 +831,6 @@ final void clear() {\n         size = 0;\n     }\n \n-    private static AsciiString normalizeName(CharSequence name) {\n-        checkArgument(requireNonNull(name, \"name\").length() > 0, \"name is empty.\");\n-        return HttpHeaderNames.of(name);\n-    }\n-\n     private static void requireNonNullElement(Object values, @Nullable Object e) {\n         if (e == null) {\n             throw new NullPointerException(\"values contains null: \" + values);\n@@ -829,11 +842,44 @@ private int index(int hash) {\n     }\n \n     private void add0(int h, int i, AsciiString name, String value) {\n+        validateValue(value);\n         // Update the hash table.\n         entries[i] = new HeaderEntry(h, name, value, entries[i]);\n         ++size;\n     }\n \n+    private static void validateValue(String value) {\n+        final int valueLength = value.length();\n+        for (int i = 0; i < valueLength; i++) {\n+            final char ch = value.charAt(i);\n+            if ((ch & PROHIBITED_VALUE_CHAR_MASK) != 0) { // ch >= 16\n+                continue;\n+            }\n+\n+            // ch < 16\n+            if (PROHIBITED_VALUE_CHARS.get(ch)) {\n+                throw new IllegalArgumentException(malformedHeaderValueMessage(value));\n+            }\n+        }\n+    }\n+\n+    private static String malformedHeaderValueMessage(String value) {\n+        final StringBuilder buf = new StringBuilder(IntMath.saturatedAdd(value.length(), 64));\n+        buf.append(\"malformed header value: \");\n+\n+        final int valueLength = value.length();\n+        for (int i = 0; i < valueLength; i++) {\n+            final char ch = value.charAt(i);\n+            if (PROHIBITED_VALUE_CHARS.get(ch)) {\n+                buf.append(PROHIBITED_VALUE_CHAR_NAMES[ch]);\n+            } else {\n+                buf.append(ch);\n+            }\n+        }\n+\n+        return buf.toString();\n+    }\n+\n     private boolean addFast(Iterable<? extends Entry<? extends CharSequence, ?>> headers) {\n         if (!(headers instanceof HttpHeadersBase)) {\n             return false;"
        },
        {
            "sha": "689affcbc41f0d031317cb839182ab856b64b3a5",
            "filename": "core/src/main/java/com/linecorp/armeria/internal/ArmeriaHttpUtil.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Finternal%2FArmeriaHttpUtil.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Finternal%2FArmeriaHttpUtil.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Fmain%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Finternal%2FArmeriaHttpUtil.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -673,7 +673,7 @@ private static CharSequenceMap toLowercaseMap(Iterator<? extends CharSequence> v\n         final CharSequenceMap result = new CharSequenceMap(arraySizeHint);\n \n         while (valuesIter.hasNext()) {\n-            final AsciiString lowerCased = HttpHeaderNames.of(valuesIter.next()).toLowerCase();\n+            final AsciiString lowerCased = AsciiString.of(valuesIter.next()).toLowerCase();\n             try {\n                 int index = lowerCased.forEachByte(FIND_COMMA);\n                 if (index != -1) {"
        },
        {
            "sha": "6c23642135cc94e515c69ecbef97eff276ee321c",
            "filename": "core/src/test/java/com/linecorp/armeria/common/HttpHeaderNamesTest.java",
            "status": "modified",
            "additions": 60,
            "deletions": 4,
            "changes": 64,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNamesTest.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNamesTest.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeaderNamesTest.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -16,15 +16,16 @@\n package com.linecorp.armeria.common;\n \n import static org.assertj.core.api.Assertions.assertThat;\n+import static org.assertj.core.api.Assertions.assertThatThrownBy;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import io.netty.util.AsciiString;\n \n-public class HttpHeaderNamesTest {\n+class HttpHeaderNamesTest {\n \n     @Test\n-    public void testOfAsciiString() {\n+    void testOfAsciiString() {\n         // Should produce a lower-cased AsciiString.\n         final AsciiString mixedCased = AsciiString.of(\"Foo\");\n         assertThat((Object) HttpHeaderNames.of(mixedCased)).isNotSameAs(mixedCased);\n@@ -39,11 +40,66 @@ public void testOfAsciiString() {\n     }\n \n     @Test\n-    public void testOfCharSequence() {\n+    void testOfCharSequence() {\n         // Should produce a lower-cased AsciiString.\n         assertThat((Object) HttpHeaderNames.of(\"Foo\")).isEqualTo(AsciiString.of(\"foo\"));\n \n         // Should reuse known header name instances.\n         assertThat((Object) HttpHeaderNames.of(\"date\")).isSameAs(HttpHeaderNames.DATE);\n     }\n+\n+    @Test\n+    void pseudoHeaderNameValidation() {\n+        // Known pseudo header names should pass validation.\n+        assertThat((Object) HttpHeaderNames.of(\":method\")).isSameAs(HttpHeaderNames.METHOD);\n+        assertThat((Object) HttpHeaderNames.of(\":scheme\")).isSameAs(HttpHeaderNames.SCHEME);\n+        assertThat((Object) HttpHeaderNames.of(\":authority\")).isSameAs(HttpHeaderNames.AUTHORITY);\n+        assertThat((Object) HttpHeaderNames.of(\":path\")).isSameAs(HttpHeaderNames.PATH);\n+        assertThat((Object) HttpHeaderNames.of(\":status\")).isSameAs(HttpHeaderNames.STATUS);\n+\n+        // However, any other headers that start with `:` should fail.\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\":foo\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: :foo\");\n+    }\n+\n+    @Test\n+    void headerNameValidation() {\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <EMPTY>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\u0000\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <NUL>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\t\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <TAB>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\n\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <LF>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\u000B\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <VT>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\f\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <FF>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"\\r\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <CR>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\" \"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <SP>\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\",\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: ,\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\":\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: :\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\";\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: ;\");\n+        assertThatThrownBy(() -> HttpHeaderNames.of(\"=\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: =\");\n+    }\n }"
        },
        {
            "sha": "d6898077c69dfa1ab495cf7b105ad98490943598",
            "filename": "core/src/test/java/com/linecorp/armeria/common/HttpHeadersBaseTest.java",
            "status": "modified",
            "additions": 81,
            "deletions": 59,
            "changes": 140,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBaseTest.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBaseTest.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fcommon%2FHttpHeadersBaseTest.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -31,25 +31,25 @@\n \n import static org.assertj.core.api.Assertions.assertThat;\n import static org.assertj.core.api.Assertions.assertThatThrownBy;\n-import static org.junit.Assert.fail;\n+import static org.junit.jupiter.api.Assertions.fail;\n \n import java.net.URI;\n import java.util.Iterator;\n import java.util.List;\n import java.util.Map;\n import java.util.NoSuchElementException;\n \n-import org.junit.Test;\n+import org.junit.jupiter.api.Test;\n \n import com.google.common.collect.ImmutableList;\n \n import io.netty.handler.codec.http2.Http2Headers.PseudoHeaderName;\n import io.netty.util.AsciiString;\n \n-public class HttpHeadersBaseTest {\n+class HttpHeadersBaseTest {\n \n     @Test\n-    public void testEqualsInsertionOrderSameHeaderName() {\n+    void testEqualsInsertionOrderSameHeaderName() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.add(\"a\", \"b\");\n         h1.add(\"a\", \"c\");\n@@ -60,7 +60,7 @@ public void testEqualsInsertionOrderSameHeaderName() {\n     }\n \n     @Test\n-    public void testEqualsInsertionOrderDifferentHeaderNames() {\n+    void testEqualsInsertionOrderDifferentHeaderNames() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.add(\"a\", \"b\");\n         h1.add(\"c\", \"d\");\n@@ -73,7 +73,7 @@ public void testEqualsInsertionOrderDifferentHeaderNames() {\n     // Tests forked from io.netty.handler.codec.DefaultHeadersTest\n \n     @Test\n-    public void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n+    void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.size()).isEqualTo(0);\n         headers.add(\"name1\", \"value1\", \"value2\");\n@@ -93,7 +93,7 @@ public void addShouldIncreaseAndRemoveShouldDecreaseTheSize() {\n     }\n \n     @Test\n-    public void afterClearHeadersShouldBeEmpty() {\n+    void afterClearHeadersShouldBeEmpty() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\");\n@@ -106,7 +106,7 @@ public void afterClearHeadersShouldBeEmpty() {\n     }\n \n     @Test\n-    public void removingANameForASecondTimeShouldReturnFalse() {\n+    void removingANameForASecondTimeShouldReturnFalse() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\");\n@@ -115,7 +115,7 @@ public void removingANameForASecondTimeShouldReturnFalse() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameShouldBeAllowed() {\n+    void multipleValuesPerNameShouldBeAllowed() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value1\");\n         headers.add(\"name\", \"value2\");\n@@ -128,7 +128,7 @@ public void multipleValuesPerNameShouldBeAllowed() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIteratorWithOtherNames() {\n+    void multipleValuesPerNameIteratorWithOtherNames() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -146,7 +146,7 @@ public void multipleValuesPerNameIteratorWithOtherNames() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIterator() {\n+    void multipleValuesPerNameIterator() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -157,15 +157,15 @@ public void multipleValuesPerNameIterator() {\n     }\n \n     @Test\n-    public void multipleValuesPerNameIteratorEmpty() {\n+    void multipleValuesPerNameIteratorEmpty() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.valueIterator(\"name\")).isExhausted();\n         assertThatThrownBy(() -> headers.valueIterator(\"name\").next())\n                 .isInstanceOf(NoSuchElementException.class);\n     }\n \n     @Test\n-    public void testContains() {\n+    void testContains() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n \n         headers.addLong(\"long\", Long.MAX_VALUE);\n@@ -200,7 +200,7 @@ public void testContains() {\n     }\n \n     @Test\n-    public void testCopy() throws Exception {\n+    void testCopy() throws Exception {\n         HttpHeadersBase headers = newEmptyHeaders();\n         headers.addLong(\"long\", Long.MAX_VALUE);\n         headers.addInt(\"int\", Integer.MIN_VALUE);\n@@ -239,7 +239,7 @@ public void testCopy() throws Exception {\n     }\n \n     @Test\n-    public void canMixConvertedAndNormalValues() {\n+    void canMixConvertedAndNormalValues() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value\");\n         headers.addInt(\"name\", 100);\n@@ -251,7 +251,7 @@ public void canMixConvertedAndNormalValues() {\n     }\n \n     @Test\n-    public void testGetAndRemove() {\n+    void testGetAndRemove() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name2\", \"value2\", \"value3\");\n@@ -267,14 +267,14 @@ public void testGetAndRemove() {\n     }\n \n     @Test\n-    public void whenNameContainsMultipleValuesGetShouldReturnTheFirst() {\n+    void whenNameContainsMultipleValuesGetShouldReturnTheFirst() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\", \"value2\");\n         assertThat(headers.get(\"name1\")).isEqualTo(\"value1\");\n     }\n \n     @Test\n-    public void getWithDefaultValueWorks() {\n+    void getWithDefaultValueWorks() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n \n@@ -283,7 +283,7 @@ public void getWithDefaultValueWorks() {\n     }\n \n     @Test\n-    public void setShouldOverWritePreviousValue() {\n+    void setShouldOverWritePreviousValue() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.set(\"name\", \"value1\");\n         headers.set(\"name\", \"value2\");\n@@ -294,7 +294,7 @@ public void setShouldOverWritePreviousValue() {\n     }\n \n     @Test\n-    public void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n+    void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n \n         h1.add(\"name1\", \"value1\");\n@@ -319,7 +319,7 @@ public void setAllShouldOverwriteSomeAndLeaveOthersUntouched() {\n     }\n \n     @Test\n-    public void headersWithSameNamesAndValuesShouldBeEquivalent() {\n+    void headersWithSameNamesAndValuesShouldBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         headers1.add(\"name2\", \"value2\");\n@@ -340,15 +340,15 @@ public void headersWithSameNamesAndValuesShouldBeEquivalent() {\n     }\n \n     @Test\n-    public void emptyHeadersShouldBeEqual() {\n+    void emptyHeadersShouldBeEqual() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         final HttpHeadersBase headers2 = newEmptyHeaders();\n         assertThat(headers2).isEqualTo(headers1);\n         assertThat(headers2.hashCode()).isEqualTo(headers1.hashCode());\n     }\n \n     @Test\n-    public void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n+    void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         final HttpHeadersBase headers2 = newEmptyHeaders();\n@@ -357,7 +357,7 @@ public void headersWithSameNamesButDifferentValuesShouldNotBeEquivalent() {\n     }\n \n     @Test\n-    public void subsetOfHeadersShouldNotBeEquivalent() {\n+    void subsetOfHeadersShouldNotBeEquivalent() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\");\n         headers1.add(\"name2\", \"value2\");\n@@ -367,7 +367,7 @@ public void subsetOfHeadersShouldNotBeEquivalent() {\n     }\n \n     @Test\n-    public void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n+    void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n         final HttpHeadersBase h1 = newEmptyHeaders();\n         h1.set(\"name1\", \"value1\");\n         final HttpHeadersBase h2 = newEmptyHeaders();\n@@ -378,15 +378,15 @@ public void headersWithDifferentNamesAndValuesShouldNotBeEquivalent() {\n         assertThat(h2).isEqualTo(h2);\n     }\n \n-    @Test(expected = NoSuchElementException.class)\n-    public void iterateEmptyHeadersShouldThrow() {\n+    @Test\n+    void iterateEmptyHeadersShouldThrow() {\n         final Iterator<Map.Entry<AsciiString, String>> iterator = newEmptyHeaders().iterator();\n         assertThat(iterator.hasNext()).isFalse();\n-        iterator.next();\n+        assertThatThrownBy(iterator::next).isInstanceOf(NoSuchElementException.class);\n     }\n \n     @Test\n-    public void iteratorShouldReturnAllNameValuePairs() {\n+    void iteratorShouldReturnAllNameValuePairs() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name1\", \"value1\", \"value2\");\n         headers1.add(\"name2\", \"value3\");\n@@ -403,7 +403,7 @@ public void iteratorShouldReturnAllNameValuePairs() {\n     }\n \n     @Test\n-    public void iteratorSetShouldFail() {\n+    void iteratorSetShouldFail() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\", \"value2\", \"value3\");\n         headers.add(\"name2\", \"value4\");\n@@ -414,7 +414,7 @@ public void iteratorSetShouldFail() {\n     }\n \n     @Test\n-    public void testEntryEquals() {\n+    void testEntryEquals() {\n         final HttpHeadersBase nameValue = newEmptyHeaders();\n         nameValue.add(\"name\", \"value\");\n         final HttpHeadersBase nameValueCopy = newEmptyHeaders();\n@@ -444,13 +444,13 @@ public void testEntryEquals() {\n     }\n \n     @Test\n-    public void getAllReturnsEmptyListForUnknownName() {\n+    void getAllReturnsEmptyListForUnknownName() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         assertThat(headers.getAll(\"noname\").size()).isEqualTo(0);\n     }\n \n     @Test\n-    public void setHeadersShouldClearAndOverwrite() {\n+    void setHeadersShouldClearAndOverwrite() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name\", \"value\");\n \n@@ -463,7 +463,7 @@ public void setHeadersShouldClearAndOverwrite() {\n     }\n \n     @Test\n-    public void setHeadersShouldOnlyOverwriteHeaders() {\n+    void setHeadersShouldOnlyOverwriteHeaders() {\n         final HttpHeadersBase headers1 = newEmptyHeaders();\n         headers1.add(\"name\", \"value\");\n         headers1.add(\"name1\", \"value1\");\n@@ -481,22 +481,22 @@ public void setHeadersShouldOnlyOverwriteHeaders() {\n         assertThat(expected).isEqualTo(headers1);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void testAddSelf() {\n+    @Test\n+    void testAddSelf() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n-        headers.add(headers);\n+        assertThatThrownBy(() -> headers.add(headers)).isInstanceOf(IllegalArgumentException.class);\n     }\n \n     @Test\n-    public void testSetSelfIsNoOp() {\n+    void testSetSelfIsNoOp() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name\", \"value\");\n         headers.set(headers);\n         assertThat(headers.size()).isEqualTo(1);\n     }\n \n     @Test\n-    public void testToString() {\n+    void testToString() {\n         HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"name1\", \"value1\");\n         headers.add(\"name1\", \"value2\");\n@@ -527,7 +527,7 @@ public void testToString() {\n     }\n \n     @Test\n-    public void testNotThrowWhenConvertFails() {\n+    void testNotThrowWhenConvertFails() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.set(\"name1\", \"\");\n         assertThat(headers.getInt(\"name1\")).isNull();\n@@ -546,10 +546,30 @@ public void testNotThrowWhenConvertFails() {\n         assertThat(headers.getTimeMillis(\"name1\", Long.MAX_VALUE)).isEqualTo(Long.MAX_VALUE);\n     }\n \n+    @Test\n+    void valueValidation() {\n+        final HttpHeadersBase headers = newEmptyHeaders();\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\u0000\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <NUL>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\n\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <LF>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\u000B\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <VT>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\f\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <FF>\");\n+        assertThatThrownBy(() -> headers.add(\"foo\", \"\\r\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header value: <CR>\");\n+    }\n+\n     // Tests forked from io.netty.handler.codec.http.HttpHeadersTest\n \n     @Test\n-    public void testGetOperations() {\n+    void testGetOperations() {\n         final HttpHeadersBase headers = newEmptyHeaders();\n         headers.add(\"Foo\", \"1\");\n         headers.add(\"Foo\", \"2\");\n@@ -560,33 +580,35 @@ public void testGetOperations() {\n         assertThat(values).containsExactly(\"1\", \"2\");\n     }\n \n-    @Test(expected = NullPointerException.class)\n-    public void testSetNullHeaderValue() {\n-        final HttpHeadersBase headers = newEmptyHeaders();\n-        headers.set(\"test\", (String) null);\n+    @Test\n+    void testSetNullHeaderValue() {\n+        assertThatThrownBy(() -> newEmptyHeaders().set(\"test\", (String) null))\n+                .isInstanceOf(NullPointerException.class);\n     }\n \n     // Tests forked from io.netty.handler.codec.http2.DefaultHttp2HeadersTest\n \n-    @Test(expected = NullPointerException.class)\n-    public void nullHeaderNameNotAllowed() {\n-        newEmptyHeaders().add(null, \"foo\");\n+    @Test\n+    void nullHeaderNameNotAllowed() {\n+        assertThatThrownBy(() -> newEmptyHeaders().add(null, \"foo\")).isInstanceOf(NullPointerException.class);\n     }\n \n-    @Test(expected = IllegalArgumentException.class)\n-    public void emptyHeaderNameNotAllowed() {\n-        newEmptyHeaders().add(\"\", \"foo\");\n+    @Test\n+    void emptyHeaderNameNotAllowed() {\n+        assertThatThrownBy(() -> newEmptyHeaders().add(\"\", \"foo\"))\n+                .isInstanceOf(IllegalArgumentException.class)\n+                .hasMessageContaining(\"malformed header name: <EMPTY>\");\n     }\n \n     @Test\n-    public void testPseudoHeadersMustComeFirstWhenIterating() {\n+    void testPseudoHeadersMustComeFirstWhenIterating() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         verifyPseudoHeadersFirst(headers);\n         verifyAllPseudoHeadersPresent(headers);\n     }\n \n     @Test\n-    public void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n+    void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         final HttpHeadersBase nonPseudoHeaders = newEmptyHeaders();\n         for (Map.Entry<AsciiString, String> entry : headers) {\n@@ -614,7 +636,7 @@ public void testPseudoHeadersWithRemovePreservesPseudoIterationOrder() {\n     }\n \n     @Test\n-    public void testPseudoHeadersWithClearDoesNotLeak() {\n+    void testPseudoHeadersWithClearDoesNotLeak() {\n         final HttpHeadersBase headers = newHttp2Headers();\n \n         assertThat(headers.isEmpty()).isFalse();\n@@ -643,7 +665,7 @@ public void testPseudoHeadersWithClearDoesNotLeak() {\n     }\n \n     @Test\n-    public void testSetOrdersPseudoHeadersCorrectly() {\n+    void testSetOrdersPseudoHeadersCorrectly() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         final HttpHeadersBase other = newEmptyHeaders();\n         other.add(\"name2\", \"value2\");\n@@ -663,7 +685,7 @@ public void testSetOrdersPseudoHeadersCorrectly() {\n     }\n \n     @Test\n-    public void testHeaderNameNormalization() {\n+    void testHeaderNameNormalization() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         headers.add(\"Foo\", \"bar\");\n         assertThat(headers.getAll(\"foo\")).containsExactly(\"bar\");\n@@ -673,7 +695,7 @@ public void testHeaderNameNormalization() {\n     }\n \n     @Test\n-    public void testClearResetsPseudoHeaderDivision() {\n+    void testClearResetsPseudoHeaderDivision() {\n         final HttpHeadersBase http2Headers = newHttp2Headers();\n         http2Headers.method(HttpMethod.POST);\n         http2Headers.set(\"some\", \"value\");\n@@ -684,7 +706,7 @@ public void testClearResetsPseudoHeaderDivision() {\n     }\n \n     @Test\n-    public void testContainsNameAndValue() {\n+    void testContainsNameAndValue() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         assertThat(headers.contains(\"name1\", \"value2\")).isTrue();\n         assertThat(headers.contains(\"name1\", \"Value2\")).isFalse();\n@@ -693,7 +715,7 @@ public void testContainsNameAndValue() {\n     }\n \n     @Test\n-    public void testUri() {\n+    void testUri() {\n         final HttpHeadersBase headers = newHttp2Headers();\n         assertThat(headers.uri()).isEqualTo(URI.create(\"https://netty.io/index.html\"));\n     }"
        },
        {
            "sha": "807102e7b64c821ca3f4277805d8be66d4f9c85c",
            "filename": "core/src/test/java/com/linecorp/armeria/server/HttpServerHeaderValidationTest.java",
            "status": "added",
            "additions": 101,
            "deletions": 0,
            "changes": 101,
            "blob_url": "https://github.com/line/armeria/blob/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fserver%2FHttpServerHeaderValidationTest.java",
            "raw_url": "https://github.com/line/armeria/raw/b597f7a865a527a84ee3d6937075cfbb4470ed20/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fserver%2FHttpServerHeaderValidationTest.java",
            "contents_url": "https://api.github.com/repos/line/armeria/contents/core%2Fsrc%2Ftest%2Fjava%2Fcom%2Flinecorp%2Farmeria%2Fserver%2FHttpServerHeaderValidationTest.java?ref=b597f7a865a527a84ee3d6937075cfbb4470ed20",
            "patch": "@@ -0,0 +1,101 @@\n+/*\n+ * Copyright 2016 LINE Corporation\n+ *\n+ * LINE Corporation licenses this file to you under the Apache License,\n+ * version 2.0 (the \"License\"); you may not use this file except in compliance\n+ * with the License. You may obtain a copy of the License at:\n+ *\n+ *   https://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT\n+ * WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the\n+ * License for the specific language governing permissions and limitations\n+ * under the License.\n+ */\n+package com.linecorp.armeria.server;\n+\n+import static com.linecorp.armeria.common.SessionProtocol.H1;\n+import static com.linecorp.armeria.common.SessionProtocol.H1C;\n+import static com.linecorp.armeria.common.SessionProtocol.H2;\n+import static com.linecorp.armeria.common.SessionProtocol.H2C;\n+import static org.assertj.core.api.Assertions.assertThat;\n+\n+import java.net.URLEncoder;\n+import java.nio.charset.StandardCharsets;\n+import java.util.stream.Stream;\n+\n+import org.junit.jupiter.api.AfterAll;\n+import org.junit.jupiter.api.Timeout;\n+import org.junit.jupiter.api.extension.ExtensionContext;\n+import org.junit.jupiter.api.extension.RegisterExtension;\n+import org.junit.jupiter.params.ParameterizedTest;\n+import org.junit.jupiter.params.provider.Arguments;\n+import org.junit.jupiter.params.provider.ArgumentsProvider;\n+import org.junit.jupiter.params.provider.ArgumentsSource;\n+\n+import com.linecorp.armeria.client.ClientFactory;\n+import com.linecorp.armeria.client.WebClient;\n+import com.linecorp.armeria.common.AggregatedHttpResponse;\n+import com.linecorp.armeria.common.HttpData;\n+import com.linecorp.armeria.common.HttpResponse;\n+import com.linecorp.armeria.common.HttpStatus;\n+import com.linecorp.armeria.common.ResponseHeaders;\n+import com.linecorp.armeria.testing.junit.server.ServerExtension;\n+\n+import io.netty.handler.codec.http.QueryStringDecoder;\n+import io.netty.handler.ssl.util.InsecureTrustManagerFactory;\n+\n+@Timeout(10000)\n+class HttpServerHeaderValidationTest {\n+\n+    static final ClientFactory clientFactory = ClientFactory.builder().sslContextCustomizer(scb -> {\n+        scb.trustManager(InsecureTrustManagerFactory.INSTANCE);\n+    }).build();\n+\n+    @RegisterExtension\n+    static final ServerExtension server = new ServerExtension() {\n+        @Override\n+        protected void configure(ServerBuilder sb) throws Exception {\n+            sb.http(0);\n+            sb.https(0);\n+            sb.tlsSelfSigned();\n+\n+            sb.route().get(\"/headers-custom\")\n+              .build((ctx, req) -> {\n+                  final String param = new QueryStringDecoder(req.path()).parameters()\n+                                                                         .get(\"param\").get(0);\n+                  return HttpResponse.of(\n+                          ResponseHeaders.of(HttpStatus.OK, \"server-header\", param),\n+                          HttpData.ofUtf8(\"OK\"));\n+              });\n+        }\n+    };\n+\n+    @AfterAll\n+    static void closeClientFactory() {\n+        clientFactory.close();\n+    }\n+\n+    @ParameterizedTest\n+    @ArgumentsSource(WebClientProvider.class)\n+    void malformedHeaderValue(WebClient client) throws Exception {\n+        final String payloadRaw = \"my-header\\r\\nnot-a-header: should_be_illegal\";\n+        final String payload = URLEncoder.encode(payloadRaw, StandardCharsets.US_ASCII.name());\n+        final String path = \"/headers-custom?param=\" + payload;\n+        final AggregatedHttpResponse res = client.get(path).aggregate().get();\n+        assertThat(res.status()).isEqualTo(HttpStatus.INTERNAL_SERVER_ERROR);\n+        assertThat(res.headers().get(\"not-a-header\")).isNull();\n+    }\n+\n+    private static class WebClientProvider implements ArgumentsProvider {\n+        @Override\n+        public Stream<? extends Arguments> provideArguments(ExtensionContext context) {\n+            return Stream.of(H1C, H1, H2C, H2)\n+                         .map(protocol -> Arguments.of(WebClient.of(\n+                                 clientFactory,\n+                                 protocol.uriText() + \"://127.0.0.1:\" +\n+                                 (protocol.isTls() ? server.httpsPort() : server.httpPort()))));\n+        }\n+    }\n+}"
        }
    ]
}
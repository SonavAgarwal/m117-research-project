{
    "sha": "311baf12252abf21947afd07bf0a0291ec3ec796",
    "node_id": "MDY6Q29tbWl0MTU3MTQ5ODk6MzExYmFmMTIyNTJhYmYyMTk0N2FmZDA3YmYwYTAyOTFlYzNlYzc5Ng==",
    "commit": {
        "author": {
            "name": "Daniel Fisher",
            "email": "dfisher@vt.edu",
            "date": "2020-01-29T21:59:00Z"
        },
        "committer": {
            "name": "GitHub",
            "email": "noreply@github.com",
            "date": "2020-01-29T21:59:00Z"
        },
        "message": "Merge pull request #53 from serac/52-safe-header\n\nDefine new ciphertext header format.",
        "tree": {
            "sha": "000d311ea8ce1fc70239252d0ca152341185d33c",
            "url": "https://api.github.com/repos/vt-middleware/cryptacular/git/trees/000d311ea8ce1fc70239252d0ca152341185d33c"
        },
        "url": "https://api.github.com/repos/vt-middleware/cryptacular/git/commits/311baf12252abf21947afd07bf0a0291ec3ec796",
        "comment_count": 0,
        "verification": {
            "verified": true,
            "reason": "valid",
            "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJeMgAkCRBK7hj4Ov3rIwAAdHIIAD6CfwC3/biP+kvs/dOBOqTU\nXiMUAlZBXcdioWCkH7boraJXRsPkCHqq8i75taiJzqGzcn3QMI+22hOUnOIgY/QL\nQfpZRRGbpm1MxWvEtFXTTw+iR7JRBZnOWOIrXo0LMfr9E5qmZlndDWwII2eJ6bQz\nw2SD5/088A5A9oXGFNWx78Z7/fvB1TK2/vsARYRGikX4EMJlq8MgLrf2Af/udqP1\nh/n0iuv9gl1jzW+Otmh9XgKAjZQCselq8dL8EZMMU6+NSG0jFvoQCvmN4CFCR8ay\nTNTF2jOUqBY2If0tXIagS+TyTl4PjiiqgBtzjAeYHpeK6Wp/MHKwoSUUuU+b7AQ=\n=szid\n-----END PGP SIGNATURE-----\n",
            "payload": "tree 000d311ea8ce1fc70239252d0ca152341185d33c\nparent fafccd07ab1214e3588a35afe3c361519129605f\nparent 00395c232cdc62d4292ce27999c026fc1f076b1d\nauthor Daniel Fisher <dfisher@vt.edu> 1580335140 -0500\ncommitter GitHub <noreply@github.com> 1580335140 -0500\n\nMerge pull request #53 from serac/52-safe-header\n\nDefine new ciphertext header format.",
            "verified_at": "2024-01-16T19:59:59Z"
        }
    },
    "url": "https://api.github.com/repos/vt-middleware/cryptacular/commits/311baf12252abf21947afd07bf0a0291ec3ec796",
    "html_url": "https://github.com/vt-middleware/cryptacular/commit/311baf12252abf21947afd07bf0a0291ec3ec796",
    "comments_url": "https://api.github.com/repos/vt-middleware/cryptacular/commits/311baf12252abf21947afd07bf0a0291ec3ec796/comments",
    "author": {
        "login": "dfish3r",
        "id": 1051499,
        "node_id": "MDQ6VXNlcjEwNTE0OTk=",
        "avatar_url": "https://avatars.githubusercontent.com/u/1051499?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dfish3r",
        "html_url": "https://github.com/dfish3r",
        "followers_url": "https://api.github.com/users/dfish3r/followers",
        "following_url": "https://api.github.com/users/dfish3r/following{/other_user}",
        "gists_url": "https://api.github.com/users/dfish3r/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dfish3r/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dfish3r/subscriptions",
        "organizations_url": "https://api.github.com/users/dfish3r/orgs",
        "repos_url": "https://api.github.com/users/dfish3r/repos",
        "events_url": "https://api.github.com/users/dfish3r/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dfish3r/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "web-flow",
        "id": 19864447,
        "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
        "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/web-flow",
        "html_url": "https://github.com/web-flow",
        "followers_url": "https://api.github.com/users/web-flow/followers",
        "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
        "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
        "organizations_url": "https://api.github.com/users/web-flow/orgs",
        "repos_url": "https://api.github.com/users/web-flow/repos",
        "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
        "received_events_url": "https://api.github.com/users/web-flow/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "fafccd07ab1214e3588a35afe3c361519129605f",
            "url": "https://api.github.com/repos/vt-middleware/cryptacular/commits/fafccd07ab1214e3588a35afe3c361519129605f",
            "html_url": "https://github.com/vt-middleware/cryptacular/commit/fafccd07ab1214e3588a35afe3c361519129605f"
        },
        {
            "sha": "00395c232cdc62d4292ce27999c026fc1f076b1d",
            "url": "https://api.github.com/repos/vt-middleware/cryptacular/commits/00395c232cdc62d4292ce27999c026fc1f076b1d",
            "html_url": "https://github.com/vt-middleware/cryptacular/commit/00395c232cdc62d4292ce27999c026fc1f076b1d"
        }
    ],
    "stats": {
        "total": 782,
        "additions": 708,
        "deletions": 74
    },
    "files": [
        {
            "sha": "d43bf9a92e9de4d448fa985d8277b099d0c1b355",
            "filename": "src/main/java/org/cryptacular/CiphertextHeader.java",
            "status": "modified",
            "additions": 52,
            "deletions": 13,
            "changes": 65,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeader.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeader.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeader.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -34,18 +34,26 @@\n  * decrypt outstanding data which will be subsequently re-encrypted with a new key.</p>\n  *\n  * @author  Middleware Services\n+ *\n+ * @deprecated Superseded by {@link CiphertextHeaderV2}\n  */\n+@Deprecated\n public class CiphertextHeader\n {\n+  /** Maximum nonce length in bytes. */\n+  protected static final int MAX_NONCE_LEN = 255;\n+\n+  /** Maximum key name length in bytes. */\n+  protected static final int MAX_KEYNAME_LEN = 500;\n \n   /** Header nonce field value. */\n-  private final byte[] nonce;\n+  protected final byte[] nonce;\n \n   /** Header key name field value. */\n-  private String keyName;\n+  protected final String keyName;\n \n   /** Header length in bytes. */\n-  private int length;\n+  protected final int length;\n \n \n   /**\n@@ -67,12 +75,17 @@ public CiphertextHeader(final byte[] nonce)\n    */\n   public CiphertextHeader(final byte[] nonce, final String keyName)\n   {\n-    this.nonce = nonce;\n-    this.length = 8 + nonce.length;\n+    if (nonce.length > MAX_NONCE_LEN) {\n+      throw new IllegalArgumentException(\"Nonce exceeds size limit in bytes (\" + MAX_NONCE_LEN + \")\");\n+    }\n     if (keyName != null) {\n-      this.length += 4 + keyName.getBytes().length;\n-      this.keyName = keyName;\n+      if (ByteUtil.toBytes(keyName).length > MAX_KEYNAME_LEN) {\n+        throw new IllegalArgumentException(\"Key name exceeds size limit in bytes (\" + MAX_KEYNAME_LEN + \")\");\n+      }\n     }\n+    this.nonce = nonce;\n+    this.keyName = keyName;\n+    length = computeLength();\n   }\n \n   /**\n@@ -127,6 +140,19 @@ public byte[] encode()\n   }\n \n \n+  /**\n+   * @return  Length of this header encoded as bytes.\n+   */\n+  protected int computeLength()\n+  {\n+    int len = 8 + nonce.length;\n+    if (keyName != null) {\n+      len += 4 + keyName.getBytes().length;\n+    }\n+    return len;\n+  }\n+\n+\n   /**\n    * Creates a header from encrypted data containing a cleartext header prepended to the start.\n    *\n@@ -143,17 +169,20 @@ public static CiphertextHeader decode(final byte[] data) throws EncodingExceptio\n \n     final int length = bb.getInt();\n     if (length < 0) {\n-      throw new EncodingException(\"Invalid ciphertext header length: \" + length);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     }\n \n     final byte[] nonce;\n     int nonceLen = 0;\n     try {\n       nonceLen = bb.getInt();\n+      if (nonceLen > MAX_NONCE_LEN) {\n+        throw new EncodingException(\"Bad ciphertext header: maximum nonce length exceeded\");\n+      }\n       nonce = new byte[nonceLen];\n       bb.get(nonce);\n     } catch (IndexOutOfBoundsException | BufferUnderflowException e) {\n-      throw new EncodingException(\"Invalid nonce length: \" + nonceLen);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     }\n \n     String keyName = null;\n@@ -162,11 +191,14 @@ public static CiphertextHeader decode(final byte[] data) throws EncodingExceptio\n       int keyLen = 0;\n       try {\n         keyLen = bb.getInt();\n+        if (keyLen > MAX_KEYNAME_LEN) {\n+          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");\n+        }\n         b = new byte[keyLen];\n         bb.get(b);\n         keyName = new String(b);\n       } catch (IndexOutOfBoundsException | BufferUnderflowException e) {\n-        throw new EncodingException(\"Invalid key length: \" + keyLen);\n+        throw new EncodingException(\"Bad ciphertext header\");\n       }\n     }\n \n@@ -188,17 +220,20 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx\n   {\n     final int length = ByteUtil.readInt(input);\n     if (length < 0) {\n-      throw new EncodingException(\"Invalid ciphertext header length: \" + length);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     }\n \n     final byte[] nonce;\n     int nonceLen = 0;\n     try {\n       nonceLen = ByteUtil.readInt(input);\n+      if (nonceLen > MAX_NONCE_LEN) {\n+        throw new EncodingException(\"Bad ciphertext header: maximum nonce size exceeded\");\n+      }\n       nonce = new byte[nonceLen];\n       input.read(nonce);\n     } catch (ArrayIndexOutOfBoundsException e) {\n-      throw new EncodingException(\"Invalid nonce length: \" + nonceLen);\n+      throw new EncodingException(\"Bad ciphertext header\");\n     } catch (IOException e) {\n       throw new StreamException(e);\n     }\n@@ -209,10 +244,13 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx\n       int keyLen = 0;\n       try {\n         keyLen = ByteUtil.readInt(input);\n+        if (keyLen > MAX_KEYNAME_LEN) {\n+          throw new EncodingException(\"Bad ciphertext header: maximum key length exceeded\");\n+        }\n         b = new byte[keyLen];\n         input.read(b);\n       } catch (ArrayIndexOutOfBoundsException e) {\n-        throw new EncodingException(\"Invalid key length: \" + keyLen);\n+        throw new EncodingException(\"Bad ciphertext header\");\n       } catch (IOException e) {\n         throw new StreamException(e);\n       }\n@@ -221,4 +259,5 @@ public static CiphertextHeader decode(final InputStream input) throws EncodingEx\n \n     return new CiphertextHeader(nonce, keyName);\n   }\n+\n }"
        },
        {
            "sha": "23d039e8eeb78ef31810984731932f398c1978dc",
            "filename": "src/main/java/org/cryptacular/CiphertextHeaderV2.java",
            "status": "added",
            "additions": 309,
            "deletions": 0,
            "changes": 309,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -0,0 +1,309 @@\n+/* See LICENSE for licensing and NOTICE for copyright. */\n+package org.cryptacular;\n+\n+import java.io.ByteArrayOutputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.nio.BufferUnderflowException;\n+import java.nio.ByteBuffer;\n+import java.nio.ByteOrder;\n+import java.util.function.BiConsumer;\n+import java.util.function.Function;\n+import javax.crypto.SecretKey;\n+import org.bouncycastle.crypto.digests.SHA256Digest;\n+import org.bouncycastle.crypto.macs.HMac;\n+import org.cryptacular.util.ByteUtil;\n+\n+/**\n+ * Cleartext header prepended to ciphertext providing data required for decryption.\n+ *\n+ * <p>Data format:</p>\n+ *\n+ * <pre>\n+     +---------+---------+---+----------+-------+------+\n+     | Version | KeyName | 0 | NonceLen | Nonce | HMAC |\n+     +---------+---------+---+----------+-------+------+\n+     |                                                 |\n+     +--- 4 ---+--- x ---+ 1 +--- 1 ----+-- y --+- 32 -+\n+ * </pre>\n+ *\n+ * <p>Where fields are defined as follows:</p>\n+ *\n+ * <ul>\n+ *   <li>Version - Header version format as a negative number (4-byte integer). Current version is -2.</li>\n+ *   <li>KeyName - Symbolic key name encoded as UTF-8 bytes (variable length)</li>\n+ *   <li>0 - Null byte signifying the end of the symbolic key name</li>\n+ *   <li>NonceLen - Nonce length in bytes (1-byte unsigned integer)</li>\n+ *   <li>Nonce - Nonce bytes (variable length)</li>\n+ *   <li>HMAC - HMAC-256 over preceding fields (32 bytes)</li>\n+ * </ul>\n+ *\n+ * <p>The last two fields provide support for multiple keys at the encryption provider. A common case for multiple\n+ * keys is key rotation; by tagging encrypted data with a key name, an old key may be retrieved by name to decrypt\n+ * outstanding data which will be subsequently re-encrypted with a new key.</p>\n+ *\n+ * @author  Middleware Services\n+ */\n+public class CiphertextHeaderV2 extends CiphertextHeader\n+{\n+  /** Header version format. */\n+  private static final int VERSION = -2;\n+\n+  /** Size of HMAC algorithm output in bytes. */\n+  private static final int HMAC_SIZE = 32;\n+\n+  /** Function to resolve a key from a symbolic key name. */\n+  private Function<String, SecretKey> keyLookup;\n+\n+\n+  /**\n+   * Creates a new instance with a nonce and named key.\n+   *\n+   * @param  nonce  Nonce bytes.\n+   * @param  keyName  Key name.\n+   */\n+  public CiphertextHeaderV2(final byte[] nonce, final String keyName)\n+  {\n+    super(nonce, keyName);\n+    if (keyName == null || keyName.isEmpty()) {\n+      throw new IllegalArgumentException(\"Key name is required\");\n+    }\n+  }\n+\n+\n+  /**\n+   * Sets the function to resolve keys from {@link #keyName}.\n+   *\n+   * @param  keyLookup  Key lookup function.\n+   */\n+  public void setKeyLookup(final Function<String, SecretKey> keyLookup)\n+  {\n+    this.keyLookup = keyLookup;\n+  }\n+\n+\n+  @Override\n+  public byte[] encode()\n+  {\n+    final SecretKey key = keyLookup != null ? keyLookup.apply(keyName) : null;\n+    if (key == null) {\n+      throw new IllegalStateException(\"Could not resolve secret key to generate header HMAC\");\n+    }\n+    return encode(key);\n+  }\n+\n+\n+  /**\n+   * Encodes the header into bytes.\n+   *\n+   * @param  hmacKey  Key used to generate header HMAC.\n+   *\n+   * @return  Byte representation of header.\n+   */\n+  public byte[] encode(final SecretKey hmacKey)\n+  {\n+    if (hmacKey == null) {\n+      throw new IllegalArgumentException(\"Secret key cannot be null\");\n+    }\n+    final ByteBuffer bb = ByteBuffer.allocate(length);\n+    bb.order(ByteOrder.BIG_ENDIAN);\n+    bb.putInt(VERSION);\n+    bb.put(ByteUtil.toBytes(keyName));\n+    bb.put((byte) 0);\n+    bb.put(ByteUtil.toUnsignedByte(nonce.length));\n+    bb.put(nonce);\n+    bb.put(hmac(bb.array(), 0, bb.limit() - HMAC_SIZE));\n+    return bb.array();\n+  }\n+\n+\n+  /**\n+   * @return  Length of this header encoded as bytes.\n+   */\n+  protected int computeLength()\n+  {\n+    return 4 + ByteUtil.toBytes(keyName).length + 2 + nonce.length + HMAC_SIZE;\n+  }\n+\n+\n+  /**\n+   * Creates a header from encrypted data containing a cleartext header prepended to the start.\n+   *\n+   * @param  data  Encrypted data with prepended header data.\n+   * @param  keyLookup  Function used to look up the secret key from the symbolic key name in the header.\n+   *\n+   * @return  Decoded header.\n+   *\n+   * @throws  EncodingException  when ciphertext header cannot be decoded.\n+   */\n+  public static CiphertextHeaderV2 decode(final byte[] data, final Function<String, SecretKey> keyLookup)\n+      throws EncodingException\n+  {\n+    final ByteBuffer bb = ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN);\n+    return decodeInternal(\n+      ByteBuffer.wrap(data).order(ByteOrder.BIG_ENDIAN),\n+      keyLookup,\n+      ByteBuffer -> bb.getInt(),\n+      ByteBuffer -> bb.get(),\n+      (ByteBuffer, output) -> bb.get(output));\n+  }\n+\n+\n+  /**\n+   * Creates a header from encrypted data containing a cleartext header prepended to the start.\n+   *\n+   * @param  input  Input stream that is positioned at the start of ciphertext header data.\n+   * @param  keyLookup  Function used to look up the secret key from the symbolic key name in the header.\n+   *\n+   * @return  Decoded header.\n+   *\n+   * @throws  EncodingException  when ciphertext header cannot be decoded.\n+   * @throws  StreamException  on stream IO errors.\n+   */\n+  public static CiphertextHeaderV2 decode(final InputStream input, final Function<String, SecretKey> keyLookup)\n+      throws EncodingException, StreamException\n+  {\n+    return decodeInternal(\n+      input, keyLookup, ByteUtil::readInt, CiphertextHeaderV2::readByte, CiphertextHeaderV2::readInto);\n+  }\n+\n+\n+  /**\n+   * Internal header decoding routine.\n+   *\n+   * @param  <T>  Type of input source.\n+   * @param  source  Source of header data (input stream or byte buffer).\n+   * @param  keyLookup  Function to look up key from symbolic key name in header.\n+   * @param  readIntFn  Function that produces a 4-byte integer from the input source.\n+   * @param  readByteFn  Function that produces a byte from the input source.\n+   * @param  readBytesConsumer  Function that fills a byte array from the input source.\n+   *\n+   * @return  Decoded header.\n+   */\n+  private static <T> CiphertextHeaderV2 decodeInternal(\n+      final T source,\n+      final Function<String, SecretKey> keyLookup,\n+      final Function<T, Integer> readIntFn,\n+      final Function<T, Byte> readByteFn,\n+      final BiConsumer<T, byte[]> readBytesConsumer)\n+  {\n+    final SecretKey key;\n+    final String keyName;\n+    final byte[] nonce;\n+    final byte[] hmac;\n+    try {\n+      final int version = readIntFn.apply(source);\n+      if (version != VERSION) {\n+        throw new EncodingException(\"Unsupported ciphertext header version\");\n+      }\n+      final ByteArrayOutputStream out = new ByteArrayOutputStream(100);\n+      byte b = 0;\n+      int count = 0;\n+      while ((b = readByteFn.apply(source)) != 0) {\n+        out.write(b);\n+        if (out.size() > MAX_KEYNAME_LEN) {\n+          throw new EncodingException(\"Bad ciphertext header: maximum nonce length exceeded\");\n+        }\n+        count++;\n+      }\n+      keyName = ByteUtil.toString(out.toByteArray(), 0, count);\n+      key = keyLookup.apply(keyName);\n+      if (key == null) {\n+        throw new IllegalStateException(\"Symbolic key name mentioned in header was not found\");\n+      }\n+      final int nonceLen = ByteUtil.toInt(readByteFn.apply(source));\n+      nonce = new byte[nonceLen];\n+      readBytesConsumer.accept(source, nonce);\n+      hmac = new byte[HMAC_SIZE];\n+      readBytesConsumer.accept(source, hmac);\n+    } catch (IndexOutOfBoundsException | BufferUnderflowException e) {\n+      throw new EncodingException(\"Bad ciphertext header\");\n+    }\n+    final CiphertextHeaderV2 header = new CiphertextHeaderV2(nonce, keyName);\n+    final byte[] encoded = header.encode(key);\n+    if (!arraysEqual(hmac, 0, encoded, encoded.length - HMAC_SIZE, HMAC_SIZE)) {\n+      throw new EncodingException(\"Ciphertext header HMAC verification failed\");\n+    }\n+    header.setKeyLookup(keyLookup);\n+    return header;\n+  }\n+\n+\n+  /**\n+   * Generates an HMAC-256 over the given input byte array.\n+   *\n+   * @param  input  Input bytes.\n+   * @param  offset  Starting position in input byte array.\n+   * @param  length  Number of bytes in input to consume.\n+   *\n+   * @return  HMAC as byte array.\n+   */\n+  private static byte[] hmac(final byte[] input, final int offset, final int length)\n+  {\n+    final HMac hmac = new HMac(new SHA256Digest());\n+    final byte[] output = new byte[HMAC_SIZE];\n+    hmac.update(input, offset, length);\n+    hmac.doFinal(output, 0);\n+    return output;\n+  }\n+\n+\n+  /**\n+   * Read <code>output.length</code> bytes from the input stream into the output buffer.\n+   *\n+   * @param  input  Input stream.\n+   * @param  output  Output buffer.\n+   *\n+   * @throws  StreamException  on stream IO errors.\n+   */\n+  private static void readInto(final InputStream input, final byte[] output)\n+  {\n+    try {\n+      input.read(output);\n+    } catch (IOException e) {\n+      throw new StreamException(e);\n+    }\n+  }\n+\n+\n+  /**\n+   * Read a single byte from the input stream.\n+   *\n+   * @param  input  Input stream.\n+   *\n+   * @return  Byte read from input stream.\n+   */\n+  private static byte readByte(final InputStream input)\n+  {\n+    try {\n+      return (byte) input.read();\n+    } catch (IOException e) {\n+      throw new StreamException(e);\n+    }\n+  }\n+\n+\n+  /**\n+   * Determines if two byte array ranges are equal bytewise.\n+   *\n+   * @param  a  First array to compare.\n+   * @param  aOff  Offset into first array.\n+   * @param  b  Second array to compare.\n+   * @param  bOff  Offset into second array.\n+   * @param  length  Number of bytes to compare.\n+   *\n+   * @return  True if every byte in the given range is equal, false otherwise.\n+   */\n+  private static boolean arraysEqual(final byte[] a, final int aOff, final byte[] b, final int bOff, final int length)\n+  {\n+    if (length + aOff > a.length || length + bOff > b.length) {\n+      return false;\n+    }\n+    for (int i = 0; i < length; i++) {\n+      if (a[i + aOff] != b[i + bOff]) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+}"
        },
        {
            "sha": "0d06b326aa66c8e676a195e8610abe278b5423f6",
            "filename": "src/main/java/org/cryptacular/bean/AbstractBlockCipherBean.java",
            "status": "modified",
            "additions": 5,
            "deletions": 5,
            "changes": 10,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractBlockCipherBean.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractBlockCipherBean.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractBlockCipherBean.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -45,25 +45,25 @@ public AbstractBlockCipherBean(\n   protected byte[] process(final CiphertextHeader header, final boolean mode, final byte[] input)\n   {\n     final BlockCipherAdapter cipher = newCipher(header, mode);\n-    final byte[] headerBytes = header.encode();\n     int outOff;\n     final int inOff;\n     final int length;\n     final byte[] output;\n     if (mode) {\n+      final byte[] headerBytes = header.encode();\n       final int outSize = headerBytes.length + cipher.getOutputSize(input.length);\n       output = new byte[outSize];\n       System.arraycopy(headerBytes, 0, output, 0, headerBytes.length);\n       inOff = 0;\n       outOff = headerBytes.length;\n       length = input.length;\n     } else {\n-      length = input.length - headerBytes.length;\n+      outOff = 0;\n+      inOff = header.getLength();\n+      length = input.length - inOff;\n \n       final int outSize = cipher.getOutputSize(length);\n       output = new byte[outSize];\n-      inOff = headerBytes.length;\n-      outOff = 0;\n     }\n     outOff += cipher.processBytes(input, inOff, length, output, outOff);\n     outOff += cipher.doFinal(output, outOff);\n@@ -85,7 +85,7 @@ protected void process(\n   {\n     final BlockCipherAdapter cipher = newCipher(header, mode);\n     final int outSize = cipher.getOutputSize(StreamUtil.CHUNK_SIZE);\n-    final byte[] outBuf = new byte[outSize > StreamUtil.CHUNK_SIZE ? outSize : StreamUtil.CHUNK_SIZE];\n+    final byte[] outBuf = new byte[Math.max(outSize, StreamUtil.CHUNK_SIZE)];\n     StreamUtil.pipeAll(\n       input,\n       output,"
        },
        {
            "sha": "fd7376331b15e9c68a141bdc129a1969ec17d71d",
            "filename": "src/main/java/org/cryptacular/bean/AbstractCipherBean.java",
            "status": "modified",
            "additions": 18,
            "deletions": 13,
            "changes": 31,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractCipherBean.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractCipherBean.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAbstractCipherBean.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -8,14 +8,16 @@\n import java.security.KeyStore;\n import javax.crypto.SecretKey;\n import org.cryptacular.CiphertextHeader;\n+import org.cryptacular.CiphertextHeaderV2;\n import org.cryptacular.CryptoException;\n import org.cryptacular.EncodingException;\n import org.cryptacular.StreamException;\n import org.cryptacular.generator.Nonce;\n+import org.cryptacular.util.CipherUtil;\n \n /**\n  * Base class for all cipher beans. The base class assumes all ciphertext output will contain a prepended {@link\n- * CiphertextHeader} containing metadata that facilitates decryption.\n+ * CiphertextHeaderV2} containing metadata that facilitates decryption.\n  *\n  * @author  Middleware Services\n  */\n@@ -128,14 +130,14 @@ public void setNonce(final Nonce nonce)\n   @Override\n   public byte[] encrypt(final byte[] input) throws CryptoException\n   {\n-    return process(new CiphertextHeader(nonce.generate(), keyAlias), true, input);\n+    return process(header(), true, input);\n   }\n \n \n   @Override\n   public void encrypt(final InputStream input, final OutputStream output) throws CryptoException, StreamException\n   {\n-    final CiphertextHeader header = new CiphertextHeader(nonce.generate(), keyAlias);\n+    final CiphertextHeaderV2 header = header();\n     try {\n       output.write(header.encode());\n     } catch (IOException e) {\n@@ -148,23 +150,15 @@ public void encrypt(final InputStream input, final OutputStream output) throws C\n   @Override\n   public byte[] decrypt(final byte[] input) throws CryptoException, EncodingException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(input);\n-    if (header.getKeyName() == null) {\n-      throw new CryptoException(\"Ciphertext header does not contain required key\");\n-    }\n-    return process(header, false, input);\n+    return process(CipherUtil.decodeHeader(input, this::lookupKey), false, input);\n   }\n \n \n   @Override\n   public void decrypt(final InputStream input, final OutputStream output)\n       throws CryptoException, EncodingException, StreamException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(input);\n-    if (header.getKeyName() == null) {\n-      throw new CryptoException(\"Ciphertext header does not contain required key\");\n-    }\n-    process(header, false, input, output);\n+    process(CipherUtil.decodeHeader(input, this::lookupKey), false, input, output);\n   }\n \n \n@@ -211,4 +205,15 @@ protected SecretKey lookupKey(final String alias)\n    * @param  output  Stream that receives output of cipher.\n    */\n   protected abstract void process(CiphertextHeader header, boolean mode, InputStream input, OutputStream output);\n+\n+\n+  /**\n+   * @return  New ciphertext header for a pending encryption or decryption operation performed by this instance.\n+   */\n+  private CiphertextHeaderV2 header()\n+  {\n+    final CiphertextHeaderV2 header = new CiphertextHeaderV2(nonce.generate(), keyAlias);\n+    header.setKeyLookup(this::lookupKey);\n+    return header;\n+  }\n }"
        },
        {
            "sha": "2163639671185f36c96ba6e20b4d06eddc5ef97f",
            "filename": "src/main/java/org/cryptacular/util/ByteUtil.java",
            "status": "modified",
            "additions": 44,
            "deletions": 1,
            "changes": 45,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FByteUtil.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FByteUtil.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FByteUtil.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -31,14 +31,27 @@ private ByteUtil() {}\n    *\n    * @param  data  4-byte array in big-endian format.\n    *\n-   * @return  Long integer value.\n+   * @return  Integer value.\n    */\n   public static int toInt(final byte[] data)\n   {\n     return (data[0] << 24) | ((data[1] & 0xff) << 16) | ((data[2] & 0xff) << 8) | (data[3] & 0xff);\n   }\n \n \n+  /**\n+   * Converts an unsigned byte into an integer.\n+   *\n+   * @param  unsigned  Unsigned byte.\n+   *\n+   * @return  Integer value.\n+   */\n+  public static int toInt(final byte unsigned)\n+  {\n+    return 0x000000FF & unsigned;\n+  }\n+\n+\n   /**\n    * Reads 4-bytes from the input stream and converts to a 32-bit integer.\n    *\n@@ -175,6 +188,21 @@ public static String toString(final byte[] bytes)\n   }\n \n \n+  /**\n+   * Converts a portion of a byte array into a string in the UTF-8 character set.\n+   *\n+   * @param  bytes  Byte array to convert.\n+   * @param  offset  Offset into byte array where string content begins.\n+   * @param  length  Total number of bytes to convert.\n+   *\n+   * @return  UTF-8 string representation of bytes.\n+   */\n+  public static String toString(final byte[] bytes, final int offset, final int length)\n+  {\n+    return new String(bytes, offset, length, DEFAULT_CHARSET);\n+  }\n+\n+\n   /**\n    * Converts a byte buffer into a string in the UTF-8 character set.\n    *\n@@ -226,6 +254,19 @@ public static byte[] toBytes(final String s)\n   }\n \n \n+  /**\n+   * Converts an integer into an unsigned byte. All bits above 1 byte are truncated.\n+   *\n+   * @param  b  Integer value.\n+   *\n+   * @return  Unsigned byte as a byte.\n+   */\n+  public static byte toUnsignedByte(final int b)\n+  {\n+    return (byte) (0x000000FF & b);\n+  }\n+\n+\n   /**\n    * Converts a byte buffer into a byte array.\n    *\n@@ -244,4 +285,6 @@ public static byte[] toArray(final ByteBuffer buffer)\n     buffer.get(array);\n     return array;\n   }\n+\n+\n }"
        },
        {
            "sha": "40ef4d1e7b8cc1654e7e86c9ba6721af3b95b6b3",
            "filename": "src/main/java/org/cryptacular/util/CipherUtil.java",
            "status": "modified",
            "additions": 70,
            "deletions": 19,
            "changes": 89,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtil.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtil.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Fmain%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtil.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -4,6 +4,7 @@\n import java.io.IOException;\n import java.io.InputStream;\n import java.io.OutputStream;\n+import java.util.function.Function;\n import javax.crypto.SecretKey;\n import org.bouncycastle.crypto.BlockCipher;\n import org.bouncycastle.crypto.modes.AEADBlockCipher;\n@@ -13,6 +14,7 @@\n import org.bouncycastle.crypto.params.KeyParameter;\n import org.bouncycastle.crypto.params.ParametersWithIV;\n import org.cryptacular.CiphertextHeader;\n+import org.cryptacular.CiphertextHeaderV2;\n import org.cryptacular.CryptoException;\n import org.cryptacular.EncodingException;\n import org.cryptacular.StreamException;\n@@ -37,15 +39,15 @@ private CipherUtil() {}\n \n \n   /**\n-   * Encrypts data using an AEAD cipher. A {@link CiphertextHeader} is prepended to the resulting ciphertext and used as\n-   * AAD (Additional Authenticated Data) passed to the AEAD cipher.\n+   * Encrypts data using an AEAD cipher. A {@link CiphertextHeaderV2} is prepended to the resulting ciphertext and\n+   * used as AAD (Additional Authenticated Data) passed to the AEAD cipher.\n    *\n    * @param  cipher  AEAD cipher.\n    * @param  key  Encryption key.\n    * @param  nonce  Nonce generator.\n    * @param  data  Plaintext data to be encrypted.\n    *\n-   * @return  Concatenation of encoded {@link CiphertextHeader} and encrypted data that completely fills the returned\n+   * @return  Concatenation of encoded {@link CiphertextHeaderV2} and encrypted data that completely fills the returned\n    *          byte array.\n    *\n    * @throws  CryptoException  on encryption errors.\n@@ -54,22 +56,22 @@ public static byte[] encrypt(final AEADBlockCipher cipher, final SecretKey key,\n     throws CryptoException\n   {\n     final byte[] iv = nonce.generate();\n-    final byte[] header = new CiphertextHeader(iv).encode();\n+    final byte[] header = new CiphertextHeaderV2(iv, \"1\").encode(key);\n     cipher.init(true, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, iv, header));\n     return encrypt(new AEADBlockCipherAdapter(cipher), header, data);\n   }\n \n \n   /**\n-   * Encrypts data using an AEAD cipher. A {@link CiphertextHeader} is prepended to the resulting ciphertext and used as\n-   * AAD (Additional Authenticated Data) passed to the AEAD cipher.\n+   * Encrypts data using an AEAD cipher. A {@link CiphertextHeaderV2} is prepended to the resulting ciphertext and used\n+   * as AAD (Additional Authenticated Data) passed to the AEAD cipher.\n    *\n    * @param  cipher  AEAD cipher.\n    * @param  key  Encryption key.\n    * @param  nonce  Nonce generator.\n    * @param  input  Input stream containing plaintext data.\n-   * @param  output  Output stream that receives a {@link CiphertextHeader} followed by ciphertext data produced by the\n-   *                 AEAD cipher in encryption mode.\n+   * @param  output  Output stream that receives a {@link CiphertextHeaderV2} followed by ciphertext data produced by\n+   *                 the AEAD cipher in encryption mode.\n    *\n    * @throws  CryptoException  on encryption errors.\n    * @throws  StreamException  on IO errors.\n@@ -83,7 +85,7 @@ public static void encrypt(\n     throws CryptoException, StreamException\n   {\n     final byte[] iv = nonce.generate();\n-    final byte[] header = new CiphertextHeader(iv).encode();\n+    final byte[] header = new CiphertextHeaderV2(iv, \"1\").encode(key);\n     cipher.init(true, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, iv, header));\n     writeHeader(header, output);\n     process(new AEADBlockCipherAdapter(cipher), input, output);\n@@ -95,7 +97,7 @@ public static void encrypt(\n    *\n    * @param  cipher  AEAD cipher.\n    * @param  key  Encryption key.\n-   * @param  data  Ciphertext data containing a prepended {@link CiphertextHeader}. The header is treated as AAD input\n+   * @param  data  Ciphertext data containing a prepended {@link CiphertextHeaderV2}. The header is treated as AAD input\n    *               to the cipher that is verified during decryption.\n    *\n    * @return  Decrypted data that completely fills the returned byte array.\n@@ -106,7 +108,7 @@ public static void encrypt(\n   public static byte[] decrypt(final AEADBlockCipher cipher, final SecretKey key, final byte[] data)\n       throws CryptoException, EncodingException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(data);\n+    final CiphertextHeader header = decodeHeader(data, String -> key);\n     final byte[] nonce = header.getNonce();\n     final byte[] hbytes = header.encode();\n     cipher.init(false, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, nonce, hbytes));\n@@ -119,7 +121,7 @@ public static byte[] decrypt(final AEADBlockCipher cipher, final SecretKey key,\n    *\n    * @param  cipher  AEAD cipher.\n    * @param  key  Encryption key.\n-   * @param  input  Input stream containing a {@link CiphertextHeader} followed by ciphertext data. The header is\n+   * @param  input  Input stream containing a {@link CiphertextHeaderV2} followed by ciphertext data. The header is\n    *                treated as AAD input to the cipher that is verified during decryption.\n    * @param  output  Output stream that receives plaintext produced by block cipher in decryption mode.\n    *\n@@ -134,7 +136,7 @@ public static void decrypt(\n     final OutputStream output)\n     throws CryptoException, EncodingException, StreamException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(input);\n+    final CiphertextHeader header = decodeHeader(input, String -> key);\n     final byte[] nonce = header.getNonce();\n     final byte[] hbytes = header.encode();\n     cipher.init(false, new AEADParameters(new KeyParameter(key.getEncoded()), MAC_SIZE_BITS, nonce, hbytes));\n@@ -143,7 +145,7 @@ public static void decrypt(\n \n \n   /**\n-   * Encrypts data using the given block cipher with PKCS5 padding. A {@link CiphertextHeader} is prepended to the\n+   * Encrypts data using the given block cipher with PKCS5 padding. A {@link CiphertextHeaderV2} is prepended to the\n    * resulting ciphertext.\n    *\n    * @param  cipher  Block cipher.\n@@ -152,7 +154,7 @@ public static void decrypt(\n    *                cipher block size.\n    * @param  data  Plaintext data to be encrypted.\n    *\n-   * @return  Concatenation of encoded {@link CiphertextHeader} and encrypted data that completely fills the returned\n+   * @return  Concatenation of encoded {@link CiphertextHeaderV2} and encrypted data that completely fills the returned\n    *          byte array.\n    *\n    * @throws  CryptoException  on encryption errors.\n@@ -161,7 +163,7 @@ public static byte[] encrypt(final BlockCipher cipher, final SecretKey key, fina\n     throws CryptoException\n   {\n     final byte[] iv = nonce.generate();\n-    final byte[] header = new CiphertextHeader(iv).encode();\n+    final byte[] header = new CiphertextHeaderV2(iv, \"1\").encode(key);\n     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());\n     padded.init(true, new ParametersWithIV(new KeyParameter(key.getEncoded()), iv));\n     return encrypt(new BufferedBlockCipherAdapter(padded), header, data);\n@@ -191,7 +193,7 @@ public static void encrypt(\n     throws CryptoException, StreamException\n   {\n     final byte[] iv = nonce.generate();\n-    final byte[] header = new CiphertextHeader(iv).encode();\n+    final byte[] header = new CiphertextHeaderV2(iv, \"1\").encode(key);\n     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());\n     padded.init(true, new ParametersWithIV(new KeyParameter(key.getEncoded()), iv));\n     writeHeader(header, output);\n@@ -214,7 +216,7 @@ public static void encrypt(\n   public static byte[] decrypt(final BlockCipher cipher, final SecretKey key, final byte[] data)\n     throws CryptoException, EncodingException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(data);\n+    final CiphertextHeader header = decodeHeader(data, String -> key);\n     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());\n     padded.init(false, new ParametersWithIV(new KeyParameter(key.getEncoded()), header.getNonce()));\n     return decrypt(new BufferedBlockCipherAdapter(padded), data, header.getLength());\n@@ -240,13 +242,62 @@ public static void decrypt(\n     final OutputStream output)\n     throws CryptoException, EncodingException, StreamException\n   {\n-    final CiphertextHeader header = CiphertextHeader.decode(input);\n+    final CiphertextHeader header = decodeHeader(input, String -> key);\n     final PaddedBufferedBlockCipher padded = new PaddedBufferedBlockCipher(cipher, new PKCS7Padding());\n     padded.init(false, new ParametersWithIV(new KeyParameter(key.getEncoded()), header.getNonce()));\n     process(new BufferedBlockCipherAdapter(padded), input, output);\n   }\n \n \n+  /**\n+   * Decodes the ciphertext header at the start of the given byte array.\n+   * Supports both original (deprecated) and v2 formats.\n+   *\n+   * @param  data  Ciphertext data with prepended header.\n+   * @param  keyLookup  Decryption key lookup function.\n+   *\n+   * @return  Ciphertext header instance.\n+   */\n+  public static CiphertextHeader decodeHeader(final byte[] data, final Function<String, SecretKey> keyLookup)\n+  {\n+    try {\n+      return CiphertextHeaderV2.decode(data, keyLookup);\n+    } catch (EncodingException e) {\n+      return CiphertextHeader.decode(data);\n+    }\n+  }\n+\n+\n+  /**\n+   * Decodes the ciphertext header at the start of the given input stream.\n+   * Supports both original (deprecated) and v2 formats.\n+   *\n+   * @param  in  Ciphertext stream that is positioned at the start of the ciphertext header.\n+   * @param  keyLookup  Decryption key lookup function.\n+   *\n+   * @return  Ciphertext header instance.\n+   */\n+  public static CiphertextHeader decodeHeader(final InputStream in, final Function<String, SecretKey> keyLookup)\n+  {\n+    CiphertextHeader header;\n+    try {\n+      // Mark the stream start position so we can try again with old format header\n+      if (in.markSupported()) {\n+        in.mark(4);\n+      }\n+      header = CiphertextHeaderV2.decode(in, keyLookup);\n+    } catch (EncodingException e) {\n+      try {\n+        in.reset();\n+      } catch (IOException ioe) {\n+        throw new StreamException(\"Stream error trying to process old header format: \" + ioe.getMessage());\n+      }\n+      header = CiphertextHeader.decode(in);\n+    }\n+    return header;\n+  }\n+\n+\n   /**\n    * Encrypts the given data.\n    *"
        },
        {
            "sha": "51abfaeabb7b4273caa3778fc07f1f5f0e097738",
            "filename": "src/test/java/org/cryptacular/CiphertextHeaderTest.java",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderTest.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderTest.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderTest.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -0,0 +1,55 @@\n+/* See LICENSE for licensing and NOTICE for copyright. */\n+package org.cryptacular;\n+\n+import java.util.Arrays;\n+import org.cryptacular.util.CodecUtil;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+/**\n+ * Unit test for {@link CiphertextHeader}.\n+ *\n+ * @author Middleware Services\n+ */\n+public class CiphertextHeaderTest\n+{\n+\n+  @Test(\n+      expectedExceptions = IllegalArgumentException.class,\n+      expectedExceptionsMessageRegExp = \"Nonce exceeds size limit in bytes.*\")\n+  public void testNonceLimitConstructor()\n+  {\n+    new CiphertextHeader(new byte[256], \"key2\");\n+  }\n+\n+  @Test\n+  public void testEncodeDecodeSuccess()\n+  {\n+    final byte[] nonce = new byte[255];\n+    Arrays.fill(nonce, (byte) 7);\n+    final CiphertextHeader expected = new CiphertextHeader(nonce, \"aleph\");\n+    final byte[] encoded = expected.encode();\n+    assertEquals(expected.getLength(), encoded.length);\n+    final CiphertextHeader actual = CiphertextHeader.decode(encoded);\n+    assertEquals(expected.getNonce(), actual.getNonce());\n+    assertEquals(expected.getKeyName(), actual.getKeyName());\n+    assertEquals(expected.getLength(), actual.getLength());\n+  }\n+\n+  @Test(\n+    expectedExceptions = EncodingException.class,\n+    expectedExceptionsMessageRegExp = \"Bad ciphertext header: maximum nonce length exceeded\")\n+  public void testDecodeFailNonceLengthExceeded()\n+  {\n+    // https://github.com/vt-middleware/cryptacular/issues/52\n+    CiphertextHeader.decode(CodecUtil.hex(\"000000347ffffffd\"));\n+  }\n+\n+  @Test(\n+      expectedExceptions = EncodingException.class,\n+      expectedExceptionsMessageRegExp = \"Bad ciphertext header: maximum key length exceeded\")\n+  public void testDecodeFailKeyLengthExceeded()\n+  {\n+    CiphertextHeader.decode(CodecUtil.hex(\"000000F300000004DEADBEEF00FFFFFF\"));\n+  }\n+}"
        },
        {
            "sha": "7313d3586f34e7bb3a9a783ffa975898edf65ad4",
            "filename": "src/test/java/org/cryptacular/CiphertextHeaderV2Test.java",
            "status": "added",
            "additions": 67,
            "deletions": 0,
            "changes": 67,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2Test.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2Test.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2FCiphertextHeaderV2Test.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -0,0 +1,67 @@\n+/* See LICENSE for licensing and NOTICE for copyright. */\n+package org.cryptacular;\n+\n+import java.util.Arrays;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import org.cryptacular.generator.sp80038a.RBGNonce;\n+import org.testng.annotations.Test;\n+import static org.testng.Assert.assertEquals;\n+\n+/**\n+ * Unit test for {@link CiphertextHeaderV2}.\n+ *\n+ * @author Middleware Services\n+ */\n+public class CiphertextHeaderV2Test\n+{\n+  /** Test HMAC key. */\n+  private final SecretKey key = new SecretKeySpec(new RBGNonce().generate(), \"AES\");\n+\n+  @Test(\n+      expectedExceptions = IllegalArgumentException.class,\n+      expectedExceptionsMessageRegExp = \"Nonce exceeds size limit in bytes.*\")\n+  public void testNonceLimitConstructor()\n+  {\n+    new CiphertextHeaderV2(new byte[256], \"key2\");\n+  }\n+\n+  @Test\n+  public void testEncodeDecodeSuccess()\n+  {\n+    final byte[] nonce = new byte[255];\n+    Arrays.fill(nonce, (byte) 7);\n+    final CiphertextHeaderV2 expected = new CiphertextHeaderV2(nonce, \"aleph\");\n+    expected.setKeyLookup(this::getKey);\n+    final byte[] encoded = expected.encode();\n+    assertEquals(expected.getLength(), encoded.length);\n+    final CiphertextHeaderV2 actual = CiphertextHeaderV2.decode(encoded, this::getKey);\n+    assertEquals(expected.getNonce(), actual.getNonce());\n+    assertEquals(expected.getKeyName(), actual.getKeyName());\n+    assertEquals(expected.getLength(), actual.getLength());\n+  }\n+\n+  @Test(\n+      expectedExceptions = EncodingException.class,\n+      expectedExceptionsMessageRegExp = \"Ciphertext header HMAC verification failed\")\n+  public void testEncodeDecodeFailBadHMAC()\n+  {\n+    final byte[] nonce = new byte[16];\n+    Arrays.fill(nonce, (byte) 3);\n+    final CiphertextHeaderV2 expected = new CiphertextHeaderV2(nonce, \"aleph\");\n+    // Tamper with computed HMAC\n+    final byte[] encoded = expected.encode(key);\n+    final int index = encoded.length - 3;\n+    final byte b = encoded[index];\n+    encoded[index] = (byte) (b + 1);\n+    CiphertextHeaderV2.decode(encoded, this::getKey);\n+  }\n+\n+  private SecretKey getKey(final String alias)\n+  {\n+    if (\"aleph\".equals(alias)) {\n+      return key;\n+    }\n+    return null;\n+  }\n+}"
        },
        {
            "sha": "a26f341b98cba71f8ebc15f8ab742c5036e62fd6",
            "filename": "src/test/java/org/cryptacular/bean/AEADBlockCipherBeanTest.java",
            "status": "modified",
            "additions": 41,
            "deletions": 23,
            "changes": 64,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAEADBlockCipherBeanTest.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAEADBlockCipherBeanTest.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Fbean%2FAEADBlockCipherBeanTest.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -5,12 +5,12 @@\n import java.io.ByteArrayOutputStream;\n import java.io.File;\n import java.security.KeyStore;\n-import javax.crypto.SecretKey;\n import org.cryptacular.FailListener;\n import org.cryptacular.generator.sp80038d.CounterNonce;\n import org.cryptacular.io.FileResource;\n import org.cryptacular.spec.AEADBlockCipherSpec;\n import org.cryptacular.util.ByteUtil;\n+import org.cryptacular.util.CodecUtil;\n import org.cryptacular.util.StreamUtil;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Listeners;\n@@ -25,6 +25,7 @@\n @Listeners(FailListener.class)\n public class AEADBlockCipherBeanTest\n {\n+\n   @DataProvider(name = \"test-arrays\")\n   public Object[][] getTestArrays()\n   {\n@@ -78,14 +79,7 @@ public Object[][] getTestStreams()\n   public void testEncryptDecryptArray(final String input, final String cipherSpecString)\n     throws Exception\n   {\n-    final AEADBlockCipherBean cipherBean = new AEADBlockCipherBean();\n-    final AEADBlockCipherSpec cipherSpec = AEADBlockCipherSpec.parse(cipherSpecString);\n-    cipherBean.setNonce(new CounterNonce(\"vtmw\", System.nanoTime()));\n-    cipherBean.setKeyAlias(\"vtcrypt\");\n-    cipherBean.setKeyPassword(\"vtcrypt\");\n-    cipherBean.setKeyStore(getTestKeyStore());\n-    cipherBean.setBlockCipherSpec(cipherSpec);\n-\n+    final AEADBlockCipherBean cipherBean = newCipherBean(AEADBlockCipherSpec.parse(cipherSpecString));\n     final byte[] ciphertext = cipherBean.encrypt(ByteUtil.toBytes(input));\n     assertEquals(ByteUtil.toString(cipherBean.decrypt(ciphertext)), input);\n   }\n@@ -95,14 +89,7 @@ public void testEncryptDecryptArray(final String input, final String cipherSpecS\n   public void testEncryptDecryptStream(final String path, final String cipherSpecString)\n     throws Exception\n   {\n-    final AEADBlockCipherBean cipherBean = new AEADBlockCipherBean();\n-    final AEADBlockCipherSpec cipherSpec = AEADBlockCipherSpec.parse(cipherSpecString);\n-    cipherBean.setNonce(new CounterNonce(\"vtmw\", System.nanoTime()));\n-    cipherBean.setKeyAlias(\"vtcrypt\");\n-    cipherBean.setKeyPassword(\"vtcrypt\");\n-    cipherBean.setKeyStore(getTestKeyStore());\n-    cipherBean.setBlockCipherSpec(cipherSpec);\n-\n+    final AEADBlockCipherBean cipherBean = newCipherBean(AEADBlockCipherSpec.parse(cipherSpecString));\n     final ByteArrayOutputStream tempOut = new ByteArrayOutputStream(8192);\n     cipherBean.encrypt(StreamUtil.makeStream(new File(path)), tempOut);\n \n@@ -113,6 +100,34 @@ public void testEncryptDecryptStream(final String path, final String cipherSpecS\n   }\n \n \n+  @Test\n+  public void testDecryptArrayBackwardCompatibleHeader()\n+  {\n+    final AEADBlockCipherBean cipherBean = newCipherBean(new AEADBlockCipherSpec(\"Twofish\", \"OCB\"));\n+    final String expected = \"Have you passed through this night?\";\n+    final String v1CiphertextHex =\n+        \"0000001f0000000c76746d770002ba17043672d900000007767463727970745a38dee735266e3f5f7aafec8d1c9ed8a0830a2ff9\" +\n+        \"c3a46c25f89e69b6eb39dbb82fd13da50e32b2544a73f1a4476677b377e6\";\n+    final byte[] plaintext = cipherBean.decrypt(CodecUtil.hex(v1CiphertextHex));\n+    assertEquals(expected, ByteUtil.toString(plaintext));\n+  }\n+\n+\n+  @Test\n+  public void testDecryptStreamBackwardCompatibleHeader()\n+  {\n+    final AEADBlockCipherBean cipherBean = newCipherBean(new AEADBlockCipherSpec(\"Twofish\", \"OCB\"));\n+    final String expected = \"Have you passed through this night?\";\n+    final String v1CiphertextHex =\n+      \"0000001f0000000c76746d770002ba17043672d900000007767463727970745a38dee735266e3f5f7aafec8d1c9ed8a0830a2ff9\" +\n+        \"c3a46c25f89e69b6eb39dbb82fd13da50e32b2544a73f1a4476677b377e6\";\n+    final ByteArrayInputStream in = new ByteArrayInputStream(CodecUtil.hex(v1CiphertextHex));\n+    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    cipherBean.decrypt(in, out);\n+    assertEquals(expected, ByteUtil.toString(out.toByteArray()));\n+  }\n+\n+\n   private static KeyStore getTestKeyStore()\n   {\n     final KeyStoreFactoryBean bean = new KeyStoreFactoryBean();\n@@ -122,12 +137,15 @@ private static KeyStore getTestKeyStore()\n     return bean.newInstance();\n   }\n \n-  private static SecretKey getTestKey()\n+\n+  private static AEADBlockCipherBean newCipherBean(final AEADBlockCipherSpec cipherSpec)\n   {\n-    final KeyStoreBasedKeyFactoryBean<SecretKey> secretKeyFactoryBean = new KeyStoreBasedKeyFactoryBean<>();\n-    secretKeyFactoryBean.setKeyStore(getTestKeyStore());\n-    secretKeyFactoryBean.setPassword(\"vtcrypt\");\n-    secretKeyFactoryBean.setAlias(\"vtcrypt\");\n-    return secretKeyFactoryBean.newInstance();\n+    final AEADBlockCipherBean cipherBean = new AEADBlockCipherBean();\n+    cipherBean.setNonce(new CounterNonce(\"vtmw\", System.nanoTime()));\n+    cipherBean.setKeyAlias(\"vtcrypt\");\n+    cipherBean.setKeyPassword(\"vtcrypt\");\n+    cipherBean.setKeyStore(getTestKeyStore());\n+    cipherBean.setBlockCipherSpec(cipherSpec);\n+    return cipherBean;\n   }\n }"
        },
        {
            "sha": "886ce54d28ad572084e5de9b9e0feb665259047e",
            "filename": "src/test/java/org/cryptacular/util/CipherUtilTest.java",
            "status": "modified",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/vt-middleware/cryptacular/blob/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtilTest.java",
            "raw_url": "https://github.com/vt-middleware/cryptacular/raw/311baf12252abf21947afd07bf0a0291ec3ec796/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtilTest.java",
            "contents_url": "https://api.github.com/repos/vt-middleware/cryptacular/contents/src%2Ftest%2Fjava%2Forg%2Fcryptacular%2Futil%2FCipherUtilTest.java?ref=311baf12252abf21947afd07bf0a0291ec3ec796",
            "patch": "@@ -17,11 +17,14 @@\n import org.bouncycastle.crypto.modes.OCBBlockCipher;\n import org.bouncycastle.crypto.modes.OFBBlockCipher;\n import org.cryptacular.FailListener;\n+import org.cryptacular.bean.KeyStoreBasedKeyFactoryBean;\n+import org.cryptacular.bean.KeyStoreFactoryBean;\n import org.cryptacular.generator.Nonce;\n import org.cryptacular.generator.SecretKeyGenerator;\n import org.cryptacular.generator.sp80038a.LongCounterNonce;\n import org.cryptacular.generator.sp80038a.RBGNonce;\n import org.cryptacular.generator.sp80038d.CounterNonce;\n+import org.cryptacular.io.FileResource;\n import org.testng.annotations.DataProvider;\n import org.testng.annotations.Listeners;\n import org.testng.annotations.Test;\n@@ -35,6 +38,22 @@\n @Listeners(FailListener.class)\n public class CipherUtilTest\n {\n+  /** Static key derived from keystore on resource classpath. */\n+  private static final SecretKey STATIC_KEY;\n+\n+  static\n+  {\n+    final KeyStoreFactoryBean keyStoreFactory = new KeyStoreFactoryBean();\n+    keyStoreFactory.setPassword(\"vtcrypt\");\n+    keyStoreFactory.setResource(new FileResource(new File(\"src/test/resources/keystores/cipher-bean.jceks\")));\n+    keyStoreFactory.setType(\"JCEKS\");\n+    final KeyStoreBasedKeyFactoryBean<SecretKey> keyFactory = new KeyStoreBasedKeyFactoryBean<>();\n+    keyFactory.setKeyStore(keyStoreFactory.newInstance());\n+    keyFactory.setAlias(\"vtcrypt\");\n+    keyFactory.setPassword(\"vtcrypt\");\n+    STATIC_KEY = keyFactory.newInstance();\n+  }\n+\n   @DataProvider(name = \"block-cipher\")\n   public Object[][] getBlockCipherData()\n   {\n@@ -165,4 +184,32 @@ public void testAeadBlockCipherEncryptDecryptStream(final String path)\n     CipherUtil.decrypt(cipher, key, tempIn, actual);\n     assertEquals(new String(actual.toByteArray()), expected);\n   }\n+\n+\n+  @Test\n+  public void testDecryptArrayBackwardCompatibleHeader()\n+  {\n+    final AEADBlockCipher cipher = new OCBBlockCipher(new TwofishEngine(), new TwofishEngine());\n+    final String expected = \"Have you passed through this night?\";\n+    final String v1CiphertextHex =\n+      \"0000001f0000000c76746d770002ba17043672d900000007767463727970745a38dee735266e3f5f7aafec8d1c9ed8a0830a2ff9\" +\n+        \"c3a46c25f89e69b6eb39dbb82fd13da50e32b2544a73f1a4476677b377e6\";\n+    final byte[] plaintext = CipherUtil.decrypt(cipher, STATIC_KEY, CodecUtil.hex(v1CiphertextHex));\n+    assertEquals(expected, ByteUtil.toString(plaintext));\n+  }\n+\n+\n+  @Test\n+  public void testDecryptStreamBackwardCompatibleHeader()\n+  {\n+    final AEADBlockCipher cipher = new OCBBlockCipher(new TwofishEngine(), new TwofishEngine());\n+    final String expected = \"Have you passed through this night?\";\n+    final String v1CiphertextHex =\n+      \"0000001f0000000c76746d770002ba17043672d900000007767463727970745a38dee735266e3f5f7aafec8d1c9ed8a0830a2ff9\" +\n+        \"c3a46c25f89e69b6eb39dbb82fd13da50e32b2544a73f1a4476677b377e6\";\n+    final ByteArrayInputStream in = new ByteArrayInputStream(CodecUtil.hex(v1CiphertextHex));\n+    final ByteArrayOutputStream out = new ByteArrayOutputStream();\n+    CipherUtil.decrypt(cipher, STATIC_KEY, in, out);\n+    assertEquals(expected, ByteUtil.toString(out.toByteArray()));\n+  }\n }"
        }
    ]
}
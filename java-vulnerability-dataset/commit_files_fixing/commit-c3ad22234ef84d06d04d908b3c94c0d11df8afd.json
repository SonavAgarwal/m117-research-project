{
    "sha": "c3ad22234ef84d06d04d908b3c94c0d11df8afda",
    "node_id": "MDY6Q29tbWl0MTA1OTQzMDpjM2FkMjIyMzRlZjg0ZDA2ZDA0ZDkwOGIzYzk0YzBkMTFkZjhhZmRh",
    "commit": {
        "author": {
            "name": "Dennis Reed",
            "email": "dereed@redhat.com",
            "date": "2016-06-12T22:03:42Z"
        },
        "committer": {
            "name": "Dennis Reed",
            "email": "dereed@redhat.com",
            "date": "2016-06-15T05:13:23Z"
        },
        "message": "[JBPAPP-11251] Backport JGRP-2021 to EAP 5.2.",
        "tree": {
            "sha": "2f2c63b0d0f8e986cf20df4daee249ea3da6e8bc",
            "url": "https://api.github.com/repos/belaban/JGroups/git/trees/2f2c63b0d0f8e986cf20df4daee249ea3da6e8bc"
        },
        "url": "https://api.github.com/repos/belaban/JGroups/git/commits/c3ad22234ef84d06d04d908b3c94c0d11df8afda",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/belaban/JGroups/commits/c3ad22234ef84d06d04d908b3c94c0d11df8afda",
    "html_url": "https://github.com/belaban/JGroups/commit/c3ad22234ef84d06d04d908b3c94c0d11df8afda",
    "comments_url": "https://api.github.com/repos/belaban/JGroups/commits/c3ad22234ef84d06d04d908b3c94c0d11df8afda/comments",
    "author": {
        "login": "dereed",
        "id": 549466,
        "node_id": "MDQ6VXNlcjU0OTQ2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/549466?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dereed",
        "html_url": "https://github.com/dereed",
        "followers_url": "https://api.github.com/users/dereed/followers",
        "following_url": "https://api.github.com/users/dereed/following{/other_user}",
        "gists_url": "https://api.github.com/users/dereed/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dereed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dereed/subscriptions",
        "organizations_url": "https://api.github.com/users/dereed/orgs",
        "repos_url": "https://api.github.com/users/dereed/repos",
        "events_url": "https://api.github.com/users/dereed/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dereed/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "dereed",
        "id": 549466,
        "node_id": "MDQ6VXNlcjU0OTQ2Ng==",
        "avatar_url": "https://avatars.githubusercontent.com/u/549466?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/dereed",
        "html_url": "https://github.com/dereed",
        "followers_url": "https://api.github.com/users/dereed/followers",
        "following_url": "https://api.github.com/users/dereed/following{/other_user}",
        "gists_url": "https://api.github.com/users/dereed/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/dereed/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/dereed/subscriptions",
        "organizations_url": "https://api.github.com/users/dereed/orgs",
        "repos_url": "https://api.github.com/users/dereed/repos",
        "events_url": "https://api.github.com/users/dereed/events{/privacy}",
        "received_events_url": "https://api.github.com/users/dereed/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "e9b00eab460c0e2dac076a9924fa3ca3eb18354c",
            "url": "https://api.github.com/repos/belaban/JGroups/commits/e9b00eab460c0e2dac076a9924fa3ca3eb18354c",
            "html_url": "https://github.com/belaban/JGroups/commit/e9b00eab460c0e2dac076a9924fa3ca3eb18354c"
        }
    ],
    "stats": {
        "total": 3395,
        "additions": 3262,
        "deletions": 133
    },
    "files": [
        {
            "sha": "f2ee5550c256784d34dd4f306361acb41a2ac871",
            "filename": "build.xml",
            "status": "modified",
            "additions": 2,
            "deletions": 0,
            "changes": 2,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/build.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/build.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/build.xml?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -70,11 +70,13 @@\n     <patternset id=\"all.tests\">\n         <include name=\"org/jgroups/tests/**Test**\"/>\n         <include name=\"org/jgroups/blocks/**Test**\"/>\n+        <include name=\"org/jgroups/protocols/**Test**\"/>\n     </patternset>\n \n     <patternset id=\"junit.excludes\">\n         <exclude name=\"**/DistributedQueueTest*\"/>\n         <exclude name=\"**/ChannelTestBase*\"/>\n+        <exclude name=\"**/EncryptTest*\"/>\n     </patternset>\n \n "
        },
        {
            "sha": "6792a89db52a23b611ea5aa1c9e3dca0f0556c0d",
            "filename": "conf/asym-encrypt.xml",
            "status": "added",
            "additions": 28,
            "deletions": 0,
            "changes": 28,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fasym-encrypt.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fasym-encrypt.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fasym-encrypt.xml?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,28 @@\n+\n+<config>\n+    <UDP mcast_recv_buf_size=\"64000\" mcast_send_buf_size=\"32000\" mcast_port=\"45566\" ucast_recv_buf_size=\"64000\"\n+        use_incoming_packet_handler=\"false\" mcast_addr=\"228.8.8.8\"\n+        loopback=\"true\" ucast_send_buf_size=\"32000\" ip_ttl=\"32\"/>\n+    <PING timeout=\"2000\" num_initial_members=\"3\"/>\n+    <MERGE2 max_interval=\"10000\" min_interval=\"5000\"/>\n+    <FD timeout=\"2000\" max_tries=\"3\" shun=\"true\"/>\n+    <VERIFY_SUSPECT timeout=\"1500\"/>\n+\n+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->\n+    <ASYM_ENCRYPT\n+            encrypt_entire_message=\"true\"\n+            sym_keylength=\"128\"\n+            sym_algorithm=\"AES/ECB/PKCS5Padding\"\n+            asym_keylength=\"512\"\n+            asym_algorithm=\"RSA\"/>\n+\n+    <pbcast.NAKACK gc_lag=\"50\" retransmit_timeout=\"600,1200,2400,4800\"/>\n+    <UNICAST timeout=\"1200,2400,3600\"/>\n+    <pbcast.STABLE stability_delay=\"1000\" desired_avg_gossip=\"20000\" max_bytes=\"0\"/>\n+    <FRAG2 frag_size=\"8192\"  />\n+    <!-- AUTH below is required by ASYM_ENCRYPT -->\n+    <AUTH auth_class=\"org.jgroups.auth.MD5Token\"\n+          auth_value=\"chris\"\n+          token_hash=\"MD5\"/>\n+    <pbcast.GMS print_local_addr=\"true\" join_timeout=\"3000\" shun=\"true\"/>\n+</config>"
        },
        {
            "sha": "7701639d57e9e4233e3d786d36c06d1801c20eb8",
            "filename": "conf/jg-magic-map.xml",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fjg-magic-map.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fjg-magic-map.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fjg-magic-map.xml?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -42,4 +42,5 @@\n     <class id=\"66\" name=\"org.jgroups.blocks.PullPushAdapter$PullHeader\"/>\n     <class id=\"67\" name=\"org.jgroups.protocols.AuthHeader\"/>\n     <class id=\"68\" name=\"org.jgroups.protocols.MERGE3$CoordAnnouncement\"/>\n+    <class id=\"69\" name=\"org.jgroups.protocols.EncryptHeader\"/>\n </magic-number-class-mapping>"
        },
        {
            "sha": "62b7451b13ce81cefe546045b2972c14879f81fa",
            "filename": "conf/sym-encrypt.xml",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fsym-encrypt.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/conf%2Fsym-encrypt.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fsym-encrypt.xml?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,29 @@\n+\n+<config>\n+    <UDP mcast_recv_buf_size=\"64000\" mcast_send_buf_size=\"32000\" mcast_port=\"45566\" ucast_recv_buf_size=\"64000\"\n+        use_incoming_packet_handler=\"false\" mcast_addr=\"228.8.8.8\"\n+        loopback=\"true\" ucast_send_buf_size=\"32000\" ip_ttl=\"32\"/>\n+    <PING timeout=\"2000\" num_initial_members=\"3\"/>\n+    <MERGE2 max_interval=\"10000\" min_interval=\"5000\"/>\n+    <FD timeout=\"2000\" max_tries=\"3\" shun=\"true\"/>\n+    <VERIFY_SUSPECT timeout=\"1500\"/>\n+\n+    <!-- Symmetric encryption with a keystore -->\n+    <SYM_ENCRYPT\n+        provider=\"SunJCE\"\n+        sym_algorithm=\"AES\"\n+        encrypt_entire_message=\"true\"\n+        keystore_name=\"/home/bela/JGroups/keystore/defaultStore.keystore\"\n+        store_password=\"changeit\" alias=\"myKey\"/>\n+\n+\n+    <pbcast.NAKACK gc_lag=\"50\" retransmit_timeout=\"600,1200,2400,4800\"/>\n+    <UNICAST timeout=\"1200,2400,3600\"/>\n+    <pbcast.STABLE stability_delay=\"1000\" desired_avg_gossip=\"20000\" max_bytes=\"0\"/>\n+    <FRAG2 frag_size=\"8192\"  />\n+    <!-- AUTH below is optional -->\n+    <AUTH auth_class=\"org.jgroups.auth.MD5Token\"\n+          auth_value=\"chris\"\n+          token_hash=\"MD5\"/>\n+    <pbcast.GMS print_local_addr=\"true\" join_timeout=\"3000\" shun=\"true\"/>\n+</config>"
        },
        {
            "sha": "c2528fb732699b0a52136117695630e396c44da2",
            "filename": "doc/design/MaliciousAttacks.txt",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/doc%2Fdesign%2FMaliciousAttacks.txt",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/doc%2Fdesign%2FMaliciousAttacks.txt",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/doc%2Fdesign%2FMaliciousAttacks.txt?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,91 @@\n+\n+Use of encryption and authentication protocols to fend off malicious attacks\n+============================================================================\n+Author: Bela Ban, April 2016\n+JIRA:   https://issues.jboss.org/browse/JGRP-2021\n+\n+The following discussion refers to the changes made in JGroups 4.0. These have been backported to the 2.6 branch, but\n+the syntax looks different. However, the concepts are the same.\n+\n+\n+\n+Types of attacks handled\n+------------------------\n+Malicious attacks essentially include (1) non-authorized nodes being able to join a cluster and (2) non-members being\n+able to communicate with cluster members.\n+\n+(1) is handled by AUTH which allows only authenticated nodes to join a cluster.\n+\n+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster\n+members such that a non-member cannot understand them.\n+\n+\n+\n+Authentication\n+--------------\n+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.\n+Other scenarios where a check is performed are:\n+* Merging: make sure only authenticated members can merge into a new cluster\n+* View installation (if enabled): views and merge views can only be installed by authenticated members\n+\n+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or\n+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that\n+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.\n+\n+\n+\n+Authorization\n+-------------\n+There is currently no authorization in JGroups. Once a member is admitted to the cluster (via authentication),\n+it can send and receive messages to anyone.\n+\n+\n+\n+Encryption\n+----------\n+This is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared\n+keystore (symmetric encryption, below) or a new joiner fetches it from the coordinator via public/private key exchange\n+(asymmetric encryption, below).\n+\n+A sent message is encrypted with the shared secret key by the sender and decrypted with the same secret key by the\n+receiver(s).\n+\n+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload\n+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the\n+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,\n+and increment the seqno. This is prevented by copying and _signing_ the message.\n+\n+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped\n+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,\n+and no attempt is made to decrypt it.\n+\n+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination\n+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,\n+the cost of computing a hashcode and encrypting it is added to the above cost.\n+\n+Attributes present in both symmetric and asymmetric encryption include sign_msgs and encrypt_entire_message.\n+\n+\n+Symmetric encryption\n+--------------------\n+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. keystore_name\n+(name of the keystore, needs to be found on the classpath), store_password, key_password and alias.\n+\n+\n+Asymmetric encryption\n+---------------------\n+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After\n+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key\n+(including P's public key) to C.\n+\n+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key\n+and installs it. From then on, P encrypts and decrypts messages using the secret key.\n+\n+When a member leaves, C can optionally (based on change_key_on_leave) create a new secret key, and every cluster member\n+needs to fetch it again, using the public/private key exchange described above.\n+\n+\n+\n+\n+\n+"
        },
        {
            "sha": "7223331920ccc2807f5729e3f649441ec212feaa",
            "filename": "src/org/jgroups/Message.java",
            "status": "modified",
            "additions": 26,
            "deletions": 2,
            "changes": 28,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2FMessage.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2FMessage.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2FMessage.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -58,6 +58,7 @@ public class Message implements Externalizable, Streamable {\n     public static final byte OOB       = 1;\n     public static final byte LOW_PRIO  = 2; // not yet sure if we want this flag...\n     public static final byte HIGH_PRIO = 4; // not yet sure if we want this flag...\n+    public static final byte NO_RELIABILITY = 8;\n \n     private byte flags=0;\n \n@@ -357,6 +358,23 @@ public Message copy() {\n      * @return Message with specified data\n      */\n     public Message copy(boolean copy_buffer) {\n+        return copy(copy_buffer, true);\n+    }\n+\n+   /**\n+    * Create a copy of the message. If offset and length are used (to refer to another buffer), the\n+    * copy will contain only the subset offset and length point to, copying the subset into the new\n+    * copy.<p/>\n+    * Note that for headers, only the arrays holding references to the headers are copied, not the headers themselves !\n+    * The consequence is that the headers array of the copy hold the *same* references as the original, so do *not*\n+    * modify the headers ! If you want to change a header, copy it and call {@link Message#putHeader(short,Header)} again.\n+    * \n+    * @param copy_buffer\n+    * @param copy_headers\n+    *           Copy the headers\n+    * @return Message with specified data\n+    */\n+    public Message copy(boolean copy_buffer, boolean copy_headers) {\n         Message retval=new Message(false);\n         retval.dest_addr=dest_addr;\n         retval.src_addr=src_addr;\n@@ -368,11 +386,10 @@ public Message copy(boolean copy_buffer) {\n             retval.setBuffer(buf, offset, length);\n         }\n \n-        retval.headers=createHeaders(headers);\n+        retval.headers=copy_headers? createHeaders(headers) : createHeaders(3);\n         return retval;\n     }\n \n-\n     protected Object clone() throws CloneNotSupportedException {\n         return copy();\n     }\n@@ -675,6 +692,13 @@ private String flagsToString() {\n                 first=false;\n             sb.append(\"HIGH_PRIO\");\n         }\n+        if(isFlagSet(NO_RELIABILITY)) {\n+            if(!first)\n+                sb.append(\"|\");\n+            else\n+                first=false;\n+            sb.append(\"NO_RELIABILITY\");\n+        }\n         return sb.toString();\n     }\n "
        },
        {
            "sha": "3eb6d4bb0145222b178581759fac51f06daf255f",
            "filename": "src/org/jgroups/View.java",
            "status": "modified",
            "additions": 20,
            "deletions": 1,
            "changes": 21,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2FView.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2FView.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2FView.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -6,6 +6,7 @@\n import org.jgroups.util.Util;\n \n import java.io.*;\n+import java.util.Collection;\n import java.util.HashMap;\n import java.util.Map;\n import java.util.Vector;\n@@ -72,7 +73,6 @@ public View(Address creator, long id, Vector<Address> members) {\n         this(new ViewId(creator, id), members);\n     }\n \n-\n     /**\n      * returns the view ID of this view\n      * if this view was created with the empty constructur, null will be returned\n@@ -93,6 +93,8 @@ public Address getCreator() {\n         return vid != null ? vid.getCoordAddress() : null;\n     }\n \n+    public Address getCoord() {return !members.isEmpty()? members.get(0) : null;}\n+\n     /**\n      * Returns a reference to the List of members (ordered)\n      * Do NOT change this list, hence your will invalidate the view\n@@ -104,6 +106,13 @@ public Vector<Address> getMembers() {\n         return Util.unmodifiableVector(members);\n     }\n \n+    /** Returns the underlying list. The caller <em>must not</em> modify the contents. Should not be used by\n+     *  application code ! This method may be removed at any time, so don't use it !\n+     */\n+    public Vector<Address> getMembersRaw() {\n+           return members;\n+    }\n+\n     /**\n      * returns true, if this view contains a certain member\n      *\n@@ -115,6 +124,16 @@ public boolean containsMember(Address mbr) {\n         return !(mbr == null || members == null) && members.contains(mbr);\n     }\n \n+    public boolean containsMembers(Collection<Address> mbrs) {\n+        if(mbrs == null || members == null)\n+            return false;\n+        for(Address mbr: mbrs) {\n+            if(!containsMember(mbr))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n \n     public boolean equals(Object obj) {\n         if(!(obj instanceof View))"
        },
        {
            "sha": "b9dc4bbb2f5ac593a6b0265d202fb4136252ebeb",
            "filename": "src/org/jgroups/auth/AuthToken.java",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fauth%2FAuthToken.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fauth%2FAuthToken.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fauth%2FAuthToken.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -20,6 +20,11 @@ public abstract class AuthToken implements Serializable, Streamable{\n \n     public void setAuth(AUTH auth) {this.auth=auth;}\n \n+    public void init() throws Exception {}\n+    public void start() throws Exception {}\n+    public void stop() {}\n+    public void destroy() {}\n+\n     /**\n      * Used to return the full package and class name of the implementation.  This is used by the AUTH protocol to create an instance of the implementation.\n      * @return a java.lang.String object of the package and class name"
        },
        {
            "sha": "f299982fcd0b1bb2ef323ba6bff7b181ea784e01",
            "filename": "src/org/jgroups/demos/KeyStoreGenerator.java",
            "status": "modified",
            "additions": 12,
            "deletions": 0,
            "changes": 12,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -5,6 +5,7 @@\n import java.io.FileOutputStream;\n import java.io.OutputStream;\n import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n \n import javax.crypto.KeyGenerator;\n import javax.crypto.SecretKey;\n@@ -121,6 +122,17 @@ public static SecretKey initSymKey() throws Exception\n \t\treturn secretKey;\n \t\t\n \t}\n+\n+    public static SecretKey createSecretKey() throws Exception {\n+        return createSecretKey(symAlg, keySize);\n+    }\n+\n+    public static SecretKey createSecretKey(String sym_alg, int key_size) throws NoSuchAlgorithmException {\n+        // KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(sym_alg));\n+        KeyGenerator keyGen=KeyGenerator.getInstance(sym_alg);\n+        keyGen.init(key_size);\n+        return keyGen.generateKey();\n+    }\n \t\n \tprivate static String getAlgorithm(String s)\n \t{"
        },
        {
            "sha": "b6d6dfb1a390e7da51209b3658a9906d2d6bee09",
            "filename": "src/org/jgroups/protocols/ASYM_ENCRYPT.java",
            "status": "added",
            "additions": 417,
            "deletions": 0,
            "changes": 417,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,417 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.util.AsciiString;\n+import org.jgroups.util.Util;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Properties;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+\n+/**\n+ * Encrypts and decrypts communication in JGroups by using a secret key distributed to all cluster members by the\n+ * key server (coordinator) using asymmetric (public/private key) encryption.<br>\n+ *\n+ * The secret key is identical for all cluster members and is used to encrypt messages when sending and decrypt them\n+ * when receiving messages.\n+ *\n+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK}, so that most important\n+ * headers are encrypted as well, to prevent replay attacks.<br>\n+ *\n+ * The current keyserver (always the coordinator) generates a secret key. When a new member joins, it asks the keyserver\n+ * for the secret key. The keyserver encrypts the secret key with the joiner's public key and the joiner decrypts it with\n+ * its private key and then installs it and starts encrypting and decrypting messages with the secret key.<br>\n+ *\n+ * View changes that identify a new keyserver will result in a new secret key being generated and then distributed to\n+ * all cluster members. This overhead can be substantial in an application with a reasonable member churn.<br>\n+ *\n+ * This protocol is suited to an application that does not ship with a known key but instead it is generated and\n+ * distributed by the keyserver.\n+ *\n+ * Since messages can only get encrypted and decrypted when the secret key was received from the keyserver, messages\n+ * other then join and merge requests/responses are dropped when the secret key isn't yet available. Join and merge\n+ * requests / responses are handled by {@link AUTH}.\n+ *\n+ * @author Bela Ban\n+ * @author Steve Woodcock\n+ */\n+public class ASYM_ENCRYPT extends EncryptBase {\n+\n+    // When a member leaves the view, change the secret key, preventing old members from eavesdropping\"\n+    protected boolean                              change_key_on_leave=true;\n+    protected volatile Address                     key_server_addr;\n+    // True if this member is the current key server, false otherwise\n+    protected volatile boolean                     is_key_server;\n+    protected KeyPair                              key_pair; // to store own's public/private Key\n+    protected Cipher                               asym_cipher;  // decrypting cypher for secret key requests\n+    // queue all up msgs until the secret key has been received/created\n+    // whether or not to queue received messages (until the secret key was received)\n+    protected volatile boolean                     queue_up_msgs=true;\n+    // queues a bounded number of messages received during a null secret key (or fetching the key from a new coord)\n+    protected final BlockingQueue<Message>         up_queue=new ArrayBlockingQueue<Message>(100);\n+\n+    protected volatile long                        last_key_request;\n+\n+    public KeyPair getKeyPair()                         {return key_pair;}\n+    public Cipher  getAsymCipher()                      {return asym_cipher;}\n+    public Address getKeyServerAddr()                   {return key_server_addr;}\n+    public void    setKeyServerAddr(Address key_srv)    {this.key_server_addr=key_srv;}\n+\n+    // Number of received messages currently queued\n+    public int numQueuedMessages() {return up_queue.size();}\n+\n+    public String getName()\n+    {\n+        return \"ASYM_ENCRYPT\";\n+    }\n+\n+    public boolean setProperties(Properties props)\n+    {\n+        String str;\n+\n+        super.setProperties(props);\n+\n+        str=props.getProperty(\"change_key_on_leave\");\n+        if(str != null)\n+        {\n+            change_key_on_leave=Boolean.valueOf(str).booleanValue();\n+            props.remove(\"change_key_on_leave\");\n+        }\n+\n+        if (!props.isEmpty())\n+        {\n+\n+            if (log.isErrorEnabled())\n+                log.error(\"these properties are not recognized:\" + props);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    // Triggers a request for the secret key to the current keyserver\n+    public void sendKeyRequest() {\n+        if(key_server_addr == null) {\n+            log.error(String.format(\"%s: key server is currently not set\", local_addr));\n+            return;\n+        }\n+        sendKeyRequest(key_server_addr);\n+    }\n+\n+    public void init() throws Exception {\n+        initKeyPair();\n+        super.init();\n+    }\n+\n+    public void stop() {\n+        drainUpQueue();\n+        super.stop();\n+    }\n+\n+    public Object down(Event evt) {\n+        if(evt.getType() == Event.MSG) {\n+            Message msg=(Message)evt.getArg();\n+            if(skip(msg))\n+                return down_prot.down(evt);\n+        }\n+        return super.down(evt);\n+    }\n+\n+    public Object up(Event evt) {\n+        if(evt.getType() == Event.MSG) {\n+            Message msg=(Message)evt.getArg();\n+            if(skip(msg))\n+                return up_prot.up(evt);\n+        }\n+        return super.up(evt);\n+    }\n+\n+\n+\n+    /** Checks if a message needs to be encrypted/decrypted. Join and merge requests/responses don't need to be\n+     * encrypted as they're authenticated by {@link AUTH} */\n+    protected static boolean skip(Message msg) {\n+        GMS.GmsHeader hdr=(GMS.GmsHeader)msg.getHeader(GMS.name);\n+        if(hdr == null) return false;\n+        switch(hdr.getType()) {\n+            case GMS.GmsHeader.JOIN_REQ:\n+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n+            case GMS.GmsHeader.JOIN_RSP:\n+            case GMS.GmsHeader.MERGE_REQ:\n+            case GMS.GmsHeader.MERGE_RSP:\n+            case GMS.GmsHeader.VIEW_ACK:\n+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    @Override protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+        switch(hdr.getType()) {\n+            case EncryptHeader.SECRET_KEY_REQ:\n+                handleSecretKeyRequest(msg);\n+                break;\n+            case EncryptHeader.SECRET_KEY_RSP:\n+                handleSecretKeyResponse(msg, hdr.getVersion());\n+                break;\n+            default:\n+                log.warn(String.format(\"%s: received unknown encrypt header of type %d\", local_addr, hdr.getType()));\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    @Override protected boolean process(Message msg) {\n+        if(queue_up_msgs || secret_key == null) {\n+            up_queue.offer(msg);\n+            log.trace(String.format(\"%s: queuing %s message from %s as secret key hasn't been retrieved from keyserver %s yet, hdrs: %s\",\n+                      local_addr, msg.getDest() == null? \"mcast\" : \"unicast\", msg.getSrc(), key_server_addr, msg.printHeaders()));\n+            if(last_key_request == 0 || System.currentTimeMillis() - last_key_request > 2000) {\n+                last_key_request=System.currentTimeMillis();\n+                sendKeyRequest();\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected void handleSecretKeyRequest(final Message msg) {\n+        if(!inView(msg.getSrc(), \"%s: key requester %s is not in current view %s; ignoring key request\"))\n+            return;\n+        log.debug(String.format(\"%s: received key request from %s\", local_addr, msg.getSrc()));\n+        try {\n+            PublicKey tmpKey=generatePubKey(msg.getBuffer());\n+            sendSecretKey(secret_key, tmpKey, msg.getSrc());\n+        }\n+        catch(Exception e) {\n+            log.warn(String.format(\"%s: unable to reconstitute peer's public key\", local_addr));\n+        }\n+    }\n+\n+\n+    protected void handleSecretKeyResponse(final Message msg, final byte[] key_version) {\n+        if(!inView(msg.getSrc(), \"%s: ignoring secret key sent by %s which is not in current view %s\"))\n+            return;\n+        try {\n+            SecretKey tmp=decodeKey(msg.getBuffer());\n+            if(tmp == null)\n+                sendKeyRequest(key_server_addr); // unable to understand response, let's try again\n+            else {\n+                // otherwise set the returned key as the shared key\n+                log.debug(String.format(\"%s: received secret key from keyserver %s\", local_addr, msg.getSrc()));\n+                setKeys(tmp, key_version);\n+            }\n+        }\n+        catch(Exception e) {\n+            log.warn(local_addr + \": unable to process received public key\", e);\n+        }\n+    }\n+\n+\n+    /** Initialise the symmetric key if none is supplied in a keystore */\n+    protected SecretKey createSecretKey() throws Exception {\n+        KeyGenerator keyGen=null;\n+        // see if we have a provider specified\n+        if(provider != null && !provider.trim().isEmpty())\n+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm), provider);\n+        else\n+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm));\n+        // generate the key using the defined init properties\n+        keyGen.init(sym_keylength);\n+        return keyGen.generateKey();\n+    }\n+\n+\n+\n+    /** Generates the public/private key pair from the init params */\n+    protected void initKeyPair() throws Exception {\n+        // generate keys according to the specified algorithms\n+        // generate publicKey and Private Key\n+        KeyPairGenerator KpairGen=null;\n+        if(provider != null && !provider.trim().isEmpty())\n+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm), provider);\n+        else\n+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm));\n+        KpairGen.initialize(asym_keylength,new SecureRandom());\n+        key_pair=KpairGen.generateKeyPair();\n+\n+        // set up the Cipher to decrypt secret key responses encrypted with our key\n+        if(provider != null && !provider.trim().isEmpty())\n+            asym_cipher=Cipher.getInstance(asym_algorithm, provider);\n+        else\n+            asym_cipher=Cipher.getInstance(asym_algorithm);\n+        asym_cipher.init(Cipher.DECRYPT_MODE, key_pair.getPrivate());\n+    }\n+\n+\n+    @Override protected synchronized void handleView(View v) {\n+        boolean left_mbrs=change_key_on_leave && this.view != null && !v.containsMembers(this.view.getMembersRaw());\n+        super.handleView(v);\n+\n+        Address tmpKeyServer=v.getCoord(); // the coordinator is the keyserver\n+        if(tmpKeyServer.equals(local_addr)) {\n+            if(!is_key_server || left_mbrs)\n+                becomeKeyServer(tmpKeyServer, left_mbrs);\n+        }\n+        else\n+            handleNewKeyServer(tmpKeyServer, v instanceof MergeView, left_mbrs);\n+    }\n+\n+\n+    protected void becomeKeyServer(Address tmpKeyServer, boolean left_mbrs) {\n+        if(log.isDebugEnabled()) {\n+            if(!is_key_server)\n+                log.debug(String.format(\"%s: I'm the new key server\", local_addr));\n+            else if(left_mbrs)\n+                log.debug(String.format(\"%s: creating new secret key because members left\", local_addr));\n+        }\n+        key_server_addr=tmpKeyServer;\n+        is_key_server=true;\n+        try {\n+            this.secret_key=createSecretKey();\n+            initSymCiphers(sym_algorithm, secret_key);\n+            drainUpQueue();\n+        }\n+        catch(Exception ex) {\n+            log.error(local_addr + \": failed creating secret key and initializing ciphers\", ex);\n+        }\n+    }\n+\n+    /** If the keyserver changed, send a request for the secret key to the keyserver */\n+    protected void handleNewKeyServer(Address newKeyServer, boolean merge_view, boolean left_mbrs) {\n+        if(keyServerChanged(newKeyServer) || merge_view || left_mbrs) {\n+            secret_key=null;\n+            sym_version=null;\n+            queue_up_msgs=true;\n+            key_server_addr=newKeyServer;\n+            is_key_server=false;\n+            log.debug(String.format(\"%s: sending request for secret key to the new keyserver %s\", local_addr, key_server_addr));\n+            sendKeyRequest(key_server_addr);\n+        }\n+    }\n+\n+    protected boolean keyServerChanged(Address newKeyServer) {\n+        return !equals(key_server_addr, newKeyServer);\n+    }\n+\n+\n+\n+    protected void setKeys(SecretKey key, byte[] version) throws Exception {\n+        if(Arrays.equals(this.sym_version, version))\n+            return;\n+        Cipher decoding_cipher=secret_key != null? decoding_ciphers.take() : null;\n+        // put the previous key into the map, keep the cipher: no leak, as we'll clear decoding_ciphers in initSymCiphers()\n+        if(decoding_cipher != null)\n+            key_map.put(new AsciiString(version), decoding_cipher);\n+        secret_key=key;\n+        initSymCiphers(key.getAlgorithm(), key);\n+        sym_version=version;\n+        drainUpQueue();\n+    }\n+\n+\n+    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {\n+        byte[] encryptedKey=encryptSecretKey(secret_key, public_key);\n+        Message newMsg=new Message(source, local_addr, encryptedKey);\n+        newMsg.putHeader(getName(), new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, getSymVersion()));\n+        log.debug(String.format(\"%s: sending secret key to %s\", local_addr, source));\n+        down_prot.down(new Event(Event.MSG,newMsg));\n+    }\n+\n+    /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */\n+    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {\n+        Cipher tmp;\n+        if (provider != null && !provider.trim().isEmpty())\n+            tmp=Cipher.getInstance(asym_algorithm, provider);\n+        else\n+            tmp=Cipher.getInstance(asym_algorithm);\n+        tmp.init(Cipher.ENCRYPT_MODE, public_key);\n+\n+        // encrypt current secret key\n+        return tmp.doFinal(secret_key.getEncoded());\n+    }\n+\n+\n+    /** send client's public key to server and request server's public key */\n+    protected void sendKeyRequest(Address key_server) {\n+        Message newMsg=new Message(key_server, local_addr, key_pair.getPublic().getEncoded());\n+        newMsg.putHeader(getName(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, sym_version));\n+        down_prot.down(new Event(Event.MSG,newMsg));\n+    }\n+\n+\n+    protected SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {\n+        byte[] keyBytes;\n+\n+        synchronized(this) {\n+            keyBytes=asym_cipher.doFinal(encodedKey);\n+        }\n+\n+        try {\n+            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(sym_algorithm));\n+            Cipher temp;\n+            if (provider != null && !provider.trim().isEmpty())\n+                temp=Cipher.getInstance(sym_algorithm, provider);\n+            else\n+                temp=Cipher.getInstance(sym_algorithm);\n+            temp.init(Cipher.SECRET_KEY, keySpec);\n+            return keySpec;\n+        }\n+        catch(Exception e) {\n+            log.error(\"Failed to decode key\", e);\n+            return null;\n+        }\n+    }\n+\n+    // doesn't have to be 100% correct: leftover messages wll be delivered later and will be discarded as dupes, as\n+    // retransmission is likely to have kicked in before anyway\n+    protected void drainUpQueue() {\n+        queue_up_msgs=false;\n+        Message queued_msg;\n+        while((queued_msg=up_queue.poll()) != null) {\n+            try {\n+                Message decrypted_msg=decryptMessage(null, queued_msg.copy());\n+                if(decrypted_msg != null)\n+                    up_prot.up(new Event(Event.MSG, decrypted_msg));\n+            }\n+            catch(Exception ex) {\n+                log.error(String.format(\"failed decrypting message from %s: %s\", queued_msg.getSrc(), ex));\n+            }\n+        }\n+    }\n+\n+\n+    @Override protected void handleUnknownVersion() {\n+        if(!is_key_server)\n+            sendKeyRequest(key_server_addr);\n+    }\n+\n+    /** Used to reconstitute public key sent in byte form from peer */\n+    protected PublicKey generatePubKey(byte[] encodedKey) {\n+        PublicKey pubKey=null;\n+        try {\n+            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asym_algorithm));\n+            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);\n+            pubKey=KeyFac.generatePublic(x509KeySpec);\n+        }\n+        catch(Exception e) {\n+            e.printStackTrace();\n+        }\n+        return pubKey;\n+    }\n+\n+    protected static boolean equals(Object a, Object b) {\n+        return (a == b) || (a != null && a.equals(b));\n+    }\n+\n+}"
        },
        {
            "sha": "924e3c83e0c18652e115a3c27b6c7a1e09a98dec",
            "filename": "src/org/jgroups/protocols/AUTH.java",
            "status": "modified",
            "additions": 203,
            "deletions": 125,
            "changes": 328,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -1,53 +1,95 @@\n package org.jgroups.protocols;\n \n \n-import org.jgroups.Address;\n-import org.jgroups.Event;\n-import org.jgroups.Message;\n+import org.jgroups.*;\n import org.jgroups.auth.AuthToken;\n+import org.jgroups.conf.ClassConfigurator;\n import org.jgroups.protocols.pbcast.GMS;\n import org.jgroups.protocols.pbcast.JoinRsp;\n import org.jgroups.stack.Protocol;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedList;\n+import java.util.List;\n import java.util.Properties;\n \n \n /**\n- * The AUTH protocol adds a layer of authentication to JGroups\n+ * The AUTH protocol adds a layer of authentication to JGroups. It intercepts join and merge requests and rejects them\n+ * if the joiner or merger is not permitted to join a or merge into a cluster. AUTH should be placed right below\n+ * {@link GMS} in the configuration.\n  * @author Chris Mills\n+ * @author Bela Ban\n  */\n-public class AUTH extends Protocol{\n+public class AUTH extends Protocol {\n \n     static final String NAME = \"AUTH\";\n \n-    /**\n-     * used on the coordinator to authentication joining member requests against\n-     */\n-    private AuthToken serverSideToken = null;\n+    /** Interface to provide callbacks for handling up events */\n+    public interface UpHandler {\n+        /**\n+         * Called when an up event has been received\n+         * @param evt the event\n+         * @return true if the event should be passed up, else false\n+         */\n+        boolean handleUpEvent(Event evt);\n+    }\n+\n+\n+    /** Used on the coordinator to authentication joining member requests against */\n+    protected AuthToken             auth_token;\n+\n+    /** List of UpHandler which are called when an up event has been received. Usually used by AuthToken impls */\n+    protected final List<UpHandler> up_handlers=new ArrayList<UpHandler>();\n+\n+    protected Address               local_addr;\n+\n \n-    public AUTH(){\n+    public AUTH() {}\n+\n+    protected volatile boolean      authenticate_coord=true;\n+    \n+    // Do join or merge responses from the coordinator also need to be authenticated\n+    public void setAuthCoord( boolean authenticateCoord) {\n+        this.authenticate_coord= authenticateCoord;\n     }\n \n-    public boolean setProperties(Properties props) {\n+    public String    getAuthClass()                {return auth_token != null? auth_token.getClass().getName() : null;}\n+    public AuthToken getAuthToken()                {return auth_token;}\n+    public void      setAuthToken(AuthToken token) {this.auth_token=token;}\n+    public void      register(UpHandler handler)   {up_handlers.add(handler);}\n+    public void      unregister(UpHandler handler) {up_handlers.remove(handler);}\n+    public Address   getAddress()                  {return local_addr;}\n \n-        String authClassString = props.getProperty(\"auth_class\");\n \n-        if(authClassString != null){\n+    public boolean setProperties(Properties props) {\n+        String str;\n+\n+        str = props.getProperty(\"auth_class\");\n+        if(str != null){\n             props.remove(\"auth_class\");\n \n             try{\n-                Object obj = Class.forName(authClassString).newInstance();\n-                serverSideToken = (AuthToken) obj;\n-                serverSideToken.setAuth(this);\n-                serverSideToken.setValue(props);\n+                Object obj = Class.forName(str).newInstance();\n+                auth_token = (AuthToken) obj;\n+                auth_token.setAuth(this);\n+                auth_token.setValue(props);\n             }catch(Exception e){\n                 if(log.isFatalEnabled()){\n-                    log.fatal(\"Failed to create server side token (\" + authClassString + \")\");\n+                    log.fatal(\"Failed to create server side token (\" + str + \")\");\n                     log.fatal(e);\n                 }\n                 return false;\n             }\n         }\n \n+        str=props.getProperty(\"authenticate_coord\");\n+        if(str != null)\n+        {\n+            authenticate_coord=Boolean.valueOf(str).booleanValue();\n+            props.remove(\"authenticate_coord\");\n+        }\n+\n         if(!props.isEmpty()) {\n             //this should never happen as everything is read in to the AuthToken instance\n             if(log.isErrorEnabled()){\n@@ -61,146 +103,182 @@ public boolean setProperties(Properties props) {\n     public final String getName() {\n         return AUTH.NAME;\n     }\n-    /**\n-     * Used to create a failed JOIN_RSP message to pass back down the stack\n-     * @param joiner The Address of the requesting member\n-     * @param message The failure message to send back to the joiner\n-     * @return An Event containing a GmsHeader with a JoinRsp object\n-     */\n-    private Event createFailureEvent(Address joiner, String message){\n-        Message msg = new Message(joiner, null, null);\n \n-        if(log.isDebugEnabled()){\n-            log.debug(\"Creating JoinRsp with failure message - \" + message);\n-        }\n-        JoinRsp joinRes = new JoinRsp(message);\n-        //need to specify the error message on the JoinRsp object once it's been changed\n+    public void init() throws Exception {\n+        super.init();\n+        if(auth_token == null)\n+            throw new IllegalStateException(\"no authentication mechanism configured\");\n+        auth_token.init();\n+    }\n \n-        GMS.GmsHeader gmsHeader = new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, joinRes);\n-        msg.putHeader(GMS.name, gmsHeader);\n+    public void start() throws Exception {\n+        super.start();\n+        if(auth_token != null)\n+            auth_token.start();\n+    }\n \n-        if(log.isDebugEnabled()){\n-            log.debug(\"GMSHeader created for failure JOIN_RSP\");\n-        }\n+    public void stop() {\n+        if(auth_token != null)\n+            auth_token.stop();\n+        super.stop();\n+    }\n \n-        return new Event(Event.MSG, msg);\n+    public void destroy() {\n+        if(auth_token != null)\n+            auth_token.destroy();\n+        super.destroy();\n     }\n \n     /**\n-     * An event was received from the layer below. Usually the current layer will want to examine\n-     * the event type and - depending on its type - perform some computation\n-     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n-     * when receiving a VIEW_CHANGE event).\n-     * Finally the event is either a) discarded, or b) an event is sent down\n-     * the stack using <code>down_prot.down()</code> or c) the event (or another event) is sent up\n-     * the stack using <code>up_prot.up()</code>.\n+     * An event was received from the layer below. Usually the current layer will want to examine the event type and\n+     * - depending on its type - perform some computation (e.g. removing headers from a MSG event type, or updating\n+     * the internal membership list when receiving a VIEW_CHANGE event).\n+     * Finally the event is either a) discarded, or b) an event is sent down the stack using {@code down_prot.down()}\n+     * or c) the event (or another event) is sent up the stack using {@code up_prot.up()}.\n      */\n     public Object up(Event evt) {\n-        GMS.GmsHeader hdr = isJoinMessage(evt);\n-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_REQ || hdr.getType() == GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER)){\n-            if(log.isDebugEnabled()){\n-                log.debug(\"AUTH got up event\");\n-            }\n-            //we found a join message - now try and get the AUTH Header\n-            Message msg = (Message)evt.getArg();\n-\n-            if((msg.getHeader(AUTH.NAME) != null) && (msg.getHeader(AUTH.NAME) instanceof AuthHeader)){\n-                AuthHeader authHeader = (AuthHeader)msg.getHeader(AUTH.NAME);\n-\n-                if(authHeader != null){\n-                    //Now we have the AUTH Header we need to validate it\n-                    if(this.serverSideToken.authenticate(authHeader.getToken(), msg)){\n-                        //valid token\n-                        if(log.isDebugEnabled()){\n-                            log.debug(\"AUTH passing up event\");\n-                        }\n-                        up_prot.up(evt);\n-                    }else{\n-                        //invalid token\n-                        if(log.isWarnEnabled()){\n-                            log.warn(\"AUTH failed to validate AuthHeader token\");\n-                        }\n-                        sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), \"Authentication failed\"));\n-                    }\n-                }else{\n-                    //Invalid AUTH Header - need to send failure message\n-                    if(log.isWarnEnabled()){\n-                        log.warn(\"AUTH failed to get valid AuthHeader from Message\");\n-                    }\n-                    sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), \"Failed to find valid AuthHeader in Message\"));\n-                }\n-            }else{\n-                if(log.isDebugEnabled()){\n-                    log.debug(\"No AUTH Header Found\");\n+        switch(evt.getType()) {\n+            case Event.MSG:\n+                Message msg=(Message)evt.getArg();\n+\n+                // If we have a join or merge request --> authenticate, else pass up\n+                GMS.GmsHeader gms_hdr=getGMSHeader(evt);\n+                if(gms_hdr != null && needsAuthentication(gms_hdr)) {\n+                    AuthHeader auth_hdr=(AuthHeader)msg.getHeader(AUTH.NAME);\n+                    if(auth_hdr == null)\n+                        throw new IllegalStateException(String.format(\"found %s from %s but no AUTH header\", gms_hdr, msg.getSrc()));\n+                    if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed\n+                        return null;    // don't pass up\n                 }\n-                //should be a failure\n-                sendRejectionMessage(msg.getSrc(), createFailureEvent(msg.getSrc(), \"Failed to find an AuthHeader in Message\"));\n-            }\n-        } else {\n-            return up_prot.up(evt);\n+                break;\n         }\n-        return null;\n+        if(!callUpHandlers(evt))\n+            return null;\n+\n+        return up_prot.up(evt);\n     }\n \n \n-    private void sendRejectionMessage(Address dest, Event join_rsp) {\n-        if(dest == null) {\n-            log.error(\"destination is null, cannot send JOIN rejection message to null destination\");\n-            return;\n-        }\n-        down_prot.down(join_rsp);\n-    }\n \n     /**\n      * An event is to be sent down the stack. The layer may want to examine its type and perform\n      * some action on it, depending on the event's type. If the event is a message MSG, then\n      * the layer may need to add a header to it (or do nothing at all) before sending it down\n-     * the stack using <code>down_prot.down()</code>. In case of a GET_ADDRESS event (which tries to\n+     * the stack using {@code down_prot.down()}. In case of a GET_ADDRESS event (which tries to\n      * retrieve the stack's address from one of the bottom layers), the layer may need to send\n-     * a new response event back up the stack using <code>up_prot.up()</code>.\n+     * a new response event back up the stack using {@code up_prot.up()}.\n      */\n     public Object down(Event evt) {\n-        GMS.GmsHeader hdr = isJoinMessage(evt);\n-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_REQ || hdr.getType() == GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER)){\n-            if(log.isDebugEnabled()){\n-                log.debug(\"AUTH got down event\");\n-            }\n-            //we found a join request message - now add an AUTH Header\n-            Message msg = (Message)evt.getArg();\n-            AuthHeader authHeader = new AuthHeader();\n-            authHeader.setToken(this.serverSideToken);\n-            msg.putHeader(AUTH.NAME, authHeader);\n-\n-            if(log.isDebugEnabled()){\n-                log.debug(\"AUTH passing down event\");\n-            }\n+        GMS.GmsHeader hdr = getGMSHeader(evt);\n+        if(hdr != null && needsAuthentication(hdr)) {\n+            // we found a join request message - now add an AUTH Header\n+            Message msg=(Message)evt.getArg();\n+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));\n         }\n \n-        if((hdr != null) && (hdr.getType() == GMS.GmsHeader.JOIN_RSP)){\n-            if(log.isDebugEnabled()){\n-                log.debug(hdr.toString());\n+        if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n+            local_addr=(Address)evt.getArg();\n+\n+        return down_prot.down(evt);\n+    }\n+\n+\n+\n+    protected boolean needsAuthentication(GMS.GmsHeader hdr) {\n+        switch(hdr.getType()) {\n+            case GMS.GmsHeader.JOIN_REQ:\n+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n+            case GMS.GmsHeader.MERGE_REQ:\n+                return true;\n+            case GMS.GmsHeader.JOIN_RSP:\n+            case GMS.GmsHeader.MERGE_RSP:\n+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:\n+                return this.authenticate_coord;\n+            default:\n+                return false;\n+        }\n+    }\n+\n+\n+    /**\n+     * Handles a GMS header\n+     * @param gms_hdr\n+     * @param msg\n+     * @return true if the message should be passed up, or else false\n+     */\n+    protected boolean handleAuthHeader(GMS.GmsHeader gms_hdr, AuthHeader auth_hdr, Message msg) {\n+        if(needsAuthentication(gms_hdr)) {\n+            if(this.auth_token.authenticate(auth_hdr.getToken(), msg))\n+                return true; //  authentication passed, send message up the stack\n+            else {\n+                log.warn(String.format(\"%s: failed to validate AuthHeader (token: %s) from %s; dropping message\",\n+                         local_addr, auth_token.getClass().getSimpleName(), msg.getSrc()));\n+                sendRejectionMessage(gms_hdr.getType(), msg.getSrc(), \"authentication failed\");\n+                return false;\n             }\n         }\n+        return true;\n+    }\n+\n+\n+    protected void sendRejectionMessage(byte type, Address dest, String error_msg) {\n+        switch(type) {\n+            case GMS.GmsHeader.JOIN_REQ:\n+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n+                sendJoinRejectionMessage(dest, error_msg);\n+                break;\n+            case GMS.GmsHeader.MERGE_REQ:\n+                sendMergeRejectionMessage(dest);\n+                break;\n+        }\n+    }\n \n-        return down_prot.down(evt);\n+    protected void sendJoinRejectionMessage(Address dest, String error_msg) {\n+        if(dest == null)\n+            return;\n+\n+        JoinRsp joinRes=new JoinRsp(error_msg); // specify the error message on the JoinRsp\n+        Message msg = new Message(dest);\n+        msg.putHeader(GMS.name, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, joinRes));\n+        if(this.authenticate_coord)\n+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));\n+        down_prot.down(new Event(Event.MSG, msg));\n+    }\n+\n+    protected void sendMergeRejectionMessage(Address dest) {\n+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP);\n+        hdr.setMergeRejected(true);\n+        Message msg=new Message(dest);\n+        msg.setFlag(Message.OOB);\n+        msg.putHeader(GMS.name, hdr);\n+        if(this.authenticate_coord)\n+            msg.putHeader(AUTH.NAME, new AuthHeader(this.auth_token));\n+        log.debug(\"merge response=\" + hdr);\n+        down_prot.down(new Event(Event.MSG, msg));\n+    }\n+\n+    protected boolean callUpHandlers(Event evt) {\n+        boolean pass_up=true;\n+        for(UpHandler handler: up_handlers) {\n+            if(!handler.handleUpEvent(evt))\n+                pass_up=false;\n+        }\n+        return pass_up;\n     }\n \n     /**\n-     * Used to check if the message type is a Gms message\n+     * Get the header from a GMS message\n      * @param evt The event object passed in to AUTH\n      * @return A GmsHeader object or null if the event contains a message of a different type\n      */\n-    private static GMS.GmsHeader isJoinMessage(Event evt){\n-        Message msg;\n-        switch(evt.getType()){\n-          case Event.MSG:\n-                msg = (Message)evt.getArg();\n-                Object obj = msg.getHeader(\"GMS\");\n-                if(obj == null || !(obj instanceof GMS.GmsHeader)){\n-                    return null;\n-                }\n-                return (GMS.GmsHeader)obj;\n-        }\n+    protected static GMS.GmsHeader getGMSHeader(Event evt){\n+        return evt.getType() == Event.MSG? getGMSHeader((Message)evt.getArg()) : null;\n+    }\n+\n+    protected static GMS.GmsHeader getGMSHeader(Message msg){\n+        Header hdr = msg.getHeader(GMS.name);\n+        if(hdr instanceof GMS.GmsHeader)\n+            return (GMS.GmsHeader)hdr;\n         return null;\n     }\n }"
        },
        {
            "sha": "719e6f1bbddab36f1995825eac9307c3660383b0",
            "filename": "src/org/jgroups/protocols/AuthHeader.java",
            "status": "modified",
            "additions": 5,
            "deletions": 0,
            "changes": 5,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FAuthHeader.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FAuthHeader.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FAuthHeader.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -16,6 +16,11 @@ public class AuthHeader extends Header implements Streamable{\n \n     public AuthHeader(){\n     }\n+\n+    public AuthHeader(AuthToken token) {\n+        this.token=token;\n+    }\n+\n     /**\n      * Sets the token value to that of the passed in token object\n      * @param token the new authentication token"
        },
        {
            "sha": "68b282bd4ae8f5789aad6714046a48d39d922bcf",
            "filename": "src/org/jgroups/protocols/DISCARD.java",
            "status": "modified",
            "additions": 7,
            "deletions": 0,
            "changes": 7,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FDISCARD.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FDISCARD.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FDISCARD.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -42,6 +42,13 @@ public class DISCARD extends Protocol {\n \n     protected boolean use_gui=false;\n \n+    public boolean isDiscardAll() {\n+        return discard_all;\n+    }\n+\n+    public void setDiscardAll(boolean discard_all) {\n+        this.discard_all=discard_all;\n+    }\n \n     /**\n      * All protocol names have to be unique !"
        },
        {
            "sha": "f76e7b01c7f041260b2dd3fdd7eb306c580c89a0",
            "filename": "src/org/jgroups/protocols/EncryptBase.java",
            "status": "added",
            "additions": 464,
            "deletions": 0,
            "changes": 464,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,464 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.stack.Protocol;\n+import org.jgroups.util.*;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.Properties;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.zip.Adler32;\n+import java.util.zip.CRC32;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.\n+ * @author Bela Ban\n+ */\n+public abstract class EncryptBase extends Protocol {\n+    protected static final String DEFAULT_SYM_ALGO=\"AES\";\n+\n+\n+    /* -----------------------------------------    Properties     -------------------------------------------------- */\n+    // Cryptographic Service Provider\n+    protected String                        provider;\n+\n+    // Cipher engine transformation for asymmetric algorithm. Default is RSA\n+    protected String                        asym_algorithm=\"RSA\";\n+\n+    // Cipher engine transformation for symmetric algorithm. Default is AES\n+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;\n+\n+    // Initial public/private key length. Default is 512\n+    protected int                           asym_keylength=512;\n+\n+    // Initial key length for matching symmetric algorithm. Default is 128\n+    protected int                           sym_keylength=128;\n+\n+    // Number of ciphers in the pool to parallelize encrypt and decrypt requests\n+    protected int                           cipher_pool_size=8;\n+\n+    // If true, the entire message (including payload and headers) is encrypted, else only the payload\n+    protected boolean                       encrypt_entire_message=true;\n+\n+    // If true, all messages are digitally signed by adding an encrypted checksum of the encrypted\n+    // message to the header. Ignored if encrypt_entire_message is false\n+    protected boolean                       sign_msgs=true;\n+\n+    // When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is\n+    // true, Adler32 will be used\n+    protected boolean                       use_adler;\n+\n+    protected volatile Address              local_addr;\n+\n+    protected volatile View                 view;\n+\n+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size\n+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;\n+\n+    // version filed for secret key\n+    protected volatile byte[]               sym_version;\n+\n+    // shared secret key to encrypt/decrypt messages\n+    protected volatile SecretKey            secret_key;\n+\n+    // map to hold previous keys so we can decrypt some earlier messages if we need to\n+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<AsciiString,Cipher>();\n+\n+    public int       getAsymKeylength()                 {return asym_keylength;}\n+    public void      setAsymKeylength(int len)          {this.asym_keylength=len;}\n+    public int       getSymKeylength()                  {return sym_keylength;}\n+    public void      setSymKeylength(int len)           {this.sym_keylength=len;}\n+    public SecretKey getSecretKey()                     {return secret_key;}\n+    public void      setSecretKey(SecretKey key)        {this.secret_key=key;}\n+    public String    getSymAlgorithm()                  {return sym_algorithm;}\n+    public void      setSymAlgorithm(String alg)        {this.sym_algorithm=alg;}\n+    public String    getAsymAlgorithm()                 {return asym_algorithm;}\n+    public void      setAsymAlgorithm(String alg)       {this.asym_algorithm=alg;}\n+    public byte[]    getSymVersion()                    {return sym_version;}\n+    public void      setSymVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length);}\n+    public void      setLocalAddress(Address addr)      {this.local_addr=addr;}\n+    public boolean   getEncryptEntireMessage()          {return encrypt_entire_message;}\n+    public void      setEncryptEntireMessage(boolean b) {this.encrypt_entire_message=b;}\n+    public boolean   getSignMessages()                  {return this.sign_msgs;}\n+    public void      setSignMessages(boolean flag)      {this.sign_msgs=flag;}\n+    public boolean   getAdler()                         {return use_adler;}\n+    public void      setAdler(boolean flag)             {this.use_adler=flag;}\n+    public String    getVersion()                       {return Util.byteArrayToHexString(sym_version);}\n+\n+    public boolean setProperties(Properties props)\n+    {\n+        String str;\n+\n+        super.setProperties(props);\n+\n+        str = props.getProperty(\"provider\");\n+        if (str != null)\n+        {\n+            provider = str;\n+            props.remove(\"provider\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"Provider used is \" + provider);\n+        }\n+\n+        // asymmetric algorithm name\n+        str = props.getProperty(\"asym_algorithm\");\n+        if (str != null)\n+        {\n+            asym_algorithm = str;\n+            props.remove(\"asym_algorithm\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"Asym algo used is \" + asym_algorithm);\n+        }\n+\n+        // symmetric algorithm name\n+        str = props.getProperty(\"sym_algorithm\");\n+        if (str != null)\n+        {\n+            sym_algorithm = str;\n+            props.remove(\"sym_algorithm\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"Sym algo used is \" + sym_algorithm);\n+        }\n+\n+        // asymmetric key length\n+        str = props.getProperty(\"asym_keylength\");\n+        if (str != null)\n+        {\n+            asym_keylength = Integer.parseInt(str);\n+            props.remove(\"asym_keylength\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"Asym keylength used is \" + asym_keylength);\n+        }\n+\n+        // asymmetric key length\n+        str = props.getProperty(\"sym_keylength\");\n+        if (str != null)\n+        {\n+            sym_keylength = Integer.parseInt(str);\n+            props.remove(\"sym_keylength\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"Sym keylength used is \" + sym_keylength);\n+        }\n+\n+        // cipher pool size\n+        str = props.getProperty(\"cipher_pool_size\");\n+        if (str != null)\n+        {\n+            cipher_pool_size = Integer.parseInt(str);\n+            props.remove(\"cipher_pool_size\");\n+        }\n+\n+        str=props.getProperty(\"encrypt_entire_message\");\n+        if(str != null)\n+        {\n+            encrypt_entire_message=Boolean.valueOf(str).booleanValue();\n+            props.remove(\"encrypt_entire_message\");\n+        }\n+\n+        str=props.getProperty(\"sign_msgs\");\n+        if(str != null)\n+        {\n+            sign_msgs=Boolean.valueOf(str).booleanValue();\n+            props.remove(\"sign_msgs\");\n+        }\n+\n+        str=props.getProperty(\"use_adler\");\n+        if(str != null)\n+        {\n+            use_adler=Boolean.valueOf(str).booleanValue();\n+            props.remove(\"use_adler\");\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    public void init() throws Exception {\n+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);\n+        if(tmp != cipher_pool_size) {\n+            log.warn(String.format(\"%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation\", local_addr, cipher_pool_size, tmp));\n+            cipher_pool_size=tmp;\n+        }\n+        encoding_ciphers=new ArrayBlockingQueue<Cipher>(cipher_pool_size);\n+        decoding_ciphers=new ArrayBlockingQueue<Cipher>(cipher_pool_size);\n+        initSymCiphers(sym_algorithm, secret_key);\n+    }\n+\n+\n+    public Object down(Event evt) {\n+        switch(evt.getType()) {\n+            case Event.MSG:\n+                Message msg=(Message)evt.getArg();\n+                try {\n+                    if(secret_key == null) {\n+                        log.trace(String.format(\"%s: discarded %s message to %s as secret key is null, hdrs: %s\",\n+                                  local_addr, msg.getDest() == null? \"mcast\" : \"unicast\", msg.getDest(), msg.printHeaders()));\n+                        return null;\n+                    }\n+                    encryptAndSend(msg);\n+                }\n+                catch(Exception e) {\n+                    log.warn(local_addr + \": unable to send message down\", e);\n+                }\n+                return null;\n+\n+            case Event.VIEW_CHANGE:\n+                handleView((View)evt.getArg());\n+                break;\n+        }\n+        return down_prot.down(evt);\n+    }\n+\n+\n+    public Object up(Event evt) {\n+        switch(evt.getType()) {\n+            case Event.VIEW_CHANGE:\n+                handleView((View)evt.getArg());\n+                break;\n+            case Event.SET_LOCAL_ADDRESS:\n+                local_addr=(Address)evt.getArg();\n+                break;\n+            case Event.MSG:\n+                Message msg=(Message)evt.getArg();\n+                try {\n+                    return handleUpMessage(msg);\n+                }\n+                catch(Exception e) {\n+                    log.warn(local_addr + \": exception occurred decrypting message\", e);\n+                }\n+                return null;\n+        }\n+        return up_prot.up(evt);\n+    }\n+\n+\n+\n+\n+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */\n+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {\n+        if(secret == null)\n+            return;\n+        encoding_ciphers.clear();\n+        decoding_ciphers.clear();\n+        for(int i=0; i < cipher_pool_size; i++ ) {\n+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));\n+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));\n+        };\n+\n+        //set the version\n+        MessageDigest digest=MessageDigest.getInstance(\"MD5\");\n+        digest.reset();\n+        digest.update(secret.getEncoded());\n+\n+        byte[] tmp=digest.digest();\n+        sym_version=Arrays.copyOf(tmp, tmp.length);\n+        log.debug(String.format(\"%s: created %d symmetric ciphers with secret key (%d bytes)\", local_addr, cipher_pool_size, sym_version.length));\n+    }\n+\n+\n+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {\n+        Cipher cipher=provider != null && !provider.trim().isEmpty()?\n+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);\n+        cipher.init(mode, secret_key);\n+        return cipher;\n+    }\n+\n+\n+    protected Object handleUpMessage(Message msg) throws Exception {\n+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(getName());\n+        if(hdr == null) {\n+            log.error(String.format(\"%s: received message without encrypt header from %s; dropping it\", local_addr, msg.getSrc()));\n+            return null;\n+        }\n+        switch(hdr.getType()) {\n+            case EncryptHeader.ENCRYPT:\n+                return handleEncryptedMessage(msg);\n+            default:\n+                return handleUpEvent(msg,hdr);\n+        }\n+    }\n+\n+\n+    protected Object handleEncryptedMessage(Message msg) throws Exception {\n+        if(!process(msg))\n+            return null;\n+\n+        // try and decrypt the message - we need to copy msg as we modify its\n+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)\n+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits\n+        if(tmpMsg != null)\n+            return up_prot.up(new Event(Event.MSG, tmpMsg));\n+        log.warn(String.format(\"%s: unrecognized cipher; discarding message from %s\", local_addr, msg.getSrc()));\n+        return null;\n+    }\n+\n+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+        return null;\n+    }\n+\n+    /** Whether or not to process this received message */\n+    protected boolean process(Message msg) {return true;}\n+\n+    protected void handleView(View view) {\n+        this.view=view;\n+    }\n+\n+    protected boolean inView(Address sender, String error_msg) {\n+        View curr_view=this.view;\n+        if(curr_view == null || curr_view.containsMember(sender))\n+            return true;\n+        log.error(String.format(error_msg, local_addr, sender, curr_view));\n+        return false;\n+    }\n+\n+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}\n+\n+\n+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */\n+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {\n+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(getName());\n+        if(hdr.getVersion() == null)\n+            return null;\n+        if(!Arrays.equals(hdr.getVersion(), sym_version)) {\n+            cipher=key_map.get(new AsciiString(hdr.getVersion()));\n+            if(cipher == null) {\n+                handleUnknownVersion();\n+                return null;\n+            }\n+            log.trace(String.format(\"%s: decrypting msg from %s using previous cipher version\", local_addr, msg.getSrc()));\n+            return _decrypt(cipher, msg, hdr);\n+        }\n+        return _decrypt(cipher, msg, hdr);\n+    }\n+\n+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {\n+        byte[] decrypted_msg;\n+\n+        if(!encrypt_entire_message && msg.getLength() == 0)\n+            return msg;\n+\n+        if(encrypt_entire_message && sign_msgs) {\n+            byte[] signature=hdr.getSignature();\n+            if(signature == null) {\n+                log.error(String.format(\"%s: dropped message from %s as the header did not have a checksum\", local_addr, msg.getSrc()));\n+                return null;\n+            }\n+\n+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);\n+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n+            if(actual_checksum != msg_checksum) {\n+                log.error(String.format(\"%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)\",\n+                          local_addr, msg.getSrc(), msg_checksum, actual_checksum));\n+                return null;\n+            }\n+        }\n+\n+        if(cipher == null)\n+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);\n+        else\n+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n+\n+        if(!encrypt_entire_message) {\n+            msg.setBuffer(decrypted_msg);\n+            return msg;\n+        }\n+\n+        Message ret=(Message)Util.streamableFromByteBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);\n+        if(ret.getDest() == null)\n+            ret.setDest(msg.getDest());\n+        if(ret.getSrc() == null)\n+            ret.setSrc(msg.getSrc());\n+        return ret;\n+    }\n+\n+\n+    protected void encryptAndSend(Message msg) throws Exception {\n+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, getSymVersion());\n+        if(encrypt_entire_message) {\n+            if(msg.getSrc() == null)\n+                msg.setSrc(local_addr);\n+\n+            byte [] serialized_msg=Util.streamableToByteBuffer(msg);\n+            byte[] encrypted_msg=code(serialized_msg,0,serialized_msg.length,false);\n+\n+            if(sign_msgs) {\n+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);\n+                byte[] checksum_array=encryptChecksum(checksum);\n+                hdr.setSignature(checksum_array);\n+            }\n+\n+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver\n+            Message tmp=msg.copy(false, false);\n+            tmp.setBuffer(encrypted_msg);\n+            tmp.putHeader(getName(),hdr);\n+            down_prot.down(new Event(Event.MSG, tmp));\n+            return;\n+        }\n+\n+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption\n+        Message msgEncrypted=msg.copy(false);\n+        msgEncrypted.putHeader(getName(), hdr);\n+        if(msg.getLength() > 0)\n+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));\n+        down_prot.down(new Event(Event.MSG,msgEncrypted));\n+    }\n+\n+\n+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {\n+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;\n+        Cipher cipher=queue.take();\n+        try {\n+            return cipher.doFinal(buf, offset, length);\n+        }\n+        finally {\n+            queue.offer(cipher);\n+        }\n+    }\n+\n+    protected long computeChecksum(byte[] input, int offset, int length) {\n+        Checksum checksummer=createChecksummer();\n+        checksummer.update(input, offset, length);\n+        return checksummer.getValue();\n+    }\n+\n+    protected byte[] encryptChecksum(long checksum) throws Exception {\n+        byte[] checksum_array=new byte[Global.LONG_SIZE];\n+        Bits.writeLong(checksum, checksum_array, 0);\n+        return code(checksum_array, 0, checksum_array.length, false);\n+    }\n+\n+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {\n+        byte[] decrypted_checksum;\n+        if(cipher == null)\n+            decrypted_checksum=code(input, offset, length, true);\n+        else\n+            decrypted_checksum=cipher.doFinal(input, offset, length);\n+        return Bits.readLong(decrypted_checksum, 0);\n+    }\n+\n+\n+    /* Get the algorithm name from \"algorithm/mode/padding\"  taken from original ENCRYPT */\n+    protected static String getAlgorithm(String s) {\n+        int index=s.indexOf('/');\n+        return index == -1? s : s.substring(0, index);\n+    }\n+\n+\n+    /** Called when the version shipped in the header can't be found */\n+    protected void handleUnknownVersion() {}\n+\n+\n+\n+}"
        },
        {
            "sha": "201cdd8fc19c38631a20eca49c18e00bbe038ca7",
            "filename": "src/org/jgroups/protocols/EncryptHeader.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,80 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.Global;\n+import org.jgroups.Header;\n+import org.jgroups.util.Streamable;\n+import org.jgroups.util.Util;\n+\n+import java.io.DataInputStream;\n+import java.io.DataOutputStream;\n+import java.io.IOException;\n+\n+/**\n+ * @author Bela Ban\n+ * @since  3.6.10\n+ */\n+public class EncryptHeader extends Header implements Streamable {\n+    public static final byte ENCRYPT        = 1 << 0;\n+    public static final byte SECRET_KEY_REQ = 1 << 1;\n+    public static final byte SECRET_KEY_RSP = 1 << 2;\n+\n+    protected byte   type;\n+    protected byte[] version;\n+    protected byte[] signature; // the encrypted checksum\n+\n+\n+    public EncryptHeader() {}\n+\n+\n+    public EncryptHeader(byte type, byte[] version) {\n+        this.type=type;\n+        this.version=version;\n+    }\n+\n+    public byte          getType()           {return type;}\n+    public byte[]        getVersion()        {return version;}\n+    public byte[]        getSignature()         {return signature;}\n+    public void setSignature(byte[] s) {this.signature=s;}\n+\n+    public void writeExternal(java.io.ObjectOutput out) throws IOException\n+    {\n+        out.writeByte(type);\n+        out.writeObject(version);\n+        out.writeObject(signature);\n+    }\n+\n+\n+    public void readExternal(java.io.ObjectInput in) throws IOException, ClassNotFoundException\n+    {\n+        type = in.readByte();\n+        version = (byte [])in.readObject();\n+        signature = (byte [])in.readObject();\n+    }\n+\n+    public void writeTo(DataOutputStream out) throws IOException {\n+        out.writeByte(type);\n+        Util.writeByteBuffer(version, out);\n+        Util.writeByteBuffer(signature, out);\n+    }\n+\n+    public void readFrom(DataInputStream in) throws IOException, IllegalAccessException, InstantiationException {\n+        type=in.readByte();\n+        version=Util.readByteBuffer(in);\n+        signature=Util.readByteBuffer(in);\n+    }\n+\n+    public String toString() {\n+        return String.format(\"[%s version=%s]\", typeToString(type), (version != null? version.length + \" bytes\" : \"n/a\"));\n+    }\n+\n+    public int size() {return Global.BYTE_SIZE + Util.size(version) + Util.size(signature) /*+ Util.size(payload) */;}\n+\n+    protected static String typeToString(byte type) {\n+        switch(type) {\n+            case ENCRYPT:        return \"ENCRYPT\";\n+            case SECRET_KEY_REQ: return \"SECRET_KEY_REQ\";\n+            case SECRET_KEY_RSP: return \"SECRET_KEY_RSP\";\n+            default:             return \"<unrecognized type \" + type;\n+        }\n+    }\n+}"
        },
        {
            "sha": "115e571c3c39caf6a66a633cf4aefc3d3ec0255f",
            "filename": "src/org/jgroups/protocols/SYM_ENCRYPT.java",
            "status": "added",
            "additions": 187,
            "deletions": 0,
            "changes": 187,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,187 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.util.Util;\n+\n+import javax.crypto.SecretKey;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+import java.util.Properties;\n+\n+/**\n+ * Encrypts and decrypts communication in JGroups by using a secret key shared by all cluster members.<p>\n+ *\n+ * The secret key is identical for all cluster members and is injected into this protocol at startup, e.g. by reading\n+ * it from a keystore. Messages are sent by encrypting them with the secret key and received by decrypting them with\n+ * the secret key. Note that all cluster members must be shipped with the same keystore file<p>\n+ *\n+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK}, so that most important\n+ * headers are encrypted as well, to prevent replay attacks.<p>\n+ *\n+ * A possible configuration looks like this:<br><br>\n+ * {@code <SYM_ENCRYPT key_store_name=\"defaultStore.keystore\" store_password=\"changeit\" alias=\"myKey\"/>}\n+ * <br>\n+ * <br>\n+ * In order to use SYM_ENCRYPT layer in this manner, it is necessary to have the secret key already generated in a\n+ * keystore file. The directory containing the keystore file must be on the application's classpath. You cannot create a\n+ * secret key keystore file using the keytool application shipped with the JDK. A java file called KeyStoreGenerator is\n+ * included in the demo package that can be used from the command line (or IDE) to generate a suitable keystore.\n+ *\n+ * @author Bela Ban\n+ * @author Steve Woodcock\n+ */\n+public class SYM_ENCRYPT extends EncryptBase {\n+\n+    /* -----------------------------------------    Properties     -------------------------------------------------- */\n+    // File on classpath that contains keystore repository\n+    protected String   keystore_name;\n+\n+    // Password used to check the integrity/unlock the keystore. Change the default\n+    protected String   store_password=\"changeit\"; // JDK default\n+\n+    // Password for recovering the key. Change the default\"\n+    protected String   key_password; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)\n+\n+\n+    // Alias used for recovering the key. Change the default\"\n+    protected String   alias=\"mykey\"; // JDK default\n+\n+\n+    public String getKeystoreName()                      {return this.keystore_name;}\n+    public void   setKeystoreName(String n)              {this.keystore_name=n;}\n+    public String getAlias()                             {return alias;}\n+    public void   setAlias(String a)                     {this.alias=a;}\n+    public String getStorePassword()                     {return store_password;}\n+    public void   setStorePassword(String pwd)           {this.store_password=pwd;}\n+\n+\n+    public String getName()\n+    {\n+        return \"SYM_ENCRYPT\";\n+    }\n+\n+    public boolean setProperties(Properties props)\n+    {\n+        String str;\n+\n+        super.setProperties(props);\n+\n+        // key store name\n+        str = props.getProperty(\"keystore_name\");\n+        if (str != null)\n+        {\n+            keystore_name = str;\n+            props.remove(\"keystore_name\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"keystore_name used is \" + keystore_name);\n+        }\n+\n+        // key store password\n+        str = props.getProperty(\"store_password\");\n+        if (str != null)\n+        {\n+            store_password = str;\n+            props.remove(\"store_password\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"store_password used is not null\");\n+        }\n+\n+        // key password\n+        str = props.getProperty(\"key_password\");\n+        if (str != null)\n+        {\n+            key_password = str;\n+            props.remove(\"key_password\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"key_password used is not null\");\n+        } else if (store_password != null)\n+        {\n+            key_password = store_password;\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"key_password used is same as store_password\");\n+        }\n+\n+        // key aliase\n+        str = props.getProperty(\"alias\");\n+        if (str != null)\n+        {\n+            alias = str;\n+            props.remove(\"alias\");\n+\n+            if (log.isInfoEnabled())\n+                log.info(\"alias used is \" + alias);\n+        }\n+\n+        if (!props.isEmpty())\n+        {\n+\n+            if (log.isErrorEnabled())\n+                log.error(\"these properties are not recognized:\" + props);\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    public void init() throws Exception {\n+        readSecretKeyFromKeystore();\n+        super.init();\n+    }\n+\n+    /**\n+     * Initialisation if a supplied key is defined in the properties. This supplied key must be in a keystore which\n+     * can be generated using the keystoreGenerator file in demos. The keystore must be on the classpath to find it.\n+     */\n+    protected void readSecretKeyFromKeystore() throws Exception {\n+        InputStream inputStream=null;\n+        // must not use default keystore type - as it does not support secret keys\n+        KeyStore store=KeyStore.getInstance(\"JCEKS\");\n+\n+        SecretKey tempKey=null;\n+        try {\n+            if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test\n+                // load in keystore using this thread's classloader\n+                inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(keystore_name);\n+                if(inputStream == null)\n+                    inputStream=new FileInputStream(keystore_name);\n+                // we can't find a keystore here -\n+                if(inputStream == null)\n+                    throw new Exception(\"Unable to load keystore \" + keystore_name + \" ensure file is on classpath\");\n+                // we have located a file lets load the keystore\n+                try {\n+                    store.load(inputStream, store_password.toCharArray());\n+                    // loaded keystore - get the key\n+                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());\n+                }\n+                catch(IOException e) {\n+                    throw new Exception(\"Unable to load keystore \" + keystore_name + \": \" + e);\n+                }\n+                catch(NoSuchAlgorithmException e) {\n+                    throw new Exception(\"No Such algorithm \" + keystore_name + \": \" + e);\n+                }\n+                catch(CertificateException e) {\n+                    throw new Exception(\"Certificate exception \" + keystore_name + \": \" + e);\n+                }\n+\n+                if(tempKey == null)\n+                    throw new Exception(\"Unable to retrieve key '\" + alias + \"' from keystore \" + keystore_name);\n+                this.secret_key=tempKey;\n+                if(sym_algorithm.equals(DEFAULT_SYM_ALGO))\n+                    sym_algorithm=tempKey.getAlgorithm();\n+            }\n+        }\n+        finally {\n+            Util.close(inputStream);\n+        }\n+    }\n+\n+\n+}"
        },
        {
            "sha": "32a9001e6c885c634b209f97070cd19f843f8066",
            "filename": "src/org/jgroups/protocols/UNICAST.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FUNICAST.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2FUNICAST.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FUNICAST.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -295,7 +295,7 @@ public Object up(Event evt) {\n                 msg=(Message)evt.getArg();\n                 dst=msg.getDest();\n \n-                if(dst == null || dst.isMulticastAddress())  // only handle unicast messages\n+                if(dst == null || dst.isMulticastAddress() || msg.isFlagSet(Message.NO_RELIABILITY))  // only handle unicast messages\n                     break;  // pass up\n \n                 // changed from removeHeader(): we cannot remove the header because if we do loopback=true at the\n@@ -338,7 +338,7 @@ public Object down(Event evt) {\n                 Address dst=msg.getDest();\n \n                 /* only handle unicast messages */\n-                if (dst == null || dst.isMulticastAddress()) {\n+                if (dst == null || dst.isMulticastAddress() || msg.isFlagSet(Message.NO_RELIABILITY)) {\n                     break;\n                 }\n "
        },
        {
            "sha": "c716cbb3fadb1a3a6e2b1b90700de391238cc580",
            "filename": "src/org/jgroups/protocols/pbcast/ClientGmsImpl.java",
            "status": "modified",
            "additions": 8,
            "deletions": 0,
            "changes": 8,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FClientGmsImpl.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FClientGmsImpl.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FClientGmsImpl.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -67,6 +67,7 @@ private void join(Address mbr, boolean joinWithStateTransfer) {\n         Address coord=null;\n         JoinRsp rsp=null;\n         View tmp_view;\n+        long join_attempts=0;\n         leaving=false;\n \n         join_promise.reset();\n@@ -134,8 +135,15 @@ private void join(Address mbr, boolean joinWithStateTransfer) {\n                 if(rsp == null)\n                     rsp=join_promise.getResult(gms.join_timeout);\n                 if(rsp == null) {\n+                    join_attempts++;\n                     if(log.isWarnEnabled())\n                         log.warn(\"join(\" + mbr + \") sent to \" + coord + \" timed out (after \" + gms.join_timeout + \" ms), retrying\");\n+                    if(gms.max_join_attempts != 0 && join_attempts >= gms.max_join_attempts) {\n+                        if(log.isWarnEnabled())\n+                            log.warn(\"Too many JOIN attempts: becoming singleton\");\n+                        becomeSingletonMember(mbr);\n+                        return;\n+                    }\n                 }\n                 else {\n                     // 1. check whether JOIN was rejected"
        },
        {
            "sha": "542e8466344ea14ac0b60ae50041576c1089b3a1",
            "filename": "src/org/jgroups/protocols/pbcast/GMS.java",
            "status": "modified",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FGMS.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FGMS.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FGMS.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -41,6 +41,8 @@ public class GMS extends Protocol {\n     long                      join_timeout=5000;\n     long                      leave_timeout=5000;\n     long                      merge_timeout=5000;           // time to wait for all MERGE_RSPS\n+    /** Number of join attempts before we give up and become a singleton. Zero means 'never give up */\n+    long                      max_join_attempts=0;\n     private final Object      impl_mutex=new Object();       // synchronizes event entry into impl\n     private final Hashtable<String,GmsImpl>   impls=new Hashtable<String,GmsImpl>(3);\n     private boolean           shun=false;\n@@ -122,6 +124,8 @@ public String getName() {\n     public long getJoinRetryTimeout() {return -1;}\n     /** @deprecated */\n     public void setJoinRetryTimeout(long t) {}\n+    public long getMaxJoinAttempts() {return max_join_attempts;}\n+    public void setMaxJoinAttempts(long t) {max_join_attempts=t;}\n     public boolean isShun() {return shun;}\n     public void setShun(boolean s) {shun=s;}\n \n@@ -969,6 +973,12 @@ public boolean setProperties(Properties props) {\n             props.remove(\"resume_task_timeout\");\n         }\n \n+        str=props.getProperty(\"max_join_attempts\");\n+        if(str != null) {\n+            max_join_attempts=Long.parseLong(str);\n+            props.remove(\"max_join_attempts\");\n+        }\n+\n         str=props.getProperty(\"disable_initial_coord\");\n         if(str != null) {\n             disable_initial_coord=Boolean.valueOf(str).booleanValue();\n@@ -1122,6 +1132,10 @@ public Address getMember() {\n             return mbr;\n         }\n \n+        public void setMergeRejected(boolean merge_rejected) {\n+            this.merge_rejected=merge_rejected;\n+        }\n+\n         public String toString() {\n             StringBuilder sb=new StringBuilder(\"GmsHeader\");\n             sb.append('[' + type2String(type) + ']');"
        },
        {
            "sha": "0f2a819a9e2df52c6b099657edf1d324b146e7cb",
            "filename": "src/org/jgroups/protocols/pbcast/NAKACK.java",
            "status": "modified",
            "additions": 4,
            "deletions": 2,
            "changes": 6,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FNAKACK.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FNAKACK.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2Fpbcast%2FNAKACK.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -102,7 +102,7 @@ public class NAKACK extends Protocol implements Retransmitter.RetransmitCommand,\n     private boolean leaving=false;\n     private boolean started=false;\n     private TimeScheduler timer=null;\n-    private static final String name=\"NAKACK\";\n+    public static final String name=\"NAKACK\";\n \n     private long xmit_reqs_received;\n     private long xmit_reqs_sent;\n@@ -598,7 +598,7 @@ public Object down(Event evt) {\n             case Event.MSG:\n                 Message msg=(Message)evt.getArg();\n                 Address dest=msg.getDest();\n-                if(dest != null && !dest.isMulticastAddress()) {\n+                if((dest != null && !dest.isMulticastAddress()) || msg.isFlagSet(Message.NO_RELIABILITY)) {\n                     break; // unicast address: not null and not mcast, pass down unchanged\n                 }\n                 send(evt, msg);\n@@ -687,6 +687,8 @@ public Object up(Event evt) {\n \n         case Event.MSG:\n             Message msg=(Message)evt.getArg();\n+            if(msg.isFlagSet(Message.NO_RELIABILITY))\n+                break;\n             NakAckHeader hdr=(NakAckHeader)msg.getHeader(name);\n             if(hdr == null)\n                 break;  // pass up (e.g. unicast msg)"
        },
        {
            "sha": "4b9856334782ab5b8a05e62da3370e8b3c03711c",
            "filename": "src/org/jgroups/util/AsciiString.java",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FAsciiString.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FAsciiString.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FAsciiString.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,84 @@\n+package org.jgroups.util;\n+\n+/**\n+ * Simple string implemented as a byte[] array. Each character's higher 8 bits are truncated and\n+ * only the lower 8 bits are stored. AsciiString is mutable for efficiency reasons, but the chars array should never\n+ * be changed !\n+ * @author Bela Ban\n+ * @since  3.5\n+ */\n+public class AsciiString implements Comparable<AsciiString> {\n+    protected final byte[] val;\n+\n+    public AsciiString() {\n+        val=new byte[]{};\n+    }\n+\n+    public AsciiString(String str) {\n+        int length=str != null? str.length() : 0;\n+        this.val=new byte[length];\n+        for(int i=0; i < length; i++)\n+            val[i]=(byte)str.charAt(i);\n+    }\n+\n+    public AsciiString(AsciiString str) {\n+        this.val=str.val;\n+    }\n+\n+    public AsciiString(byte[] val) {\n+        this.val=val; // mutable, used only for creation\n+    }\n+\n+    public AsciiString(int length) {\n+        this.val=new byte[length];\n+    }\n+\n+    public byte[] chars() {return val;} // mutable\n+\n+    public int length() {\n+        return val.length;\n+    }\n+\n+    public int compareTo(AsciiString str) {\n+        if(str == null) return 1;\n+        if(chars().hashCode() == str.val.hashCode())\n+            return 0;\n+\n+        int len1=val.length;\n+        int len2=str.val.length;\n+        int lim=Math.min(len1, len2);\n+        byte[] v1=val;\n+        byte[] v2=str.val;\n+\n+        int k = 0;\n+        while (k < lim) {\n+            byte c1 =v1[k];\n+            byte c2 =v2[k];\n+            if (c1 != c2)\n+                return c1 > c2? 1 : -1;\n+            k++;\n+        }\n+        return len1 > len2? 1 : len1 < len2? -1 : 0;\n+    }\n+\n+\n+\n+    public boolean equals(Object obj) {\n+        return obj instanceof AsciiString && compareTo((AsciiString)obj) == 0;\n+    }\n+\n+    public int hashCode() {\n+        int h=0;\n+        for(int i=0; i < val.length; i++)\n+            h=31 * h + val[i];\n+        return h;\n+    }\n+\n+    public String toString() {\n+        return new String(val);\n+    }\n+\n+\n+\n+\n+}"
        },
        {
            "sha": "39e34c8aa0c39d7c654d914283dec8fb8831334f",
            "filename": "src/org/jgroups/util/Bits.java",
            "status": "added",
            "additions": 773,
            "deletions": 0,
            "changes": 773,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FBits.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FBits.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FBits.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,773 @@\n+package org.jgroups.util;\n+\n+import org.jgroups.Global;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+import java.io.IOException;\n+import java.nio.ByteBuffer;\n+\n+/**\n+ * Class (similar to (and partly copied from) java.nio.Bits) containing helper methods to encode variables\n+ * (e.g. ints, long, List&lt;Address&gt; etc) to memory (byte buffer) or output streams and read variables\n+ * from memory or input streams.<p/>\n+ * The write methods write a type (e.g. an int or a char) to a buffer ({@link ByteBuffer} or output stream, using\n+ * <a href=\"https://developers.google.com/protocol-buffers/docs/encoding\">variable-length encoding</a>. If\n+ * there are not enough byte in the buffer to write a type, a {@link java.nio.BufferOverflowException} is thrown.\n+ * If the variable cannot be written to the output stream, an IOException is thrown.\n+ * <p/>\n+ * The read methods read a variable-length encoded type from a buffer or input stream. If there are fewer bytes in\n+ * the buffer than needed to read the type, a {@link java.nio.BufferUnderflowException} is thrown. If the read fails,\n+ * an IOException is thrown.\n+ * <p/>\n+ * The size() methods return the number of bytes used to encode the given type with variable-length encoding.\n+ * <p/>\n+ * There are additional helper methods to write/read custom JGroups types, e.g. address lists, Views etc\n+ * <p/>\n+ * Note that methods to read/write atomic types (char, int etc) should only be used if variable-length encoding is\n+ * desired; otherwise {@link DataOutput#writeInt(int)} or {@link ByteBuffer#putInt(int)} should be used instead.\n+ * <p/>\n+ * At the time of writing this (Feb 2014), most methods have not yet been implemented.\n+ * @author Bela Ban\n+ * @author Sanne Grinovero\n+ * @since  3.5\n+ */\n+public final class Bits {\n+\n+\tprivate Bits() {\n+\t\tthrow new InstantiationError( \"Must not instantiate this class\" );\n+\t}\n+\n+    // -------------------- char ------------------------ //\n+\n+    // No compression of chars as they only use 2 bytes\n+    public static char makeChar(byte[] buf, int offset) {\n+        return (char) ((buf[offset + 1] & 0xFF) + (buf[offset] << 8));\n+    }\n+\n+    public static void writeChar(char c, byte[] buf, int offset) {\n+        buf[offset+1]=(byte)c;\n+        buf[offset]=(byte)(c >>> 8);\n+    }\n+\n+    public static char readChar(byte[] buf, int offset) {\n+        return makeChar(buf, offset);\n+    }\n+\n+    // -------------------- short ----------------------- //\n+\n+    // No implementations as encoding a char doesn't use much space\n+\n+    public static short makeShort(byte a, byte b) {\n+        return (short)((a << 8) | (b & 0xff));\n+    }\n+\n+    public static short makeShort(byte a) {\n+        return (short) (a & 0xff);\n+    }\n+\n+    public static void writeShort(short s, byte[] buf, int offset) {\n+        buf[offset+1]=(byte)s;\n+        buf[offset]=(byte)(s >>> 8);\n+    }\n+\n+    public static short readShort(byte[] buf, int offset) {\n+        return (short)((buf[offset+1] & 0xFF) + (buf[offset] << 8));\n+    }\n+\n+    // --------------------- int ------------------------ //\n+\n+\n+    /**\n+     * Writes an int to a ByteBuffer\n+     * @param num the int to be written\n+     * @param buf the buffer\n+     */\n+    public static void writeInt(int num, ByteBuffer buf) {\n+        if(num == 0) {\n+            buf.put((byte)0);\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        buf.put(bytes_needed);\n+        for(int i=0; i < bytes_needed; i++)\n+            buf.put(getByteAt(num, i));\n+    }\n+\n+    /**\n+     * Writes an int to an output stream\n+     * @param num the int to be written\n+     * @param out the output stream\n+     */\n+    public static void writeInt(int num, DataOutput out) throws IOException {\n+        if(num == 0) {\n+            out.write(0);\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        out.write(bytes_needed);\n+        for(int i=0; i < bytes_needed; i++)\n+            out.write(getByteAt(num, i));\n+    }\n+\n+    public static void writeInt(int num, byte[] buf, int offset) {\n+        buf[offset+3]=(byte)num;\n+        buf[offset+2]=(byte)(num >>>  8);\n+        buf[offset+1]=(byte)(num >>> 16);\n+        buf[offset]=(byte)(num >>> 24);\n+    }\n+\n+    public static void writeIntCompressed(int num, byte[] buf, int offset) {\n+        if(num == 0) {\n+            buf[offset]=0;\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        buf[offset++]=bytes_needed;\n+        for(int i=0; i < bytes_needed; i++)\n+            buf[offset++]=getByteAt(num, i);\n+    }\n+\n+\n+    /**\n+     * Reads an int from a buffer.\n+     * @param buf the buffer\n+     * @return the int read from the buffer\n+     */\n+    public static int readInt(ByteBuffer buf) {\n+        byte len=buf.get();\n+        if(len == 0)\n+            return 0;\n+        byte[] retval=new byte[len];\n+        buf.get(retval, 0, len);\n+        return makeInt(retval, 0, len);\n+    }\n+\n+    /**\n+     * Reads an int from an input stream\n+     * @param in the input stream\n+     * @return the int read from the input stream\n+     */\n+    public static int readInt(DataInput in) throws IOException {\n+        byte len=in.readByte();\n+        if(len == 0)\n+            return 0;\n+        byte[] buf=new byte[len];\n+        in.readFully(buf, 0, len);\n+        return makeInt(buf, 0, len);\n+    }\n+\n+    public static int readInt(byte[] buf, int offset) {\n+        return ((buf[offset+3] & 0xFF)) +\n+          ((buf[offset+2] & 0xFF) <<  8) +\n+          ((buf[offset+1] & 0xFF) << 16) +\n+          ((buf[offset]) << 24);\n+    }\n+\n+    public static int readIntCompressed(byte[] buf, int offset) {\n+        byte len=buf[offset++];\n+        if(len == 0)\n+            return 0;\n+        byte[] buffer=new byte[len];\n+        for(int i=0; i < len; i++)\n+            buffer[i]=buf[offset++];\n+        return makeInt(buffer, 0, len);\n+    }\n+\n+\n+    /**\n+     * Computes the size of a variable-length encoded int\n+     * @param num the int\n+     * @return the number of bytes needed to variable-length encode num\n+     */\n+    public static int size(int num) {\n+        return (byte)(num == 0? 1 : bytesRequiredFor(num) +1);\n+    }\n+\n+\n+\n+\n+    // -------------------- long ------------------------ //\n+\n+    /**\n+     * Writes a long to a ByteBuffer\n+     * @param num the long to be written\n+     * @param buf the buffer\n+     */\n+    public static void writeLong(long num, ByteBuffer buf) {\n+        if(num == 0) {\n+            buf.put((byte)0);\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        buf.put(bytes_needed);\n+        for(int i=0; i < bytes_needed; i++)\n+            buf.put(getByteAt(num, i));\n+    }\n+\n+    /**\n+     * Writes a long to out in variable-length encoding. Note that currently variable-length encoding is <em>not</em>\n+     * used (a similar mechanism is used); this will be implemented later.\n+     * @param num the long\n+     * @param out the output stream to write num to\n+     * @throws IOException\n+     */\n+    public static void writeLong(final long num, final DataOutput out) throws IOException {\n+        if(num == 0) {\n+            out.write(0);\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        out.write(bytes_needed);\n+        for(int i=0; i < bytes_needed; i++)\n+            out.write(getByteAt(num, i));\n+    }\n+\n+    public static void writeLong(long num, byte[] buf, int offset) {\n+        buf[offset+7]=(byte)num;\n+        buf[offset+6]=(byte)(num >>>  8);\n+        buf[offset+5]=(byte)(num >>> 16);\n+        buf[offset+4]=(byte)(num >>> 24);\n+        buf[offset+3]=(byte)(num >>> 32);\n+        buf[offset+2]=(byte)(num >>> 40);\n+        buf[offset+1]=(byte)(num >>> 48);\n+        buf[offset]=(byte)(num >>> 56);\n+    }\n+\n+    public static void writeLongCompressed(long num, byte[] buf, int offset) {\n+        if(num == 0) {\n+            buf[offset]=0;\n+            return;\n+        }\n+        final byte bytes_needed=bytesRequiredFor(num);\n+        buf[offset++]=bytes_needed;\n+        for(int i=0; i < bytes_needed; i++)\n+            buf[offset++]=getByteAt(num, i);\n+    }\n+\n+\n+\n+    /**\n+     * Reads a long from a buffer.\n+     * @param buf the buffer\n+     * @return the long read from the buffer\n+     */\n+    public static long readLong(ByteBuffer buf) {\n+        byte len=buf.get();\n+        if(len == 0)\n+            return 0;\n+        byte[] retval=new byte[len];\n+        buf.get(retval, 0, len);\n+        return makeLong(retval, 0, len);\n+    }\n+\n+    /**\n+     * Reads a variable-length encoded long from an input stream.  Note that currently variable-length encoding is <em>not</em>\n+     * used (a similar mechanism is used); this will be implemented later.\n+     * @param in the input stream\n+     * @return the long read from the input stream\n+     * @throws IOException\n+     */\n+    public static long readLong(DataInput in) throws IOException {\n+        byte len=in.readByte();\n+        if(len == 0)\n+            return 0;\n+        byte[] buf=new byte[len];\n+        in.readFully(buf, 0, len);\n+        return makeLong(buf, 0, len);\n+    }\n+\n+    public static long readLong(byte[] buf, int offset) {\n+        return ((buf[offset+7] & 0xFFL)) +\n+          ((buf[offset+6] & 0xFFL) <<  8) +\n+          ((buf[offset+5] & 0xFFL) << 16) +\n+          ((buf[offset+4] & 0xFFL) << 24) +\n+          ((buf[offset+3] & 0xFFL) << 32) +\n+          ((buf[offset+2] & 0xFFL) << 40) +\n+          ((buf[offset+1] & 0xFFL) << 48) +\n+          (((long) buf[offset])    << 56);\n+    }\n+\n+    public static long readLongCompressed(byte[] buf, int offset) {\n+        byte len=buf[offset++];\n+        if(len == 0)\n+            return 0;\n+        byte[] buffer=new byte[len];\n+        for(int i=0; i < len; i++)\n+            buffer[i]=buf[offset++];\n+        return makeLong(buffer, 0, len);\n+    }\n+\n+    /**\n+     * Computes the size of a variable-length encoded long.  Note that this is <em>not</em> currently using\n+     * variable-length encoding (will be implemented later).\n+     * @param num the long\n+     * @return the number of bytes needed to variable-length encode num\n+     */\n+    public static int size(long num) {\n+        return (byte)(num == 0? 1 : bytesRequiredFor(num) +1);\n+    }\n+\n+\n+\n+\n+\n+    // ------------------ long seq ---------------------- //\n+\n+    /**\n+     * Writes 2 sequence numbers (seqnos) in compressed format to buf.\n+     * The seqnos are non-negative and hr is guaranteed to be &gt;= hd.\n+     * <p/>\n+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply\n+     * write the 2 longs individually.\n+     * @param hd the highest delivered seqno. Guaranteed to be a positive number\n+     * @param hr the highest received seqno. Guaranteed to be a positive number. Greater than or equal to hd\n+     * @param buf the buffer to write to\n+     */\n+    public static void writeLongSequence(long hd, long hr, ByteBuffer buf) {\n+        if(hr < hd)\n+            throw new IllegalArgumentException(\"hr (\" + hr + \") has to be >= hd (\" + hd + \")\");\n+\n+        if(hd == 0 && hr == 0) {\n+            buf.put((byte)0);\n+            return;\n+        }\n+\n+        long delta=hr - hd;\n+\n+        // encode highest_delivered followed by delta\n+        byte bytes_for_hd=bytesRequiredFor(hd), bytes_for_delta=bytesRequiredFor(delta);\n+        byte bytes_needed=encodeLength(bytes_for_hd, bytes_for_delta);\n+        buf.put(bytes_needed);\n+\n+        for(int i=0; i < bytes_for_hd; i++)\n+            buf.put(getByteAt(hd, i));\n+\n+        for(int i=0; i < bytes_for_delta; i++)\n+            buf.put(getByteAt(delta, i));\n+    }\n+\n+    /**\n+     * Writes 2 sequence numbers (seqnos) in compressed format to an output stream.\n+     * The seqnos are non-negative and hr is guaranteed to be &gt;= hd.\n+     * <p/>\n+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply\n+     * write the 2 longs individually.\n+     * @param hd the highest delivered seqno. Guaranteed to be a positive number\n+     * @param hr the highest received seqno. Guaranteed to be a positive number. Greater than or equal to hd\n+     * @param out the output stream to write to\n+     */\n+    public static void writeLongSequence(long hd, long hr, DataOutput out) throws IOException {\n+        if(hr < hd)\n+            throw new IllegalArgumentException(\"hr (\" + hr + \") has to be >= hd (\" + hd + \")\");\n+\n+        if(hd == 0 && hr == 0) {\n+            out.write(0);\n+            return;\n+        }\n+\n+        long delta=hr - hd;\n+\n+        // encode highest_delivered followed by delta\n+        byte bytes_for_hd=bytesRequiredFor(hd), bytes_for_delta=bytesRequiredFor(delta);\n+        byte bytes_needed=encodeLength(bytes_for_hd, bytes_for_delta);\n+        out.write(bytes_needed);\n+\n+        for(int i=0; i < bytes_for_hd; i++)\n+            out.write(getByteAt(hd, i));\n+\n+        for(int i=0; i < bytes_for_delta; i++)\n+            out.write(getByteAt(delta, i));\n+    }\n+\n+    /**\n+     * Reads 2 compressed longs from buf.\n+     * <p/>\n+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply\n+     * read the 2 longs individually.\n+     * @param buf the buffer to read from\n+     * @return an array of 2 longs (hd and hr)\n+     */\n+    public static long[] readLongSequence(ByteBuffer buf) {\n+        byte len=buf.get();\n+        if(len == 0)\n+            return new long[]{0,0};\n+\n+        byte[] lengths=decodeLength(len);\n+        long[] seqnos=new long[2];\n+        byte[] retval=new byte[lengths[0] + lengths[1]];\n+        buf.get(retval, 0, retval.length);\n+        seqnos[0]=makeLong(retval, 0, lengths[0]);\n+        seqnos[1]=makeLong(retval, lengths[0], lengths[1]) + seqnos[0];\n+        return seqnos;\n+    }\n+\n+    /**\n+     * Reads 2 compressed longs from in.\n+     * Reads 2 compressed longs from buf.\n+     * <p/>\n+     * Once variable-length encoding has been implemented, this method will probably get dropped as we can simply\n+     * read the 2 longs individually.\n+     * @param in the input stream to read from\n+     * @return an array of 2 longs (hd and hr)\n+     */\n+    public static long[] readLongSequence(DataInput in) throws IOException {\n+        byte len=in.readByte();\n+        if(len == 0)\n+            return new long[]{0,0};\n+\n+        byte[] lengths=decodeLength(len);\n+        long[] seqnos=new long[2];\n+        byte[] buf=new byte[lengths[0] + lengths[1]];\n+        in.readFully(buf, 0, buf.length);\n+        seqnos[0]=makeLong(buf, 0, lengths[0]);\n+        seqnos[1]=makeLong(buf, lengths[0], lengths[1]) + seqnos[0];\n+        return seqnos;\n+    }\n+\n+\n+\n+    public static byte size(long hd, long hr) {\n+        if(hd == 0 && hr == 0)\n+            return 1;\n+\n+        byte num_bytes_for_hd=bytesRequiredFor(hd), num_bytes_for_delta=bytesRequiredFor(hr - hd);\n+        return (byte)(num_bytes_for_hd + num_bytes_for_delta + 1);\n+    }\n+\n+    public static long makeLong(byte[] buf, int offset, int bytes_to_read) {\n+        long retval=0;\n+        for(int i=0; i < bytes_to_read; i++) {\n+            byte b=buf[offset + i];\n+            retval |= ((long)b & 0xff) << (i * 8);\n+        }\n+        return retval;\n+    }\n+\n+    public static int makeInt(byte[] buf, int offset, int bytes_to_read) {\n+        int retval=0;\n+        for(int i=0; i < bytes_to_read; i++) {\n+            byte b=buf[offset + i];\n+            retval |= ((int)b & 0xff) << (i * 8);\n+        }\n+        return retval;\n+    }\n+\n+\n+\n+    // -------------------- float ----------------------- //\n+\n+    /**\n+     * Writes a float to a ByteBuffer\n+     * @param num the float to be written\n+     * @param buf the buffer\n+     */\n+    public static void writeFloat(float num, ByteBuffer buf) {\n+        writeInt(Float.floatToIntBits(num), buf);\n+    }\n+\n+    /**\n+     * Writes a float to an output stream\n+     * @param num the float to be written\n+     * @param out the output stream\n+     */\n+    public static void writeFloat(float num, DataOutput out) throws IOException {\n+        writeInt(Float.floatToIntBits(num), out);\n+    }\n+\n+    public static void writeFloat(float num, byte[] buf, int offset) {\n+        writeInt(Float.floatToIntBits(num), buf, offset);\n+    }\n+\n+    /**\n+     * Reads a a float from a buffer.\n+     * @param buf the buffer\n+     * @return the float read from the buffer\n+     */\n+    public static float readFloat(ByteBuffer buf) {\n+        return Float.intBitsToFloat(readInt(buf));\n+    }\n+\n+    /**\n+     * Reads a a float from an input stream.\n+     * @param in the input stream\n+     * @return the float read from the input stream\n+     */\n+    public static float readFloat(DataInput in) throws IOException {\n+        return Float.intBitsToFloat(readInt(in));\n+    }\n+\n+    public static float readFloat(byte[] buf, int offset) {\n+        return Float.intBitsToFloat(readInt(buf, offset));\n+    }\n+\n+\n+    /**\n+     * Computes the size of a variable-length encoded float\n+     * @param num the float\n+     * @return the number of bytes needed to variable-length encode num\n+     */\n+    public static int size(float num) {\n+        return size(Float.floatToIntBits(num));\n+    }\n+\n+\n+\n+    // -------------------- double ---------------------- //\n+\n+    /**\n+     * Writes a double to a ByteBuffer\n+     * @param num the double to be written\n+     * @param buf the buffer\n+     */\n+    public static void writeDouble(double num, ByteBuffer buf) {\n+        writeLong(Double.doubleToLongBits(num), buf);\n+    }\n+\n+    /**\n+     * Writes a double to an output stream\n+     * @param num the double to be written\n+     * @param out the output stream\n+     */\n+    public static void writeDouble(double num, DataOutput out) throws IOException {\n+        writeLong(Double.doubleToLongBits(num), out);\n+    }\n+\n+    public static void writeDouble(double num, byte[] buf, int offset) {\n+        writeLong(Double.doubleToLongBits(num), buf, offset);\n+    }\n+\n+\n+    /**\n+     * Reads a double from a buffer.\n+     * @param buf the buffer\n+     * @return the double read from the buffer\n+     */\n+    public static double readDouble(ByteBuffer buf) {\n+        return Double.longBitsToDouble(readLong(buf));\n+    }\n+\n+    /**\n+     * Reads a double from an input stream\n+     * @param in the input stream\n+     * @return the double read from the input stream\n+     */\n+    public static double readDouble(DataInput in) throws IOException {\n+        return Double.longBitsToDouble(readLong(in));\n+    }\n+\n+    public static double readDouble(byte[] buf, int offset) {\n+        return Double.longBitsToDouble(readLong(buf, offset));\n+    }\n+\n+    /**\n+     * Computes the size of a variable-length encoded double\n+     * @param num the double\n+     * @return the number of bytes needed to variable-length encode num\n+     */\n+    public static int size(double num) {\n+        return size(Double.doubleToLongBits(num));\n+    }\n+\n+\n+\n+\n+    // -------------------- String ---------------------- //\n+\n+    /**\n+     * Writes a string to buf. The length of the string is written first, followed by the chars (as single-byte values).\n+     * Multi-byte values are truncated: only the lower byte of each multi-byte char is written, similar to\n+     * {@link DataOutput#writeChars(String)}.\n+     * @param s the string\n+     * @param buf the buffer\n+     */\n+    public static void writeString(String s, ByteBuffer buf) {\n+        buf.put((byte)(s != null? 1 : 0));\n+        if(s != null) {\n+            byte[] bytes=s.getBytes();\n+            writeInt(bytes.length, buf);\n+            buf.put(bytes);\n+        }\n+    }\n+\n+    /**\n+     * Writes a string to buf. The length of the string is written first, followed by the chars (as single-byte values).\n+     * Multi-byte values are truncated: only the lower byte of each multi-byte char is written, similar to\n+     * {@link DataOutput#writeChars(String)}.\n+     * @param s the string\n+     * @param out the output stream\n+     */\n+    public static void writeString(String s, DataOutput out) throws IOException {\n+        if(s != null) {\n+            out.write(1);\n+            out.writeUTF(s);\n+        }\n+        else\n+            out.write(0);\n+    }\n+\n+    /**\n+     * Reads a string from buf. The length is read first, followed by the chars. Each char is a single byte\n+     * @param buf the buffer\n+     * @return the string read from buf\n+     */\n+    public static String readString(ByteBuffer buf) {\n+        if(buf.get() == 0)\n+            return null;\n+        int len=readInt(buf);\n+        byte[] bytes=new byte[len];\n+        buf.get(bytes);\n+        return new String(bytes);\n+    }\n+\n+    /**\n+     * Reads a string from buf. The length is read first, followed by the chars. Each char is a single byte\n+     * @param in the input stream\n+     * @return the string read from buf\n+     */\n+    public static String readString(DataInput in) throws IOException {\n+        int b=in.readByte();\n+        if(b == 1)\n+            return in.readUTF();\n+        return null;\n+    }\n+\n+\n+    /**\n+     * Measures the number of bytes required to encode a string, taking multibyte characters into account. Measures\n+     * strings written by {@link DataOutput#writeUTF(String)}.\n+     * @param str the string\n+     * @return the number of bytes required for encoding str\n+     */\n+    public static int sizeUTF(String str) {\n+        int len=str != null? str.length() : 0, utflen=2;\n+        if(len == 0)\n+            return utflen;\n+        for(int i = 0; i < len; i++) {\n+           int  c=str.charAt(i);\n+            if((c >= 0x0001) && (c <= 0x007F))\n+                utflen++;\n+            else if (c > 0x07FF)\n+                utflen += 3;\n+            else\n+                utflen += 2;\n+        }\n+        return utflen;\n+    }\n+\n+    public static int size(String str) {\n+        if(str == null)\n+            return Global.BYTE_SIZE;\n+        byte[] bytes=str.getBytes();\n+        return Global.BYTE_SIZE + size(bytes.length) + bytes.length;\n+    }\n+\n+\n+\n+    // ------------------ AsciiString ------------------- //\n+    /**\n+     * Writes an AsciiString to buf. The length of the string is written first, followed by the chars (as single-byte values).\n+     * @param s the string\n+     * @param buf the buffer\n+     */\n+    public static void writeAsciiString(AsciiString s, ByteBuffer buf) {\n+        short length=(short)(s != null? s.length() : -1);\n+        buf.putShort(length);\n+        if(s != null)\n+            buf.put(s.chars());\n+    }\n+\n+    /**\n+     * Writes an AsciiString to buf. The length of the string is written first, followed by the chars (as single-byte values).\n+     * @param s the string\n+     * @param out the output stream\n+     */\n+    public static void writeAsciiString(AsciiString s, DataOutput out) throws IOException {\n+        short length=(short)(s != null? s.length() : -1);\n+        out.writeShort(length);\n+        if(s != null)\n+            out.write(s.chars());\n+    }\n+\n+    /**\n+     * Reads an AsciiString from buf. The length is read first, followed by the chars. Each char is a single byte\n+     * @param buf the buffer\n+     * @return the string read from buf\n+     */\n+    public static AsciiString readAsciiString(ByteBuffer buf) {\n+        short len=buf.getShort();\n+        if(len < 0)\n+            return null;\n+        AsciiString retval=new AsciiString(len);\n+        buf.get(retval.chars());\n+        return retval;\n+    }\n+\n+    /**\n+     * Reads an AsciiString from buf. The length is read first, followed by the chars. Each char is a single byte\n+     * @param in the input stream\n+     * @return the string read from buf\n+     */\n+    public static AsciiString readAsciiString(DataInput in) throws IOException {\n+        short len=in.readShort();\n+        if(len < 0)\n+            return null;\n+        AsciiString retval=new AsciiString(len);\n+        in.readFully(retval.chars());\n+        return retval;\n+    }\n+\n+\n+    /**\n+     * Measures the number of bytes required to encode an AsciiSring.\n+     * @param str the string\n+     * @return the number of bytes required for encoding str\n+     */\n+    public static int size(AsciiString str) {\n+        return str == null? Global.SHORT_SIZE : Global.SHORT_SIZE + str.length();\n+    }\n+\n+\n+\n+    /**\n+     * Encodes the number of bytes needed into a single byte. The first number is encoded in the first nibble (the\n+     * first 4 bits), the second number in the second nibble\n+     * @param len1 The number of bytes needed to store a long. Must be between 0 and 8\n+     * @param len2 The number of bytes needed to store a long. Must be between 0 and 8\n+     * @return The byte storing the 2 numbers len1 and len2\n+     */\n+    protected static byte encodeLength(byte len1, byte len2) {\n+        byte retval=len2;\n+        retval |= (len1 << 4);\n+        return retval;\n+    }\n+\n+    protected static byte[] decodeLength(byte len) {\n+        return new byte[]{(byte)((len & 0xff) >> 4),(byte)(len & ~0xf0)}; // 0xf0 is the first nibble set (11110000)\n+    }\n+\n+    protected static byte bytesRequiredFor(long number) {\n+        if(number >> 56 != 0) return 8;\n+        if(number >> 48 != 0) return 7;\n+        if(number >> 40 != 0) return 6;\n+        if(number >> 32 != 0) return 5;\n+        if(number >> 24 != 0) return 4;\n+        if(number >> 16 != 0) return 3;\n+        if(number >>  8 != 0) return 2;\n+        return 1;\n+    }\n+\n+    protected static byte bytesRequiredFor(int number) {\n+        if(number >> 24 != 0) return 4;\n+        if(number >> 16 != 0) return 3;\n+        if(number >>  8 != 0) return 2;\n+        return 1;\n+    }\n+\n+\n+    static protected byte getByteAt(long num, int index) {\n+        return (byte)((num >> (index * 8)));\n+    }\n+\n+\n+}"
        },
        {
            "sha": "27622a88e5902516adcbefe2f72da56edfdafbb6",
            "filename": "src/org/jgroups/util/MyReceiver.java",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,35 @@\n+package org.jgroups.util;\n+\n+import org.jgroups.Message;\n+import org.jgroups.ReceiverAdapter;\n+\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+\n+/**\n+ * Generic receiver for a JChannel\n+ * @author Bela Ban\n+ * @since  3.3\n+ */\n+public class MyReceiver<T> extends ReceiverAdapter {\n+    protected final List<T> list=new CopyOnWriteArrayList<T>();\n+    protected String        name;\n+    protected boolean       verbose;\n+    protected boolean       raw_msgs;\n+\n+    public void receive(Message msg) {\n+        T obj=raw_msgs? (T)msg : (T)msg.getObject();\n+        list.add(obj);\n+        if(verbose) {\n+            System.out.println((name() != null? name() + \":\" : \"\") + \" received message from \" + msg.getSrc() + \": \" + obj);\n+        }\n+    }\n+\n+    public MyReceiver    rawMsgs(boolean flag) {this.raw_msgs=flag; return this;}\n+    public List<T>       list()                {return list;}\n+    public MyReceiver<T> verbose(boolean flag) {verbose=flag; return this;}\n+    public String        name()                {return name;}\n+    public MyReceiver<T> name(String name)     {this.name=name; return this;}\n+    public MyReceiver<T> reset()               {list.clear(); return this;}\n+    public int           size()                {return list.size();}\n+}"
        },
        {
            "sha": "23d09bd8c19697cf5e1570c8a12f9b8f47fb0524",
            "filename": "src/org/jgroups/util/Util.java",
            "status": "modified",
            "additions": 58,
            "deletions": 1,
            "changes": 59,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FUtil.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/src%2Forg%2Fjgroups%2Futil%2FUtil.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FUtil.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -446,7 +446,6 @@ public static byte[] streamableToByteBuffer(Streamable obj) throws Exception {\n         return result;\n     }\n \n-\n     public static byte[] collectionToByteBuffer(Collection c) throws Exception {\n         byte[] result=null;\n         final ByteArrayOutputStream out_stream=new ByteArrayOutputStream(512);\n@@ -2643,6 +2642,64 @@ public static String sha(String source) {\n         }\n     }\n \n+    public static String byteArrayToHexString(byte[] b) {\n+        if(b == null)\n+            return \"null\";\n+        StringBuilder sb = new StringBuilder(b.length * 2);\n+        for (int i = 0; i < b.length; i++){\n+            int v = b[i] & 0xff;\n+            if (v < 16) { sb.append('0'); }\n+            sb.append(Integer.toHexString(v));\n+        }\n+        return sb.toString().toUpperCase();\n+    }\n+\n+    public static int getNextHigherPowerOfTwo(int num) {\n+        if(num <= 0) return 1;\n+        int highestBit=Integer.highestOneBit(num);\n+        return num <= highestBit? highestBit : highestBit << 1;\n+    }\n+\n+    public static int size(byte[] buf) {\n+        return buf == null? Global.BYTE_SIZE : Global.BYTE_SIZE + Global.INT_SIZE + buf.length;\n+    }\n+\n+    /**\n+     * Blocks until all channels have the same view\n+     * @param timeout How long to wait (max in ms)\n+     * @param interval Check every interval ms\n+     * @param channels The channels which should form the view. The expected view size is channels.length.\n+     * Must be non-null\n+     */\n+    public static void waitUntilAllChannelsHaveSameSize(long timeout, long interval, Channel... channels) throws TimeoutException {\n+        int size=channels.length;\n+\n+        if(interval >= timeout || timeout <= 0)\n+            throw new IllegalArgumentException(\"interval needs to be smaller than timeout or timeout needs to be > 0\");\n+        long target_time=System.currentTimeMillis() + timeout;\n+        while(System.currentTimeMillis() <= target_time) {\n+            boolean all_channels_have_correct_size=true;\n+            for(Channel ch: channels) {\n+                View view=ch.getView();\n+                if(view == null || view.size() != size) {\n+                    all_channels_have_correct_size=false;\n+                    break;\n+                }\n+            }\n+            if(all_channels_have_correct_size)\n+                return;\n+            Util.sleep(interval);\n+        }\n+        View[] views=new View[channels.length];\n+        StringBuilder sb=new StringBuilder();\n+        for(int i=0; i < channels.length; i++) {\n+            views[i]=channels[i].getView();\n+            sb.append(channels[i].getLocalAddress()).append(\": \").append(views[i]).append(\"\\n\");\n+        }\n+        for(View view: views)\n+            if(view == null || view.size() != size)\n+                throw new TimeoutException(\"Timeout \" + timeout + \" kicked in, views are:\\n\" + sb);\n+    }\n \n }\n "
        },
        {
            "sha": "e8f51b259a407c80dcff0a7951e392b09974690f",
            "filename": "tests/junit-functional/org/jgroups/tests/SizeTest.java",
            "status": "modified",
            "additions": 4,
            "deletions": 0,
            "changes": 4,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -398,6 +398,10 @@ public void testEncryptHeader() throws Exception {\n         _testSize(hdr);\n         hdr=new ENCRYPT.EncryptHeader((short)2, \"Hello world\");\n         _testSize(hdr);\n+        EncryptHeader hdr2=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});\n+        _testSize(hdr2);\n+        hdr2=new EncryptHeader((byte)2, \"Hello world\".getBytes());\n+        _testSize(hdr2);\n     }\n \n     public void testIpAddress() throws Exception {"
        },
        {
            "sha": "69670c378ebef71bd91718e4ff9ed46400179a85",
            "filename": "tests/junit/org/jgroups/protocols/ASYM_ENCRYPT_Test.java",
            "status": "added",
            "additions": 297,
            "deletions": 0,
            "changes": 297,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,297 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.auth.MD5Token;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.protocols.pbcast.JoinRsp;\n+import org.jgroups.protocols.pbcast.NAKACK;\n+import org.jgroups.protocols.pbcast.STABLE;\n+import org.jgroups.stack.ProtocolStack;\n+import org.jgroups.util.Util;\n+\n+import javax.crypto.SecretKey;\n+import java.util.Arrays;\n+import java.util.Vector;\n+import java.util.Properties;\n+\n+/**\n+ * Tests use cases for {@link ASYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+public class ASYM_ENCRYPT_Test extends EncryptTest {\n+    protected String getProtocolName()\n+    {\n+        return \"ASYM_ENCRYPT\";\n+    }\n+\n+    /**\n+     * A non-member sends a {@link EncryptHeader#SECRET_KEY_REQ} request to the key server. Asserts that the rogue member\n+     * doesn't get the secret key. If it did, it would be able to decrypt all messages from cluster members!\n+     */\n+    public void nonMemberGetsSecretKeyFromKeyServer() throws Exception {\n+        Util.close(rogue);\n+\n+        rogue=new JChannel(getTestStack());\n+        DISCARD discard=new DISCARD();\n+        discard.setDiscardAll(true);\n+        rogue.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);\n+        CustomENCRYPT encrypt=new CustomENCRYPT();\n+        encrypt.setProperties(new Properties());\n+        encrypt.init();\n+\n+        rogue.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);\n+        rogue.connect(cluster_name); // creates a singleton cluster\n+\n+        assert rogue.getView().size() == 1;\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        members.add(c.getLocalAddress());\n+        members.add(rogue.getLocalAddress());\n+        View rogue_view=new View(a.getLocalAddress(), a.getView().getVid().getId(), members);\n+        gms.installView(rogue_view);\n+\n+\n+        // now fabricate a KEY_REQUEST message and send it to the key server (A)\n+        Message newMsg=new Message(a.getLocalAddress(), rogue.getLocalAddress(), encrypt.getKeyPair().getPublic().getEncoded());\n+        newMsg.putHeader(encrypt.getName(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, encrypt.getSymVersion()));\n+\n+        discard.setDiscardAll(false);\n+        System.out.printf(\"-- sending KEY_REQUEST to key server %s\\n\", a.getLocalAddress());\n+        encrypt.getDownProtocol().down(new Event(Event.MSG, newMsg));\n+        for(int i=0; i < 10; i++) {\n+            SecretKey secret_key=encrypt.key;\n+            if(secret_key != null)\n+                break;\n+            Util.sleep(500);\n+        }\n+\n+        discard.setDiscardAll(true);\n+        Vector<Address> rogueMember = new Vector<Address>();\n+        rogueMember.add(rogue.getLocalAddress());\n+        gms.installView(new View(rogue.getLocalAddress(), 20, rogueMember));\n+        System.out.printf(\"-- secret key is %s (should be null)\\n\", encrypt.key);\n+        assert encrypt.key == null : String.format(\"should not have received secret key %s\", encrypt.key);\n+    }\n+\n+\n+\n+    /** Verifies that a non-member (non-coord) cannot send a JOIN-RSP to a member */\n+    public void nonMemberInjectingJoinResponse() throws Exception {\n+        Util.close(rogue);\n+        rogue=create();\n+        ProtocolStack stack=rogue.getProtocolStack();\n+        AUTH auth=(AUTH)stack.findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)stack.findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        DISCARD discard=new DISCARD();\n+        discard.setDiscardAll(true);\n+        stack.insertProtocol(discard, ProtocolStack.ABOVE, TP.class);\n+        rogue.connect(cluster_name);\n+        assert rogue.getView().size() == 1;\n+        discard.setDiscardAll(false);\n+        stack.removeProtocol(\"NAKACK\");\n+        stack.removeProtocol(\"UNICAST\");\n+\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        members.add(c.getLocalAddress());\n+        members.add(rogue.getLocalAddress());\n+        View rogue_view=new View(a.getLocalAddress(), a.getView().getVid().getId() +5, members);\n+        JoinRsp join_rsp=new JoinRsp(rogue_view, null);\n+        GMS.GmsHeader gms_hdr=new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP, join_rsp);\n+        Message rogue_join_rsp=new Message(b.getLocalAddress(), rogue.getLocalAddress(), null);\n+        rogue_join_rsp.putHeader(GMS.name, gms_hdr);\n+        rogue_join_rsp.setFlag(Message.NO_RELIABILITY); // bypasses NAKACK / UNICAST\n+        rogue.down(new Event(Event.MSG, rogue_join_rsp));\n+        for(int i=0; i < 10; i++) {\n+            if(b.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert b.getView().size() == 3 : String.format(\"B's view is %s, but should be {A,B,C}\", b.getView());\n+    }\n+\n+\n+\n+    /** The rogue node has an incorrect {@link AUTH} config (secret) and can thus not join */\n+    public void rogueMemberCannotJoinDueToAuthRejection() throws Exception {\n+        Util.close(rogue);\n+        rogue=create();\n+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(2);\n+        rogue.connect(cluster_name);\n+        System.out.printf(\"Rogue's view is %s\\n\", rogue.getView());\n+        assert rogue.getView().size() == 1 : String.format(\"rogue should have a singleton view of itself, but doesn't: %s\", rogue.getView());\n+    }\n+\n+\n+    public void mergeViewInjectionByNonMember() throws Exception {\n+        Util.close(rogue);\n+        rogue=create();\n+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        rogue.connect(cluster_name);\n+\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        members.add(c.getLocalAddress());\n+        members.add(rogue.getLocalAddress());\n+        MergeView merge_view=new MergeView(a.getLocalAddress(), a.getView().getVid().getId()+5, members, null);\n+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW, merge_view);\n+        Message merge_view_msg=new Message(null);\n+        merge_view_msg.putHeader(GMS.name, hdr);\n+        merge_view_msg.setFlag(Message.NO_RELIABILITY);\n+        System.out.printf(\"** %s: trying to install MergeView %s in all members\\n\", rogue.getLocalAddress(), merge_view);\n+        rogue.down(new Event(Event.MSG, merge_view_msg));\n+\n+        // check if A, B or C installed the MergeView sent by rogue:\n+        for(int i=0; i < 10; i++) {\n+            boolean rogue_views_installed=false;\n+\n+            for(JChannel ch: Arrays.asList(a,b,c))\n+                if(ch.getView().containsMember(rogue.getLocalAddress()))\n+                    rogue_views_installed=true;\n+            if(rogue_views_installed)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: Arrays.asList(a,b,c))\n+            System.out.printf(\"%s: %s\\n\", ch.getLocalAddress(), ch.getView());\n+        for(JChannel ch: Arrays.asList(a,b,c))\n+            assert !ch.getView().containsMember(rogue.getLocalAddress());\n+    }\n+\n+\n+    /** Tests that when {ABC} -> {AB}, neither A nor B can receive a message from non-member C */\n+    public void testMessagesByLeftMember() throws Exception {\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        View view=new View(a.getLocalAddress(), a.getView().getVid().getId()+1, members);\n+        for(JChannel ch: Arrays.asList(a,b)) {\n+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);\n+            gms.installView(view);\n+        };\n+        printView(a,b,c);\n+        c.getProtocolStack().removeProtocol(\"NAKACK\"); // to prevent A and B from discarding C as non-member\n+\n+        Util.sleep(1000); // give members time to handle the new view\n+        c.send(new Message(null, null, \"hello world from left member C!\"));\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"A: received msgs from non-member C: %s\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"B: received msgs from non-member C: %s\", print(rb.list()));\n+    }\n+\n+    /** Tests that a left member C cannot decrypt messages from the cluster */\n+    public void testEavesdroppingByLeftMember() throws Exception {\n+        printSymVersion(a,b,c);\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        View view=new View(a.getLocalAddress(), a.getView().getVid().getId()+1, members);\n+         for(JChannel ch: Arrays.asList(a,b)) {\n+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);\n+            gms.installView(view);\n+        };\n+        printView(a,b,c);\n+        c.getProtocolStack().removeProtocol(\"NAKACK\"); // to prevent A and B from discarding C as non-member\n+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b);\n+\n+        // somewhat of a kludge as we don't have UNICAST: if we didn't remove C's connection to A, C might retransmit\n+        // the JOIN-REQ to A and get added to the cluster, so the code below would fail as C would be able to eavesdrop\n+        // on A and B\n+        UNICAST uni=(UNICAST)c.getProtocolStack().findProtocol(UNICAST.class);\n+        uni.removeConnection(a.getLocalAddress());\n+        Util.sleep(5000); // give members time to handle the new view\n+\n+        printView(a,b,c);\n+        printSymVersion(a,b,c);\n+        a.send(new Message(null, null, \"hello from A\"));\n+        b.send(new Message(null, null, \"hello from B\"));\n+\n+        for(int i=0; i < 10; i++) {\n+            if(rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert rc.size() == 0 : String.format(\"C: received msgs from cluster: %s\", print(rc.list()));\n+    }\n+\n+\n+    protected JChannel create() throws Exception {\n+        JChannel ch=new JChannel(getTestStack());\n+        ProtocolStack stack=ch.getProtocolStack();\n+        EncryptBase encrypt=createENCRYPT();\n+        stack.insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);\n+        AUTH auth=new AUTH();\n+        auth.setAuthCoord(true);\n+        auth.setAuthToken(new MD5Token(\"mysecret\")); // .setAuthCoord(false);\n+        stack.insertProtocol(auth, ProtocolStack.BELOW, GMS.class);\n+        GMS gms = (GMS)stack.findProtocol(GMS.class);\n+        gms.setJoinTimeout(1000); // .setValue(\"view_ack_collection_timeout\", 10);\n+        STABLE stable=((STABLE)stack.findProtocol(STABLE.class));\n+        stable.setDesiredAverageGossip(1000);\n+        stable.setMaxBytes(500);\n+        return ch;\n+    }\n+\n+    protected void printSymVersion(JChannel ... channels) {\n+        for(JChannel ch: channels) {\n+            ASYM_ENCRYPT encr=(ASYM_ENCRYPT)ch.getProtocolStack().findProtocol(ASYM_ENCRYPT.class);\n+            byte[] sym_version=encr.getSymVersion();\n+            System.out.printf(\"sym-version %s: %s\\n\", ch.getLocalAddress(), Util.byteArrayToHexString(sym_version));\n+        }\n+    }\n+\n+    protected void printView(JChannel ... channels) {\n+        for(JChannel ch: channels)\n+            System.out.printf(\"%s: %s\\n\", ch.getLocalAddress(), ch.getView());\n+    }\n+\n+\n+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this\n+    // unit test would fail!\n+    protected ASYM_ENCRYPT createENCRYPT() throws Exception {\n+        ASYM_ENCRYPT encrypt=new ASYM_ENCRYPT();\n+        Properties props=new Properties();\n+        props.put(\"encrypt_entire_message\", \"true\");\n+        props.put(\"sign_msgs\", \"true\");\n+        encrypt.setProperties(props);\n+        encrypt.init();\n+        return encrypt;\n+    }\n+\n+\n+\n+    protected static class CustomENCRYPT extends ASYM_ENCRYPT {\n+        protected SecretKey key;\n+\n+        protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+            if(hdr.getType() == EncryptHeader.SECRET_KEY_RSP) {\n+                try {\n+                    key=decodeKey(msg.getBuffer());\n+                    System.out.printf(\"received secret key %s !\\n\", key);\n+                }\n+                catch(Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+            return super.handleUpEvent(msg, hdr);\n+        }\n+    }\n+}"
        },
        {
            "sha": "f9e66bbb895524d1fb868fc74a553f09cc934cdc",
            "filename": "tests/junit/org/jgroups/protocols/EncryptTest.java",
            "status": "added",
            "additions": 354,
            "deletions": 0,
            "changes": 354,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,354 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.demos.KeyStoreGenerator;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.protocols.pbcast.NAKACK;\n+import org.jgroups.protocols.pbcast.NakAckHeader;\n+import org.jgroups.protocols.pbcast.STABLE;\n+import org.jgroups.stack.Protocol;\n+import org.jgroups.util.Buffer;\n+import org.jgroups.util.MyReceiver;\n+import org.jgroups.util.Util;\n+\n+import junit.framework.TestCase;\n+import javax.crypto.SecretKey;\n+import java.lang.reflect.Field;\n+import java.util.List;\n+import java.util.Vector;\n+import java.util.Properties;\n+\n+import static java.util.Arrays.asList;\n+\n+\n+/**\n+ * Base class for tests {@link SYM_ENCRYPT_Test} and {@link ASYM_ENCRYPT_Test}\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+\n+public abstract class EncryptTest extends TestCase {\n+    protected JChannel            a,b,c,rogue;\n+    protected MyReceiver<Message> ra, rb, rc, r_rogue;\n+    protected String              cluster_name;\n+\n+\tprotected void setUp() throws Exception {\n+        this.cluster_name=\"jgroups.ENCRYPT_TEST\";\n+        a=create();\n+        a.connect(cluster_name);\n+        a.setReceiver(ra=new MyReceiver<Message>().name(\"A\").rawMsgs(true));\n+\n+        b=create();\n+        b.connect(cluster_name);\n+        b.setReceiver(rb=new MyReceiver<Message>().name(\"B\").rawMsgs(true));\n+\n+        c=create();\n+        c.connect(cluster_name);\n+        c.setReceiver(rc=new MyReceiver<Message>().name(\"C\").rawMsgs(true));\n+\n+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b,c);\n+        rogue=createRogue();\n+        rogue.connect(cluster_name);\n+        for(JChannel ch: asList(a,b,c))\n+            System.out.printf(\"%s: %s\\n\", ch.getLocalAddress(), ch.getView());\n+        System.out.println(\"\");\n+    }\n+\n+\tprotected void tearDown() throws Exception {\n+        Util.close(c, b, a, rogue);\n+    }\n+\n+    protected abstract JChannel create() throws Exception;\n+    protected abstract String getProtocolName();\n+\n+\n+    /** Tests A,B or C sending messages and their reception by everyone in cluster {A,B,C} */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRegularMessageReception() throws Exception {\n+        a.send(new Message(null, null, \"Hello from A\"));\n+        b.send(new Message(null, null, \"Hello from B\"));\n+        c.send(new Message(null, null, \"Hello from C\"));\n+        for(int i=0; i < 20; i++) {\n+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)\n+                break;\n+            stable(a,b,c);\n+            Util.sleep(1000);\n+        }\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assertSize(3);\n+    }\n+\n+    /** Same as above, but all messages are 0-length */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {\n+        a.send(new Message(null));\n+        b.send(new Message(null));\n+        c.send(new Message(null));\n+        for(int i=0; i < 20; i++) {\n+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)\n+                break;\n+            stable(a,b,c);\n+            Util.sleep(100);\n+        }\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assertSize(3);\n+    }\n+\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testChecksum() throws Exception {\n+        EncryptBase encrypt=(EncryptBase)a.getProtocolStack().findProtocol(EncryptBase.class);\n+\n+        byte[] buffer=\"Hello world\".getBytes();\n+        long checksum=encrypt.computeChecksum(buffer, 0, buffer.length);\n+        byte[] checksum_array=encrypt.encryptChecksum(checksum);\n+\n+        long actual_checksum=encrypt.decryptChecksum(null, checksum_array, 0, checksum_array.length);\n+        assert checksum == actual_checksum : String.format(\"checksum: %d, actual: %d\", checksum, actual_checksum);\n+    }\n+\n+\n+    /** A rogue member should not be able to join a cluster */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRogueMemberJoin() throws Exception {\n+        Util.close(rogue);\n+        rogue=new JChannel(getTestStack());\n+        rogue.getProtocolStack().removeProtocol(getProtocolName());\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        rogue.connect(cluster_name);\n+        for(int i=0; i < 10; i++) {\n+            if(a.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: asList(a,b,c))\n+            System.out.printf(\"%s: view is %s\\n\", ch.getLocalAddress(), ch.getView());\n+        for(JChannel ch: asList(a,b,c)) {\n+            View view=ch.getView();\n+            assert view.size() == 3 : \"view should be {A,B,C}: \" + view;\n+        }\n+    }\n+\n+\n+    /** Test that A,B,C do NOT receive any message sent by a rogue node which is not member of {A,B,C} */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageSendingByRogue() throws Exception {\n+        rogue.send(new Message(null, null, \"message from rogue\"));  // tests single messages\n+        Util.sleep(500);\n+        for(int i=1; i <= 100; i++)              // tests message batches\n+            rogue.send(new Message(null, null, \"msg #\" + i + \" from rogue\"));\n+\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+    /**\n+     * R sends a message that has an encryption header and is encrypted with R's secret key (which of course is different\n+     * from the cluster members' shared key as R doesn't know it). The cluster members should drop R's message as they\n+     * shouldn't be able to decrypt it.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageSendingByRogueUsingEncryption() throws Exception {\n+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT();\n+        Properties props=new Properties();\n+        props.put(\"keystore_name\", \"/tmp/ignored.keystore\");\n+        props.put(\"encrypt_entire_message\", \"true\");\n+        props.put(\"sign_msgs\", \"true\");\n+        encrypt.setProperties(props);\n+\n+        SecretKey secret_key=KeyStoreGenerator.createSecretKey(encrypt.getSymAlgorithm(), encrypt.getSymKeylength());\n+        encrypt.setSecretKey(secret_key);\n+        encrypt.init();\n+\n+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, encrypt.getSymVersion());\n+        Message msg=new Message(null);\n+        msg.putHeader(encrypt.getName(), hdr);\n+\n+        byte[] buf=\"hello from rogue\".getBytes();\n+        byte[] encrypted_buf=encrypt.code(buf, 0, buf.length, false);\n+        msg.setBuffer(encrypted_buf);\n+        long checksum=encrypt.computeChecksum(encrypted_buf, 0, encrypted_buf.length);\n+        byte[] tmp=encrypt.encryptChecksum(checksum);\n+        hdr.setSignature(tmp);\n+\n+        rogue.send(msg);\n+\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+    /**\n+     * Tests that the non-member does NOT receive messages from cluster {A,B,C}. The de-serialization of a message's\n+     * payload (encrypted with the secret key of the rogue non-member) will fail, so the message is never passed up\n+     * to the application.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageReceptionByRogue() throws Exception {\n+        rogue.setReceiver(r_rogue=new MyReceiver().rawMsgs(true));\n+        a.setReceiver(null); b.setReceiver(null); c.setReceiver(null);\n+        a.send(new Message(null, null, \"Hello from A\"));\n+        b.send(new Message(null, null, \"Hello from B\"));\n+        c.send(new Message(null, null, \"Hello from C\"));\n+        for(int i=0; i < 10; i++) {\n+            // retransmissions will add dupes to rogue as it doesn't have dupe elimination, so we could have more than\n+            // 3 messages!\n+            if(r_rogue.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+\n+        // the non-member may have received some cluster messages, if the encrypted messages coincidentally didn't\n+        // cause a deserialization exception, but it will not be able to read their contents:\n+        if(r_rogue.size() > 0) {\n+            System.out.printf(\"Rogue non-member received %d message(s), but it should not be able to read deserialize \" +\n+                                \"the contents (this should throw exceptions below):\\n\", r_rogue.size());\n+            for(Message msg: r_rogue.list()) {\n+                try {\n+                    String payload=(String)msg.getObject();\n+                    assert !payload.startsWith(\"Hello from\");\n+                }\n+                catch(Exception t) {\n+                    System.out.printf(\"caught exception trying to de-serialize garbage payload into a string: %s\\n\", t);\n+                }\n+            };\n+        }\n+    }\n+\n+\n+    /**\n+     * Tests the scenario where the non-member R captures a message from some cluster member in {A,B,C}, then\n+     * increments the NAKACK seqno and resends that message. The message must not be received by {A,B,C};\n+     * it should be discarded.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {\n+        rogue.setReceiver(new ReceiverAdapter() {\n+            public void receive(Message msg) {\n+                System.out.printf(\"rogue: modifying and resending msg %s, hdrs: %s\\n\", msg, msg.printHeaders());\n+                rogue.setReceiver(null); // to prevent recursive cycle\n+                try {\n+                    NakAckHeader hdr=(NakAckHeader)msg.getHeader(NAKACK.name);\n+                    if(hdr != null) {\n+                        long seqno=hdr.seqno;\n+                        hdr.seqno = seqno+1;\n+                    }\n+                    else {\n+                        System.out.printf(\"Rogue was not able to get the %s header, fabricating one with seqno=50\\n\", NAKACK.class.getSimpleName());\n+                        NakAckHeader hdr2=new NakAckHeader(NakAckHeader.MSG, 50);\n+                        msg.putHeader(NAKACK.name, hdr2);\n+                    }\n+\n+                    rogue.send(msg);\n+                }\n+                catch(Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        a.send(new Message(null, null, \"Hello world from A\"));\n+\n+        // everybody in {A,B,C} should receive this message, but NOT the rogue's resent message\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 1 || rb.size() > 1 || rc.size() > 1)\n+                break; // this should NOT happen\n+            Util.sleep(500);\n+        }\n+\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assert ra.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+\n+    /**\n+     * Tests the case where a non-member installs a new view {rogue,A,B,C}, making itself the coordinator and therefore\n+     * controlling admission of new members to the cluster etc...\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRogueViewInstallation() throws Exception {\n+        final Address rogue_addr=rogue.getLocalAddress();\n+        Vector<Address> members = new Vector<Address>();\n+        members.add(rogue_addr);\n+        members.add(a.getLocalAddress());\n+        members.add(b.getLocalAddress());\n+        members.add(c.getLocalAddress());\n+        View rogue_view=new View(rogue_addr, a.getView().getVid().getId()+1, members);\n+\n+        Message view_change_msg=new Message();\n+        GMS.GmsHeader hdr = new GMS.GmsHeader(GMS.GmsHeader.VIEW, rogue_view);\n+        view_change_msg.putHeader(GMS.name, hdr);\n+\n+        rogue.send(view_change_msg);\n+\n+        for(int i=0; i < 10; i++) {\n+            if(a.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: asList(a,b,c)) {\n+            View view=ch.getView();\n+            System.out.printf(\"%s: view is %s\\n\", ch.getLocalAddress(), view);\n+            assert !view.containsMember(rogue_addr) : \"view contains rogue member: \" + view;\n+        };\n+    }\n+\n+\n+    protected static JChannel createRogue() throws Exception {\n+        return new JChannel(\"SHARED_LOOPBACK\");\n+    }\n+\n+\n+    protected void assertSize(int expected_size) {\n+        for(MyReceiver r: asList(ra,rb,rc))\n+        assert r.size() == expected_size : String.format(\"expected size: %d, actual size of %s: %d\", expected_size, r.name(), r.size());\n+    }\n+\n+    protected static String print(List<Message> msgs) {\n+        StringBuilder sb=new StringBuilder();\n+        for(Message msg: msgs)\n+            sb.append(msg.getObject()).append(\" \");\n+        return sb.toString();\n+    }\n+\n+    protected static String print(byte[] buf, int offset, int length) {\n+        StringBuilder sb=new StringBuilder(\"encrypted string: \");\n+        for(int i=0; i < length; i++) {\n+            int ch=buf[offset+i];\n+            sb.append(ch).append(' ');\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+    protected static void stable(JChannel ... channels) {\n+        for(JChannel ch: channels) {\n+            STABLE stable=(STABLE)ch.getProtocolStack().findProtocol(STABLE.class);\n+            stable.runMessageGarbageCollection();\n+        }\n+    }\n+\n+    public static String getTestStack() {\n+        return \"SHARED_LOOPBACK:PING:pbcast.NAKACK:UNICAST:pbcast.STABLE:pbcast.GMS(join_timeout=1000):FRAG2(frag_size=8000)\";\n+\t}\n+}"
        },
        {
            "sha": "193d17c236a8a7f901420c088f8337b8716ab0d9",
            "filename": "tests/junit/org/jgroups/protocols/SYM_ENCRYPT_Test.java",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/belaban/JGroups/blob/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/c3ad22234ef84d06d04d908b3c94c0d11df8afda/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java?ref=c3ad22234ef84d06d04d908b3c94c0d11df8afda",
            "patch": "@@ -0,0 +1,52 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.Global;\n+import org.jgroups.JChannel;\n+import org.jgroups.protocols.pbcast.NAKACK;\n+import org.jgroups.stack.ProtocolStack;\n+import org.jgroups.util.Util;\n+\n+import java.util.Properties;\n+\n+/**\n+ * Tests use cases for {@link SYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.\n+ * Make sure you create the keystore before running this test (ant make-keystore).\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+public class SYM_ENCRYPT_Test extends EncryptTest {\n+    protected static final String DEF_PWD=\"changeit\";\n+ \n+    protected String getProtocolName()\n+    {\n+        return \"SYM_ENCRYPT\";\n+    }\n+\n+    protected JChannel create() throws Exception {\n+        JChannel ch=new JChannel(getTestStack());\n+        SYM_ENCRYPT encrypt;\n+        try {\n+            encrypt=createENCRYPT(\"keystore/defaultStore.keystore\", DEF_PWD);\n+        }\n+        catch(Throwable t) {\n+            encrypt=createENCRYPT(\"defaultStore.keystore\", DEF_PWD);\n+        }\n+        ch.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK.class);\n+        return ch;\n+    }\n+\n+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this\n+    // unit test would fail!\n+    protected SYM_ENCRYPT createENCRYPT(String keystore_name, String store_pwd) throws Exception {\n+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT();\n+        Properties props=new Properties();\n+        props.put(\"keystore_name\", keystore_name);\n+        props.put(\"alias\", \"myKey\");\n+        props.put(\"store_password\", store_pwd);\n+        props.put(\"encrypt_entire_message\", \"true\");\n+        props.put(\"sign_msgs\", \"true\");\n+        encrypt.setProperties(props);\n+        encrypt.init();\n+        return encrypt;\n+    }\n+}"
        }
    ]
}
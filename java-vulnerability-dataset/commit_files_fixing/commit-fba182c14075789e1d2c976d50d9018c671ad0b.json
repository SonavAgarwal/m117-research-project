{
    "sha": "fba182c14075789e1d2c976d50d9018c671ad0b4",
    "node_id": "MDY6Q29tbWl0MTA1OTQzMDpmYmExODJjMTQwNzU3ODllMWQyYzk3NmQ1MGQ5MDE4YzY3MWFkMGI0",
    "commit": {
        "author": {
            "name": "Bela Ban",
            "email": "belaban@yahoo.com",
            "date": "2016-04-19T14:44:09Z"
        },
        "committer": {
            "name": "Bela Ban",
            "email": "belaban@yahoo.com",
            "date": "2016-04-26T07:00:26Z"
        },
        "message": "- Backport of JGRP-2021 to 3.6: https://issues.jboss.org/browse/JGRP-2055\n- Fixed S3_PINGTest (http -> https)\n- Using delegation rather than inheritance in {A}SYM_ENCRYPT_Test as inheritance doesn't work properly in TestNG\n- Added doc/design/MaliciousAttacks.txt\n- Added conf/sym-encrypt.xml and conf/asym-encrypt.xml\n- Added info on new encryption protocols to manual",
        "tree": {
            "sha": "8acb396744017234ef746e2d164686df53163a6b",
            "url": "https://api.github.com/repos/belaban/JGroups/git/trees/8acb396744017234ef746e2d164686df53163a6b"
        },
        "url": "https://api.github.com/repos/belaban/JGroups/git/commits/fba182c14075789e1d2c976d50d9018c671ad0b4",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/belaban/JGroups/commits/fba182c14075789e1d2c976d50d9018c671ad0b4",
    "html_url": "https://github.com/belaban/JGroups/commit/fba182c14075789e1d2c976d50d9018c671ad0b4",
    "comments_url": "https://api.github.com/repos/belaban/JGroups/commits/fba182c14075789e1d2c976d50d9018c671ad0b4/comments",
    "author": {
        "login": "belaban",
        "id": 457949,
        "node_id": "MDQ6VXNlcjQ1Nzk0OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/457949?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/belaban",
        "html_url": "https://github.com/belaban",
        "followers_url": "https://api.github.com/users/belaban/followers",
        "following_url": "https://api.github.com/users/belaban/following{/other_user}",
        "gists_url": "https://api.github.com/users/belaban/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/belaban/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/belaban/subscriptions",
        "organizations_url": "https://api.github.com/users/belaban/orgs",
        "repos_url": "https://api.github.com/users/belaban/repos",
        "events_url": "https://api.github.com/users/belaban/events{/privacy}",
        "received_events_url": "https://api.github.com/users/belaban/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "belaban",
        "id": 457949,
        "node_id": "MDQ6VXNlcjQ1Nzk0OQ==",
        "avatar_url": "https://avatars.githubusercontent.com/u/457949?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/belaban",
        "html_url": "https://github.com/belaban",
        "followers_url": "https://api.github.com/users/belaban/followers",
        "following_url": "https://api.github.com/users/belaban/following{/other_user}",
        "gists_url": "https://api.github.com/users/belaban/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/belaban/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/belaban/subscriptions",
        "organizations_url": "https://api.github.com/users/belaban/orgs",
        "repos_url": "https://api.github.com/users/belaban/repos",
        "events_url": "https://api.github.com/users/belaban/events{/privacy}",
        "received_events_url": "https://api.github.com/users/belaban/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "38b91a6b07532f8893337b01e80267c8bbe3a89e",
            "url": "https://api.github.com/repos/belaban/JGroups/commits/38b91a6b07532f8893337b01e80267c8bbe3a89e",
            "html_url": "https://github.com/belaban/JGroups/commit/38b91a6b07532f8893337b01e80267c8bbe3a89e"
        }
    ],
    "stats": {
        "total": 2320,
        "additions": 2223,
        "deletions": 97
    },
    "files": [
        {
            "sha": "b62888338181570baaa2c7d7a1d54eead0b93c97",
            "filename": ".gitignore",
            "status": "modified",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/.gitignore",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/.gitignore",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/.gitignore?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -2,6 +2,7 @@\n *.iws\n *.ipr\n *.iml\n+.ant-targets-build.xml\n .project\n .classpath\n .factorypath"
        },
        {
            "sha": "a8033055ba24c5c3a0b4329475a74a0709a4f1a7",
            "filename": "build.xml",
            "status": "modified",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/build.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/build.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/build.xml?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -631,6 +631,43 @@\n                  threadcount=\"5\" />\n     </target>\n \n+    <!--listeners=\"org.jgroups.util.JUnitXMLReporter\"-->\n+\n+    <target name=\"encrypt\" description=\"Runs SYM_ENCRYPT_Test only\" depends=\"define-testng-task\">\n+        <mkdir dir=\"${tmp.dir}/test-results/xml/functional\"/>\n+\n+        <testng classpathref=\"jg.classpath\"\n+                suitename=\"encrypt-test\"\n+                groups=\"encr\"\n+                parallel=\"classes\"\n+                threadcount=\"5\"\n+                usedefaultlisteners=\"false\"\n+                outputdir=\"${tmp.dir}/test-results/xml/functional\"\n+                timeout=\"${unittest.timeout}\"\n+                timeOut=\"${unittest.timeout}\"\n+                verbose=\"1\"\n+                listeners=\"org.jgroups.util.JUnitXMLReporter\"\n+                configfailurepolicy=\"continue\">\n+\n+            <classfileset dir=\"${compile.dir}\"/>\n+\n+            <jvmarg value=\"-Djgroups.bind_addr=${jgroups.bind_addr}\"/>\n+            <jvmarg value=\"-Djgroups.udp.ip_ttl=0\"/>\n+            <jvmarg value=\"-Djgroups.tcpping.initial_hosts=${jgroups.tcpping.initial_hosts}\"/>\n+            <jvmarg value=\"-Djgroups.tunnel.gossip_router_hosts=${jgroups.tunnel.gossip_router_hosts}\"/>\n+            <jvmarg value=\"-Dtests.tmp.dir=${tmp.dir}\"/>\n+            <jvmarg value=\"-Dlog4j.configuration=file:${conf.dir}/log4j.properties\"/>\n+            <jvmarg value=\"-Dlog4j.configurationFile=${conf.dir}/log4j2.xml\"/>\n+            <jvmarg value=\"-Djava.net.preferIPv4Stack=${java.net.preferIPv4Stack}\"/>\n+            <jvmarg value=\"-Djava.net.preferIPv6Addresses=${java.net.preferIPv6Addresses}\"/>\n+            <jvmarg value=\"-Xms400M\"/>\n+            <jvmarg value=\"-Xmx800M\"/>\n+            <!--<additional-args/>-->\n+        </testng>\n+\n+\n+    </target>\n+\n \n     <target name=\"byteman\" depends=\"postcompile,define-testng-task\" description=\"Runs the byteman tests\">\n         <mkdir dir=\"${tmp.dir}/test-results/xml/byteman\"/>"
        },
        {
            "sha": "8b9a93d34d2a518755fd279d1cc01ecf4824576e",
            "filename": "conf/asym-encrypt.xml",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fasym-encrypt.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fasym-encrypt.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fasym-encrypt.xml?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,29 @@\n+\n+<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+        xmlns=\"urn:org:jgroups\"\n+        xsi:schemaLocation=\"urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd\">\n+    <UDP />\n+    <PING/>\n+    <MERGE3/>\n+    <FD_ALL timeout=\"5000\"/>\n+    <FD_SOCK/>\n+    <VERIFY_SUSPECT/>\n+\n+    <!-- Asymmetric encryption using public/private encryption to fetch the shared secret key -->\n+    <ASYM_ENCRYPT\n+            encrypt_entire_message=\"true\"\n+            sym_keylength=\"128\"\n+            sym_algorithm=\"AES/ECB/PKCS5Padding\"\n+            asym_keylength=\"512\"\n+            asym_algorithm=\"RSA\"/>\n+\n+    <pbcast.NAKACK2/>\n+    <UNICAST3/>\n+    <pbcast.STABLE/>\n+    <FRAG2/>\n+    <!-- AUTH below is required by ASYM_ENCRYPT -->\n+    <AUTH auth_class=\"org.jgroups.auth.MD5Token\"\n+          auth_value=\"chris\"\n+          token_hash=\"MD5\"/>\n+    <pbcast.GMS join_timeout=\"2000\" />\n+</config>"
        },
        {
            "sha": "c89f7257bf2311f4ba7d1e195fbd6c73c456651f",
            "filename": "conf/jg-magic-map.xml",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fjg-magic-map.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fjg-magic-map.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fjg-magic-map.xml?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -24,7 +24,7 @@\n     <class id=\"53\"  name=\"org.jgroups.protocols.COMPRESS$CompressHeader\"/>\n     <class id=\"54\"  name=\"org.jgroups.protocols.FcHeader\"/>\n     <class id=\"56\"  name=\"org.jgroups.protocols.TpHeader\"/>\n-    <class id=\"57\"  name=\"org.jgroups.protocols.ENCRYPT$EncryptHeader\"/>\n+    <class id=\"57\"  name=\"org.jgroups.protocols.EncryptHeader\"/>\n     <class id=\"58\"  name=\"org.jgroups.protocols.SEQUENCER$SequencerHeader\"/>\n     <class id=\"61\"  name=\"org.jgroups.protocols.FD_ALL$HeartbeatHeader\"/>\n     <class id=\"62\"  name=\"org.jgroups.protocols.FD_ALL2$HeartbeatHeader\"/>"
        },
        {
            "sha": "50b4f92ec11ca07b9ceb6cdee0fab68c39dadd0d",
            "filename": "conf/jg-protocol-ids.xml",
            "status": "modified",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fjg-protocol-ids.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fjg-protocol-ids.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fjg-protocol-ids.xml?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -69,6 +69,9 @@\n     <class id=\"73\" name=\"org.jgroups.protocols.ABP\"/>\n     <class id=\"74\" name=\"org.jgroups.protocols.TCP_NIO2\"/>\n     <class id=\"75\" name=\"org.jgroups.protocols.TP\"/>\n+    <class id=\"76\" name=\"org.jgroups.protocols.SYM_ENCRYPT\"/>\n+    <class id=\"77\" name=\"org.jgroups.protocols.ASYM_ENCRYPT\"/>\n+\n \n     <!-- IDs reserved for building blocks -->\n     <class id=\"200\" name=\"org.jgroups.blocks.RequestCorrelator\"/> <!-- ID should be the same as Global.BLOCKS_START_ID -->"
        },
        {
            "sha": "fb5af811758eb26caf9a8f56956f17b326237a87",
            "filename": "conf/sym-encrypt.xml",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fsym-encrypt.xml",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/conf%2Fsym-encrypt.xml",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/conf%2Fsym-encrypt.xml?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,30 @@\n+\n+\n+\n+<config xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+        xmlns=\"urn:org:jgroups\"\n+        xsi:schemaLocation=\"urn:org:jgroups http://www.jgroups.org/schema/jgroups.xsd\">\n+    <UDP />\n+    <PING/>\n+    <MERGE3/>\n+    <FD_ALL timeout=\"5000\"/>\n+    <FD_SOCK/>\n+    <VERIFY_SUSPECT/>\n+\n+    <!-- Symmetric encryption with a keystore -->\n+    <SYM_ENCRYPT\n+        provider=\"SunJCE\"\n+        sym_algorithm=\"AES\"\n+        encrypt_entire_message=\"true\"\n+        keystore_name=\"/home/bela/JGroups/keystore/defaultStore.keystore\" \n+        store_password=\"changeit\" alias=\"myKey\"/>\n+    <pbcast.NAKACK2/>\n+    <UNICAST3/>\n+    <pbcast.STABLE/>\n+    <FRAG2/>\n+    <!-- AUTH below is optional -->\n+    <AUTH auth_class=\"org.jgroups.auth.MD5Token\"\n+          auth_value=\"chris\"\n+          token_hash=\"MD5\"/>\n+    <pbcast.GMS join_timeout=\"2000\" />\n+</config>"
        },
        {
            "sha": "f73f4a961b95a924d52a50e4b0d4061995a17a72",
            "filename": "doc/design/MaliciousAttacks.txt",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/doc%2Fdesign%2FMaliciousAttacks.txt",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/doc%2Fdesign%2FMaliciousAttacks.txt",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/doc%2Fdesign%2FMaliciousAttacks.txt?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,91 @@\n+\n+Use of encryption and authentication protocols to fend off malicious attacks\n+============================================================================\n+Author: Bela Ban, April 2016\n+JIRA:   https://issues.jboss.org/browse/JGRP-2021\n+\n+The following discussion refers to the changes made in JGroups 4.0. These have been backported to the 3.6 branch, but\n+the syntax looks different. However, the concepts are the same.\n+\n+\n+\n+Types of attacks handled\n+------------------------\n+Malicious attacks essentially include (1) non-authorized nodes being able to join a cluster and (2) non-members being\n+able to communicate with cluster members.\n+\n+(1) is handled by AUTH which allows only authenticated nodes to join a cluster.\n+\n+(2) is handled by the encryption protocol (SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster\n+members such that a non-member cannot understand them.\n+\n+\n+\n+Authentication\n+--------------\n+Authentication is performed by AUTH. Its main use is to make sure only authenticated members can join a cluster.\n+Other scenarios where a check is performed are:\n+* Merging: make sure only authenticated members can merge into a new cluster\n+* View installation (if enabled): views and merge views can only be installed by authenticated members\n+\n+So authentication makes sure that rogue nodes will never be able to be members of a cluster, be it via joining or\n+merging. Note that while AUTH is optional with SYM_ENCRYPT, it is required by ASYM_ENCRYPT: there's a sanity check that\n+will prevent a member to start if ASYM_ENCRYPT is present but AUTH is absent.\n+\n+\n+\n+Authorization\n+-------------\n+There is currently no authorization in JGroups. Once a member is admitted to the cluster (via authentication),\n+it can send and receive messages to anyone.\n+\n+\n+\n+Encryption\n+----------\n+This is based on a shared secret key that all members of a cluster have. The key is either acquired from a shared\n+keystore (symmetric encryption, below) or a new joiner fetches it from the coordinator via public/private key exchange\n+(asymmetric encryption, below).\n+\n+A sent message is encrypted with the shared secret key by the sender and decrypted with the same secret key by the\n+receiver(s).\n+\n+By default, the entire message (including the headers) is encrypted, but it is also possible to only encrypt the payload\n+(this is configurable). If the headers are not encrypted, it is possible to use replay attacks, because the\n+sequence numbers (seqnos) of a message are seen. For example, if a seqno is 50, then an attacker might copy the message,\n+and increment the seqno. This is prevented by copying and _signing_ the message.\n+\n+A message can be signed, which is a hash over the encrypted message, encrypted with the secret key. If the hash shipped\n+with a message doesn't match the hash computed over the received message, the message will be discarded by a receiver,\n+and no attempt is made to decrypt it.\n+\n+The cost of encrypting the entire message includes serializing the entire message (including headers, flags, destination\n+address etc) and encrypting it into the buffer of a new message (to the same destination). If message signing is enabled,\n+the cost of computing a hashcode and encrypting it is added to the above cost.\n+\n+Attributes present in both symmetric and asymmetric encryption include sign_msgs and encrypt_entire_message.\n+\n+\n+Symmetric encryption\n+--------------------\n+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. keystore_name\n+(name of the keystore, needs to be found on the classpath), store_password, key_password and alias.\n+\n+\n+Asymmetric encryption\n+---------------------\n+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After\n+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key\n+(including P's public key) to C.\n+\n+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key\n+and installs it. From then on, P encrypts and decrypts messages using the secret key.\n+\n+When a member leaves, C can optionally (based on change_key_on_leave) create a new secret key, and every cluster member\n+needs to fetch it again, using the public/private key exchange described above.\n+\n+\n+\n+\n+\n+"
        },
        {
            "sha": "851f10f252b8ac1aa0cf9cd626f867ce09c8c358",
            "filename": "doc/manual/protocols.adoc",
            "status": "modified",
            "additions": 87,
            "deletions": 3,
            "changes": 90,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/doc%2Fmanual%2Fprotocols.adoc",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/doc%2Fmanual%2Fprotocols.adoc",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/doc%2Fmanual%2Fprotocols.adoc?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -1507,10 +1507,15 @@ ${STATS}\n \n \n ==== Security\n+Security is used to prevent (1) non-authorized nodes being able to join a cluster and (2) non-members being\n+able to communicate with cluster members.\n \n-JGroups provides protocols to encrypt cluster traffic (ENCRYPT), and to make sure that only\n-                authorized members can join a cluster (AUTH and SASL).\n-            \n+(1) is handled by AUTH or SASL which allows only authenticated nodes to join a cluster.\n+\n+(2) is handled by the encryption protocol (ENCRYPT, SYM_ENCRYPT or ASYM_ENCRYPT) which encrypts messages between cluster\n+members such that a non-member cannot understand them.\n+\n+NOTE: ENCRYPT is deprecated, and SYM_ENCRYPT or ASYM_ENCRYPT are recommended for encryption.\n \n [[ENCRYPT]]\n \n@@ -1597,6 +1602,85 @@ NOTE: If asymmetric encryption is used (no shared key via keystore), ENCRYPT has\n \n ${ENCRYPT}\n \n+[[SYM_ENCRYPT]]\n+===== SYM_ENCRYPT\n+\n+This is done by SYM_ENCRYPT. The configuration includes mainly attributes that define the keystore, e.g. `keystore_name`\n+(name of the keystore, needs to be found on the classpath), `store_password`, `key_password` and `alias`.\n+\n+SYM_ENCRYPT uses store type JCEKS (for details between JKS and JCEKS see here), however `keytool` uses JKS, therefore\n+a keystore generated with keytool will not be accessible.\n+\n+To generate a keystore compatible with JCEKS, use the following command line options to keytool:\n+\n+----\n+keytool -genseckey -alias myKey -keypass changeit -storepass changeit  -keyalg Blowfish -keysize 56 -keystore defaultStore.keystore -storetype  JCEKS\n+----\n+\n+SYM_ENCRYPT could then be configured as follows:\n+\n+\n+\n+[source,xml]\n+----\n+<SYM_ENCRYPT sym_algorithm=\"AES\"\n+             encrypt_entire_message=\"true\"\n+             key_store_name=\"defaultStore.keystore\"\n+             store_password=\"changeit\"\n+             alias=\"myKey\"/>\n+----\n+\n+Note that defaultStore.keystore will have to be found in the claspath.\n+\n+NOTE: Both SYM_ENCRYPT and ASYM_ENCRYPT should be placed directly under NAKACK2\n+(see link:https://github.com/belaban/JGroups/tree/master/conf[sample configurations]).\n+\n+\n+${SYM_ENCRYPT}\n+\n+\n+\n+[[ASYM_ENCRYPT]]\n+===== ASYM_ENCRYPT\n+Contrary to SYM_ENCRYPT, the secret key is not fetched from a shared keystore, but from the current coordinator C. After\n+new member P joined the cluster (passing the join check done by AUTH), P sends a request to get the secret key\n+(including P's public key) to C.\n+\n+C then sends the secret key back to P, encrypted with P's public key, and P decrypts it with its private key\n+and installs it. From then on, P encrypts and decrypts messages using the secret key.\n+\n+When a member leaves, C can optionally (based on `change_key_on_leave`) create a new secret key, and every cluster member\n+needs to fetch it again, using the public/private key exchange described above.\n+\n+A stack configured to use asymmetric encryption could look like this:\n+[source,xml]\n+----\n+    ...\n+    <VERIFY_SUSPECT/>\n+    <ASYM_ENCRYPT encrypt_entire_message=\"true\"\n+             sym_keylength=\"128\"\n+             sym_algorithm=\"AES/ECB/PKCS5Padding\"\n+             asym_keylength=\"512\"\n+             asym_algorithm=\"RSA\"/>\n+\n+    <pbcast.NAKACK2/>\n+    <UNICAST3/>\n+    <pbcast.STABLE/>\n+    <FRAG2/>\n+    <AUTH auth_class=\"org.jgroups.auth.MD5Token\"\n+          auth_value=\"chris\"\n+          token_hash=\"MD5\"/>\n+    <pbcast.GMS join_timeout=\"2000\" />\n+----\n+\n+The configuration snippet shows ASYM_ENCRYPT positioned just below NAKACK2, so that headers of the important\n+retransmission protocols NAKACK2 and UNICAST3 are encrypted, too. Note that AUTH should be part of the configuration, or\n+else unauthenticated nodes would be able to acquire the secret key from the coordinator.\n+\n+${ASYM_ENCRYPT}\n+\n+\n+\n [[AUTH]]\n \n "
        },
        {
            "sha": "ab48c585373b63e7c8a3ae8f0fa9b649bd3614b9",
            "filename": "src/org/jgroups/Channel.java",
            "status": "modified",
            "additions": 1,
            "deletions": 1,
            "changes": 2,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FChannel.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FChannel.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2FChannel.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -396,7 +396,7 @@ public synchronized void clearChannelListeners() {\n     * */\n     public void setReceiver(Receiver r) {\n         if(receiver != null && r != null)\n-            log.warn(\"%s: receiver already set\");\n+            log.warn(\"%s: receiver already set\", getAddress());\n         receiver=r;\n     }\n "
        },
        {
            "sha": "998534fec3d0571122f55a550390d8ec2160e66f",
            "filename": "src/org/jgroups/Event.java",
            "status": "modified",
            "additions": 4,
            "deletions": 6,
            "changes": 10,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FEvent.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FEvent.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2FEvent.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -88,14 +88,12 @@ public Event(int type, Object arg) {\n         this.arg=arg;\n     }\n \n-    public final int getType() {\n+    public final int             getType() {\n         return type;\n     }\n-\n-\n-    public Object getArg() {\n-        return arg;\n-    }\n+    public int                   type()    {return type;}\n+    public Object                getArg()  {return arg;}\n+    public <T extends Object> T  arg()     {return (T)arg;}\n \n \n "
        },
        {
            "sha": "152472caf43ca469a9cc947aabc5f4337fc648e2",
            "filename": "src/org/jgroups/View.java",
            "status": "modified",
            "additions": 13,
            "deletions": 0,
            "changes": 13,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FView.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2FView.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2FView.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -109,6 +109,8 @@ public Address getCreator() {\n         return view_id.getCreator();\n     }\n \n+    public Address getCoord() {return members.length > 0? members[0] : null;}\n+\n     /**\n      * Returns the member list\n      * @return an unmodifiable list\n@@ -138,6 +140,17 @@ public boolean containsMember(Address mbr) {\n         return false;\n     }\n \n+    /** Returns true if all mbrs are elements of this view, false otherwise */\n+    public boolean containsMembers(Address ... mbrs) {\n+        if(mbrs == null || members == null)\n+            return false;\n+        for(Address mbr: mbrs) {\n+            if(!containsMember(mbr))\n+                return false;\n+        }\n+        return true;\n+    }\n+\n \n     public int compareTo(View o) {\n         return view_id.compareTo(o.view_id);"
        },
        {
            "sha": "6e4748a50c005875529152fd9c17f25a29139ce5",
            "filename": "src/org/jgroups/demos/KeyStoreGenerator.java",
            "status": "modified",
            "additions": 14,
            "deletions": 3,
            "changes": 17,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fdemos%2FKeyStoreGenerator.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -3,12 +3,12 @@\n \n import org.jgroups.util.Util;\n \n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n import java.io.FileOutputStream;\n import java.io.OutputStream;\n import java.security.KeyStore;\n-\n-import javax.crypto.KeyGenerator;\n-import javax.crypto.SecretKey;\n+import java.security.NoSuchAlgorithmException;\n \n /**\n  * Generates a keystore file that has a SecretKey in it. It is not possible to\n@@ -130,6 +130,17 @@ public static SecretKey initSymKey() throws Exception {\n \n     }\n \n+    public static SecretKey createSecretKey() throws Exception {\n+        return createSecretKey(symAlg, keySize);\n+    }\n+\n+    public static SecretKey createSecretKey(String sym_alg, int key_size) throws NoSuchAlgorithmException {\n+        // KeyGenerator keyGen=KeyGenerator.getInstance(getAlgorithm(sym_alg));\n+        KeyGenerator keyGen=KeyGenerator.getInstance(sym_alg);\n+        keyGen.init(key_size);\n+        return keyGen.generateKey();\n+    }\n+\n     private static String getAlgorithm(String s) {\n         int index=s.indexOf(\"/\");\n         if(index == -1)"
        },
        {
            "sha": "a34769d777068a04d050538448f04584623e64bb",
            "filename": "src/org/jgroups/protocols/ASYM_ENCRYPT.java",
            "status": "added",
            "additions": 413,
            "deletions": 0,
            "changes": 413,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,413 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.annotations.MBean;\n+import org.jgroups.annotations.ManagedAttribute;\n+import org.jgroups.annotations.ManagedOperation;\n+import org.jgroups.annotations.Property;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.util.AsciiString;\n+import org.jgroups.util.MessageBatch;\n+import org.jgroups.util.Util;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.KeyGenerator;\n+import javax.crypto.SecretKey;\n+import javax.crypto.spec.SecretKeySpec;\n+import java.security.*;\n+import java.security.spec.X509EncodedKeySpec;\n+import java.util.Arrays;\n+import java.util.Objects;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+\n+/**\n+ * Encrypts and decrypts communication in JGroups by using a secret key distributed to all cluster members by the\n+ * key server (coordinator) using asymmetric (public/private key) encryption.<br>\n+ *\n+ * The secret key is identical for all cluster members and is used to encrypt messages when sending and decrypt them\n+ * when receiving messages.\n+ *\n+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important\n+ * headers are encrypted as well, to prevent replay attacks.<br>\n+ *\n+ * The current keyserver (always the coordinator) generates a secret key. When a new member joins, it asks the keyserver\n+ * for the secret key. The keyserver encrypts the secret key with the joiner's public key and the joiner decrypts it with\n+ * its private key and then installs it and starts encrypting and decrypting messages with the secret key.<br>\n+ *\n+ * View changes that identify a new keyserver will result in a new secret key being generated and then distributed to\n+ * all cluster members. This overhead can be substantial in an application with a reasonable member churn.<br>\n+ *\n+ * This protocol is suited to an application that does not ship with a known key but instead it is generated and\n+ * distributed by the keyserver.\n+ *\n+ * Since messages can only get encrypted and decrypted when the secret key was received from the keyserver, messages\n+ * other then join and merge requests/responses are dropped when the secret key isn't yet available. Join and merge\n+ * requests / responses are handled by {@link AUTH}.\n+ *\n+ * @author Bela Ban\n+ * @author Steve Woodcock\n+ */\n+@MBean(description=\"Asymmetric encryption protocol. The secret key for encryption and decryption of messages is fetched \" +\n+  \"from a key server (the coordinator) via asymmetric encryption\")\n+public class ASYM_ENCRYPT extends EncryptBase {\n+    protected static final short                   GMS_ID=ClassConfigurator.getProtocolId(GMS.class);\n+\n+    @Property(description=\"When a member leaves the view, change the secret key, preventing old members from eavesdropping\",\n+      writable=false)\n+    protected boolean                              change_key_on_leave=true;\n+    protected volatile Address                     key_server_addr;\n+    @ManagedAttribute(description=\"True if this member is the current key server, false otherwise\")\n+    protected volatile boolean                     is_key_server;\n+    protected KeyPair                              key_pair; // to store own's public/private Key\n+    protected Cipher                               asym_cipher;  // decrypting cypher for secret key requests\n+    // queue all up msgs until the secret key has been received/created\n+    @ManagedAttribute(description=\"whether or not to queue received messages (until the secret key was received)\")\n+    protected volatile boolean                     queue_up_msgs=true;\n+    // queues a bounded number of messages received during a null secret key (or fetching the key from a new coord)\n+    protected final BlockingQueue<Message>         up_queue=new ArrayBlockingQueue<>(100);\n+\n+    protected volatile long                        last_key_request;\n+\n+\n+    public KeyPair      keyPair()                         {return key_pair;}\n+    public Cipher       asymCipher()                      {return asym_cipher;}\n+    public Address      keyServerAddr()                   {return key_server_addr;}\n+    public ASYM_ENCRYPT keyServerAddr(Address key_srv)    {this.key_server_addr=key_srv; return this;}\n+\n+    @ManagedAttribute(description=\"Number of received messages currently queued\")\n+    public int numQueuedMessages() {return up_queue.size();}\n+\n+    @ManagedOperation(description=\"Triggers a request for the secret key to the current keyserver\")\n+    public void sendKeyRequest() {\n+        if(key_server_addr == null) {\n+            log.error(\"%s: key server is currently not set\", key_server_addr);\n+            return;\n+        }\n+        sendKeyRequest(key_server_addr);\n+    }\n+\n+    public void init() throws Exception {\n+        initKeyPair();\n+        super.init();\n+    }\n+\n+    public void stop() {\n+        drainUpQueue();\n+        super.stop();\n+    }\n+\n+    public Object down(Event evt) {\n+        if(evt.type() == Event.MSG) {\n+            Message msg=evt.arg();\n+            if(skip(msg))\n+                return down_prot.down(evt);\n+        }\n+        return super.down(evt);\n+    }\n+\n+    public Object up(Event evt) {\n+        if(evt.type() == Event.MSG) {\n+            Message msg=evt.arg();\n+            if(skip(msg))\n+                return up_prot.up(evt);\n+        }\n+        return super.up(evt);\n+    }\n+\n+    public void up(MessageBatch batch) {\n+        for(Message msg: batch) {\n+            if(skip(msg)) {\n+                try {\n+                    up_prot.up(new Event(Event.MSG, msg));\n+                    batch.remove(msg);\n+                }\n+                catch(Throwable t) {\n+                    log.error(\"failed passing up message from %s: %s, ex=%s\", msg.src(), msg.printHeaders(), t);\n+                }\n+            }\n+        }\n+        if(!batch.isEmpty())\n+            super.up(batch); // decrypt the rest of the messages in the batch (if any)\n+    }\n+\n+\n+\n+    /** Checks if a message needs to be encrypted/decrypted. Join and merge requests/responses don't need to be\n+     * encrypted as they're authenticated by {@link AUTH} */\n+    protected static boolean skip(Message msg) {\n+        GMS.GmsHeader hdr=(GMS.GmsHeader)msg.getHeader(GMS_ID);\n+        if(hdr == null) return false;\n+        switch(hdr.getType()) {\n+            case GMS.GmsHeader.JOIN_REQ:\n+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n+            case GMS.GmsHeader.JOIN_RSP:\n+            case GMS.GmsHeader.MERGE_REQ:\n+            case GMS.GmsHeader.MERGE_RSP:\n+            case GMS.GmsHeader.VIEW_ACK:\n+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:\n+                return true;\n+        }\n+        return false;\n+    }\n+\n+\n+    @Override protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+        switch(hdr.type()) {\n+            case EncryptHeader.SECRET_KEY_REQ:\n+                handleSecretKeyRequest(msg);\n+                break;\n+            case EncryptHeader.SECRET_KEY_RSP:\n+                handleSecretKeyResponse(msg, hdr.version());\n+                break;\n+            default:\n+                log.warn(\"%s: received unknown encrypt header of type %d\", local_addr, hdr.type());\n+                break;\n+        }\n+        return null;\n+    }\n+\n+    @Override protected boolean process(Message msg) {\n+        if(queue_up_msgs || secret_key == null) {\n+            up_queue.offer(msg);\n+            log.trace(\"%s: queuing %s message from %s as secret key hasn't been retrieved from keyserver %s yet, hdrs: %s\",\n+                      local_addr, msg.dest() == null? \"mcast\" : \"unicast\", msg.src(), key_server_addr, msg.printHeaders());\n+            if(last_key_request == 0 || System.currentTimeMillis() - last_key_request > 2000) {\n+                last_key_request=System.currentTimeMillis();\n+                sendKeyRequest();\n+            }\n+            return false;\n+        }\n+        return true;\n+    }\n+\n+    protected void handleSecretKeyRequest(final Message msg) {\n+        if(!inView(msg.src(), \"key requester %s is not in current view %s; ignoring key request\"))\n+            return;\n+        log.debug(\"%s: received key request from %s\", local_addr, msg.getSrc());\n+        try {\n+            PublicKey tmpKey=generatePubKey(msg.getBuffer());\n+            sendSecretKey(secret_key, tmpKey, msg.getSrc());\n+        }\n+        catch(Exception e) {\n+            log.warn(\"%s: unable to reconstitute peer's public key\", local_addr);\n+        }\n+    }\n+\n+\n+    protected void handleSecretKeyResponse(final Message msg, final byte[] key_version) {\n+        if(!inView(msg.src(), \"ignoring secret key sent by %s which is not in current view %s\"))\n+            return;\n+        try {\n+            SecretKey tmp=decodeKey(msg.getBuffer());\n+            if(tmp == null)\n+                sendKeyRequest(key_server_addr); // unable to understand response, let's try again\n+            else {\n+                // otherwise set the returned key as the shared key\n+                log.debug(\"%s: received secret key from keyserver %s\", local_addr, msg.getSrc());\n+                setKeys(tmp, key_version);\n+            }\n+        }\n+        catch(Exception e) {\n+            log.warn(\"%s: unable to process received public key\", local_addr, e);\n+        }\n+    }\n+\n+\n+    /** Initialise the symmetric key if none is supplied in a keystore */\n+    protected SecretKey createSecretKey() throws Exception {\n+        KeyGenerator keyGen=null;\n+        // see if we have a provider specified\n+        if(provider != null && !provider.trim().isEmpty())\n+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm), provider);\n+        else\n+            keyGen=KeyGenerator.getInstance(getAlgorithm(sym_algorithm));\n+        // generate the key using the defined init properties\n+        keyGen.init(sym_keylength);\n+        return keyGen.generateKey();\n+    }\n+\n+\n+\n+    /** Generates the public/private key pair from the init params */\n+    protected void initKeyPair() throws Exception {\n+        // generate keys according to the specified algorithms\n+        // generate publicKey and Private Key\n+        KeyPairGenerator KpairGen=null;\n+        if(provider != null && !provider.trim().isEmpty())\n+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm), provider);\n+        else\n+            KpairGen=KeyPairGenerator.getInstance(getAlgorithm(asym_algorithm));\n+        KpairGen.initialize(asym_keylength,new SecureRandom());\n+        key_pair=KpairGen.generateKeyPair();\n+\n+        // set up the Cipher to decrypt secret key responses encrypted with our key\n+        if(provider != null && !provider.trim().isEmpty())\n+            asym_cipher=Cipher.getInstance(asym_algorithm, provider);\n+        else\n+            asym_cipher=Cipher.getInstance(asym_algorithm);\n+        asym_cipher.init(Cipher.DECRYPT_MODE, key_pair.getPrivate());\n+    }\n+\n+\n+    @Override protected synchronized void handleView(View v) {\n+        boolean left_mbrs=change_key_on_leave && this.view != null && !v.containsMembers(this.view.getMembersRaw());\n+        super.handleView(v);\n+        Address tmpKeyServer=v.getCoord(); // the coordinator is the keyserver\n+        if(tmpKeyServer.equals(local_addr)) {\n+            if(!is_key_server || left_mbrs)\n+                becomeKeyServer(tmpKeyServer, left_mbrs);\n+        }\n+        else\n+            handleNewKeyServer(tmpKeyServer, v instanceof MergeView, left_mbrs);\n+    }\n+\n+\n+    protected void becomeKeyServer(Address tmpKeyServer, boolean left_mbrs) {\n+        if(log.isDebugEnabled()) {\n+            if(!is_key_server)\n+                log.debug(\"%s: I'm the new key server\", local_addr);\n+            else if(left_mbrs)\n+                log.debug(\"%s: creating new secret key because members left\", local_addr);\n+        }\n+        key_server_addr=tmpKeyServer;\n+        is_key_server=true;\n+        try {\n+            this.secret_key=createSecretKey();\n+            initSymCiphers(sym_algorithm, secret_key);\n+            drainUpQueue();\n+        }\n+        catch(Exception ex) {\n+            log.error(\"%s: failed creating secret key and initializing ciphers\", local_addr, ex);\n+        }\n+    }\n+\n+    /** If the keyserver changed, send a request for the secret key to the keyserver */\n+    protected void handleNewKeyServer(Address newKeyServer, boolean merge_view, boolean left_mbrs) {\n+        if(keyServerChanged(newKeyServer) || merge_view || left_mbrs) {\n+            secret_key=null;\n+            sym_version=null;\n+            queue_up_msgs=true;\n+            key_server_addr=newKeyServer;\n+            is_key_server=false;\n+            log.debug(\"%s: sending request for secret key to the new keyserver %s\", local_addr, key_server_addr);\n+            sendKeyRequest(key_server_addr);\n+        }\n+    }\n+\n+\tprotected boolean keyServerChanged(Address newKeyServer) {\n+\t\treturn !Objects.equals(key_server_addr, newKeyServer);\n+\t}\n+\n+\n+\n+    protected void setKeys(SecretKey key, byte[] version) throws Exception {\n+        if(Arrays.equals(this.sym_version, version))\n+            return;\n+\n+        // System.out.printf(\"%s: ******** setting sym_version (%s) to %s\\n\", local_addr,\n+           //               Util.byteArrayToHexString(this.sym_version), Util.byteArrayToHexString(version));\n+\n+        Cipher decoding_cipher=secret_key != null? decoding_ciphers.take() : null;\n+        // put the previous key into the map, keep the cipher: no leak, as we'll clear decoding_ciphers in initSymCiphers()\n+        if(decoding_cipher != null)\n+            key_map.put(new AsciiString(version), decoding_cipher);\n+        secret_key=key;\n+        initSymCiphers(key.getAlgorithm(), key);\n+        sym_version=version;\n+        drainUpQueue();\n+    }\n+\n+\n+    protected void sendSecretKey(SecretKey secret_key, PublicKey public_key, Address source) throws Exception {\n+        byte[] encryptedKey=encryptSecretKey(secret_key, public_key);\n+        Message newMsg=new Message(source, local_addr, encryptedKey)\n+          .putHeader(this.id, new EncryptHeader(EncryptHeader.SECRET_KEY_RSP, symVersion()));\n+        log.debug(\"%s: sending secret key to %s\", local_addr, source);\n+        down_prot.down(new Event(Event.MSG,newMsg));\n+    }\n+\n+    /** Encrypts the current secret key with the requester's public key (the requester will decrypt it with its private key) */\n+    protected byte[] encryptSecretKey(SecretKey secret_key, PublicKey public_key) throws Exception {\n+        Cipher tmp;\n+        if (provider != null && !provider.trim().isEmpty())\n+            tmp=Cipher.getInstance(asym_algorithm, provider);\n+        else\n+            tmp=Cipher.getInstance(asym_algorithm);\n+        tmp.init(Cipher.ENCRYPT_MODE, public_key);\n+\n+        // encrypt current secret key\n+        return tmp.doFinal(secret_key.getEncoded());\n+    }\n+\n+\n+    /** send client's public key to server and request server's public key */\n+    protected void sendKeyRequest(Address key_server) {\n+        Message newMsg=new Message(key_server, local_addr, key_pair.getPublic().getEncoded())\n+          .putHeader(this.id,new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, sym_version));\n+        down_prot.down(new Event(Event.MSG,newMsg));\n+    }\n+\n+\n+    protected SecretKeySpec decodeKey(byte[] encodedKey) throws Exception {\n+        byte[] keyBytes;\n+\n+        synchronized(this) {\n+            keyBytes=asym_cipher.doFinal(encodedKey);\n+        }\n+\n+        try {\n+            SecretKeySpec keySpec=new SecretKeySpec(keyBytes, getAlgorithm(sym_algorithm));\n+            Cipher temp;\n+            if (provider != null && !provider.trim().isEmpty())\n+                temp=Cipher.getInstance(sym_algorithm, provider);\n+            else\n+                temp=Cipher.getInstance(sym_algorithm);\n+            temp.init(Cipher.SECRET_KEY, keySpec);\n+            return keySpec;\n+        }\n+        catch(Exception e) {\n+            log.error(Util.getMessage(\"FailedDecodingKey\"), e);\n+            return null;\n+        }\n+    }\n+\n+    // doesn't have to be 100% correct: leftover messages wll be delivered later and will be discarded as dupes, as\n+    // retransmission is likely to have kicked in before anyway\n+    protected void drainUpQueue() {\n+        queue_up_msgs=false;\n+        Message queued_msg;\n+        while((queued_msg=up_queue.poll()) != null) {\n+            try {\n+                Message decrypted_msg=decryptMessage(null, queued_msg.copy());\n+                if(decrypted_msg != null)\n+                    up_prot.up(new Event(Event.MSG, decrypted_msg));\n+            }\n+            catch(Exception ex) {\n+                log.error(\"failed decrypting message from %s: %s\", queued_msg.src(), ex);\n+            }\n+        }\n+    }\n+\n+\n+    @Override protected void handleUnknownVersion() {\n+        if(!is_key_server)\n+            sendKeyRequest(key_server_addr);\n+    }\n+\n+    /** Used to reconstitute public key sent in byte form from peer */\n+    protected PublicKey generatePubKey(byte[] encodedKey) {\n+        PublicKey pubKey=null;\n+        try {\n+            KeyFactory KeyFac=KeyFactory.getInstance(getAlgorithm(asym_algorithm));\n+            X509EncodedKeySpec x509KeySpec=new X509EncodedKeySpec(encodedKey);\n+            pubKey=KeyFac.generatePublic(x509KeySpec);\n+        }\n+        catch(Exception e) {\n+            e.printStackTrace();\n+        }\n+        return pubKey;\n+    }\n+\n+}"
        },
        {
            "sha": "01bd848a50126571261066dbe2c9379d4712c207",
            "filename": "src/org/jgroups/protocols/AUTH.java",
            "status": "modified",
            "additions": 56,
            "deletions": 54,
            "changes": 110,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FAUTH.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -19,7 +19,9 @@\n \n \n /**\n- * The AUTH protocol adds a layer of authentication to JGroups\n+ * The AUTH protocol adds a layer of authentication to JGroups. It intercepts join and merge requests and rejects them\n+ * if the joiner or merger is not permitted to join a or merge into a cluster. AUTH should be placed right below\n+ * {@link GMS} in the configuration.\n  * @author Chris Mills\n  * @author Bela Ban\n  */\n@@ -41,16 +43,16 @@ public interface UpHandler {\n         /**\n          * Called when an up event has been received\n          * @param evt the event\n-         * @return true if the event should be pass up, else false\n+         * @return true if the event should be passed up, else false\n          */\n         boolean handleUpEvent(Event evt);\n     }\n \n \n     /** Used on the coordinator to authentication joining member requests against */\n-    protected AuthToken             auth_token=null;\n+    protected AuthToken             auth_token;\n \n-    protected static final short    gms_id=ClassConfigurator.getProtocolId(GMS.class);\n+    protected static final short    GMS_ID=ClassConfigurator.getProtocolId(GMS.class);\n \n     /** List of UpHandler which are called when an up event has been received. Usually used by AuthToken impls */\n     protected final List<UpHandler> up_handlers=new ArrayList<>();\n@@ -60,14 +62,14 @@ public interface UpHandler {\n \n     public AUTH() {name=\"AUTH\";}\n \n-    private volatile boolean authenticateCoord = false;\n+    protected volatile boolean      authenticate_coord=true;\n     \n-   @Property(name=\"authenticate_coord\")\n-   public void setAuthCoord( boolean authenticateCoord) {\n-\t   this.authenticateCoord = authenticateCoord;\n-   }\n+    @Property(description=\"Do join or merge responses from the coordinator also need to be authenticated\")\n+    public AUTH setAuthCoord( boolean authenticateCoord) {\n+        this.authenticate_coord= authenticateCoord; return this;\n+    }\n \n-    @Property(name=\"auth_class\")\n+    @Property(name=\"auth_class\",description=\"The fully qualified name of the class implementing the AuthToken interface\")\n     public void setAuthClass(String class_name) throws Exception {\n         Object obj=Class.forName(class_name).newInstance();\n         auth_token=(AuthToken)obj;\n@@ -76,9 +78,9 @@ public void setAuthClass(String class_name) throws Exception {\n \n     public String    getAuthClass()                {return auth_token != null? auth_token.getClass().getName() : null;}\n     public AuthToken getAuthToken()                {return auth_token;}\n-    public void      setAuthToken(AuthToken token) {this.auth_token=token;}\n-    public void      register(UpHandler handler)   {up_handlers.add(handler);}\n-    public void      unregister(UpHandler handler) {up_handlers.remove(handler);}\n+    public AUTH      setAuthToken(AuthToken token) {this.auth_token=token; return this;}\n+    public AUTH      register(UpHandler handler)   {up_handlers.add(handler); return this;}\n+    public AUTH      unregister(UpHandler handler) {up_handlers.remove(handler);return this;}\n     public Address   getAddress()                  {return local_addr;}\n     public PhysicalAddress getPhysicalAddress()    {return getTransport().getPhysicalAddress();}\n \n@@ -92,6 +94,8 @@ protected List<Object> getConfigurableObjects() {\n \n     public void init() throws Exception {\n         super.init();\n+        if(auth_token == null)\n+            throw new IllegalStateException(\"no authentication mechanism configured\");\n         if(auth_token instanceof X509Token) {\n             X509Token tmp=(X509Token)auth_token;\n             tmp.setCertificate();\n@@ -118,13 +122,11 @@ public void destroy() {\n     }\n \n     /**\n-     * An event was received from the layer below. Usually the current layer will want to examine\n-     * the event type and - depending on its type - perform some computation\n-     * (e.g. removing headers from a MSG event type, or updating the internal membership list\n-     * when receiving a VIEW_CHANGE event).\n-     * Finally the event is either a) discarded, or b) an event is sent down\n-     * the stack using <code>down_prot.down()</code> or c) the event (or another event) is sent up\n-     * the stack using <code>up_prot.up()</code>.\n+     * An event was received from the layer below. Usually the current layer will want to examine the event type and\n+     * - depending on its type - perform some computation (e.g. removing headers from a MSG event type, or updating\n+     * the internal membership list when receiving a VIEW_CHANGE event).\n+     * Finally the event is either a) discarded, or b) an event is sent down the stack using {@code down_prot.down()}\n+     * or c) the event (or another event) is sent up the stack using {@code up_prot.up()}.\n      */\n     public Object up(Event evt) {\n         switch(evt.getType()) {\n@@ -136,7 +138,7 @@ public Object up(Event evt) {\n                 if(gms_hdr != null && needsAuthentication(gms_hdr)) {\n                     AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);\n                     if(auth_hdr == null)\n-                        throw new IllegalStateException(\"found GMS join or merge request but no AUTH header\");\n+                        throw new IllegalStateException(String.format(\"found %s from %s but no AUTH header\", gms_hdr, msg.src()));\n                     if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed\n                         return null;    // don't pass up\n                 }\n@@ -155,7 +157,7 @@ public void up(MessageBatch batch) {\n             if(gms_hdr != null && needsAuthentication(gms_hdr)) {\n                 AuthHeader auth_hdr=(AuthHeader)msg.getHeader(id);\n                 if(auth_hdr == null) {\n-                    log.warn(\"found GMS join or merge request but no AUTH header\");\n+                    log.warn(\"%s: found GMS join or merge request from %s but no AUTH header\", local_addr, batch.sender());\n                     sendRejectionMessage(gms_hdr.getType(), batch.sender(), \"join or merge without an AUTH header\");\n                     batch.remove(msg);\n                 }\n@@ -172,17 +174,16 @@ else if(!handleAuthHeader(gms_hdr, auth_hdr, msg)) // authentication failed\n      * An event is to be sent down the stack. The layer may want to examine its type and perform\n      * some action on it, depending on the event's type. If the event is a message MSG, then\n      * the layer may need to add a header to it (or do nothing at all) before sending it down\n-     * the stack using <code>down_prot.down()</code>. In case of a GET_ADDRESS event (which tries to\n+     * the stack using {@code down_prot.down()}. In case of a GET_ADDRESS event (which tries to\n      * retrieve the stack's address from one of the bottom layers), the layer may need to send\n-     * a new response event back up the stack using <code>up_prot.up()</code>.\n+     * a new response event back up the stack using {@code up_prot.up()}.\n      */\n     public Object down(Event evt) {\n         GMS.GmsHeader hdr = getGMSHeader(evt);\n         if(hdr != null && needsAuthentication(hdr)) {\n             // we found a join request message - now add an AUTH Header\n-            Message msg = (Message)evt.getArg();\n-            AuthHeader authHeader = new AuthHeader(this.auth_token);\n-            msg.putHeader(this.id, authHeader);\n+            Message msg=(Message)evt.getArg();\n+            msg.putHeader(this.id, new AuthHeader(this.auth_token));\n         }\n \n         if(evt.getType() == Event.SET_LOCAL_ADDRESS)\n@@ -194,17 +195,18 @@ public Object down(Event evt) {\n \n \n     protected boolean needsAuthentication(GMS.GmsHeader hdr) {\n-    \tswitch(hdr.getType()) {\n-        case GMS.GmsHeader.JOIN_REQ:\n-        case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n-        case GMS.GmsHeader.MERGE_REQ:\n-            return true;\n-        case GMS.GmsHeader.JOIN_RSP:\n-        case GMS.GmsHeader.MERGE_RSP:\n-        \treturn this.authenticateCoord;\n-        default:\n-            return false;\n-            }\n+        switch(hdr.getType()) {\n+            case GMS.GmsHeader.JOIN_REQ:\n+            case GMS.GmsHeader.JOIN_REQ_WITH_STATE_TRANSFER:\n+            case GMS.GmsHeader.MERGE_REQ:\n+                return true;\n+            case GMS.GmsHeader.JOIN_RSP:\n+            case GMS.GmsHeader.MERGE_RSP:\n+            case GMS.GmsHeader.INSTALL_MERGE_VIEW:\n+                return this.authenticate_coord;\n+            default:\n+                return false;\n+        }\n     }\n \n \n@@ -215,17 +217,17 @@ protected boolean needsAuthentication(GMS.GmsHeader hdr) {\n      * @return true if the message should be passed up, or else false\n      */\n     protected boolean handleAuthHeader(GMS.GmsHeader gms_hdr, AuthHeader auth_hdr, Message msg) {\n-    \tif ( needsAuthentication(gms_hdr)) {\n-            if(this.auth_token.authenticate(auth_hdr.getToken(), msg)) {\n+        if(needsAuthentication(gms_hdr)) {\n+            if(this.auth_token.authenticate(auth_hdr.getToken(), msg))\n                 return true; //  authentication passed, send message up the stack\n-            } else {\n-                log.warn(\"failed to validate AuthHeader token from \" + msg.getSrc() + \", token: \" + auth_token);\n+            else {\n+                log.warn(\"%s: failed to validate AuthHeader (token: %s) from %s; dropping message\",\n+                         local_addr, auth_token.getClass().getSimpleName(), msg.src());\n                 sendRejectionMessage(gms_hdr.getType(), msg.getSrc(), \"authentication failed\");\n                 return false;\n             }\n-    \t} else {\n-    \t\treturn true;\n-    \t}\n+        }\n+        return true;\n     }\n \n \n@@ -238,9 +240,6 @@ protected void sendRejectionMessage(byte type, Address dest, String error_msg) {\n             case GMS.GmsHeader.MERGE_REQ:\n                 sendMergeRejectionMessage(dest);\n                 break;\n-            default:\n-                log.error(\"type \" + type + \" unknown\");\n-                break;\n         }\n     }\n \n@@ -249,24 +248,27 @@ protected void sendJoinRejectionMessage(Address dest, String error_msg) {\n             return;\n \n         JoinRsp joinRes=new JoinRsp(error_msg); // specify the error message on the JoinRsp\n-        Message msg = new Message(dest).putHeader(gms_id, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))\n+        Message msg = new Message(dest).putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP))\n           .setBuffer(GMS.marshal(joinRes));\n+        if(this.authenticate_coord)\n+            msg.putHeader(this.id, new AuthHeader(this.auth_token));\n         down_prot.down(new Event(Event.MSG, msg));\n     }\n \n     protected void sendMergeRejectionMessage(Address dest) {\n-        Message msg=new Message(dest).setFlag(Message.Flag.OOB);\n         GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.MERGE_RSP);\n         hdr.setMergeRejected(true);\n-        msg.putHeader(gms_id, hdr);\n-        if(log.isDebugEnabled()) log.debug(\"merge response=\" + hdr);\n+        Message msg=new Message(dest).setFlag(Message.Flag.OOB).putHeader(GMS_ID, hdr);\n+        if(this.authenticate_coord)\n+            msg.putHeader(this.id, new AuthHeader(this.auth_token));\n+        log.debug(\"merge response=%s\", hdr);\n         down_prot.down(new Event(Event.MSG, msg));\n     }\n \n     protected boolean callUpHandlers(Event evt) {\n         boolean pass_up=true;\n         for(UpHandler handler: up_handlers) {\n-            if(handler.handleUpEvent(evt) == false)\n+            if(!handler.handleUpEvent(evt))\n                 pass_up=false;\n         }\n         return pass_up;\n@@ -282,7 +284,7 @@ protected static GMS.GmsHeader getGMSHeader(Event evt){\n     }\n \n     protected static GMS.GmsHeader getGMSHeader(Message msg){\n-        Header hdr = msg.getHeader(gms_id);\n+        Header hdr = msg.getHeader(GMS_ID);\n         if(hdr instanceof GMS.GmsHeader)\n             return (GMS.GmsHeader)hdr;\n         return null;"
        },
        {
            "sha": "fffad51993e79a5aa6afdcc13f5ce30853b4fd0b",
            "filename": "src/org/jgroups/protocols/EncryptBase.java",
            "status": "added",
            "additions": 437,
            "deletions": 0,
            "changes": 437,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptBase.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,437 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.annotations.ManagedAttribute;\n+import org.jgroups.annotations.Property;\n+import org.jgroups.stack.Protocol;\n+import org.jgroups.util.*;\n+\n+import javax.crypto.Cipher;\n+import javax.crypto.SecretKey;\n+import java.security.MessageDigest;\n+import java.util.Arrays;\n+import java.util.Map;\n+import java.util.WeakHashMap;\n+import java.util.concurrent.ArrayBlockingQueue;\n+import java.util.concurrent.BlockingQueue;\n+import java.util.zip.Adler32;\n+import java.util.zip.CRC32;\n+import java.util.zip.Checksum;\n+\n+/**\n+ * Super class of symmetric ({@link SYM_ENCRYPT}) and asymmetric ({@link ASYM_ENCRYPT}) encryption protocols.\n+ * @author Bela Ban\n+ */\n+public abstract class EncryptBase extends Protocol {\n+    protected static final String DEFAULT_SYM_ALGO=\"AES\";\n+\n+\n+    /* -----------------------------------------    Properties     -------------------------------------------------- */\n+    @Property(description=\"Cryptographic Service Provider\")\n+    protected String                        provider;\n+\n+    @Property(description=\"Cipher engine transformation for asymmetric algorithm. Default is RSA\")\n+    protected String                        asym_algorithm=\"RSA\";\n+\n+    @Property(description=\"Cipher engine transformation for symmetric algorithm. Default is AES\")\n+    protected String                        sym_algorithm=DEFAULT_SYM_ALGO;\n+\n+    @Property(description=\"Initial public/private key length. Default is 512\")\n+    protected int                           asym_keylength=512;\n+\n+    @Property(description=\"Initial key length for matching symmetric algorithm. Default is 128\")\n+    protected int                           sym_keylength=128;\n+\n+    @Property(description=\"Number of ciphers in the pool to parallelize encrypt and decrypt requests\",writable=false)\n+    protected int                           cipher_pool_size=8;\n+\n+    @Property(description=\"If true, the entire message (including payload and headers) is encrypted, else only the payload\")\n+    protected boolean                       encrypt_entire_message=true;\n+\n+    @Property(description=\"If true, all messages are digitally signed by adding an encrypted checksum of the encrypted \" +\n+      \"message to the header. Ignored if encrypt_entire_message is false\")\n+    protected boolean                       sign_msgs=true;\n+\n+    @Property(description=\"When sign_msgs is true, by default CRC32 is used to create the checksum. If use_adler is \" +\n+      \"true, Adler32 will be used\")\n+    protected boolean                       use_adler;\n+\n+    protected volatile Address              local_addr;\n+\n+    protected volatile View                 view;\n+\n+    // Cipher pools used for encryption and decryption. Size is cipher_pool_size\n+    protected BlockingQueue<Cipher>         encoding_ciphers, decoding_ciphers;\n+\n+    // version filed for secret key\n+    protected volatile byte[]               sym_version;\n+\n+    // shared secret key to encrypt/decrypt messages\n+    protected volatile SecretKey            secret_key;\n+\n+    // map to hold previous keys so we can decrypt some earlier messages if we need to\n+    protected final Map<AsciiString,Cipher> key_map=new WeakHashMap<>();\n+\n+\n+\n+    public int                      asymKeylength()                 {return asym_keylength;}\n+    public <T extends EncryptBase> T    asymKeylength(int len)          {this.asym_keylength=len; return (T)this;}\n+    public int                      symKeylength()                  {return sym_keylength;}\n+    public <T extends EncryptBase> T    symKeylength(int len)           {this.sym_keylength=len; return (T)this;}\n+    public SecretKey                secretKey()                     {return secret_key;}\n+    public <T extends EncryptBase> T    secretKey(SecretKey key)        {this.secret_key=key; return (T)this;}\n+    public String                   symAlgorithm()                  {return sym_algorithm;}\n+    public <T extends EncryptBase> T    symAlgorithm(String alg)        {this.sym_algorithm=alg; return (T)this;}\n+    public String                   asymAlgorithm()                 {return asym_algorithm;}\n+    public <T extends EncryptBase> T    asymAlgorithm(String alg)       {this.asym_algorithm=alg; return (T)this;}\n+    public byte[]                   symVersion()                    {return sym_version;}\n+    public <T extends EncryptBase> T    symVersion(byte[] v)            {this.sym_version=Arrays.copyOf(v, v.length); return (T)this;}\n+    public <T extends EncryptBase> T    localAddress(Address addr)      {this.local_addr=addr; return (T)this;}\n+    public boolean                  encryptEntireMessage()          {return encrypt_entire_message;}\n+    public <T extends EncryptBase> T    encryptEntireMessage(boolean b) {this.encrypt_entire_message=b; return (T)this;}\n+    public boolean                  signMessages()                  {return this.sign_msgs;}\n+    public <T extends EncryptBase> T    signMessages(boolean flag)      {this.sign_msgs=flag; return (T)this;}\n+    public boolean                  adler()                         {return use_adler;}\n+    public <T extends EncryptBase> T    adler(boolean flag)             {this.use_adler=flag; return (T)this;}\n+    @ManagedAttribute public String version()                       {return Util.byteArrayToHexString(sym_version);}\n+\n+    public void init() throws Exception {\n+        int tmp=Util.getNextHigherPowerOfTwo(cipher_pool_size);\n+        if(tmp != cipher_pool_size) {\n+            log.warn(\"%s: setting cipher_pool_size (%d) to %d (power of 2) for faster modulo operation\", local_addr, cipher_pool_size, tmp);\n+            cipher_pool_size=tmp;\n+        }\n+        encoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);\n+        decoding_ciphers=new ArrayBlockingQueue<>(cipher_pool_size);\n+        initSymCiphers(sym_algorithm, secret_key);\n+    }\n+\n+\n+    public Object down(Event evt) {\n+        switch(evt.getType()) {\n+            case Event.MSG:\n+                Message msg=evt.arg();\n+                try {\n+                    if(secret_key == null) {\n+                        log.trace(\"%s: discarded %s message to %s as secret key is null, hdrs: %s\",\n+                                  local_addr, msg.dest() == null? \"mcast\" : \"unicast\", msg.dest(), msg.printHeaders());\n+                        return null;\n+                    }\n+                    encryptAndSend(msg);\n+                }\n+                catch(Exception e) {\n+                    log.warn(\"%s: unable to send message down\", local_addr, e);\n+                }\n+                return null;\n+\n+            case Event.VIEW_CHANGE:\n+                handleView((View)evt.getArg());\n+                break;\n+\n+            case Event.SET_LOCAL_ADDRESS:\n+                local_addr=evt.arg();\n+                break;\n+        }\n+        return down_prot.down(evt);\n+    }\n+\n+\n+    public Object up(Event evt) {\n+        switch(evt.getType()) {\n+            case Event.VIEW_CHANGE:\n+                handleView((View)evt.getArg());\n+                break;\n+            case Event.MSG:\n+                Message msg=evt.arg();\n+                try {\n+                    return handleUpMessage(msg);\n+                }\n+                catch(Exception e) {\n+                    log.warn(\"%s: exception occurred decrypting message\", local_addr, e);\n+                }\n+                return null;\n+        }\n+        return up_prot.up(evt);\n+    }\n+\n+\n+    public void up(MessageBatch batch) {\n+        Cipher cipher=null;\n+        try {\n+            if(secret_key == null) {\n+                log.trace(\"%s: discarded %s batch from %s as secret key is null\",\n+                          local_addr, batch.dest() == null? \"mcast\" : \"unicast\", batch.sender());\n+                return;\n+            }\n+            MessageBatch.Visitor<Message> decrypter=new Decrypter(cipher=decoding_ciphers.take());\n+            batch.map(decrypter);\n+        }\n+        catch(InterruptedException e) {\n+            log.error(\"%s: failed processing batch; discarding batch\", local_addr, e);\n+            // we need to drop the batch if we for example have a failure fetching a cipher, or else other messages\n+            // in the batch might make it up the stack, bypassing decryption! This is not an issue because encryption\n+            // is below NAKACK2 or UNICAST3, so messages will get retransmitted\n+            return;\n+        }\n+        finally {\n+            if(cipher != null)\n+                decoding_ciphers.offer(cipher);\n+        }\n+        if(!batch.isEmpty())\n+            up_prot.up(batch);\n+    }\n+\n+\n+\n+    /** Initialises the ciphers for both encryption and decryption using the generated or supplied secret key */\n+    protected synchronized void initSymCiphers(String algorithm, SecretKey secret) throws Exception {\n+        if(secret == null)\n+            return;\n+        encoding_ciphers.clear();\n+        decoding_ciphers.clear();\n+        for(int i=0; i < cipher_pool_size; i++ ) {\n+            encoding_ciphers.add(createCipher(Cipher.ENCRYPT_MODE, secret, algorithm));\n+            decoding_ciphers.add(createCipher(Cipher.DECRYPT_MODE, secret, algorithm));\n+        };\n+\n+        //set the version\n+        MessageDigest digest=MessageDigest.getInstance(\"MD5\");\n+        digest.reset();\n+        digest.update(secret.getEncoded());\n+\n+        byte[] tmp=digest.digest();\n+        sym_version=Arrays.copyOf(tmp, tmp.length);\n+        log.debug(\"%s: created %d symmetric ciphers with secret key (%d bytes)\", local_addr, cipher_pool_size, sym_version.length);\n+    }\n+\n+\n+    protected Cipher createCipher(int mode, SecretKey secret_key, String algorithm) throws Exception {\n+        Cipher cipher=provider != null && !provider.trim().isEmpty()?\n+          Cipher.getInstance(algorithm, provider) : Cipher.getInstance(algorithm);\n+        cipher.init(mode, secret_key);\n+        return cipher;\n+    }\n+\n+\n+    protected Object handleUpMessage(Message msg) throws Exception {\n+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(this.id);\n+        if(hdr == null) {\n+            log.error(\"%s: received message without encrypt header from %s; dropping it\", local_addr, msg.src());\n+            return null;\n+        }\n+        switch(hdr.type()) {\n+            case EncryptHeader.ENCRYPT:\n+                return handleEncryptedMessage(msg);\n+            default:\n+                return handleUpEvent(msg,hdr);\n+        }\n+    }\n+\n+\n+    protected Object handleEncryptedMessage(Message msg) throws Exception {\n+        if(!process(msg))\n+            return null;\n+\n+        // try and decrypt the message - we need to copy msg as we modify its\n+        // buffer (http://jira.jboss.com/jira/browse/JGRP-538)\n+        Message tmpMsg=decryptMessage(null, msg.copy()); // need to copy for possible xmits\n+        if(tmpMsg != null)\n+            return up_prot.up(new Event(Event.MSG, tmpMsg));\n+        log.warn(\"%s: unrecognized cipher; discarding message from %s\", local_addr, msg.src());\n+        return null;\n+    }\n+\n+    protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+        return null;\n+    }\n+\n+    /** Whether or not to process this received message */\n+    protected boolean process(Message msg) {return true;}\n+\n+    protected void handleView(View view) {\n+        this.view=view;\n+    }\n+\n+    protected boolean inView(Address sender, String error_msg) {\n+        View curr_view=this.view;\n+        if(curr_view == null || curr_view.containsMember(sender))\n+            return true;\n+        log.error(error_msg, sender, curr_view);\n+        return false;\n+    }\n+\n+    protected Checksum createChecksummer() {return use_adler? new Adler32() : new CRC32();}\n+\n+\n+    /** Does the actual work for decrypting - if version does not match current cipher then tries the previous cipher */\n+    protected Message decryptMessage(Cipher cipher, Message msg) throws Exception {\n+        EncryptHeader hdr=(EncryptHeader)msg.getHeader(this.id);\n+        if(!Arrays.equals(hdr.version(), sym_version)) {\n+            cipher=key_map.get(new AsciiString(hdr.version()));\n+            if(cipher == null) {\n+                handleUnknownVersion();\n+                return null;\n+            }\n+            log.trace(\"%s: decrypting msg from %s using previous cipher version\", local_addr, msg.src());\n+            return _decrypt(cipher, msg, hdr);\n+        }\n+        return _decrypt(cipher, msg, hdr);\n+    }\n+\n+    protected Message _decrypt(final Cipher cipher, Message msg, EncryptHeader hdr) throws Exception {\n+        byte[] decrypted_msg;\n+\n+        if(!encrypt_entire_message && msg.getLength() == 0)\n+            return msg;\n+\n+        if(encrypt_entire_message && sign_msgs) {\n+            byte[] signature=hdr.signature();\n+            if(signature == null) {\n+                log.error(\"%s: dropped message from %s as the header did not have a checksum\", local_addr, msg.src());\n+                return null;\n+            }\n+\n+            long msg_checksum=decryptChecksum(cipher, signature, 0, signature.length);\n+            long actual_checksum=computeChecksum(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n+            if(actual_checksum != msg_checksum) {\n+                log.error(\"%s: dropped message from %s as the message's checksum (%d) did not match the computed checksum (%d)\",\n+                          local_addr, msg.src(), msg_checksum, actual_checksum);\n+                return null;\n+            }\n+        }\n+\n+        if(cipher == null)\n+            decrypted_msg=code(msg.getRawBuffer(), msg.getOffset(), msg.getLength(), true);\n+        else\n+            decrypted_msg=cipher.doFinal(msg.getRawBuffer(), msg.getOffset(), msg.getLength());\n+\n+        if(!encrypt_entire_message) {\n+            msg.setBuffer(decrypted_msg);\n+            return msg;\n+        }\n+\n+        Message ret=Util.streamableFromBuffer(Message.class,decrypted_msg,0,decrypted_msg.length);\n+        if(ret.getDest() == null)\n+            ret.setDest(msg.getDest());\n+        if(ret.getSrc() == null)\n+            ret.setSrc(msg.getSrc());\n+        return ret;\n+    }\n+\n+\n+    protected void encryptAndSend(Message msg) throws Exception {\n+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, symVersion());\n+        if(encrypt_entire_message) {\n+            if(msg.getSrc() == null)\n+                msg.setSrc(local_addr);\n+\n+            Buffer serialized_msg=Util.streamableToBuffer(msg);\n+            byte[] encrypted_msg=code(serialized_msg.getBuf(),serialized_msg.getOffset(),serialized_msg.getLength(),false);\n+\n+            if(sign_msgs) {\n+                long checksum=computeChecksum(encrypted_msg, 0, encrypted_msg.length);\n+                byte[] checksum_array=encryptChecksum(checksum);\n+                hdr.signature(checksum_array);\n+            }\n+\n+            // exclude existing headers, they will be seen again when we decrypt and unmarshal the msg at the receiver\n+            Message tmp=msg.copy(false, false).setBuffer(encrypted_msg).putHeader(this.id,hdr);\n+            down_prot.down(new Event(Event.MSG, tmp));\n+            return;\n+        }\n+\n+        // copy neeeded because same message (object) may be retransmitted -> prevent double encryption\n+        Message msgEncrypted=msg.copy(false).putHeader(this.id, hdr);\n+        if(msg.getLength() > 0)\n+            msgEncrypted.setBuffer(code(msg.getRawBuffer(),msg.getOffset(),msg.getLength(),false));\n+        down_prot.down(new Event(Event.MSG,msgEncrypted));\n+    }\n+\n+\n+    protected byte[] code(byte[] buf, int offset, int length, boolean decode) throws Exception {\n+        BlockingQueue<Cipher> queue=decode? decoding_ciphers : encoding_ciphers;\n+        Cipher cipher=queue.take();\n+        try {\n+            return cipher.doFinal(buf, offset, length);\n+        }\n+        finally {\n+            queue.offer(cipher);\n+        }\n+    }\n+\n+    protected long computeChecksum(byte[] input, int offset, int length) {\n+        Checksum checksummer=createChecksummer();\n+        checksummer.update(input, offset, length);\n+        return checksummer.getValue();\n+    }\n+\n+    protected byte[] encryptChecksum(long checksum) throws Exception {\n+        byte[] checksum_array=new byte[Global.LONG_SIZE];\n+        Bits.writeLong(checksum, checksum_array, 0);\n+        return code(checksum_array, 0, checksum_array.length, false);\n+    }\n+\n+    protected long decryptChecksum(final Cipher cipher, byte[] input, int offset, int length) throws Exception {\n+        byte[] decrypted_checksum;\n+        if(cipher == null)\n+            decrypted_checksum=code(input, offset, length, true);\n+        else\n+            decrypted_checksum=cipher.doFinal(input, offset, length);\n+        return Bits.readLong(decrypted_checksum, 0);\n+    }\n+\n+\n+    /* Get the algorithm name from \"algorithm/mode/padding\"  taken from original ENCRYPT */\n+    protected static String getAlgorithm(String s) {\n+        int index=s.indexOf('/');\n+        return index == -1? s : s.substring(0, index);\n+    }\n+\n+\n+    /** Called when the version shipped in the header can't be found */\n+    protected void handleUnknownVersion() {}\n+\n+\n+    /** Decrypts all messages in a batch, replacing encrypted messages in-place with their decrypted versions */\n+    protected class Decrypter implements MessageBatch.Visitor<Message> {\n+        protected final Cipher cipher;\n+\n+        public Decrypter(Cipher cipher) {\n+            this.cipher=cipher;\n+        }\n+\n+        public Message visit(Message msg, MessageBatch batch) {\n+            EncryptHeader hdr;\n+            if((hdr=(EncryptHeader)msg.getHeader(id)) == null) {\n+                log.error(\"%s: received message without encrypt header from %s; dropping it\", local_addr, batch.sender());\n+                batch.remove(msg); // remove from batch to prevent passing the message further up as part of the batch\n+                return null;\n+            }\n+\n+            if(hdr.type() == EncryptHeader.ENCRYPT) {\n+                try {\n+                    if(!process(msg)) {\n+                        batch.remove(msg);\n+                        return null;\n+                    }\n+                    Message tmpMsg=decryptMessage(cipher, msg.copy()); // need to copy for possible xmits\n+                    if(tmpMsg != null)\n+                        batch.replace(msg, tmpMsg);\n+                    else\n+                        batch.remove(msg);\n+                }\n+                catch(Exception e) {\n+                    log.error(\"%s: failed decrypting message from %s (offset=%d, length=%d, buf.length=%d): %s, headers are %s\",\n+                              local_addr, msg.getSrc(), msg.getOffset(), msg.getLength(), msg.getRawBuffer().length, e, msg.printHeaders());\n+                    batch.remove(msg);\n+                }\n+            }\n+            else {\n+                batch.remove(msg); // a control message will get handled by ENCRYPT and should not be passed up\n+                handleUpEvent(msg, hdr);\n+            }\n+            return null;\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "3142bbe8818b58a6c83327fad5d3acf20cf03667",
            "filename": "src/org/jgroups/protocols/EncryptHeader.java",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FEncryptHeader.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,65 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.Global;\n+import org.jgroups.Header;\n+import org.jgroups.util.Util;\n+\n+import java.io.DataInput;\n+import java.io.DataOutput;\n+\n+/**\n+ * @author Bela Ban\n+ * @since  3.6.10\n+ */\n+public class EncryptHeader extends Header {\n+    public static final byte ENCRYPT        = 1 << 0;\n+    public static final byte SECRET_KEY_REQ = 1 << 1;\n+    public static final byte SECRET_KEY_RSP = 1 << 2;\n+\n+    protected byte   type;\n+    protected byte[] version;\n+    protected byte[] signature; // the encrypted checksum\n+\n+\n+    public EncryptHeader() {}\n+\n+\n+    public EncryptHeader(byte type, byte[] version) {\n+        this.type=type;\n+        this.version=version;\n+    }\n+\n+    public byte          type()              {return type;}\n+    public byte          getType()           {return type;}\n+    public byte[]        version()           {return version;}\n+    public byte[]        getVersion()        {return version;}\n+    public byte[]        signature()         {return signature;}\n+    public EncryptHeader signature(byte[] s) {this.signature=s; return this;}\n+\n+    public void writeTo(DataOutput out) throws Exception {\n+        out.writeByte(type);\n+        Util.writeByteBuffer(version, 0, version != null? version.length : 0, out);\n+        Util.writeByteBuffer(signature, 0, signature != null? signature.length : 0, out);\n+    }\n+\n+    public void readFrom(DataInput in) throws Exception {\n+        type=in.readByte();\n+        version=Util.readByteBuffer(in);\n+        signature=Util.readByteBuffer(in);\n+    }\n+\n+    public String toString() {\n+        return String.format(\"[%s version=%s]\", typeToString(type), (version != null? version.length + \" bytes\" : \"n/a\"));\n+    }\n+\n+    public int size() {return Global.BYTE_SIZE + Util.size(version) + Util.size(signature) /*+ Util.size(payload) */;}\n+\n+    protected static String typeToString(byte type) {\n+        switch(type) {\n+            case ENCRYPT:        return \"ENCRYPT\";\n+            case SECRET_KEY_REQ: return \"SECRET_KEY_REQ\";\n+            case SECRET_KEY_RSP: return \"SECRET_KEY_RSP\";\n+            default:             return \"<unrecognized type \" + type;\n+        }\n+    }\n+}"
        },
        {
            "sha": "9ce628951c3bcc569f86810cea3870a292fea153",
            "filename": "src/org/jgroups/protocols/SYM_ENCRYPT.java",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,124 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.annotations.MBean;\n+import org.jgroups.annotations.Property;\n+import org.jgroups.util.Util;\n+\n+import javax.crypto.SecretKey;\n+import java.io.FileInputStream;\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.security.KeyStore;\n+import java.security.NoSuchAlgorithmException;\n+import java.security.cert.CertificateException;\n+\n+/**\n+ * Encrypts and decrypts communication in JGroups by using a secret key shared by all cluster members.<p>\n+ *\n+ * The secret key is identical for all cluster members and is injected into this protocol at startup, e.g. by reading\n+ * it from a keystore. Messages are sent by encrypting them with the secret key and received by decrypting them with\n+ * the secret key. Note that all cluster members must be shipped with the same keystore file<p>\n+ *\n+ * This protocol is typically placed under {@link org.jgroups.protocols.pbcast.NAKACK2}, so that most important\n+ * headers are encrypted as well, to prevent replay attacks.<p>\n+ *\n+ * A possible configuration looks like this:<br><br>\n+ * {@code <SYM_ENCRYPT key_store_name=\"defaultStore.keystore\" store_password=\"changeit\" alias=\"myKey\"/>}\n+ * <br>\n+ * <br>\n+ * In order to use SYM_ENCRYPT layer in this manner, it is necessary to have the secret key already generated in a\n+ * keystore file. The directory containing the keystore file must be on the application's classpath. You cannot create a\n+ * secret key keystore file using the keytool application shipped with the JDK. A java file called KeyStoreGenerator is\n+ * included in the demo package that can be used from the command line (or IDE) to generate a suitable keystore.\n+ *\n+ * @author Bela Ban\n+ * @author Steve Woodcock\n+ */\n+@MBean(description=\"Symmetric encryption protocol. The (shared) shared secret key is configured up front, \" +\n+  \"e.g. via a key store, or injection\")\n+public class SYM_ENCRYPT extends EncryptBase {\n+\n+    /* -----------------------------------------    Properties     -------------------------------------------------- */\n+    @Property(description=\"File on classpath that contains keystore repository\")\n+    protected String   keystore_name;\n+\n+    @Property(description=\"Password used to check the integrity/unlock the keystore. Change the default\",\n+      exposeAsManagedAttribute=false)\n+    protected String   store_password=\"changeit\"; // JDK default\n+\n+    @Property(description=\"Password for recovering the key. Change the default\", exposeAsManagedAttribute=false)\n+    protected String   key_password; // allows to assign keypwd=storepwd if not set (https://issues.jboss.org/browse/JGRP-1375)\n+\n+\n+    @Property(name=\"alias\", description=\"Alias used for recovering the key. Change the default\",exposeAsManagedAttribute=false)\n+    protected String   alias=\"mykey\"; // JDK default\n+\n+\n+    public String      keystoreName()                      {return this.keystore_name;}\n+    public SYM_ENCRYPT keystoreName(String n)              {this.keystore_name=n; return this;}\n+    public String      alias()                             {return alias;}\n+    public SYM_ENCRYPT alias(String a)                     {this.alias=a; return this;}\n+    public String      storePassword()                     {return store_password;}\n+    public SYM_ENCRYPT storePassword(String pwd)           {this.store_password=pwd; return this;}\n+\n+\n+\n+\n+    public void init() throws Exception {\n+        if(key_password == null && store_password != null) {\n+            key_password=store_password;\n+            log.debug(\"%s: key_password used is same as store_password\", local_addr);\n+        }\n+        readSecretKeyFromKeystore();\n+        super.init();\n+    }\n+\n+    /**\n+     * Initialisation if a supplied key is defined in the properties. This supplied key must be in a keystore which\n+     * can be generated using the keystoreGenerator file in demos. The keystore must be on the classpath to find it.\n+     */\n+    protected void readSecretKeyFromKeystore() throws Exception {\n+        InputStream inputStream=null;\n+        // must not use default keystore type - as it does not support secret keys\n+        KeyStore store=KeyStore.getInstance(\"JCEKS\");\n+\n+        SecretKey tempKey=null;\n+        try {\n+            if(this.secret_key == null) { // in case the secret key was set before, e.g. via injection in a unit test\n+                // load in keystore using this thread's classloader\n+                inputStream=Thread.currentThread().getContextClassLoader().getResourceAsStream(keystore_name);\n+                if(inputStream == null)\n+                    inputStream=new FileInputStream(keystore_name);\n+                // we can't find a keystore here -\n+                if(inputStream == null)\n+                    throw new Exception(\"Unable to load keystore \" + keystore_name + \" ensure file is on classpath\");\n+                // we have located a file lets load the keystore\n+                try {\n+                    store.load(inputStream, store_password.toCharArray());\n+                    // loaded keystore - get the key\n+                    tempKey=(SecretKey)store.getKey(alias, key_password.toCharArray());\n+                }\n+                catch(IOException e) {\n+                    throw new Exception(\"Unable to load keystore \" + keystore_name + \": \" + e);\n+                }\n+                catch(NoSuchAlgorithmException e) {\n+                    throw new Exception(\"No Such algorithm \" + keystore_name + \": \" + e);\n+                }\n+                catch(CertificateException e) {\n+                    throw new Exception(\"Certificate exception \" + keystore_name + \": \" + e);\n+                }\n+\n+                if(tempKey == null)\n+                    throw new Exception(\"Unable to retrieve key '\" + alias + \"' from keystore \" + keystore_name);\n+                this.secret_key=tempKey;\n+                if(sym_algorithm.equals(DEFAULT_SYM_ALGO))\n+                    sym_algorithm=tempKey.getAlgorithm();\n+            }\n+        }\n+        finally {\n+            Util.close(inputStream);\n+        }\n+    }\n+\n+\n+}"
        },
        {
            "sha": "db0813f353145df6d26e21da17aa3ad4b441f348",
            "filename": "src/org/jgroups/util/MyReceiver.java",
            "status": "modified",
            "additions": 5,
            "deletions": 3,
            "changes": 8,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FMyReceiver.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -3,27 +3,29 @@\n import org.jgroups.Message;\n import org.jgroups.ReceiverAdapter;\n \n-import java.util.ArrayList;\n import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n \n /**\n  * Generic receiver for a JChannel\n  * @author Bela Ban\n  * @since  3.3\n  */\n public class MyReceiver<T> extends ReceiverAdapter {\n-    protected final List<T> list=new ArrayList<>();\n+    protected final List<T> list=new CopyOnWriteArrayList<>();\n     protected String        name;\n     protected boolean       verbose;\n+    protected boolean       raw_msgs;\n \n     public void receive(Message msg) {\n-        T obj=(T)msg.getObject();\n+        T obj=raw_msgs? (T)msg : (T)msg.getObject();\n         list.add(obj);\n         if(verbose) {\n             System.out.println((name() != null? name() + \":\" : \"\") + \" received message from \" + msg.getSrc() + \": \" + obj);\n         }\n     }\n \n+    public MyReceiver    rawMsgs(boolean flag) {this.raw_msgs=flag; return this;}\n     public List<T>       list()                {return list;}\n     public MyReceiver<T> verbose(boolean flag) {verbose=flag; return this;}\n     public String        name()                {return name;}"
        },
        {
            "sha": "4c25e3d63580ee37059577e2e60f1ee347626ab2",
            "filename": "src/org/jgroups/util/Util.java",
            "status": "modified",
            "additions": 15,
            "deletions": 2,
            "changes": 17,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Futil%2FUtil.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/src%2Forg%2Fjgroups%2Futil%2FUtil.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/src%2Forg%2Fjgroups%2Futil%2FUtil.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -861,6 +861,18 @@ public static String bytesToString(byte[] bytes) {\n         return bytes != null? new String(bytes) : null;\n     }\n \n+    public static String byteArrayToHexString(byte[] b) {\n+        if(b == null)\n+            return \"null\";\n+        StringBuilder sb = new StringBuilder(b.length * 2);\n+        for (int i = 0; i < b.length; i++){\n+            int v = b[i] & 0xff;\n+            if (v < 16) { sb.append('0'); }\n+            sb.append(Integer.toHexString(v));\n+        }\n+        return sb.toString().toUpperCase();\n+    }\n+\n     /** Compares 2 byte arrays, elements are treated as unigned */\n     public static int compare(byte[] left,byte[] right) {\n         for(int i=0, j=0; i < left.length && j < right.length; i++,j++) {\n@@ -1016,10 +1028,11 @@ public static int size(String s) {\n     }\n \n     public static int size(byte[] buf) {\n-        int retval=Global.BYTE_SIZE + Global.INT_SIZE;\n+       /* int retval=Global.BYTE_SIZE + Global.INT_SIZE;\n         if(buf != null)\n             retval+=buf.length;\n-        return retval;\n+        return retval;*/\n+        return buf == null? Global.BYTE_SIZE : Global.BYTE_SIZE + Global.INT_SIZE + buf.length;\n     }\n \n     private static Address readOtherAddress(DataInput in) throws Exception {"
        },
        {
            "sha": "e6e36e870062ccfa4669bdbba45e2429b7633df6",
            "filename": "tests/junit-functional/org/jgroups/protocols/ASYM_ENCRYPT_Test.java",
            "status": "added",
            "additions": 334,
            "deletions": 0,
            "changes": 334,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FASYM_ENCRYPT_Test.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,334 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.auth.MD5Token;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.protocols.pbcast.DeltaView;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.protocols.pbcast.JoinRsp;\n+import org.jgroups.protocols.pbcast.NAKACK2;\n+import org.jgroups.stack.ProtocolStack;\n+import org.jgroups.util.Buffer;\n+import org.jgroups.util.ByteArrayDataOutputStream;\n+import org.jgroups.util.Util;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+import javax.crypto.SecretKey;\n+import java.util.Arrays;\n+\n+/**\n+ * Tests use cases for {@link ASYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+public class ASYM_ENCRYPT_Test extends EncryptTest {\n+    protected static final short  ASYM_ENCRYPT_ID;\n+\n+    static {\n+        ASYM_ENCRYPT_ID=ClassConfigurator.getProtocolId(ASYM_ENCRYPT.class);\n+    }\n+\n+\n+    @BeforeMethod protected void init() throws Exception {\n+        super.init(getClass().getSimpleName());\n+    }\n+\n+    @AfterMethod protected void destroy() {\n+        super.destroy();\n+    }\n+\n+  /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/\n+    public void testRegularMessageReception() throws Exception {\n+        super.testRegularMessageReception();\n+    }\n+\n+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {\n+        super.testRegularMessageReceptionWithEmptyMessages();\n+    }\n+\n+    public void testChecksum() throws Exception {\n+        super.testChecksum();\n+    }\n+\n+    public void testRogueMemberJoin() throws Exception {\n+        super.testRogueMemberJoin();\n+    }\n+\n+    public void testMessageSendingByRogue() throws Exception {\n+        super.testMessageSendingByRogue();\n+    }\n+\n+    public void testMessageSendingByRogueUsingEncryption() throws Exception {\n+        super.testMessageSendingByRogueUsingEncryption();\n+    }\n+\n+    public void testMessageReceptionByRogue() throws Exception {\n+        super.testMessageReceptionByRogue();\n+    }\n+\n+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {\n+        super.testCapturingOfMessageByNonMemberAndResending();\n+    }\n+\n+    public void testRogueViewInstallation() throws Exception {\n+        super.testRogueViewInstallation();\n+    }\n+\n+\n+\n+    /**\n+     * A non-member sends a {@link EncryptHeader#SECRET_KEY_REQ} request to the key server. Asserts that the rogue member\n+     * doesn't get the secret key. If it did, it would be able to decrypt all messages from cluster members!\n+     */\n+    public void nonMemberGetsSecretKeyFromKeyServer() throws Exception {\n+        Util.close(rogue);\n+\n+        rogue=new JChannel(Util.getTestStack()).name(\"rogue\");\n+        DISCARD discard=new DISCARD().setDiscardAll(true);\n+        rogue.getProtocolStack().insertProtocol(discard, ProtocolStack.ABOVE, TP.class);\n+        CustomENCRYPT encrypt=new CustomENCRYPT();\n+        encrypt.init();\n+\n+        rogue.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);\n+        rogue.connect(cluster_name); // creates a singleton cluster\n+\n+        assert rogue.getView().size() == 1;\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        View rogue_view=new View(a.getAddress(), a.getView().getViewId().getId(),\n+                                 Arrays.asList(a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress()));\n+        gms.installView(rogue_view);\n+\n+\n+        // now fabricate a KEY_REQUEST message and send it to the key server (A)\n+        Message newMsg=new Message(a.getAddress(), rogue.getAddress(), encrypt.keyPair().getPublic().getEncoded())\n+          .putHeader(encrypt.getId(),new EncryptHeader(EncryptHeader.SECRET_KEY_REQ, encrypt.symVersion()));\n+\n+        discard.setDiscardAll(false);\n+        System.out.printf(\"-- sending KEY_REQUEST to key server %s\\n\", a.getAddress());\n+        encrypt.getDownProtocol().down(new Event(Event.MSG, newMsg));\n+        for(int i=0; i < 10; i++) {\n+            SecretKey secret_key=encrypt.key;\n+            if(secret_key != null)\n+                break;\n+            Util.sleep(500);\n+        }\n+\n+        discard.setDiscardAll(true);\n+        gms.installView(View.create(rogue.getAddress(), 20, rogue.getAddress()));\n+        System.out.printf(\"-- secret key is %s (should be null)\\n\", encrypt.key);\n+        assert encrypt.key == null : String.format(\"should not have received secret key %s\", encrypt.key);\n+    }\n+\n+\n+\n+    /** Verifies that a non-member (non-coord) cannot send a JOIN-RSP to a member */\n+    public void nonMemberInjectingJoinResponse() throws Exception {\n+        Util.close(rogue);\n+        rogue=create(\"rogue\");\n+        ProtocolStack stack=rogue.getProtocolStack();\n+        AUTH auth=(AUTH)stack.findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)stack.findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        DISCARD discard=new DISCARD().setDiscardAll(true);\n+        stack.insertProtocol(discard, ProtocolStack.ABOVE, TP.class);\n+        rogue.connect(cluster_name);\n+        assert rogue.getView().size() == 1;\n+        discard.setDiscardAll(false);\n+        stack.removeProtocol(NAKACK2.class, UNICAST3.class);\n+\n+        View rogue_view=View.create(a.getAddress(), a.getView().getViewId().getId() +5,\n+                                    a.getAddress(),b.getAddress(),c.getAddress(),rogue.getAddress());\n+        JoinRsp join_rsp=new JoinRsp(rogue_view, null);\n+        GMS.GmsHeader gms_hdr=new GMS.GmsHeader(GMS.GmsHeader.JOIN_RSP);\n+        Message rogue_join_rsp=new Message(b.getAddress(), rogue.getAddress()).putHeader(GMS_ID, gms_hdr)\n+          .setBuffer(GMS.marshal(join_rsp)).setFlag(Message.Flag.NO_RELIABILITY); // bypasses NAKACK2 / UNICAST3\n+        rogue.down(new Event(Event.MSG, rogue_join_rsp));\n+        for(int i=0; i < 10; i++) {\n+            if(b.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert b.getView().size() == 3 : String.format(\"B's view is %s, but should be {A,B,C}\", b.getView());\n+    }\n+\n+\n+\n+    /** The rogue node has an incorrect {@link AUTH} config (secret) and can thus not join */\n+    public void rogueMemberCannotJoinDueToAuthRejection() throws Exception {\n+        Util.close(rogue);\n+        rogue=create(\"rogue\");\n+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(2);\n+        rogue.connect(cluster_name);\n+        System.out.printf(\"Rogue's view is %s\\n\", rogue.getView());\n+        assert rogue.getView().size() == 1 : String.format(\"rogue should have a singleton view of itself, but doesn't: %s\", rogue.getView());\n+    }\n+\n+\n+    public void mergeViewInjectionByNonMember() throws Exception {\n+        Util.close(rogue);\n+        rogue=create(\"rogue\");\n+        AUTH auth=(AUTH)rogue.getProtocolStack().findProtocol(AUTH.class);\n+        auth.setAuthToken(new MD5Token(\"unknown_pwd\"));\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        rogue.connect(cluster_name);\n+\n+        MergeView merge_view=new MergeView(a.getAddress(), a.getView().getViewId().getId()+5,\n+                                           Arrays.asList(a.getAddress(), b.getAddress(), c.getAddress(), rogue.getAddress()), null);\n+        GMS.GmsHeader hdr=new GMS.GmsHeader(GMS.GmsHeader.INSTALL_MERGE_VIEW, a.getAddress());\n+        Message merge_view_msg=new Message(null, marshalView(merge_view)).putHeader(GMS_ID, hdr)\n+          .setFlag(Message.Flag.NO_RELIABILITY);\n+        System.out.printf(\"** %s: trying to install MergeView %s in all members\\n\", rogue.getAddress(), merge_view);\n+        rogue.down(new Event(Event.MSG, merge_view_msg));\n+\n+        // check if A, B or C installed the MergeView sent by rogue:\n+        for(int i=0; i < 10; i++) {\n+            boolean rogue_views_installed=false;\n+\n+            for(JChannel ch: Arrays.asList(a,b,c))\n+                if(ch.getView().containsMember(rogue.getAddress()))\n+                    rogue_views_installed=true;\n+            if(rogue_views_installed)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: Arrays.asList(a,b,c))\n+            System.out.printf(\"%s: %s\\n\", ch.getAddress(), ch.getView());\n+        for(JChannel ch: Arrays.asList(a,b,c))\n+            assert !ch.getView().containsMember(rogue.getAddress());\n+    }\n+\n+\n+    /** Tests that when {ABC} -> {AB}, neither A nor B can receive a message from non-member C */\n+    public void testMessagesByLeftMember() throws Exception {\n+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());\n+        for(JChannel ch: Arrays.asList(a,b)) {\n+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);\n+            gms.installView(view);\n+        };\n+        for(JChannel ch: Arrays.asList(a,b))\n+            System.out.printf(\"%s: %s\\n\", ch.getAddress(), ch.getView());\n+        System.out.printf(\"%s: %s\\n\", c.getAddress(), c.getView());\n+\n+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member\n+\n+        Util.sleep(1000); // give members time to handle the new view\n+        c.send(null, \"hello world from left member C!\");\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"A: received msgs from non-member C: %s\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"B: received msgs from non-member C: %s\", print(rb.list()));\n+    }\n+\n+    /** Tests that a left member C cannot decrypt messages from the cluster */\n+    public void testEavesdroppingByLeftMember() throws Exception {\n+        printSymVersion(a,b,c);\n+        View view=View.create(a.getAddress(), a.getView().getViewId().getId()+1, a.getAddress(),b.getAddress());\n+         for(JChannel ch: Arrays.asList(a,b)) {\n+            GMS gms=(GMS)ch.getProtocolStack().findProtocol(GMS.class);\n+            gms.installView(view);\n+        };\n+        for(JChannel ch: Arrays.asList(a,b))\n+            System.out.printf(\"%s: %s\\n\", ch.getAddress(), ch.getView());\n+        System.out.printf(\"%s: %s\\n\", c.getAddress(), c.getView());\n+        c.getProtocolStack().removeProtocol(NAKACK2.class); // to prevent A and B from discarding C as non-member\n+\n+        Util.sleep(2000); // give members time to handle the new view\n+\n+\n+        printSymVersion(a,b,c);\n+        a.send(null, \"hello from A\");\n+        b.send(null, \"hello from B\");\n+\n+        for(int i=0; i < 10; i++) {\n+            if(rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert rc.size() == 0 : String.format(\"C: received msgs from cluster: %s\", print(rc.list()));\n+    }\n+\n+\n+    protected JChannel create(String name) throws Exception {\n+        JChannel ch=new JChannel(Util.getTestStack()).name(name);\n+        ProtocolStack stack=ch.getProtocolStack();\n+        EncryptBase encrypt=createENCRYPT();\n+        stack.insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);\n+        AUTH auth=new AUTH();\n+        auth.setAuthCoord(true);\n+        auth.setAuthToken(new MD5Token(\"mysecret\")); // .setAuthCoord(false);\n+        stack.insertProtocol(auth, ProtocolStack.BELOW, GMS.class);\n+        stack.findProtocol(GMS.class).setValue(\"join_timeout\", 2000); // .setValue(\"view_ack_collection_timeout\", 10);\n+        return ch;\n+    }\n+\n+    protected void printSymVersion(JChannel ... channels) {\n+        for(JChannel ch: channels) {\n+            ASYM_ENCRYPT encr=(ASYM_ENCRYPT)ch.getProtocolStack().findProtocol(ASYM_ENCRYPT.class);\n+            byte[] sym_version=encr.symVersion();\n+            System.out.printf(\"sym-version %s: %s\\n\", ch.getAddress(), Util.byteArrayToHexString(sym_version));\n+        }\n+    }\n+\n+\n+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this\n+    // unit test would fail!\n+    protected ASYM_ENCRYPT createENCRYPT() throws Exception {\n+        ASYM_ENCRYPT encrypt=new ASYM_ENCRYPT().encryptEntireMessage(true).signMessages(true);\n+        encrypt.init();\n+        return encrypt;\n+    }\n+\n+\n+    protected static Buffer marshalView(final View view) throws Exception {\n+        final ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);\n+        out.writeShort(determineFlags(view));\n+        view.writeTo(out);\n+        return out.getBuffer();\n+    }\n+\n+    protected static short determineFlags(final View view) {\n+        short retval=0;\n+        if(view != null) {\n+            retval|=GMS.VIEW_PRESENT;\n+            if(view instanceof MergeView)\n+                retval|=GMS.MERGE_VIEW;\n+            else if(view instanceof DeltaView)\n+                retval|=GMS.DELTA_VIEW;\n+        }\n+        return retval;\n+    }\n+\n+\n+    protected static class CustomENCRYPT extends ASYM_ENCRYPT {\n+        protected SecretKey key;\n+\n+        public CustomENCRYPT() {\n+            this.id=ASYM_ENCRYPT_ID;\n+        }\n+\n+        protected Object handleUpEvent(Message msg, EncryptHeader hdr) {\n+            if(hdr.type() == EncryptHeader.SECRET_KEY_RSP) {\n+                try {\n+                    key=decodeKey(msg.getBuffer());\n+                    System.out.printf(\"received secret key %s !\\n\", key);\n+                }\n+                catch(Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+            return super.handleUpEvent(msg, hdr);\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "0f66d1b29d4ffc71c806c5e0bab703880d0d9c1f",
            "filename": "tests/junit-functional/org/jgroups/protocols/ENCRYPTAsymmetricTest.java",
            "status": "modified",
            "additions": 9,
            "deletions": 10,
            "changes": 19,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTAsymmetricTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTAsymmetricTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTAsymmetricTest.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -9,7 +9,6 @@\n \n import org.jgroups.*;\n import org.jgroups.conf.ClassConfigurator;\n-import org.jgroups.protocols.ENCRYPT.EncryptHeader;\n import org.jgroups.stack.Protocol;\n import org.jgroups.util.MessageBatch;\n import org.jgroups.util.Util;\n@@ -27,7 +26,7 @@\n  * @author xenephon\n  * @author Bela Ban\n  */\n-@Test(groups=Global.FUNCTIONAL, sequential=false)\n+@Test(groups=Global.FUNCTIONAL)\n public class ENCRYPTAsymmetricTest {\n \n     protected static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);\n@@ -136,7 +135,7 @@ public static void testViewChangeBecomeKeyserver() throws Exception {\n         byte[] symVersion=digest.digest();\n         encrypt.keyServer=false;\n         Message msg=new Message().setBuffer(cipher.doFinal(\"hello\".getBytes()))\n-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));\n+          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));\n \n         encrypt.up(new Event(Event.MSG, msg));\n \n@@ -152,7 +151,7 @@ public static void testViewChangeBecomeKeyserver() throws Exception {\n \n         // send another encrypted message\n         Message msg2=new Message().setBuffer(cipher.doFinal(\"hello2\".getBytes()))\n-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));\n+          .putHeader(ENCRYPT_ID,new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT,symVersion));\n \n         // we should have three messages now in our observer that are decrypted\n         encrypt.up(new Event(Event.MSG, msg2));\n@@ -199,7 +198,7 @@ public static void testViewChangeNewKeyServer() throws Exception {\n         Cipher cipher=server.getSymEncodingCipher();\n         byte[] symVersion=digest.digest();\n         Message msg=new Message().setBuffer(cipher.doFinal(\"hello\".getBytes()))\n-          .putHeader(ENCRYPT_ID, new EncryptHeader(EncryptHeader.ENCRYPT, symVersion));\n+          .putHeader(ENCRYPT_ID, new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT, symVersion));\n \n         peer.up(new Event(Event.MSG, msg));\n         //assert that message is queued as we have no key from server\n@@ -216,7 +215,7 @@ public static void testViewChangeNewKeyServer() throws Exception {\n \n         Event sent=peerObserver.downMessages.get(\"message0\");\n \n-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);\n+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.KEY_REQUEST);\n         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));\n \n         // send this event to server\n@@ -225,7 +224,7 @@ public static void testViewChangeNewKeyServer() throws Exception {\n         Event reply=serverObserver.downMessages.get(\"message1\");\n \n         //assert that reply is the session key encrypted with peer's public key\n-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);\n+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.SECRETKEY);\n \n \n         assert !peer.getDesKey().equals(server.getDesKey());\n@@ -237,7 +236,7 @@ public static void testViewChangeNewKeyServer() throws Exception {\n \n         // send another encrypted message to peer to test queue\n         Message msg2=new Message().setBuffer(cipher.doFinal(\"hello2\".getBytes()))\n-          .putHeader(ENCRYPT_ID,new EncryptHeader(EncryptHeader.ENCRYPT,symVersion));\n+          .putHeader(ENCRYPT_ID,new ENCRYPT.EncryptHeader(ENCRYPT.EncryptHeader.ENCRYPT,symVersion));\n         peer.up(new Event(Event.MSG, msg2));\n \n         // make sure we have the events now in the up layers\n@@ -316,7 +315,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {\n         Event sent=peerObserver.downMessages.get(\"message0\");\n \n         // ensure type and that request contains peers pub key\n-        Util.assertEquals(((EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.KEY_REQUEST);\n+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)sent.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.KEY_REQUEST);\n         Util.assertEquals(new String(((Message)sent.getArg()).getBuffer()), new String(peer.getKpair().getPublic().getEncoded()));\n \n \n@@ -328,7 +327,7 @@ public static void testViewChangeNewKeyServerNewKey() throws Exception {\n         Event reply=peer2Observer.downMessages.get(\"message1\");\n \n         //assert that reply is the session key encrypted with peer's public key\n-        Util.assertEquals(((EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), EncryptHeader.SECRETKEY);\n+        Util.assertEquals(((ENCRYPT.EncryptHeader)((Message)reply.getArg()).getHeader(ENCRYPT_ID)).getType(), ENCRYPT.EncryptHeader.SECRETKEY);\n \n \n         assert !peer.getDesKey().equals(peer2.getDesKey());"
        },
        {
            "sha": "91bb3afa5194cfcb14dac9f39040dc92dbdc12f8",
            "filename": "tests/junit-functional/org/jgroups/protocols/ENCRYPTKeystoreTest.java",
            "status": "modified",
            "additions": 2,
            "deletions": 2,
            "changes": 4,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTKeystoreTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTKeystoreTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FENCRYPTKeystoreTest.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -21,7 +21,7 @@\n  * @author xenephon\n  * @author Bela Ban\n  */\n-@Test(groups=Global.FUNCTIONAL, sequential=false)\n+@Test(groups=Global.FUNCTIONAL)\n public class ENCRYPTKeystoreTest {\n \n     static final short ENCRYPT_ID=ClassConfigurator.getProtocolId(ENCRYPT.class);\n@@ -68,7 +68,7 @@ public static void testMessageDownEncode() throws Exception {\n     }\n \n \n-    public static void testMessageUpDecode() throws Exception {\n+    public void testMessageUpDecode() throws Exception {\n         ENCRYPT encrypt=create(\"defaultStore.keystore\"), encrypt2=create(\"defaultStore.keystore\");\n         \n         MockProtocol observer=new MockProtocol();"
        },
        {
            "sha": "b1d45640b75c34122be87d4891592f2ad53a6e04",
            "filename": "tests/junit-functional/org/jgroups/protocols/EncryptTest.java",
            "status": "added",
            "additions": 346,
            "deletions": 0,
            "changes": 346,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FEncryptTest.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,346 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.*;\n+import org.jgroups.conf.ClassConfigurator;\n+import org.jgroups.demos.KeyStoreGenerator;\n+import org.jgroups.protocols.pbcast.GMS;\n+import org.jgroups.protocols.pbcast.NAKACK2;\n+import org.jgroups.protocols.pbcast.NakAckHeader2;\n+import org.jgroups.util.Buffer;\n+import org.jgroups.util.ByteArrayDataOutputStream;\n+import org.jgroups.util.MyReceiver;\n+import org.jgroups.util.Util;\n+import org.testng.annotations.Test;\n+\n+import javax.crypto.SecretKey;\n+import java.lang.reflect.Field;\n+import java.util.List;\n+\n+import static java.util.Arrays.asList;\n+\n+\n+/**\n+ * Base class for tests {@link SYM_ENCRYPT_Test} and {@link ASYM_ENCRYPT_Test}\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+\n+@Test(enabled=false)\n+public abstract class EncryptTest {\n+    protected JChannel            a,b,c,rogue;\n+    protected MyReceiver<Message> ra, rb, rc, r_rogue;\n+    protected String              cluster_name;\n+    protected static final short  GMS_ID;\n+\n+    static {\n+        GMS_ID=ClassConfigurator.getProtocolId(GMS.class);\n+    }\n+\n+    protected void init(String cluster_name) throws Exception {\n+        this.cluster_name=cluster_name;\n+        a=create(\"A\");\n+        a.connect(cluster_name);\n+        a.setReceiver(ra=new MyReceiver<>().rawMsgs(true));\n+\n+        b=create(\"B\");\n+        b.connect(cluster_name);\n+        b.setReceiver(rb=new MyReceiver<>().rawMsgs(true));\n+\n+        c=create(\"C\");\n+        c.connect(cluster_name);\n+        c.setReceiver(rc=new MyReceiver<>().rawMsgs(true));\n+\n+        Util.waitUntilAllChannelsHaveSameSize(10000, 500, a,b,c);\n+        rogue=createRogue(\"rogue\");\n+        rogue.connect(cluster_name);\n+        for(JChannel ch: asList(a,b,c))\n+            System.out.printf(\"%s: %s\\n\", ch.getAddress(), ch.getView());\n+        System.out.println(\"\");\n+    }\n+\n+    @Test(enabled=false) protected void destroy() {\n+        Util.close(c, b, a, rogue);\n+    }\n+\n+    protected abstract JChannel create(String name) throws Exception;\n+\n+\n+\n+    /** Tests A,B or C sending messages and their reception by everyone in cluster {A,B,C} */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    protected void testRegularMessageReception() throws Exception {\n+        a.send(null, \"Hello from A\");\n+        b.send(null, \"Hello from B\");\n+        c.send(null, \"Hello from C\");\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assertSize(3);\n+    }\n+\n+    /** Same as above, but all messages are 0-length */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {\n+        a.send(new Message(null));\n+        b.send(new Message(null));\n+        c.send(new Message(null));\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() == 3 && rb.size() == 3 && rc.size() == 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assertSize(3);\n+    }\n+\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testChecksum() throws Exception {\n+        EncryptBase encrypt=(EncryptBase)a.getProtocolStack().findProtocol(EncryptBase.class);\n+\n+        byte[] buffer=\"Hello world\".getBytes();\n+        long checksum=encrypt.computeChecksum(buffer, 0, buffer.length);\n+        byte[] checksum_array=encrypt.encryptChecksum(checksum);\n+\n+        long actual_checksum=encrypt.decryptChecksum(null, checksum_array, 0, checksum_array.length);\n+        assert checksum == actual_checksum : String.format(\"checksum: %d, actual: %d\", checksum, actual_checksum);\n+    }\n+\n+\n+    /** A rogue member should not be able to join a cluster */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRogueMemberJoin() throws Exception {\n+        Util.close(rogue);\n+        rogue=new JChannel(Util.getTestStack()).name(\"rogue\");\n+        rogue.getProtocolStack().removeProtocol(EncryptBase.class);\n+        GMS gms=(GMS)rogue.getProtocolStack().findProtocol(GMS.class);\n+        gms.setMaxJoinAttempts(1);\n+        rogue.connect(cluster_name);\n+        for(int i=0; i < 10; i++) {\n+            if(a.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: asList(a,b,c))\n+            System.out.printf(\"%s: view is %s\\n\", ch.getAddress(), ch.getView());\n+        for(JChannel ch: asList(a,b,c)) {\n+            View view=ch.getView();\n+            assert view.size() == 3 : \"view should be {A,B,C}: \" + view;\n+        }\n+    }\n+\n+\n+    /** Test that A,B,C do NOT receive any message sent by a rogue node which is not member of {A,B,C} */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageSendingByRogue() throws Exception {\n+        rogue.send(null, \"message from rogue\");  // tests single messages\n+        Util.sleep(500);\n+        for(int i=1; i <= 100; i++)              // tests message batches\n+            rogue.send(null, \"msg #\" + i + \" from rogue\");\n+\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+    /**\n+     * R sends a message that has an encryption header and is encrypted with R's secret key (which of course is different\n+     * from the cluster members' shared key as R doesn't know it). The cluster members should drop R's message as they\n+     * shouldn't be able to decrypt it.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageSendingByRogueUsingEncryption() throws Exception {\n+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName(\"/tmp/ignored.keystore\");\n+        encrypt.encryptEntireMessage(true).signMessages(true);\n+\n+        SecretKey secret_key=KeyStoreGenerator.createSecretKey();\n+        Field secretKey=Util.getField(SYM_ENCRYPT.class, \"secret_key\");\n+        secretKey.setAccessible(true);\n+        Util.setField(secretKey, encrypt, secret_key);\n+        encrypt.init();\n+\n+        short encrypt_id=ClassConfigurator.getProtocolId(SYM_ENCRYPT.class);\n+        EncryptHeader hdr=new EncryptHeader(EncryptHeader.ENCRYPT, encrypt.symVersion());\n+        Message msg=new Message(null).putHeader(encrypt_id, hdr);\n+\n+        byte[] buf=\"hello from rogue\".getBytes();\n+        byte[] encrypted_buf=encrypt.code(buf, 0, buf.length, false);\n+        msg.setBuffer(encrypted_buf);\n+        long checksum=encrypt.computeChecksum(encrypted_buf, 0, encrypted_buf.length);\n+        byte[] tmp=encrypt.encryptChecksum(checksum);\n+        hdr.signature(tmp);\n+\n+        rogue.send(msg);\n+\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 0 || rb.size() > 0 || rc.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+        assert ra.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 0 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+    /**\n+     * Tests that the non-member does NOT receive messages from cluster {A,B,C}. The de-serialization of a message's\n+     * payload (encrypted with the secret key of the rogue non-member) will fail, so the message is never passed up\n+     * to the application.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testMessageReceptionByRogue() throws Exception {\n+        rogue.setReceiver(r_rogue=new MyReceiver().rawMsgs(true));\n+        a.setReceiver(null); b.setReceiver(null); c.setReceiver(null);\n+        a.send(null, \"Hello from A\");\n+        b.send(null, \"Hello from B\");\n+        c.send(null, \"Hello from C\");\n+        for(int i=0; i < 10; i++) {\n+            // retransmissions will add dupes to rogue as it doesn't have dupe elimination, so we could have more than\n+            // 3 messages!\n+            if(r_rogue.size() > 0)\n+                break;\n+            Util.sleep(500);\n+        }\n+\n+        // the non-member may have received some cluster messages, if the encrypted messages coincidentally didn't\n+        // cause a deserialization exception, but it will not be able to read their contents:\n+        if(r_rogue.size() > 0) {\n+            System.out.printf(\"Rogue non-member received %d message(s), but it should not be able to read deserialize \" +\n+                                \"the contents (this should throw exceptions below):\\n\", r_rogue.size());\n+            for(Message msg: r_rogue.list()) {\n+                try {\n+                    String payload=(String)msg.getObject();\n+                    assert !payload.startsWith(\"Hello from\");\n+                }\n+                catch(Exception t) {\n+                    System.out.printf(\"caught exception trying to de-serialize garbage payload into a string: %s\\n\", t);\n+                }\n+            };\n+        }\n+    }\n+\n+\n+    /**\n+     * Tests the scenario where the non-member R captures a message from some cluster member in {A,B,C}, then\n+     * increments the NAKACK2 seqno and resends that message. The message must not be received by {A,B,C};\n+     * it should be discarded.\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {\n+        rogue.setReceiver(new ReceiverAdapter() {\n+            public void receive(Message msg) {\n+                System.out.printf(\"rogue: modifying and resending msg %s, hdrs: %s\\n\", msg, msg.printHeaders());\n+                rogue.setReceiver(null); // to prevent recursive cycle\n+                try {\n+                    short prot_id=ClassConfigurator.getProtocolId(NAKACK2.class);\n+                    NakAckHeader2 hdr=(NakAckHeader2)msg.getHeader(prot_id);\n+                    if(hdr != null) {\n+                        long seqno=hdr.getSeqno();\n+                        Util.setField(Util.getField(NakAckHeader2.class, \"seqno\"), hdr, seqno+1);\n+                    }\n+                    else {\n+                        System.out.printf(\"Rogue was not able to get the %s header, fabricating one with seqno=50\\n\", NAKACK2.class.getSimpleName());\n+                        NakAckHeader2 hdr2=NakAckHeader2.createMessageHeader(50);\n+                        msg.putHeader(prot_id, hdr2);\n+                    }\n+\n+                    rogue.send(msg);\n+                }\n+                catch(Exception e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        });\n+\n+        a.send(null, \"Hello world from A\");\n+\n+        // everybody in {A,B,C} should receive this message, but NOT the rogue's resent message\n+        for(int i=0; i < 10; i++) {\n+            if(ra.size() > 1 || rb.size() > 1 || rc.size() > 1)\n+                break; // this should NOT happen\n+            Util.sleep(500);\n+        }\n+\n+        for(MyReceiver r: asList(ra,rb,rc))\n+            System.out.printf(\"%s: %s\\n\", r.name(), print(r.list()));\n+        assert ra.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(ra.list()));\n+        assert rb.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rb.list()));\n+        assert rc.size() == 1 : String.format(\"received msgs from non-member: '%s'; this should not be the case\", print(rc.list()));\n+    }\n+\n+\n+\n+    /**\n+     * Tests the case where a non-member installs a new view {rogue,A,B,C}, making itself the coordinator and therefore\n+     * controlling admission of new members to the cluster etc...\n+     */\n+    // @Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+    public void testRogueViewInstallation() throws Exception {\n+        final Address rogue_addr=rogue.getAddress();\n+        View rogue_view=View.create(rogue_addr, a.getView().getViewId().getId()+1,\n+                                    rogue_addr, a.getAddress(), b.getAddress(), c.getAddress());\n+\n+        Message view_change_msg=new Message().putHeader(GMS_ID, new GMS.GmsHeader(GMS.GmsHeader.VIEW))\n+          .setBuffer(marshal(rogue_view));\n+        rogue.send(view_change_msg);\n+\n+        for(int i=0; i < 10; i++) {\n+            if(a.getView().size() > 3)\n+                break;\n+            Util.sleep(500);\n+        }\n+        for(JChannel ch: asList(a,b,c)) {\n+            View view=ch.getView();\n+            System.out.printf(\"%s: view is %s\\n\", ch.getAddress(), view);\n+            assert !view.containsMember(rogue_addr) : \"view contains rogue member: \" + view;\n+        };\n+    }\n+\n+\n+    protected static JChannel createRogue(String name) throws Exception {\n+        return new JChannel(new SHARED_LOOPBACK()).name(name);\n+    }\n+\n+\n+    protected static Buffer marshal(final View view) throws Exception {\n+        ByteArrayDataOutputStream out=new ByteArrayDataOutputStream(512);\n+        out.writeShort(1);\n+        if(view != null)\n+            view.writeTo(out);\n+        return out.getBuffer();\n+    }\n+\n+    protected void assertSize(int expected_size) {\n+        for(MyReceiver r: asList(ra,rb,rc))\n+        assert r.size() == expected_size : String.format(\"expected size: %d, actual size of %s: %d\", expected_size, r.name(), r.size());\n+    }\n+\n+    protected static String print(List<Message> msgs) {\n+        StringBuilder sb=new StringBuilder();\n+        for(Message msg: msgs)\n+            sb.append(msg.getObject()).append(\" \");\n+        return sb.toString();\n+    }\n+\n+    protected static String print(byte[] buf, int offset, int length) {\n+        StringBuilder sb=new StringBuilder(\"encrypted string: \");\n+        for(int i=0; i < length; i++) {\n+            int ch=buf[offset+i];\n+            sb.append(ch).append(' ');\n+        }\n+        return sb.toString();\n+    }\n+\n+\n+}"
        },
        {
            "sha": "e9f5967ac8906a0ce580b98a6397feb838969c22",
            "filename": "tests/junit-functional/org/jgroups/protocols/SYM_ENCRYPT_Test.java",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Fprotocols%2FSYM_ENCRYPT_Test.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -0,0 +1,94 @@\n+package org.jgroups.protocols;\n+\n+import org.jgroups.Global;\n+import org.jgroups.JChannel;\n+import org.jgroups.protocols.pbcast.NAKACK2;\n+import org.jgroups.stack.ProtocolStack;\n+import org.jgroups.util.Util;\n+import org.testng.annotations.AfterMethod;\n+import org.testng.annotations.BeforeMethod;\n+import org.testng.annotations.Test;\n+\n+/**\n+ * Tests use cases for {@link SYM_ENCRYPT} described in https://issues.jboss.org/browse/JGRP-2021.\n+ * Make sure you create the keystore before running this test (ant make-keystore).\n+ * @author Bela Ban\n+ * @since  4.0\n+ */\n+@Test(groups=Global.FUNCTIONAL,singleThreaded=true)\n+public class SYM_ENCRYPT_Test extends EncryptTest {\n+    protected static final String DEF_PWD=\"changeit\";\n+\n+    @BeforeMethod protected void init() throws Exception {\n+        super.init(getClass().getSimpleName());\n+    }\n+\n+    @AfterMethod protected void destroy() {\n+        super.destroy();\n+    }\n+\n+\n+    /** Calling methods in superclass. Kludge because TestNG doesn't call methods in superclass correctly **/\n+    public void testRegularMessageReception() throws Exception {\n+        super.testRegularMessageReception();\n+    }\n+\n+    public void testRegularMessageReceptionWithEmptyMessages() throws Exception {\n+        super.testRegularMessageReceptionWithEmptyMessages();\n+    }\n+\n+    public void testChecksum() throws Exception {\n+        super.testChecksum();\n+    }\n+\n+    public void testRogueMemberJoin() throws Exception {\n+        super.testRogueMemberJoin();\n+    }\n+\n+    public void testMessageSendingByRogue() throws Exception {\n+        super.testMessageSendingByRogue();\n+    }\n+\n+    public void testMessageSendingByRogueUsingEncryption() throws Exception {\n+        super.testMessageSendingByRogueUsingEncryption();\n+    }\n+\n+    public void testMessageReceptionByRogue() throws Exception {\n+        super.testMessageReceptionByRogue();\n+    }\n+\n+    public void testCapturingOfMessageByNonMemberAndResending() throws Exception {\n+        super.testCapturingOfMessageByNonMemberAndResending();\n+    }\n+\n+    public void testRogueViewInstallation() throws Exception {\n+        super.testRogueViewInstallation();\n+    }\n+\n+\n+\n+\n+    protected JChannel create(String name) throws Exception {\n+        JChannel ch=new JChannel(Util.getTestStack()).name(name);\n+        SYM_ENCRYPT encrypt;\n+        try {\n+            encrypt=createENCRYPT(\"keystore/defaultStore.keystore\", DEF_PWD);\n+        }\n+        catch(Throwable t) {\n+            encrypt=createENCRYPT(\"defaultStore.keystore\", DEF_PWD);\n+        }\n+        ch.getProtocolStack().insertProtocol(encrypt, ProtocolStack.BELOW, NAKACK2.class);\n+        return ch;\n+    }\n+\n+\n+    // Note that setting encrypt_entire_message to true is critical here, or else some of the tests in this\n+    // unit test would fail!\n+    protected SYM_ENCRYPT createENCRYPT(String keystore_name, String store_pwd) throws Exception {\n+        SYM_ENCRYPT encrypt=new SYM_ENCRYPT().keystoreName(keystore_name).alias(\"myKey\")\n+          .storePassword(store_pwd).encryptEntireMessage(true).signMessages(true);\n+        encrypt.init();\n+        return encrypt;\n+    }\n+\n+}"
        },
        {
            "sha": "2bbefe6223b15250ac0c80c495bed81721c3e7f6",
            "filename": "tests/junit-functional/org/jgroups/tests/SizeTest.java",
            "status": "modified",
            "additions": 3,
            "deletions": 3,
            "changes": 6,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit-functional%2Forg%2Fjgroups%2Ftests%2FSizeTest.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -688,10 +688,10 @@ public static void testRelay2Header() throws Exception {\n     }\n \n \n-    public static void testEncryptHeader() throws Exception {\n-        ENCRYPT.EncryptHeader hdr=new ENCRYPT.EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});\n+    public void testEncryptHeader() throws Exception {\n+        EncryptHeader hdr=new EncryptHeader((byte)1, new byte[]{'b','e', 'l', 'a'});\n         _testSize(hdr);\n-        hdr=new ENCRYPT.EncryptHeader((byte)2, \"Hello world\".getBytes());\n+        hdr=new EncryptHeader((byte)2, \"Hello world\".getBytes());\n         _testSize(hdr);\n     }\n "
        },
        {
            "sha": "9f1b20b2868ef81d4188303796656113cf74a37e",
            "filename": "tests/junit/org/jgroups/protocols/S3_PINGTest.java",
            "status": "modified",
            "additions": 9,
            "deletions": 9,
            "changes": 18,
            "blob_url": "https://github.com/belaban/JGroups/blob/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FS3_PINGTest.java",
            "raw_url": "https://github.com/belaban/JGroups/raw/fba182c14075789e1d2c976d50d9018c671ad0b4/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FS3_PINGTest.java",
            "contents_url": "https://api.github.com/repos/belaban/JGroups/contents/tests%2Fjunit%2Forg%2Fjgroups%2Fprotocols%2FS3_PINGTest.java?ref=fba182c14075789e1d2c976d50d9018c671ad0b4",
            "patch": "@@ -1,16 +1,16 @@\n package org.jgroups.protocols;\n \n-import java.util.Arrays;\n-import java.util.HashMap;\n-import java.util.Map;\n-\n import org.jgroups.Global;\n import org.jgroups.protocols.S3_PING.PreSignedUrlParser;\n import org.jgroups.protocols.S3_PING.Utils;\n import org.testng.Assert;\n import org.testng.annotations.BeforeMethod;\n import org.testng.annotations.Test;\n \n+import java.util.Arrays;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n @Test(groups={Global.STACK_INDEPENDENT})\n public class S3_PINGTest {\n     private S3_PING ping;\n@@ -80,7 +80,7 @@ public void testUsingPreSignedUrlWhenSet() {\n     \n     @Test\n     public void testGenerateQueryStringAuthenticationWithBasicGet() {\n-        String expectedUrl = \"http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D\";\n+        String expectedUrl = \"https://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=Khyk4bU1A3vaed9woyp%2B5qepazQ%3D\";\n         String encodedUrl =\n             Utils.generateQueryStringAuthentication(\"abcd\", \"efgh\", \"get\",\n                                                     \"test-bucket\", \"node1\",\n@@ -91,7 +91,7 @@ public void testGenerateQueryStringAuthenticationWithBasicGet() {\n     \n     @Test\n     public void testGenerateQueryStringAuthenticationWithBasicPost() {\n-        String expectedUrl = \"http://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D\";\n+        String expectedUrl = \"https://test-bucket.s3.amazonaws.com/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=%2BsCW1Fc20UUvIqPjeGXkyN960sk%3D\";\n         String encodedUrl =\n             Utils.generateQueryStringAuthentication(\"abcd\", \"efgh\", \"POST\",\n                                                     \"test-bucket\", \"node1\",\n@@ -104,7 +104,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPost() {\n     public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {\n         Map headers = new HashMap();\n         headers.put(\"x-amz-acl\", Arrays.asList(\"public-read\"));\n-        String expectedUrl = \"http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D\";\n+        String expectedUrl = \"https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D\";\n         String encodedUrl =\n             Utils.generateQueryStringAuthentication(\"abcd\", \"efgh\", \"put\",\n                                                     \"test-bucket\", \"subdir/node1\",\n@@ -115,7 +115,7 @@ public void testGenerateQueryStringAuthenticationWithBasicPutAndHeaders() {\n     \n     @Test\n     public void testGeneratePreSignedUrlForPut() {\n-        String expectedUrl = \"http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D\";\n+        String expectedUrl = \"https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=GWu2Mm5MysW83YDgS2R0Jakthes%3D\";\n         String preSignedUrl = S3_PING.generatePreSignedUrl(\"abcd\", \"efgh\", \"put\",\n                                                            \"test-bucket\", \"subdir/node1\",\n                                                            1234567890);\n@@ -124,7 +124,7 @@ public void testGeneratePreSignedUrlForPut() {\n     \n     @Test\n     public void testGeneratePreSignedUrlForDelete() {\n-        String expectedUrl = \"http://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D\";\n+        String expectedUrl = \"https://test-bucket.s3.amazonaws.com/subdir/node1?AWSAccessKeyId=abcd&Expires=1234567890&Signature=qbEMukqq0KIpZVjXaDi0VxepSVo%3D\";\n         String preSignedUrl = S3_PING.generatePreSignedUrl(\"abcd\", \"efgh\", \"delete\",\n                                                            \"test-bucket\", \"subdir/node1\",\n                                                            1234567890);"
        }
    ]
}
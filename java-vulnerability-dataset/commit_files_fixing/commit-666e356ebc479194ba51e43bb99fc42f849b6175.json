{
    "sha": "666e356ebc479194ba51e43bb99fc42f849b6175",
    "node_id": "MDY6Q29tbWl0MzE0ODk3OTo2NjZlMzU2ZWJjNDc5MTk0YmE1MWU0M2JiOTlmYzQyZjg0OWI2MTc1",
    "commit": {
        "author": {
            "name": "Rob Winch",
            "email": "rwinch@gopivotal.com",
            "date": "2016-12-07T20:32:41Z"
        },
        "committer": {
            "name": "Rob Winch",
            "email": "rwinch@gopivotal.com",
            "date": "2016-12-21T15:04:00Z"
        },
        "message": "Block URL Encoded \"/\" in DefaultHttpFirewall\n\nFixes gh-4169",
        "tree": {
            "sha": "d01f41301abb6455091d1b94d7af5bd78cdd5c03",
            "url": "https://api.github.com/repos/spring-projects/spring-security/git/trees/d01f41301abb6455091d1b94d7af5bd78cdd5c03"
        },
        "url": "https://api.github.com/repos/spring-projects/spring-security/git/commits/666e356ebc479194ba51e43bb99fc42f849b6175",
        "comment_count": 3,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/spring-projects/spring-security/commits/666e356ebc479194ba51e43bb99fc42f849b6175",
    "html_url": "https://github.com/spring-projects/spring-security/commit/666e356ebc479194ba51e43bb99fc42f849b6175",
    "comments_url": "https://api.github.com/repos/spring-projects/spring-security/commits/666e356ebc479194ba51e43bb99fc42f849b6175/comments",
    "author": null,
    "committer": null,
    "parents": [
        {
            "sha": "fc516b55a647277f58d679b8040fe5a15711338b",
            "url": "https://api.github.com/repos/spring-projects/spring-security/commits/fc516b55a647277f58d679b8040fe5a15711338b",
            "html_url": "https://github.com/spring-projects/spring-security/commit/fc516b55a647277f58d679b8040fe5a15711338b"
        }
    ],
    "stats": {
        "total": 159,
        "additions": 126,
        "deletions": 33
    },
    "files": [
        {
            "sha": "a63035a0388c11b84f83c002cec8aeca78544171",
            "filename": "web/src/main/java/org/springframework/security/web/firewall/DefaultHttpFirewall.java",
            "status": "modified",
            "additions": 63,
            "deletions": 24,
            "changes": 87,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/666e356ebc479194ba51e43bb99fc42f849b6175/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/666e356ebc479194ba51e43bb99fc42f849b6175/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewall.java?ref=666e356ebc479194ba51e43bb99fc42f849b6175",
            "patch": "@@ -19,49 +19,89 @@\n import javax.servlet.http.HttpServletResponse;\n \n /**\n- * Default implementation which wraps requests in order to provide consistent values of\n- * the {@code servletPath} and {@code pathInfo}, which do not contain path parameters (as\n- * defined in <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>). Different\n- * servlet containers interpret the servlet spec differently as to how path parameters are\n- * treated and it is possible they might be added in order to bypass particular security\n- * constraints. When using this implementation, they will be removed for all requests as\n- * the request passes through the security filter chain. Note that this means that any\n- * segments in the decoded path which contain a semi-colon, will have the part following\n- * the semi-colon removed for request matching. Your application should not contain any\n- * valid paths which contain semi-colons.\n+ * Default implementation which wraps requests in order to provide consistent\n+ * values of the {@code servletPath} and {@code pathInfo}, which do not contain\n+ * path parameters (as defined in\n+ * <a href=\"http://www.ietf.org/rfc/rfc2396.txt\">RFC 2396</a>). Different\n+ * servlet containers interpret the servlet spec differently as to how path\n+ * parameters are treated and it is possible they might be added in order to\n+ * bypass particular security constraints. When using this implementation, they\n+ * will be removed for all requests as the request passes through the security\n+ * filter chain. Note that this means that any segments in the decoded path\n+ * which contain a semi-colon, will have the part following the semi-colon\n+ * removed for request matching. Your application should not contain any valid\n+ * paths which contain semi-colons.\n  * <p>\n- * If any un-normalized paths are found (containing directory-traversal character\n- * sequences), the request will be rejected immediately. Most containers normalize the\n- * paths before performing the servlet-mapping, but again this is not guaranteed by the\n- * servlet spec.\n+ * If any un-normalized paths are found (containing directory-traversal\n+ * character sequences), the request will be rejected immediately. Most\n+ * containers normalize the paths before performing the servlet-mapping, but\n+ * again this is not guaranteed by the servlet spec.\n  *\n  * @author Luke Taylor\n  */\n public class DefaultHttpFirewall implements HttpFirewall {\n+\tprivate boolean allowUrlEncodedSlash;\n \n-\tpublic FirewalledRequest getFirewalledRequest(HttpServletRequest request)\n-\t\t\tthrows RequestRejectedException {\n+\t@Override\n+\tpublic FirewalledRequest getFirewalledRequest(HttpServletRequest request) throws RequestRejectedException {\n \t\tFirewalledRequest fwr = new RequestWrapper(request);\n \n \t\tif (!isNormalized(fwr.getServletPath()) || !isNormalized(fwr.getPathInfo())) {\n-\t\t\tthrow new RequestRejectedException(\"Un-normalized paths are not supported: \"\n-\t\t\t\t\t+ fwr.getServletPath()\n+\t\t\tthrow new RequestRejectedException(\"Un-normalized paths are not supported: \" + fwr.getServletPath()\n \t\t\t\t\t+ (fwr.getPathInfo() != null ? fwr.getPathInfo() : \"\"));\n \t\t}\n \n+\t\tString requestURI = fwr.getRequestURI();\n+\t\tif (containsInvalidUrlEncodedSlash(requestURI)) {\n+\t\t\tthrow new RequestRejectedException(\"The requestURI cannot contain encoded slash. Got \" + requestURI);\n+\t\t}\n+\n \t\treturn fwr;\n \t}\n \n+\t@Override\n \tpublic HttpServletResponse getFirewalledResponse(HttpServletResponse response) {\n \t\treturn new FirewalledResponse(response);\n \t}\n \n \t/**\n-\t * Checks whether a path is normalized (doesn't contain path traversal sequences like\n-\t * \"./\", \"/../\" or \"/.\")\n+\t * <p>\n+\t * Sets if the application should allow a URL encoded slash character.\n+\t * </p>\n+\t * <p>\n+\t * If true (default is false), a URL encoded slash will be allowed in the\n+\t * URL. Allowing encoded slashes can cause security vulnerabilities in some\n+\t * situations depending on how the container constructs the\n+\t * HttpServletRequest.\n+\t * </p>\n \t *\n-\t * @param path the path to test\n-\t * @return true if the path doesn't contain any path-traversal character sequences.\n+\t * @param allowUrlEncodedSlash\n+\t *            the new value (default false)\n+\t */\n+\tpublic void setAllowUrlEncodedSlash(boolean allowUrlEncodedSlash) {\n+\t\tthis.allowUrlEncodedSlash = allowUrlEncodedSlash;\n+\t}\n+\n+\tprivate boolean containsInvalidUrlEncodedSlash(String uri) {\n+\t\tif (this.allowUrlEncodedSlash || uri == null) {\n+\t\t\treturn false;\n+\t\t}\n+\n+\t\tif (uri.contains(\"%2f\") || uri.contains(\"%2F\")) {\n+\t\t\treturn true;\n+\t\t}\n+\n+\t\treturn false;\n+\t}\n+\n+\t/**\n+\t * Checks whether a path is normalized (doesn't contain path traversal\n+\t * sequences like \"./\", \"/../\" or \"/.\")\n+\t *\n+\t * @param path\n+\t *            the path to test\n+\t * @return true if the path doesn't contain any path-traversal character\n+\t *         sequences.\n \t */\n \tprivate boolean isNormalized(String path) {\n \t\tif (path == null) {\n@@ -75,8 +115,7 @@ private boolean isNormalized(String path) {\n \t\t\tif (gap == 2 && path.charAt(i + 1) == '.') {\n \t\t\t\t// \".\", \"/./\" or \"/.\"\n \t\t\t\treturn false;\n-\t\t\t}\n-\t\t\telse if (gap == 3 && path.charAt(i + 1) == '.' && path.charAt(i + 2) == '.') {\n+\t\t\t} else if (gap == 3 && path.charAt(i + 1) == '.' && path.charAt(i + 2) == '.') {\n \t\t\t\treturn false;\n \t\t\t}\n "
        },
        {
            "sha": "41ec1030864bdb95642449f7b9c6a4982857e29f",
            "filename": "web/src/test/java/org/springframework/security/web/firewall/DefaultHttpFirewallTests.java",
            "status": "modified",
            "additions": 63,
            "deletions": 9,
            "changes": 72,
            "blob_url": "https://github.com/spring-projects/spring-security/blob/666e356ebc479194ba51e43bb99fc42f849b6175/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java",
            "raw_url": "https://github.com/spring-projects/spring-security/raw/666e356ebc479194ba51e43bb99fc42f849b6175/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-security/contents/web%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fsecurity%2Fweb%2Ffirewall%2FDefaultHttpFirewallTests.java?ref=666e356ebc479194ba51e43bb99fc42f849b6175",
            "patch": "@@ -15,39 +15,93 @@\n  */\n package org.springframework.security.web.firewall;\n \n-import static org.assertj.core.api.Assertions.fail;\n-\n import org.junit.Test;\n+\n import org.springframework.mock.web.MockHttpServletRequest;\n \n+import static org.assertj.core.api.Assertions.fail;\n+\n /**\n  * @author Luke Taylor\n  */\n public class DefaultHttpFirewallTests {\n-\tpublic String[] unnormalizedPaths = { \"/..\", \"/./path/\", \"/path/path/.\",\n-\t\t\t\"/path/path//.\", \"./path/../path//.\", \"./path\", \".//path\", \".\" };\n+\tpublic String[] unnormalizedPaths = { \"/..\", \"/./path/\", \"/path/path/.\", \"/path/path//.\", \"./path/../path//.\",\n+\t\t\t\"./path\", \".//path\", \".\" };\n \n \t@Test\n \tpublic void unnormalizedPathsAreRejected() throws Exception {\n \t\tDefaultHttpFirewall fw = new DefaultHttpFirewall();\n \n \t\tMockHttpServletRequest request;\n-\t\tfor (String path : unnormalizedPaths) {\n+\t\tfor (String path : this.unnormalizedPaths) {\n \t\t\trequest = new MockHttpServletRequest();\n \t\t\trequest.setServletPath(path);\n \t\t\ttry {\n \t\t\t\tfw.getFirewalledRequest(request);\n \t\t\t\tfail(path + \" is un-normalized\");\n-\t\t\t}\n-\t\t\tcatch (RequestRejectedException expected) {\n+\t\t\t} catch (RequestRejectedException expected) {\n \t\t\t}\n \t\t\trequest.setPathInfo(path);\n \t\t\ttry {\n \t\t\t\tfw.getFirewalledRequest(request);\n \t\t\t\tfail(path + \" is un-normalized\");\n-\t\t\t}\n-\t\t\tcatch (RequestRejectedException expected) {\n+\t\t\t} catch (RequestRejectedException expected) {\n \t\t\t}\n \t\t}\n \t}\n+\n+\t/**\n+\t * On WebSphere 8.5 a URL like /context-root/a/b;%2f1/c can bypass a rule on\n+\t * /a/b/c because the pathInfo is /a/b;/1/c which ends up being /a/b/1/c\n+\t * while Spring MVC will strip the ; content from requestURI before the path\n+\t * is URL decoded.\n+\t */\n+\t@Test(expected = RequestRejectedException.class)\n+\tpublic void getFirewalledRequestWhenLowercaseEncodedPathThenException() {\n+\t\tDefaultHttpFirewall fw = new DefaultHttpFirewall();\n+\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+\t\trequest.setRequestURI(\"/context-root/a/b;%2f1/c\");\n+\t\trequest.setContextPath(\"/context-root\");\n+\t\trequest.setServletPath(\"\");\n+\t\trequest.setPathInfo(\"/a/b;/1/c\"); // URL decoded requestURI\n+\t\tfw.getFirewalledRequest(request);\n+\t}\n+\n+\t@Test(expected = RequestRejectedException.class)\n+\tpublic void getFirewalledRequestWhenUppercaseEncodedPathThenException() {\n+\t\tDefaultHttpFirewall fw = new DefaultHttpFirewall();\n+\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+\t\trequest.setRequestURI(\"/context-root/a/b;%2f1/c\");\n+\t\trequest.setContextPath(\"/context-root\");\n+\t\trequest.setServletPath(\"\");\n+\t\trequest.setPathInfo(\"/a/b;/1/c\"); // URL decoded requestURI\n+\n+\t\tfw.getFirewalledRequest(request);\n+\t}\n+\n+\t@Test\n+\tpublic void getFirewalledRequestWhenAllowUrlEncodedSlashAndLowercaseEncodedPathThenNoException() {\n+\t\tDefaultHttpFirewall fw = new DefaultHttpFirewall();\n+\t\tfw.setAllowUrlEncodedSlash(true);\n+\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+\t\trequest.setRequestURI(\"/context-root/a/b;%2f1/c\");\n+\t\trequest.setContextPath(\"/context-root\");\n+\t\trequest.setServletPath(\"\");\n+\t\trequest.setPathInfo(\"/a/b;/1/c\"); // URL decoded requestURI\n+\n+\t\tfw.getFirewalledRequest(request);\n+\t}\n+\n+\t@Test\n+\tpublic void getFirewalledRequestWhenAllowUrlEncodedSlashAndUppercaseEncodedPathThenNoException() {\n+\t\tDefaultHttpFirewall fw = new DefaultHttpFirewall();\n+\t\tfw.setAllowUrlEncodedSlash(true);\n+\t\tMockHttpServletRequest request = new MockHttpServletRequest();\n+\t\trequest.setRequestURI(\"/context-root/a/b;%2f1/c\");\n+\t\trequest.setContextPath(\"/context-root\");\n+\t\trequest.setServletPath(\"\");\n+\t\trequest.setPathInfo(\"/a/b;/1/c\"); // URL decoded requestURI\n+\n+\t\tfw.getFirewalledRequest(request);\n+\t}\n }"
        }
    ]
}
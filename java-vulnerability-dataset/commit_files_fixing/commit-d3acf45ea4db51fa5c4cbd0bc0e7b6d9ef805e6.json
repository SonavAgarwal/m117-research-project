{
    "sha": "d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
    "node_id": "MDY6Q29tbWl0MTE0ODc1MzpkM2FjZjQ1ZWE0ZGI1MWZhNWM0Y2JkMGJjMGU3YjZkOWVmODA1ZTY5",
    "commit": {
        "author": {
            "name": "Andy Clement",
            "email": "aclement@pivotal.io",
            "date": "2018-03-12T18:11:40Z"
        },
        "committer": {
            "name": "Andy Clement",
            "email": "aclement@pivotal.io",
            "date": "2018-04-05T21:36:36Z"
        },
        "message": "Modify SpEL code gen to take account of null safe refs\n\nWith this change the code generation for method and property\nreferences is modified to include branching logic in the\ncase of null safe dereferencing (?.). This is complicated\nby the possible usage of primitives on the left hand side\nof the dereference. To cope with this case primitives are\npromoted to boxed types when this situation occurs enabling\nnull to be passed as a possible result.\n\nIssue: SPR-16489",
        "tree": {
            "sha": "7e8080ed7e0ef9a7a4f5dbb225965a411649e031",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/git/trees/7e8080ed7e0ef9a7a4f5dbb225965a411649e031"
        },
        "url": "https://api.github.com/repos/spring-projects/spring-framework/git/commits/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
    "html_url": "https://github.com/spring-projects/spring-framework/commit/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
    "comments_url": "https://api.github.com/repos/spring-projects/spring-framework/commits/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/comments",
    "author": {
        "login": "aclement",
        "id": 226298,
        "node_id": "MDQ6VXNlcjIyNjI5OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/226298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aclement",
        "html_url": "https://github.com/aclement",
        "followers_url": "https://api.github.com/users/aclement/followers",
        "following_url": "https://api.github.com/users/aclement/following{/other_user}",
        "gists_url": "https://api.github.com/users/aclement/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/aclement/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/aclement/subscriptions",
        "organizations_url": "https://api.github.com/users/aclement/orgs",
        "repos_url": "https://api.github.com/users/aclement/repos",
        "events_url": "https://api.github.com/users/aclement/events{/privacy}",
        "received_events_url": "https://api.github.com/users/aclement/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "aclement",
        "id": 226298,
        "node_id": "MDQ6VXNlcjIyNjI5OA==",
        "avatar_url": "https://avatars.githubusercontent.com/u/226298?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/aclement",
        "html_url": "https://github.com/aclement",
        "followers_url": "https://api.github.com/users/aclement/followers",
        "following_url": "https://api.github.com/users/aclement/following{/other_user}",
        "gists_url": "https://api.github.com/users/aclement/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/aclement/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/aclement/subscriptions",
        "organizations_url": "https://api.github.com/users/aclement/orgs",
        "repos_url": "https://api.github.com/users/aclement/repos",
        "events_url": "https://api.github.com/users/aclement/events{/privacy}",
        "received_events_url": "https://api.github.com/users/aclement/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "573f1d77f285ba34253d98a9ed056e0bb4bba219",
            "url": "https://api.github.com/repos/spring-projects/spring-framework/commits/573f1d77f285ba34253d98a9ed056e0bb4bba219",
            "html_url": "https://github.com/spring-projects/spring-framework/commit/573f1d77f285ba34253d98a9ed056e0bb4bba219"
        }
    ],
    "stats": {
        "total": 299,
        "additions": 284,
        "deletions": 15
    },
    "files": [
        {
            "sha": "33e77e7791358d2bdef05ad61056184f64d9c2a2",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/CodeFlow.java",
            "status": "modified",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCodeFlow.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCodeFlow.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FCodeFlow.java?ref=d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
            "patch": "@@ -1003,4 +1003,19 @@ public interface ClinitAdder {\n \t\tvoid generateCode(MethodVisitor mv, CodeFlow codeflow);\n \t}\n \n+\tpublic static String toBoxedDescriptor(String primitiveDescriptor) {\n+\t\tswitch (primitiveDescriptor.charAt(0)) {\n+\t\t\tcase 'I': return \"Ljava/lang/Integer\";\n+\t\t\tcase 'J': return \"Ljava/lang/Long\";\n+\t\t\tcase 'F': return \"Ljava/lang/Float\";\n+\t\t\tcase 'D': return \"Ljava/lang/Double\";\n+\t\t\tcase 'B': return \"Ljava/lang/Byte\";\n+\t\t\tcase 'C': return \"Ljava/lang/Character\";\n+\t\t\tcase 'S': return \"Ljava/lang/Short\";\n+\t\t\tcase 'Z': return \"Ljava/lang/Boolean\";\n+\t\t\tdefault:\n+\t\t\t\tthrow new IllegalArgumentException(\"Unexpected non primitive descriptor \"+primitiveDescriptor);\n+\t\t}\t\n+\t}\n+\n }"
        },
        {
            "sha": "e1045ec95de475b17bd52f14f75f9a44c663947f",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/MethodReference.java",
            "status": "modified",
            "additions": 35,
            "deletions": 11,
            "changes": 46,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FMethodReference.java?ref=d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
            "patch": "@@ -24,6 +24,7 @@\n import java.util.Collections;\n import java.util.List;\n \n+import org.springframework.asm.Label;\n import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n@@ -53,6 +54,8 @@ public class MethodReference extends SpelNodeImpl {\n \n \tprivate final boolean nullSafe;\n \n+\tprivate String originalPrimitiveExitTypeDescriptor = null;\n+\n \tprivate volatile CachedMethodExecutor cachedExecutor;\n \n \n@@ -233,7 +236,14 @@ private void updateExitTypeDescriptor() {\n \t\tCachedMethodExecutor executorToCheck = this.cachedExecutor;\n \t\tif (executorToCheck != null && executorToCheck.get() instanceof ReflectiveMethodExecutor) {\n \t\t\tMethod method = ((ReflectiveMethodExecutor) executorToCheck.get()).getMethod();\n-\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(method.getReturnType());\n+\t\t\tString descriptor = CodeFlow.toDescriptor(method.getReturnType());\n+\t\t\tif (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {\n+\t\t\t\toriginalPrimitiveExitTypeDescriptor = descriptor;\n+\t\t\t\tthis.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);\n+\t\t\t}\n+\t\t\telse {\n+\t\t\t\tthis.exitTypeDescriptor = descriptor;\n+\t\t\t}\n \t\t}\n \t}\n \n@@ -293,17 +303,23 @@ public void generateCode(MethodVisitor mv, CodeFlow cf) {\n \t\tboolean isStaticMethod = Modifier.isStatic(method.getModifiers());\n \t\tString descriptor = cf.lastDescriptor();\n \n-\t\tif (descriptor == null) {\n-\t\t\tif (!isStaticMethod) {\n-\t\t\t\t// Nothing on the stack but something is needed\n-\t\t\t\tcf.loadTarget(mv);\n-\t\t\t}\n+\t\tLabel skipIfNull = null;\n+\t\tif (descriptor == null && !isStaticMethod) {\n+\t\t\t// Nothing on the stack but something is needed\n+\t\t\tcf.loadTarget(mv);\n \t\t}\n-\t\telse {\n-\t\t\tif (isStaticMethod) {\n-\t\t\t\t// Something on the stack when nothing is needed\n-\t\t\t\tmv.visitInsn(POP);\n-\t\t\t}\n+\t\tif ((descriptor != null || !isStaticMethod) && nullSafe) {\n+\t\t\tmv.visitInsn(DUP);\n+\t\t\tskipIfNull = new Label();\n+\t\t\tLabel continueLabel = new Label();\n+\t\t\tmv.visitJumpInsn(IFNONNULL,continueLabel);\n+\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n+\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n+\t\t\tmv.visitLabel(continueLabel);\n+\t\t}\n+\t\tif (descriptor != null && isStaticMethod) {\n+\t\t\t// Something on the stack when nothing is needed\n+\t\t\tmv.visitInsn(POP);\n \t\t}\n \t\t\n \t\tif (CodeFlow.isPrimitive(descriptor)) {\n@@ -323,6 +339,14 @@ public void generateCode(MethodVisitor mv, CodeFlow cf) {\n \t\tmv.visitMethodInsn((isStaticMethod ? INVOKESTATIC : INVOKEVIRTUAL), classDesc, method.getName(),\n \t\t\t\tCodeFlow.createSignatureDescriptor(method), method.getDeclaringClass().isInterface());\n \t\tcf.pushDescriptor(this.exitTypeDescriptor);\n+\t\tif (originalPrimitiveExitTypeDescriptor != null) {\n+\t\t\t// The output of the accessor will be a primitive but from the block above it might be null,\n+\t\t\t// so to have a 'common stack' element at skipIfNull target we need to box the primitive\n+\t\t\tCodeFlow.insertBoxIfNecessary(mv, originalPrimitiveExitTypeDescriptor);\n+\t\t}\n+\t\tif (skipIfNull != null) {\n+\t\t\tmv.visitLabel(skipIfNull);\n+\t\t}\n \t}\n \n "
        },
        {
            "sha": "646cb7d9155a76a3cd12c95ad0322efd13eb501c",
            "filename": "spring-expression/src/main/java/org/springframework/expression/spel/ast/PropertyOrFieldReference.java",
            "status": "modified",
            "additions": 37,
            "deletions": 3,
            "changes": 40,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Fmain%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2Fast%2FPropertyOrFieldReference.java?ref=d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
            "patch": "@@ -21,6 +21,7 @@\n import java.util.List;\n import java.util.Map;\n \n+import org.springframework.asm.Label;\n import org.springframework.asm.MethodVisitor;\n import org.springframework.core.convert.TypeDescriptor;\n import org.springframework.expression.AccessException;\n@@ -47,6 +48,8 @@ public class PropertyOrFieldReference extends SpelNodeImpl {\n \n \tprivate final boolean nullSafe;\n \n+\tprivate String originalPrimitiveExitTypeDescriptor = null;\n+\n \tprivate final String name;\n \n \tprivate volatile PropertyAccessor cachedReadAccessor;\n@@ -83,7 +86,7 @@ public TypedValue getValueInternal(ExpressionState state) throws EvaluationExcep\n \t\tPropertyAccessor accessorToUse = this.cachedReadAccessor;\n \t\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n \t\t\tCompilablePropertyAccessor accessor = (CompilablePropertyAccessor) accessorToUse;\n-\t\t\tthis.exitTypeDescriptor = CodeFlow.toDescriptor(accessor.getPropertyType());\n+\t\t\tsetExitTypeDescriptor(CodeFlow.toDescriptor(accessor.getPropertyType()));\n \t\t}\n \t\treturn tv;\n \t}\n@@ -350,8 +353,40 @@ public void generateCode(MethodVisitor mv, CodeFlow cf) {\n \t\tif (!(accessorToUse instanceof CompilablePropertyAccessor)) {\n \t\t\tthrow new IllegalStateException(\"Property accessor is not compilable: \" + accessorToUse);\n \t\t}\n+\t\tLabel skipIfNull = null;\n+\t\tif (nullSafe) {\n+\t\t\tmv.visitInsn(DUP);\n+\t\t\tskipIfNull = new Label();\n+\t\t\tLabel continueLabel = new Label();\n+\t\t\tmv.visitJumpInsn(IFNONNULL,continueLabel);\n+\t\t\tCodeFlow.insertCheckCast(mv, this.exitTypeDescriptor);\n+\t\t\tmv.visitJumpInsn(GOTO, skipIfNull);\n+\t\t\tmv.visitLabel(continueLabel);\n+\t\t}\n \t\t((CompilablePropertyAccessor) accessorToUse).generateCode(this.name, mv, cf);\n \t\tcf.pushDescriptor(this.exitTypeDescriptor);\n+\t\tif (originalPrimitiveExitTypeDescriptor != null) {\n+\t\t\t// The output of the accessor is a primitive but from the block above it might be null,\n+\t\t\t// so to have a common stack element type at skipIfNull target it is necessary\n+\t\t\t// to box the primitive\n+\t\t\tCodeFlow.insertBoxIfNecessary(mv, originalPrimitiveExitTypeDescriptor);\n+\t\t}\n+\t\tif (skipIfNull != null) {\n+\t\t\tmv.visitLabel(skipIfNull);\n+\t\t}\n+\t}\n+\n+\tvoid setExitTypeDescriptor(String descriptor) {\n+\t\t// If this property or field access would return a primitive - and yet\n+\t\t// it is also marked null safe - then the exit type descriptor must be\n+\t\t// promoted to the box type to allow a null value to be passed on\n+\t\tif (this.nullSafe && CodeFlow.isPrimitive(descriptor)) {\n+\t\t\tthis.originalPrimitiveExitTypeDescriptor = descriptor;\n+\t\t\tthis.exitTypeDescriptor = CodeFlow.toBoxedDescriptor(descriptor);\n+\t\t}\n+\t\telse {\n+\t\t\tthis.exitTypeDescriptor = descriptor;\n+\t\t}\n \t}\n \n \n@@ -379,8 +414,7 @@ public TypedValue getValue() {\n \t\t\t\t\tthis.ref.getValueInternal(this.contextObject, this.evalContext, this.autoGrowNullReferences);\n \t\t\tPropertyAccessor accessorToUse = this.ref.cachedReadAccessor;\n \t\t\tif (accessorToUse instanceof CompilablePropertyAccessor) {\n-\t\t\t\tthis.ref.exitTypeDescriptor =\n-\t\t\t\t\t\tCodeFlow.toDescriptor(((CompilablePropertyAccessor) accessorToUse).getPropertyType());\n+\t\t\t\tthis.ref.setExitTypeDescriptor(CodeFlow.toDescriptor(((CompilablePropertyAccessor) accessorToUse).getPropertyType()));\n \t\t\t}\n \t\t\treturn value;\n \t\t}"
        },
        {
            "sha": "50330b25639871517ba166bb0ef36c7203d382c0",
            "filename": "spring-expression/src/test/java/org/springframework/expression/spel/SpelCompilationCoverageTests.java",
            "status": "modified",
            "additions": 197,
            "deletions": 1,
            "changes": 198,
            "blob_url": "https://github.com/spring-projects/spring-framework/blob/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java",
            "raw_url": "https://github.com/spring-projects/spring-framework/raw/d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java",
            "contents_url": "https://api.github.com/repos/spring-projects/spring-framework/contents/spring-expression%2Fsrc%2Ftest%2Fjava%2Forg%2Fspringframework%2Fexpression%2Fspel%2FSpelCompilationCoverageTests.java?ref=d3acf45ea4db51fa5c4cbd0bc0e7b6d9ef805e69",
            "patch": "@@ -701,7 +701,167 @@ public void ternaryWithBooleanReturn() { // SPR-12271\n \t\tassertCanCompile(expression);\n \t\tassertEquals(\"def\", expression.getValue());\n \t}\n+\t\n+\t@Test\n+\tpublic void nullsafeFieldPropertyDereferencing_SPR16489() throws Exception {\n+\t\tFooObjectHolder foh = new FooObjectHolder();\n+\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n+\t\tcontext.setRootObject(foh);\n+\n+\t\t// First non compiled:\n+\t\tSpelExpression expression = (SpelExpression) parser.parseExpression(\"foo?.object\");\n+\t\tassertEquals(\"hello\",expression.getValue(context));\n+\t\tfoh.foo = null;\n+\t\tassertNull(expression.getValue(context));\n+\t\t\n+\t\t// Now revert state of foh and try compiling it:\n+\t\tfoh.foo = new FooObject();\n+\t\tassertEquals(\"hello\",expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tassertEquals(\"hello\",expression.getValue(context));\n+\t\tfoh.foo = null;\n+\t\tassertNull(expression.getValue(context));\n+\t\t\n+\t\t// Static references\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.propertya\");\n+\t\tcontext.setVariable(\"var\", StaticsHelper.class);\n+\t\tassertEquals(\"sh\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", StaticsHelper.class);\n+\t\tassertEquals(\"sh\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Single size primitive (boolean)\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.a\");\n+\t\tcontext.setVariable(\"var\", new TestClass4());\n+\t\tassertFalse((Boolean)expression.getValue(context));\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", new TestClass4());\n+\t\tassertFalse((Boolean)expression.getValue(context));\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Double slot primitives\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.four\");\n+\t\tcontext.setVariable(\"var\", new Three());\n+\t\tassertEquals(\"0.04\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", new Three());\n+\t\tassertEquals(\"0.04\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t}\n+\t\n+\t@Test\n+\tpublic void nullsafeMethodChaining_SPR16489() throws Exception {\n+\t\tFooObjectHolder foh = new FooObjectHolder();\n+\t\tStandardEvaluationContext context = new StandardEvaluationContext();\n+\t\tcontext.setRootObject(foh);\n+\n+\t\t// First non compiled:\n+\t\tSpelExpression expression = (SpelExpression) parser.parseExpression(\"getFoo()?.getObject()\");\n+\t\tassertEquals(\"hello\",expression.getValue(context));\n+\t\tfoh.foo = null;\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tfoh.foo = new FooObject();\n+\t\tassertEquals(\"hello\",expression.getValue(context));\n+\t\tfoh.foo = null;\n+\t\tassertNull(expression.getValue(context));\n+\t\t\n+\t\t// Static method references\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.methoda()\");\n+\t\tcontext.setVariable(\"var\", StaticsHelper.class);\n+\t\tassertEquals(\"sh\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", StaticsHelper.class);\n+\t\tassertEquals(\"sh\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\t\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.intValue()\");\n+\t\tcontext.setVariable(\"var\", 4);\n+\t\tassertEquals(\"4\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", 4);\n+\t\tassertEquals(\"4\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n \n+\t\t\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.booleanValue()\");\n+\t\tcontext.setVariable(\"var\", false);\n+\t\tassertEquals(\"false\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", false);\n+\t\tassertEquals(\"false\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.booleanValue()\");\n+\t\tcontext.setVariable(\"var\", true);\n+\t\tassertEquals(\"true\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", true);\n+\t\tassertEquals(\"true\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.longValue()\");\n+\t\tcontext.setVariable(\"var\", 5L);\n+\t\tassertEquals(\"5\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", 5L);\n+\t\tassertEquals(\"5\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.floatValue()\");\n+\t\tcontext.setVariable(\"var\", 3f);\n+\t\tassertEquals(\"3.0\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", 3f);\n+\t\tassertEquals(\"3.0\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\n+\t\t// Nullsafe guard on expression element evaluating to primitive/null\n+\t\texpression = (SpelExpression)parser.parseExpression(\"#var?.shortValue()\");\n+\t\tcontext.setVariable(\"var\", (short)8);\n+\t\tassertEquals(\"8\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t\tassertCanCompile(expression);\n+\t\tcontext.setVariable(\"var\", (short)8);\n+\t\tassertEquals(\"8\",expression.getValue(context).toString());\n+\t\tcontext.setVariable(\"var\", null);\n+\t\tassertNull(expression.getValue(context));\n+\t}\n+\t\n \t@Test\n \tpublic void elvis() throws Exception {\n \t\tExpression expression = parser.parseExpression(\"'a'?:'b'\");\n@@ -3063,19 +3223,47 @@ public void opModulus_12041() throws Exception {\n \t\tassertEquals(1.0f, expression.getValue());\n \t}\n \n+\t@Test\n+\tpublic void compilationOfBasicNullSafeMethodReference() {\n+\t\tSpelExpressionParser parser = new SpelExpressionParser(\n+\t\t\t\tnew SpelParserConfiguration(SpelCompilerMode.OFF, getClass().getClassLoader()));\n+\t\tSpelExpression expression = parser.parseRaw(\"#it?.equals(3)\");\n+\t\tStandardEvaluationContext context = new StandardEvaluationContext(new Object[] {1});\n+\t\tcontext.setVariable(\"it\", 3);\n+\t\texpression.setEvaluationContext(context);\n+\t\tassertTrue(expression.getValue(Boolean.class));\n+\t\tcontext.setVariable(\"it\", null);\n+\t\tassertNull(expression.getValue(Boolean.class));\n+\t\t\n+\t\tassertCanCompile(expression);\n+\t\t\n+\t\tcontext.setVariable(\"it\", 3);\n+\t\tassertTrue(expression.getValue(Boolean.class));\n+\t\tcontext.setVariable(\"it\", null);\n+\t\tassertNull(expression.getValue(Boolean.class));\n+\t}\n+\t\n \t@Test\n \tpublic void failsWhenSettingContextForExpression_SPR12326() {\n \t\tSpelExpressionParser parser = new SpelExpressionParser(\n-\t\t\t\tnew SpelParserConfiguration(SpelCompilerMode.IMMEDIATE, getClass().getClassLoader()));\n+\t\t\t\tnew SpelParserConfiguration(SpelCompilerMode.OFF, getClass().getClassLoader()));\n \t\tPerson3 person = new Person3(\"foo\", 1);\n \t\tSpelExpression expression = parser.parseRaw(\"#it?.age?.equals([0])\");\n \t\tStandardEvaluationContext context = new StandardEvaluationContext(new Object[] {1});\n \t\tcontext.setVariable(\"it\", person);\n \t\texpression.setEvaluationContext(context);\n \t\tassertTrue(expression.getValue(Boolean.class));\n+\t\t// This will trigger compilation (second usage)\n \t\tassertTrue(expression.getValue(Boolean.class));\n+\t\tcontext.setVariable(\"it\", null);\n+\t\tassertNull(expression.getValue(Boolean.class));\n+\t\t\n \t\tassertCanCompile(expression);\n+\t\t\n+\t\tcontext.setVariable(\"it\", person);\n \t\tassertTrue(expression.getValue(Boolean.class));\n+\t\tcontext.setVariable(\"it\", null);\n+\t\tassertNull(expression.getValue(Boolean.class));\n \t}\n \n \n@@ -5078,6 +5266,14 @@ public Object getObject() {\n \t\t}\n \t}\n \n+\tpublic static class FooObjectHolder {\n+\t\t\n+\t\tprivate FooObject foo = new FooObject();\n+\t\t\n+\t\tpublic FooObject getFoo() {\n+\t\t\treturn foo;\n+\t\t}\n+\t}\n \n \tpublic static class FooObject {\n "
        }
    ]
}
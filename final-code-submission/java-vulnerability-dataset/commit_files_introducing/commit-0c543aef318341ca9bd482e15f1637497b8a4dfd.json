{
    "sha": "0c543aef318341ca9bd482e15f1637497b8a4dfd",
    "node_id": "MDY6Q29tbWl0MTU5Mjg2NTA6MGM1NDNhZWYzMTgzNDFjYTliZDQ4MmUxNWYxNjM3NDk3YjhhNGRmZA==",
    "commit": {
        "author": {
            "name": "Lukasz Lenart",
            "email": "lukaszlenart@apache.org",
            "date": "2010-02-18T08:22:46Z"
        },
        "committer": {
            "name": "Lukasz Lenart",
            "email": "lukaszlenart@apache.org",
            "date": "2010-02-18T08:22:46Z"
        },
        "message": "Move XWork core under Struts 2 to simplify relese proces\n\ngit-svn-id: https://svn.apache.org/repos/asf/struts/struts2/trunk@911280 13f79535-47bb-0310-9956-ffa450edef68",
        "tree": {
            "sha": "c99a42e141c9f04a4b385e9512d4fa26a85aac20",
            "url": "https://api.github.com/repos/apache/struts/git/trees/c99a42e141c9f04a4b385e9512d4fa26a85aac20"
        },
        "url": "https://api.github.com/repos/apache/struts/git/commits/0c543aef318341ca9bd482e15f1637497b8a4dfd",
        "comment_count": 0,
        "verification": {
            "verified": false,
            "reason": "unsigned",
            "signature": null,
            "payload": null,
            "verified_at": null
        }
    },
    "url": "https://api.github.com/repos/apache/struts/commits/0c543aef318341ca9bd482e15f1637497b8a4dfd",
    "html_url": "https://github.com/apache/struts/commit/0c543aef318341ca9bd482e15f1637497b8a4dfd",
    "comments_url": "https://api.github.com/repos/apache/struts/commits/0c543aef318341ca9bd482e15f1637497b8a4dfd/comments",
    "author": {
        "login": "lukaszlenart",
        "id": 170103,
        "node_id": "MDQ6VXNlcjE3MDEwMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/170103?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/lukaszlenart",
        "html_url": "https://github.com/lukaszlenart",
        "followers_url": "https://api.github.com/users/lukaszlenart/followers",
        "following_url": "https://api.github.com/users/lukaszlenart/following{/other_user}",
        "gists_url": "https://api.github.com/users/lukaszlenart/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/lukaszlenart/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lukaszlenart/subscriptions",
        "organizations_url": "https://api.github.com/users/lukaszlenart/orgs",
        "repos_url": "https://api.github.com/users/lukaszlenart/repos",
        "events_url": "https://api.github.com/users/lukaszlenart/events{/privacy}",
        "received_events_url": "https://api.github.com/users/lukaszlenart/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "committer": {
        "login": "lukaszlenart",
        "id": 170103,
        "node_id": "MDQ6VXNlcjE3MDEwMw==",
        "avatar_url": "https://avatars.githubusercontent.com/u/170103?v=4",
        "gravatar_id": "",
        "url": "https://api.github.com/users/lukaszlenart",
        "html_url": "https://github.com/lukaszlenart",
        "followers_url": "https://api.github.com/users/lukaszlenart/followers",
        "following_url": "https://api.github.com/users/lukaszlenart/following{/other_user}",
        "gists_url": "https://api.github.com/users/lukaszlenart/gists{/gist_id}",
        "starred_url": "https://api.github.com/users/lukaszlenart/starred{/owner}{/repo}",
        "subscriptions_url": "https://api.github.com/users/lukaszlenart/subscriptions",
        "organizations_url": "https://api.github.com/users/lukaszlenart/orgs",
        "repos_url": "https://api.github.com/users/lukaszlenart/repos",
        "events_url": "https://api.github.com/users/lukaszlenart/events{/privacy}",
        "received_events_url": "https://api.github.com/users/lukaszlenart/received_events",
        "type": "User",
        "user_view_type": "public",
        "site_admin": false
    },
    "parents": [
        {
            "sha": "053dfd2b0502750fdf413de8a45c982c9662e70c",
            "url": "https://api.github.com/repos/apache/struts/commits/053dfd2b0502750fdf413de8a45c982c9662e70c",
            "html_url": "https://github.com/apache/struts/commit/053dfd2b0502750fdf413de8a45c982c9662e70c"
        }
    ],
    "stats": {
        "total": 72963,
        "additions": 72963,
        "deletions": 0
    },
    "files": [
        {
            "sha": "ddc5e5c878e77e17d2227f37dda8cb8dd6a100dc",
            "filename": "xwork-core/pom.xml",
            "status": "added",
            "additions": 252,
            "deletions": 0,
            "changes": 252,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fpom.xml",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fpom.xml",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fpom.xml?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,252 @@\n+<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+<project xmlns=\"http://maven.apache.org/POM/4.0.0\" xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\"\n+         xsi:schemaLocation=\"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd\">\n+\n+    <modelVersion>4.0.0</modelVersion>\n+    <groupId>com.opensymphony</groupId>\n+    <artifactId>xwork-core</artifactId>\n+    <packaging>jar</packaging>\n+    <name>XWork: Core</name>\n+    \n+    <parent>\n+        <groupId>com.opensymphony</groupId>\n+        <artifactId>xwork-parent</artifactId>\n+        <version>2.1.7-SNAPSHOT</version>\n+    </parent>\n+\n+    <scm>\n+        <connection>scm:svn:http://svn.opensymphony.com/svn/xwork/trunk/core</connection>\n+        <developerConnection>\n+            scm:svn:https://svn.opensymphony.com/svn/xwork/trunk/core\n+        </developerConnection>\n+        <url>https://svn.opensymphony.com/svn/xwork/trunk/core</url>\n+    </scm>\n+\n+    <licenses>\n+        <license>\n+            <name>The OpenSymphony Software License 1.1</name>\n+            <url>../src/resources/LICENSE.txt</url>\n+            <comments>\n+                This license is derived and fully compatible with the Apache Software\n+                License - see http://www.apache.org/LICENSE.txt\n+            </comments>\n+        </license>\n+    </licenses>\n+\n+    <profiles>\n+        <profile>\n+            <!--\n+                   Run the translator for Java 1.4 compatiblity\n+\n+                   OS/X Sample:\n+                   $ cd xwork/\n+                   $ mvn clean install -Pj4 -Djava14.jar=$JAVA_HOME/../Classes/classes.jar\n+\n+                -->\n+            <id>j4</id>\n+            <build>\n+                <plugins>\n+                    <plugin>\n+                        <groupId>org.codehaus.mojo</groupId>\n+                        <artifactId>retrotranslator-maven-plugin</artifactId>\n+                        <version>1.0-alpha-4</version>\n+                        <executions>\n+                            <execution>\n+                                <phase>package</phase>\n+                                <goals>\n+                                    <goal>translate-project</goal>\n+                                </goals>\n+                                <configuration>\n+                                    <verify>false</verify>\n+                                    <failonwarning>true</failonwarning>\n+                                    <lazy>true</lazy>\n+                                    <advanced>true</advanced>\n+                                    <verbose>false</verbose>\n+                                </configuration>\n+                            </execution>\n+                        </executions>\n+                    </plugin>\n+                </plugins>\n+            </build>\n+            <!--\n+            <dependencies>\n+                <dependency>\n+                    <groupId>sun.jdk</groupId>\n+                    <artifactId>rt</artifactId>\n+                    <version>1.4.0</version>\n+                    <scope>system</scope>\n+                    <systemPath>${java14.jar}</systemPath>\n+                </dependency>\n+                <dependency>\n+                    <groupId>net.sf.retrotranslator</groupId>\n+                    <artifactId>retrotranslator-runtime</artifactId>\n+                    <version>1.2.1</version>\n+                </dependency>\n+                <dependency>\n+                    <groupId>net.sf.retrotranslator</groupId>\n+                    <artifactId>retrotranslator-transformer</artifactId>\n+                    <version>1.2.1</version>\n+                </dependency>\n+            </dependencies>\n+            -->\n+        </profile>\n+    </profiles>\n+\n+    <build>\n+        <sourceDirectory>${basedir}/src/main/java</sourceDirectory>\n+        <testSourceDirectory>${basedir}/src/test/java</testSourceDirectory>\n+        <resources>\n+            <resource>\n+                <directory>${basedir}/src/main/resources</directory>\n+            </resource>\n+        </resources>\n+        <testResources>\n+            <testResource>\n+                <directory>${basedir}/src/test/resources</directory>\n+            </testResource>\n+        </testResources>\n+        <plugins>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-surefire-plugin</artifactId>\n+                <version>2.4.2</version>\n+                <configuration>\n+                    <useSystemClassLoader>false</useSystemClassLoader>\n+                    <additionalClasspathElements>\n+                        <element>${project.build.testOutputDirectory}/xwork-jar.jar</element>\n+                        <element>${project.build.testOutputDirectory}/xwork-zip.zip</element>\n+                        <element>${project.build.testOutputDirectory}/xwork - jar.jar</element>\n+                        <element>${project.build.testOutputDirectory}/xwork - zip.zip</element>\n+                    </additionalClasspathElements>\n+                    <includes>\n+                        <include>**/*Test.java</include>\n+                    </includes>\n+                    <excludes>\n+                        <exclude>**/XWorkTestCase.java</exclude>\n+                        <exclude>**/TestBean.java</exclude>\n+                        <exclude>**/TestBean2.java</exclude>\n+                        <exclude>**/TestInterceptor.java</exclude>\n+                        <exclude>**/AnnotatedTestBean.java</exclude>\n+                        <exclude>**/ContainerImplTest.java</exclude>\n+                        <exclude>**/URLUtilTest.java</exclude>\n+                    </excludes>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.codehaus.mojo</groupId>\n+                <artifactId>cobertura-maven-plugin</artifactId>\n+                <executions>\n+                    <execution>\n+                        <goals>\n+                            <goal>clean</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <artifactId>maven-jar-plugin</artifactId>\n+                <configuration>\n+                    <archive>\n+                        <manifestFile>${project.build.outputDirectory}/META-INF/MANIFEST.MF</manifestFile>\n+                    </archive>\n+                </configuration>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.maven.plugins</groupId>\n+                <artifactId>maven-shade-plugin</artifactId>\n+                <version>1.2</version>\n+                <executions>\n+                    <execution>\n+                        <phase>package</phase>\n+                        <goals>\n+                            <goal>shade</goal>\n+                        </goals>\n+                        <configuration>\n+                            <shadedArtifactId>xwork-core</shadedArtifactId>\n+                            <artifactSet>\n+                                <excludes>\n+                                    <exclude>junit:junit</exclude>\n+                                    <exclude>commons-logging:commons-logging</exclude>\n+                                    <exclude>opensymphony:ognl</exclude>\n+                                    <exclude>ognl:ognl</exclude>\n+                                    <exclude>jboss:javassist</exclude>\n+                                    <exclude>org.springframework:spring-core</exclude>\n+                                    <exclude>org.springframework:spring-aop</exclude>\n+                                    <exclude>org.springframework:spring-aspects</exclude>\n+                                    <exclude>org.springframework:spring-beans</exclude>\n+                                    <exclude>org.springframework:spring-context</exclude>\n+                                    <exclude>org.springframework:spring-context-support</exclude>\n+                                    <exclude>org.springframework:spring-web</exclude>\n+                                    <exclude>org.springframework:spring-test</exclude>\n+                                    <exclude>mockobjects:mockobjects-core</exclude>\n+                                    <exclude>org.easymock:easymock</exclude>\n+                                    <exclude>aopalliance:aopalliance</exclude>\n+                                    <exclude>aspectwerkz:aspectwerkz-core</exclude>\n+                                    <exclude>org.aspectj:aspectjrt</exclude>\n+                                    <exclude>org.aspectj:aspectjweaver</exclude>\n+                                    <exclude>cglib:cglib</exclude>\n+                                    <exclude>cglib:cglib-nodep</exclude>\n+                                    <exclude>asm:asm-util</exclude>\n+                                    <exclude>org.testng:testng:jdk15</exclude>\n+                                </excludes>\n+                            </artifactSet>\n+                            <filters>\n+                                <filter>\n+                                    <artifact>commons-lang:commons-lang</artifact>\n+                                    <includes>\n+                                        <include>org/apache/commons/lang/StringUtils.class</include>\n+                                        <include>org/apache/commons/lang/math/NumberUtils.class</include>\n+                                        <include>org/apache/commons/lang/ObjectUtils*.class</include>\n+                                        <include>org/apache/commons/lang/StringEscapeUtils.class</include>\n+                                        <include>org/apache/commons/lang/exception/NestableRuntimeException.class</include>\n+                                        <include>org/apache/commons/lang/exception/Nestable.class</include>\n+                                        <include>org/apache/commons/lang/Entities*class</include>\n+                                        <include>org/apache/commons/lang/UnhandledException.class</include>\n+                                        <include>org/apache/commons/lang/IntHashMap*class</include>\n+                                    </includes>\n+                                </filter>\n+                            </filters>\n+                            <relocations>\n+                                <relocation>\n+                                    <pattern>org.objectweb.asm</pattern>\n+                                    <shadedPattern>org.objectweb.asm.xwork</shadedPattern>\n+                                </relocation>\n+                                <relocation>\n+                                    <pattern>org.apache.commons.lang</pattern>\n+                                    <shadedPattern>org.apache.commons.lang.xwork</shadedPattern>\n+                                </relocation>\n+                            </relocations>\n+                            <transformers>\n+                                <transformer\n+                                        implementation=\"org.apache.maven.plugins.shade.resource.ComponentsXmlResourceTransformer\"/>\n+                            </transformers>\n+                        </configuration>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+            <plugin>\n+                <groupId>org.apache.felix</groupId>\n+                <artifactId>maven-bundle-plugin</artifactId>\n+                <configuration>\n+                    <instructions>\n+                        <Export-Package>org.apache.commons.lang.xwork.*,com.opensymphony.xwork2.*</Export-Package>\n+                    </instructions>\n+                </configuration>\n+                <executions>\n+                    <execution>\n+                        <id>bundle-manifest</id>\n+                        <phase>process-classes</phase>\n+                        <goals>\n+                            <goal>manifest</goal>\n+                        </goals>\n+                    </execution>\n+                </executions>\n+            </plugin>\n+        </plugins>\n+        <defaultGoal>install</defaultGoal>\n+    </build>\n+\n+\n+\n+\n+</project>"
        },
        {
            "sha": "f10a431b680ac711fde521edd54870d11442c950",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/Action.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FAction.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FAction.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FAction.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,80 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+/**\n+ * All actions <b>may</b> implement this interface, which exposes the <code>execute()</code> method.\n+ * <p/>\n+ * However, as of XWork 1.1, this is <b>not</b> required and is only here to assist users. You are free to create POJOs\n+ * that honor the same contract defined by this interface without actually implementing the interface.\n+ */\n+public interface Action {\n+\n+    /**\n+     * The action execution was successful. Show result\n+     * view to the end user.\n+     */\n+    public static final String SUCCESS = \"success\";\n+\n+    /**\n+     * The action execution was successful but do not\n+     * show a view. This is useful for actions that are\n+     * handling the view in another fashion like redirect.\n+     */\n+    public static final String NONE = \"none\";\n+\n+    /**\n+     * The action execution was a failure.\n+     * Show an error view, possibly asking the\n+     * user to retry entering data.\n+     */\n+    public static final String ERROR = \"error\";\n+\n+    /**\n+     * The action execution require more input\n+     * in order to succeed.\n+     * This result is typically used if a form\n+     * handling action has been executed so as\n+     * to provide defaults for a form. The\n+     * form associated with the handler should be\n+     * shown to the end user.\n+     * <p/>\n+     * This result is also used if the given input\n+     * params are invalid, meaning the user\n+     * should try providing input again.\n+     */\n+    public static final String INPUT = \"input\";\n+\n+    /**\n+     * The action could not execute, since the\n+     * user most was not logged in. The login view\n+     * should be shown.\n+     */\n+    public static final String LOGIN = \"login\";\n+\n+\n+    /**\n+     * Where the logic of the action is executed.\n+     *\n+     * @return a string representing the logical result of the execution.\n+     *         See constants in this interface for a list of standard result values.\n+     * @throws Exception thrown if a system level exception occurs.\n+     *                   <b>Note:</b> Application level exceptions should be handled by returning\n+     *                   an error value, such as <code>Action.ERROR</code>.\n+     */\n+    public String execute() throws Exception;\n+\n+}"
        },
        {
            "sha": "170c56796880124f3c5197a0a672deafcf6033ec",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionChainResult.java",
            "status": "added",
            "additions": 291,
            "deletions": 0,
            "changes": 291,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionChainResult.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionChainResult.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionChainResult.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,291 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.*;\n+\n+\n+/**\n+* <!-- START SNIPPET: description -->\n+*\n+* This result invokes an entire other action, complete with it's own interceptor stack and result.\n+*\n+* <!-- END SNIPPET: description -->\n+*\n+* <b>This result type takes the following parameters:</b>\n+*\n+* <!-- START SNIPPET: params -->\n+*\n+* <ul>\n+*\n+* <li><b>actionName (default)</b> - the name of the action that will be chained to</li>\n+*\n+* <li><b>namespace</b> - used to determine which namespace the Action is in that we're chaining. If namespace is null,\n+* this defaults to the current namespace</li>\n+*\n+* <li><b>method</b> - used to specify another method on target action to be invoked.\n+* If null, this defaults to execute method</li>\n+*\n+* <li><b>skipActions</b> - (optional) the list of comma separated action names for the\n+* actions that could be chained to</li>\n+*\n+* </ul>\n+*\n+* <!-- END SNIPPET: params -->\n+*\n+* <b>Example:</b>\n+*\n+* <pre><!-- START SNIPPET: example -->\n+* &lt;package name=\"public\" extends=\"struts-default\"&gt;\n+*     &lt;!-- Chain creatAccount to login, using the default parameter --&gt;\n+*     &lt;action name=\"createAccount\" class=\"...\"&gt;\n+*         &lt;result type=\"chain\"&gt;login&lt;/result&gt;\n+*     &lt;/action&gt;\n+*\n+*     &lt;action name=\"login\" class=\"...\"&gt;\n+*         &lt;!-- Chain to another namespace --&gt;\n+*         &lt;result type=\"chain\"&gt;\n+*             &lt;param name=\"actionName\"&gt;dashboard&lt;/param&gt;\n+*             &lt;param name=\"namespace\"&gt;/secure&lt;/param&gt;\n+*         &lt;/result&gt;\n+*     &lt;/action&gt;\n+* &lt;/package&gt;\n+*\n+* &lt;package name=\"secure\" extends=\"struts-default\" namespace=\"/secure\"&gt;\n+*     &lt;action name=\"dashboard\" class=\"...\"&gt;\n+*         &lt;result&gt;dashboard.jsp&lt;/result&gt;\n+*     &lt;/action&gt;\n+* &lt;/package&gt;\n+* <!-- END SNIPPET: example --></pre>\n+*\n+* @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+*/\n+public class ActionChainResult implements Result {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ActionChainResult.class);\n+\n+    /**\n+     * The result parameter name to set the name of the action to chain to.\n+     */\n+    public static final String DEFAULT_PARAM = \"actionName\";\n+\n+    /**\n+     * The action context key to save the chain history.\n+     */\n+    private static final String CHAIN_HISTORY = \"CHAIN_HISTORY\";\n+\n+    /**\n+     * The result parameter name to set the name of the action to chain to.\n+     */\n+    public static final String SKIP_ACTIONS_PARAM = \"skipActions\";\n+\n+\n+    private ActionProxy proxy;\n+    private String actionName;\n+    \n+    private String namespace;\n+\n+    private String methodName;\n+\n+    /**\n+     * The list of actions to skip.\n+     */\n+    private String skipActions;\n+\n+    private ActionProxyFactory actionProxyFactory;\n+\n+    public ActionChainResult() {\n+        super();\n+    }\n+\n+    public ActionChainResult(String namespace, String actionName, String methodName) {\n+        this.namespace = namespace;\n+        this.actionName = actionName;\n+        this.methodName = methodName;\n+    }\n+\n+    public ActionChainResult(String namespace, String actionName, String methodName, String skipActions) {\n+        this.namespace = namespace;\n+        this.actionName = actionName;\n+        this.methodName = methodName;\n+        this.skipActions = skipActions;\n+    }\n+\n+\n+    /**\n+     * @param actionProxyFactory the actionProxyFactory to set\n+     */\n+    @Inject\n+    public void setActionProxyFactory(ActionProxyFactory actionProxyFactory) {\n+        this.actionProxyFactory = actionProxyFactory;\n+    }\n+\n+    /**\n+     * Set the action name.\n+     *\n+     * @param actionName The action name.\n+     */\n+    public void setActionName(String actionName) {\n+        this.actionName = actionName;\n+    }\n+\n+    /**\n+     * sets the namespace of the Action that we're chaining to.  if namespace\n+     * is null, this defaults to the current namespace.\n+     *\n+     * @param namespace the name of the namespace we're chaining to\n+     */\n+    public void setNamespace(String namespace) {\n+        this.namespace = namespace;\n+    }\n+\n+    /**\n+     * Set the list of actions to skip.\n+     * To test if an action should not throe an infinite recursion,\n+     * only the action name is used, not the namespace.\n+     *\n+     * @param actions The list of action name separated by a white space.\n+     */\n+    public void setSkipActions(String actions) {\n+        this.skipActions = actions;\n+    }\n+\n+\n+    public void setMethod(String method) {\n+        this.methodName = method;\n+    }\n+\n+    public ActionProxy getProxy() {\n+        return proxy;\n+    }\n+\n+    /**\n+     * Get the XWork chain history.\n+     * The stack is a list of <code>namespace/action!method</code> keys.\n+     */\n+    public static LinkedList<String> getChainHistory() {\n+        LinkedList<String> chainHistory = (LinkedList<String>) ActionContext.getContext().get(CHAIN_HISTORY);\n+        //  Add if not exists\n+        if (chainHistory == null) {\n+            chainHistory = new LinkedList<String>();\n+            ActionContext.getContext().put(CHAIN_HISTORY, chainHistory);\n+        }\n+\n+        return chainHistory;\n+    }\n+\n+    /**\n+     * @param invocation the DefaultActionInvocation calling the action call stack\n+     */\n+    public void execute(ActionInvocation invocation) throws Exception {\n+        // if the finalNamespace wasn't explicitly defined, assume the current one\n+        if (this.namespace == null) {\n+            this.namespace = invocation.getProxy().getNamespace();\n+        }\n+\n+        ValueStack stack = ActionContext.getContext().getValueStack();\n+        String finalNamespace = TextParseUtil.translateVariables(namespace, stack);\n+        String finalActionName = TextParseUtil.translateVariables(actionName, stack);\n+        String finalMethodName = this.methodName != null\n+                ? TextParseUtil.translateVariables(this.methodName, stack)\n+                : null;\n+\n+        if (isInChainHistory(finalNamespace, finalActionName, finalMethodName)) {\n+            addToHistory(finalNamespace, finalActionName, finalMethodName);\n+            throw new XWorkException(\"Infinite recursion detected: \"\n+                    + ActionChainResult.getChainHistory().toString());\n+        }\n+\n+        if (ActionChainResult.getChainHistory().isEmpty() && invocation != null && invocation.getProxy() != null) {\n+            addToHistory(finalNamespace, invocation.getProxy().getActionName(), invocation.getProxy().getMethod());\n+        }\n+        addToHistory(finalNamespace, finalActionName, finalMethodName);\n+\n+        HashMap<String, Object> extraContext = new HashMap<String, Object>();\n+        extraContext.put(ActionContext.VALUE_STACK, ActionContext.getContext().getValueStack());\n+        extraContext.put(ActionContext.PARAMETERS, ActionContext.getContext().getParameters());\n+        extraContext.put(CHAIN_HISTORY, ActionChainResult.getChainHistory());\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Chaining to action \" + finalActionName);\n+        }\n+\n+        proxy = actionProxyFactory.createActionProxy(finalNamespace, finalActionName, finalMethodName, extraContext);\n+        proxy.execute();\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        final ActionChainResult that = (ActionChainResult) o;\n+\n+        if (actionName != null ? !actionName.equals(that.actionName) : that.actionName != null) return false;\n+        if (methodName != null ? !methodName.equals(that.methodName) : that.methodName != null) return false;\n+        if (namespace != null ? !namespace.equals(that.namespace) : that.namespace != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override public int hashCode() {\n+        int result;\n+        result = (actionName != null ? actionName.hashCode() : 0);\n+        result = 31 * result + (namespace != null ? namespace.hashCode() : 0);\n+        result = 31 * result + (methodName != null ? methodName.hashCode() : 0);\n+        return result;\n+    }\n+\n+    private boolean isInChainHistory(String namespace, String actionName, String methodName) {\n+        LinkedList<? extends String> chainHistory = ActionChainResult.getChainHistory();\n+\n+        if (chainHistory == null) {\n+            return false;\n+        } else {\n+            //  Actions to skip\n+            Set<String> skipActionsList = new HashSet<String>();\n+            if (skipActions != null && skipActions.length() > 0) {\n+                ValueStack stack = ActionContext.getContext().getValueStack();\n+                String finalSkipActions = TextParseUtil.translateVariables(this.skipActions, stack);\n+                skipActionsList.addAll(TextParseUtil.commaDelimitedStringToSet(finalSkipActions));\n+            }\n+            if (!skipActionsList.contains(actionName)) {\n+                //  Get if key is in the chain history\n+                return chainHistory.contains(makeKey(namespace, actionName, methodName));\n+            }\n+\n+            return false;\n+        }\n+    }\n+\n+    private void addToHistory(String namespace, String actionName, String methodName) {\n+        List<String> chainHistory = ActionChainResult.getChainHistory();\n+        chainHistory.add(makeKey(namespace, actionName, methodName));\n+    }\n+\n+    private String makeKey(String namespace, String actionName, String methodName) {\n+        if (null == methodName) {\n+            return namespace + \"/\" + actionName;\n+        }\n+\n+        return namespace + \"/\" + actionName + \"!\" + methodName;\n+    }\n+}"
        },
        {
            "sha": "c8ed44b1e8c1912d3795cc812c7310e96d47e298",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionContext.java",
            "status": "added",
            "additions": 369,
            "deletions": 0,
            "changes": 369,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,369 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Locale;\n+import java.util.Map;\n+\n+\n+/**\n+ * The ActionContext is the context in which an {@link Action} is executed. Each context is basically a\n+ * container of objects an action needs for execution like the session, parameters, locale, etc. <p>\n+ * <p/>\n+ * The ActionContext is thread local which means that values stored in the ActionContext are\n+ * unique per thread. See the {@link ThreadLocal} class for more information. The benefit of\n+ * this is you don't need to worry about a user specific action context, you just get it:\n+ * <p/>\n+ * <ul><code>ActionContext context = ActionContext.getContext();</code></ul>\n+ * <p/>\n+ * Finally, because of the thread local usage you don't need to worry about making your actions thread safe.\n+ *\n+ * @author Patrick Lightbody\n+ * @author Bill Lynch (docs)\n+ */\n+public class ActionContext implements Serializable {\n+    static ThreadLocal actionContext = new ThreadLocal();\n+\n+    /**\n+     * Constant that indicates the action is running under a \"development mode\".\n+     * This mode provides more feedback that is useful for developers but probably\n+     * too verbose/error prone for production.\n+     */\n+    //public static final String DEV_MODE = \"__devMode\";\n+\n+    /**\n+     * Constant for the name of the action being executed.\n+     */\n+    public static final String ACTION_NAME = \"com.opensymphony.xwork2.ActionContext.name\";\n+\n+    /**\n+     * Constant for the {@link com.opensymphony.xwork2.util.ValueStack OGNL value stack}.\n+     */\n+    public static final String VALUE_STACK = ValueStack.VALUE_STACK;\n+\n+    /**\n+     * Constant for the action's session.\n+     */\n+    public static final String SESSION = \"com.opensymphony.xwork2.ActionContext.session\";\n+\n+    /**\n+     * Constant for the action's application context.\n+     */\n+    public static final String APPLICATION = \"com.opensymphony.xwork2.ActionContext.application\";\n+\n+    /**\n+     * Constant for the action's parameters.\n+     */\n+    public static final String PARAMETERS = \"com.opensymphony.xwork2.ActionContext.parameters\";\n+\n+    /**\n+     * Constant for the action's locale.\n+     */\n+    public static final String LOCALE = \"com.opensymphony.xwork2.ActionContext.locale\";\n+\n+    /**\n+     * Constant for the action's type converter.\n+     */\n+    public static final String TYPE_CONVERTER = \"com.opensymphony.xwork2.ActionContext.typeConverter\";\n+\n+    /**\n+     * Constant for the action's {@link com.opensymphony.xwork2.ActionInvocation invocation} context.\n+     */\n+    public static final String ACTION_INVOCATION = \"com.opensymphony.xwork2.ActionContext.actionInvocation\";\n+\n+    /**\n+     * Constant for the map of type conversion errors.\n+     */\n+    public static final String CONVERSION_ERRORS = \"com.opensymphony.xwork2.ActionContext.conversionErrors\";\n+\n+\n+    /**\n+     * Constant for the container\n+     */\n+    public static final String CONTAINER = \"com.opensymphony.xwork2.ActionContext.container\";\n+    \n+    Map<String, Object> context;\n+\n+\n+    /**\n+     * Creates a new ActionContext initialized with another context.\n+     *\n+     * @param context a context map.\n+     */\n+    public ActionContext(Map<String, Object> context) {\n+        this.context = context;\n+    }\n+\n+\n+    /**\n+     * Sets the action invocation (the execution state).\n+     *\n+     * @param actionInvocation the action execution state.\n+     */\n+    public void setActionInvocation(ActionInvocation actionInvocation) {\n+        put(ACTION_INVOCATION, actionInvocation);\n+    }\n+\n+    /**\n+     * Gets the action invocation (the execution state).\n+     *\n+     * @return the action invocation (the execution state).\n+     */\n+    public ActionInvocation getActionInvocation() {\n+        return (ActionInvocation) get(ACTION_INVOCATION);\n+    }\n+\n+    /**\n+     * Sets the action's application context.\n+     *\n+     * @param application the action's application context.\n+     */\n+    public void setApplication(Map<String, Object> application) {\n+        put(APPLICATION, application);\n+    }\n+\n+    /**\n+     * Returns a Map of the ServletContext when in a servlet environment or a generic application level Map otherwise.\n+     *\n+     * @return a Map of ServletContext or generic application level Map\n+     */\n+    public Map<String, Object> getApplication() {\n+        return (Map<String, Object>) get(APPLICATION);\n+    }\n+\n+    /**\n+     * Sets the action context for the current thread.\n+     *\n+     * @param context the action context.\n+     */\n+    public static void setContext(ActionContext context) {\n+        actionContext.set(context);\n+    }\n+\n+    /**\n+     * Returns the ActionContext specific to the current thread.\n+     *\n+     * @return the ActionContext for the current thread, is never <tt>null</tt>.\n+     */\n+    public static ActionContext getContext() {\n+        return (ActionContext) actionContext.get();\n+\n+        // Don't do lazy context creation, as it requires container; the creation of which may \n+        // precede the context creation\n+        //if (context == null) {\n+        //    ValueStack vs = ValueStackFactory.getFactory().createValueStack();\n+        //    context = new ActionContext(vs.getContext());\n+        //    setContext(context);\n+        //}\n+\n+    }\n+\n+    /**\n+     * Sets the action's context map.\n+     *\n+     * @param contextMap the context map.\n+     */\n+    public void setContextMap(Map<String, Object> contextMap) {\n+        getContext().context = contextMap;\n+    }\n+\n+    /**\n+     * Gets the context map.\n+     *\n+     * @return the context map.\n+     */\n+    public Map<String, Object> getContextMap() {\n+        return context;\n+    }\n+\n+    /**\n+     * Sets conversion errors which occurred when executing the action.\n+     *\n+     * @param conversionErrors a Map of errors which occurred when executing the action.\n+     */\n+    public void setConversionErrors(Map<String, Object> conversionErrors) {\n+        put(CONVERSION_ERRORS, conversionErrors);\n+    }\n+\n+    /**\n+     * Gets the map of conversion errors which occurred when executing the action.\n+     *\n+     * @return the map of conversion errors which occurred when executing the action or an empty map if\n+     *         there were no errors.\n+     */\n+    public Map<String, Object> getConversionErrors() {\n+        Map<String, Object> errors = (Map) get(CONVERSION_ERRORS);\n+\n+        if (errors == null) {\n+            errors = new HashMap<String, Object>();\n+            setConversionErrors(errors);\n+        }\n+\n+        return errors;\n+    }\n+\n+    /**\n+     * Sets the Locale for the current action.\n+     *\n+     * @param locale the Locale for the current action.\n+     */\n+    public void setLocale(Locale locale) {\n+        put(LOCALE, locale);\n+    }\n+\n+    /**\n+     * Gets the Locale of the current action. If no locale was ever specified the platform's\n+     * {@link java.util.Locale#getDefault() default locale} is used.\n+     *\n+     * @return the Locale of the current action.\n+     */\n+    public Locale getLocale() {\n+        Locale locale = (Locale) get(LOCALE);\n+\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+            setLocale(locale);\n+        }\n+\n+        return locale;\n+    }\n+\n+    /**\n+     * Sets the name of the current Action in the ActionContext.\n+     *\n+     * @param name the name of the current action.\n+     */\n+    public void setName(String name) {\n+        put(ACTION_NAME, name);\n+    }\n+\n+    /**\n+     * Gets the name of the current Action.\n+     *\n+     * @return the name of the current action.\n+     */\n+    public String getName() {\n+        return (String) get(ACTION_NAME);\n+    }\n+\n+    /**\n+     * Sets the action parameters.\n+     *\n+     * @param parameters the parameters for the current action.\n+     */\n+    public void setParameters(Map<String, Object> parameters) {\n+        put(PARAMETERS, parameters);\n+    }\n+\n+    /**\n+     * Returns a Map of the HttpServletRequest parameters when in a servlet environment or a generic Map of\n+     * parameters otherwise.\n+     *\n+     * @return a Map of HttpServletRequest parameters or a multipart map when in a servlet environment, or a\n+     *         generic Map of parameters otherwise.\n+     */\n+    public Map<String, Object> getParameters() {\n+        return (Map<String, Object>) get(PARAMETERS);\n+    }\n+\n+    /**\n+     * Sets a map of action session values.\n+     *\n+     * @param session  the session values.\n+     */\n+    public void setSession(Map<String, Object> session) {\n+        put(SESSION, session);\n+    }\n+\n+    /**\n+     * Gets the Map of HttpSession values when in a servlet environment or a generic session map otherwise.\n+     *\n+     * @return the Map of HttpSession values when in a servlet environment or a generic session map otherwise.\n+     */\n+    public Map<String, Object> getSession() {\n+        return (Map<String, Object>) get(SESSION);\n+    }\n+\n+    /**\n+     * Sets the OGNL value stack.\n+     *\n+     * @param stack the OGNL value stack.\n+     */\n+    public void setValueStack(ValueStack stack) {\n+        put(VALUE_STACK, stack);\n+    }\n+\n+    /**\n+     * Gets the OGNL value stack.\n+     *\n+     * @return the OGNL value stack.\n+     */\n+    public ValueStack getValueStack() {\n+        return (ValueStack) get(VALUE_STACK);\n+    }\n+    \n+    /**\n+     * Gets the container for this request\n+     * \n+     * @param cont The container\n+     */\n+    public void setContainer(Container cont) {\n+        put(CONTAINER, cont);\n+    }\n+    \n+    /**\n+     * Sets the container for this request\n+     * \n+     * @return The container\n+     */\n+    public Container getContainer() {\n+        return (Container) get(CONTAINER);\n+    }\n+    \n+    public <T> T getInstance(Class<T> type) {\n+        Container cont = getContainer();\n+        if (cont != null) {\n+            return cont.getInstance(type);\n+        } else {\n+            throw new XWorkException(\"Cannot find an initialized container for this request.\");\n+        }\n+    }\n+\n+    /**\n+     * Returns a value that is stored in the current ActionContext by doing a lookup using the value's key.\n+     *\n+     * @param key the key used to find the value.\n+     * @return the value that was found using the key or <tt>null</tt> if the key was not found.\n+     */\n+    public Object get(String key) {\n+        return context.get(key);\n+    }\n+\n+    /**\n+     * Stores a value in the current ActionContext. The value can be looked up using the key.\n+     *\n+     * @param key   the key of the value.\n+     * @param value the value to be stored.\n+     */\n+    public void put(String key, Object value) {\n+        context.put(key, value);\n+    }\n+}"
        },
        {
            "sha": "58c992a518948cdf73299223742c060cf25ed2c6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionEventListener.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionEventListener.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionEventListener.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionEventListener.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,41 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+/**\n+ * Provides hooks for handling key action events\n+ */\n+public interface ActionEventListener {\n+    /**\n+     * Called after an action has been created. \n+     * \n+     * @param action The action\n+     * @param stack The current value stack\n+     * @return The action to use\n+     */\n+    public Object prepare(Object action, ValueStack stack);\n+    \n+    /**\n+     * Called when an exception is thrown by the action\n+     * \n+     * @param t The exception/error that was thrown\n+     * @param stack The current value stack\n+     * @return A result code to execute, can be null\n+     */\n+    public String handleException(Throwable t, ValueStack stack);\n+}"
        },
        {
            "sha": "4154a0afb65e773e979f1abdbdb7fd002d0fd4d1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionInvocation.java",
            "status": "added",
            "additions": 163,
            "deletions": 0,
            "changes": 163,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionInvocation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionInvocation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionInvocation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,163 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.interceptor.PreResultListener;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * An {@link ActionInvocation} represents the execution state of an {@link Action}. It holds the Interceptors and the Action instance.\n+ * By repeated re-entrant execution of the <code>invoke()</code> method, initially by the {@link ActionProxy}, then by the Interceptors, the\n+ * Interceptors are all executed, and then the {@link Action} and the {@link Result}.\n+ *\n+ * @author Jason Carreira\n+ * @see com.opensymphony.xwork2.ActionProxy\n+ */\n+public interface ActionInvocation extends Serializable {\n+\n+    /**\n+     * Get the Action associated with this ActionInvocation.\n+     *\n+     * @return the Action\n+     */\n+    Object getAction();\n+\n+    /**\n+     * Gets whether this ActionInvocation has executed before.\n+     * This will be set after the Action and the Result have executed.\n+     *\n+     * @return <tt>true</tt> if this ActionInvocation has executed before.\n+     */\n+    boolean isExecuted();\n+\n+    /**\n+     * Gets the ActionContext associated with this ActionInvocation. The ActionProxy is\n+     * responsible for setting this ActionContext onto the ThreadLocal before invoking\n+     * the ActionInvocation and resetting the old ActionContext afterwards.\n+     *\n+     * @return the ActionContext.\n+     */\n+    ActionContext getInvocationContext();\n+\n+    /**\n+     * Get the ActionProxy holding this ActionInvocation.\n+     *\n+     * @return the ActionProxy.\n+     */\n+    ActionProxy getProxy();\n+\n+    /**\n+     * If the ActionInvocation has been executed before and the Result is an instance of {@link ActionChainResult}, this method\n+     * will walk down the chain of <code>ActionChainResult</code>s until it finds a non-chain result, which will be returned. If the\n+     * ActionInvocation's result has not been executed before, the Result instance will be created and populated with\n+     * the result params.\n+     *\n+     * @return the result.\n+     * @throws Exception can be thrown.\n+     */\n+    Result getResult() throws Exception;\n+\n+    /**\n+     * Gets the result code returned from this ActionInvocation.\n+     *\n+     * @return the result code\n+     */\n+    String getResultCode();\n+\n+    /**\n+     * Sets the result code, possibly overriding the one returned by the\n+     * action.\n+     * <p/>\n+     * The \"intended\" purpose of this method is to allow PreResultListeners to\n+     * override the result code returned by the Action.\n+     * <p/>\n+     * If this method is used before the Action executes, the Action's returned\n+     * result code will override what was set. However the Action could (if\n+     * specifically coded to do so) inspect the ActionInvocation to see that\n+     * someone \"upstream\" (e.g. an Interceptor) had suggested a value as the\n+     * result, and it could therefore return the same value itself.\n+     * <p/>\n+     * If this method is called between the Action execution and the Result\n+     * execution, then the value set here will override the result code the\n+     * action had returned.  Creating an Interceptor that implements\n+     * {@link PreResultListener} will give you this oportunity.\n+     * <p/>\n+     * If this method is called after the Result has been executed, it will\n+     * have the effect of raising an IllegalStateException.\n+     *\n+     * @param resultCode  the result code.\n+     * @throws IllegalStateException if called after the Result has been executed.\n+     * @see #isExecuted()\n+     */\n+    void setResultCode(String resultCode);\n+\n+    /**\n+     * Gets the ValueStack associated with this ActionInvocation.\n+     *\n+     * @return the ValueStack\n+     */\n+    ValueStack getStack();\n+\n+    /**\n+     * Register a {@link PreResultListener} to be notified after the Action is executed and\n+     * before the Result is executed.\n+     * <p/>\n+     * The ActionInvocation implementation must guarantee that listeners will be called in\n+     * the order in which they are registered.\n+     * <p/>\n+     * Listener registration and execution does not need to be thread-safe.\n+     *\n+     * @param listener the listener to add.\n+     */\n+    void addPreResultListener(PreResultListener listener);\n+\n+    /**\n+     * Invokes the next step in processing this ActionInvocation.\n+     * <p/>\n+     * If there are more Interceptors, this will call the next one. If Interceptors choose not to short-circuit\n+     * ActionInvocation processing and return their own return code, they will call invoke() to allow the next Interceptor\n+     * to execute. If there are no more Interceptors to be applied, the Action is executed.\n+     * If the {@link ActionProxy#getExecuteResult()} method returns <tt>true</tt>, the Result is also executed.\n+     *\n+     * @throws Exception can be thrown.\n+     * @return the return code.\n+     */\n+    String invoke() throws Exception;\n+\n+    /**\n+     * Invokes only the Action (not Interceptors or Results).\n+     * <p/>\n+     * This is useful in rare situations where advanced usage with the interceptor/action/result workflow is\n+     * being manipulated for certain functionality.\n+     *\n+     * @return the return code.\n+     * @throws Exception can be thrown.\n+     */\n+    String invokeActionOnly() throws Exception;\n+\n+    /**\n+     * Sets the action event listener to respond to key action events.\n+     *\n+     * @param listener the listener.\n+     */\n+    void setActionEventListener(ActionEventListener listener);\n+\n+    void init(ActionProxy proxy) ;\n+\n+}"
        },
        {
            "sha": "916fef387705539a9d05173ff78835ddefe384cf",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionProxy.java",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxy.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxy.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxy.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,96 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+\n+\n+/**\n+ * ActionProxy is an extra layer between XWork and the action so that different proxies are possible.\n+ * <p/>\n+ * An example of this would be a remote proxy, where the layer between XWork and the action might be RMI or SOAP.\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface ActionProxy {\n+\n+    /**\n+     * Gets the Action instance for this Proxy.\n+     *\n+     * @return the Action instance\n+     */\n+    Object getAction();\n+\n+    /**\n+     * Gets the alias name this ActionProxy is mapped to.\n+     *\n+     * @return the alias name\n+     */\n+    String getActionName();\n+\n+    /**\n+     * Gets the ActionConfig this ActionProxy is built from.\n+     *\n+     * @return the ActionConfig\n+     */\n+    ActionConfig getConfig();\n+\n+    /**\n+     * Sets whether this ActionProxy should also execute the Result after executing the Action.\n+     *\n+     * @param executeResult <tt>true</tt> to also execute the Result.\n+     */\n+    void setExecuteResult(boolean executeResult);\n+\n+    /**\n+     * Gets the status of whether the ActionProxy is set to execute the Result after the Action is executed.\n+     *\n+     * @return the status\n+     */\n+    boolean getExecuteResult();\n+\n+    /**\n+     * Gets the ActionInvocation associated with this ActionProxy.\n+     *\n+     * @return the ActionInvocation\n+     */\n+    ActionInvocation getInvocation();\n+\n+    /**\n+     * Gets the namespace the ActionConfig for this ActionProxy is mapped to.\n+     *\n+     * @return the namespace\n+     */\n+    String getNamespace();\n+\n+    /**\n+     * Execute this ActionProxy. This will set the ActionContext from the ActionInvocation into the ActionContext\n+     * ThreadLocal before invoking the ActionInvocation, then set the old ActionContext back into the ThreadLocal.\n+     *\n+     * @return the result code returned from executing the ActionInvocation\n+     * @throws Exception can be thrown.\n+     * @see ActionInvocation\n+     */\n+    String execute() throws Exception;\n+\n+    /**\n+     * Gets the method name to execute, or <tt>null</tt> if no method has been specified (meaning <code>execute</code> will be invoked).\n+     *\n+     * @return the method to execute\n+     */\n+    String getMethod();\n+    \n+}"
        },
        {
            "sha": "5cf4de016f532787e36ee0a2553787dee20411da",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionProxyFactory.java",
            "status": "added",
            "additions": 107,
            "deletions": 0,
            "changes": 107,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxyFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxyFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionProxyFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,107 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * The {@link ActionProxyFactory} is used to create {@link ActionProxy}s to be executed.\n+ * <p/>\n+ * It is the entry point to XWork that is used by a dispatcher to create an {@link ActionProxy} to execute\n+ * for a particular namespace and action name.\n+ *\n+ * @author Jason Carreira\n+ * @see DefaultActionProxyFactory\n+ */\n+public interface ActionProxyFactory {\n+\n+    /**\n+     * Creates an {@link ActionProxy} for the given namespace and action name by looking up the configuration.The ActionProxy\n+     * should be fully initialized when it is returned, including having an {@link ActionInvocation} instance associated.\n+     * <p/>\n+     * <b>Note:</b> This is the most used create method.\n+     *\n+     * @param namespace    the namespace of the action, can be <tt>null</tt>\n+     * @param actionName   the name of the action\n+     * @param extraContext a Map of extra parameters to be provided to the ActionProxy, can be <tt>null</tt>\n+     * @return ActionProxy  the created action proxy\n+     * @deprecated Since 2.1.1, use {@link #createActionProxy(String,String,String,Map) instead}\n+     */\n+    @Deprecated public ActionProxy createActionProxy(String namespace, String actionName, Map<String, Object> extraContext);\n+\n+    /**\n+     * Creates an {@link ActionProxy} for the given namespace and action name by looking up the configuration.The ActionProxy\n+     * should be fully initialized when it is returned, including having an {@link ActionInvocation} instance associated.\n+     * <p/>\n+     * <b>Note:</b> This is the most used create method.\n+     *\n+     * @param namespace    the namespace of the action, can be <tt>null</tt>\n+     * @param actionName   the name of the action\n+     * @param methodName   the name of the method to execute\n+     * @param extraContext a Map of extra parameters to be provided to the ActionProxy, can be <tt>null</tt>\n+     * @return ActionProxy  the created action proxy\n+     * @since 2.1.1\n+     */\n+    public ActionProxy createActionProxy(String namespace, String actionName, String methodName, Map<String, Object> extraContext);\n+\n+    /**\n+     * Creates an {@link ActionProxy} for the given namespace and action name by looking up the configuration.The ActionProxy\n+     * should be fully initialized when it is returned, including having an {@link ActionInvocation} instance associated.\n+     *\n+     * @param namespace    the namespace of the action, can be <tt>null</tt>\n+     * @param actionName   the name of the action\n+     * @param extraContext a Map of extra parameters to be provided to the ActionProxy, can be <tt>null</tt>\n+     * @param executeResult flag which tells whether the result should be executed after the action\n+     * @param cleanupContext flag which tells whether the original context should be preserved during execution of the proxy.\n+     * @return ActionProxy  the created action proxy\n+     * @deprecated Since 2.1.1, use {@link #createActionProxy(String,String,String,Map,boolean,boolean)} instead\n+     */\n+    @Deprecated public ActionProxy createActionProxy(String namespace, String actionName, Map<String, Object> extraContext, boolean executeResult, boolean cleanupContext);\n+\n+    /**\n+     * Creates an {@link ActionProxy} for the given namespace and action name by looking up the configuration.The ActionProxy\n+     * should be fully initialized when it is returned, including having an {@link ActionInvocation} instance associated.\n+     *\n+     * @param namespace    the namespace of the action, can be <tt>null</tt>\n+     * @param actionName   the name of the action\n+     * @param methodName   the name of the method to execute\n+     * @param extraContext a Map of extra parameters to be provided to the ActionProxy, can be <tt>null</tt>\n+     * @param executeResult flag which tells whether the result should be executed after the action\n+     * @param cleanupContext flag which tells whether the original context should be preserved during execution of the proxy.\n+     * @return ActionProxy  the created action proxy\n+     * @since 2.1.1\n+     */\n+    public ActionProxy createActionProxy(String namespace, String actionName, String methodName, Map<String, Object> extraContext, boolean executeResult, boolean cleanupContext);\n+\n+\n+     /**\n+     * Creates an {@link ActionProxy} for the given namespace and action name by looking up the configuration.The ActionProxy\n+     * should be fully initialized when it is returned, including passed {@link ActionInvocation} instance.\n+     *\n+     * @param actionInvocation the action invocation instance to associate with\n+     * @param namespace    the namespace of the action, can be <tt>null</tt>\n+     * @param actionName   the name of the action\n+     * @param methodName   the name of the method to execute\n+     * @param executeResult flag which tells whether the result should be executed after the action\n+     * @param cleanupContext flag which tells whether the original context should be preserved during execution of the proxy.\n+     * @return ActionProxy  the created action proxy\n+     * @since 2.1.1\n+     */\n+    public ActionProxy createActionProxy(ActionInvocation actionInvocation, String namespace, String actionName, String methodName,\n+                                         boolean executeResult, boolean cleanupContext);\n+    \n+}"
        },
        {
            "sha": "530e0b43ae97f43a708bdb8f83d0130dd7391504",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ActionSupport.java",
            "status": "added",
            "additions": 287,
            "deletions": 0,
            "changes": 287,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionSupport.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionSupport.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FActionSupport.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,287 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Locale;\n+import java.util.Map;\n+import java.util.ResourceBundle;\n+\n+\n+/**\n+ * Provides a default implementation for the most common actions.\n+ * See the documentation for all the interfaces this class implements for more detailed information.\n+ */\n+public class ActionSupport implements Action, Validateable, ValidationAware, TextProvider, LocaleProvider, Serializable {\n+\n+    protected static Logger LOG = LoggerFactory.getLogger(ActionSupport.class);\n+\n+    private final ValidationAwareSupport validationAware = new ValidationAwareSupport();\n+\n+    private transient TextProvider textProvider;\n+    private Container container;\n+\n+    public void setActionErrors(Collection<String> errorMessages) {\n+        validationAware.setActionErrors(errorMessages);\n+    }\n+\n+    public Collection<String> getActionErrors() {\n+        return validationAware.getActionErrors();\n+    }\n+\n+    public void setActionMessages(Collection<String> messages) {\n+        validationAware.setActionMessages(messages);\n+    }\n+\n+    public Collection<String> getActionMessages() {\n+        return validationAware.getActionMessages();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #getActionErrors()}.\n+     */\n+    @Deprecated\n+    public Collection<String> getErrorMessages() {\n+        return getActionErrors();\n+    }\n+\n+    /**\n+     * @deprecated Use {@link #getFieldErrors()}.\n+     */\n+    @Deprecated\n+    public Map<String, List<String>> getErrors() {\n+        return getFieldErrors();\n+    }\n+\n+    public void setFieldErrors(Map<String, List<String>> errorMap) {\n+        validationAware.setFieldErrors(errorMap);\n+    }\n+\n+    public Map<String, List<String>> getFieldErrors() {\n+        return validationAware.getFieldErrors();\n+    }\n+\n+    public Locale getLocale() {\n+        ActionContext ctx = ActionContext.getContext();\n+        if (ctx != null) {\n+            return ctx.getLocale();\n+        } else {\n+            LOG.debug(\"Action context not initialized\");\n+            return null;\n+        }\n+    }\n+\n+    public boolean hasKey(String key) {\n+        return getTextProvider().hasKey(key);\n+    }\n+\n+    public String getText(String aTextName) {\n+        return getTextProvider().getText(aTextName);\n+    }\n+\n+    public String getText(String aTextName, String defaultValue) {\n+        return getTextProvider().getText(aTextName, defaultValue);\n+    }\n+\n+    public String getText(String aTextName, String defaultValue, String obj) {\n+        return getTextProvider().getText(aTextName, defaultValue, obj);\n+    }\n+\n+    public String getText(String aTextName, List<Object> args) {\n+        return getTextProvider().getText(aTextName, args);\n+    }\n+\n+    public String getText(String key, String[] args) {\n+        return getTextProvider().getText(key, args);\n+    }\n+\n+    public String getText(String aTextName, String defaultValue, List<Object> args) {\n+        return getTextProvider().getText(aTextName, defaultValue, args);\n+    }\n+\n+    public String getText(String key, String defaultValue, String[] args) {\n+        return getTextProvider().getText(key, defaultValue, args);\n+    }\n+\n+    public String getText(String key, String defaultValue, List<Object> args, ValueStack stack) {\n+        return getTextProvider().getText(key, defaultValue, args, stack);\n+    }\n+\n+    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n+        return getTextProvider().getText(key, defaultValue, args, stack);\n+    }\n+\n+    public ResourceBundle getTexts() {\n+        return getTextProvider().getTexts();\n+    }\n+\n+    public ResourceBundle getTexts(String aBundleName) {\n+        return getTextProvider().getTexts(aBundleName);\n+    }\n+\n+    public void addActionError(String anErrorMessage) {\n+        validationAware.addActionError(anErrorMessage);\n+    }\n+\n+    public void addActionMessage(String aMessage) {\n+        validationAware.addActionMessage(aMessage);\n+    }\n+\n+    public void addFieldError(String fieldName, String errorMessage) {\n+        validationAware.addFieldError(fieldName, errorMessage);\n+    }\n+\n+    public String input() throws Exception {\n+        return INPUT;\n+    }\n+\n+    public String doDefault() throws Exception {\n+        return SUCCESS;\n+    }\n+\n+    /**\n+     * A default implementation that does nothing an returns \"success\".\n+     * <p/>\n+     * Subclasses should override this method to provide their business logic.\n+     * <p/>\n+     * See also {@link com.opensymphony.xwork2.Action#execute()}.\n+     *\n+     * @return returns {@link #SUCCESS}\n+     * @throws Exception can be thrown by subclasses.\n+     */\n+    public String execute() throws Exception {\n+        return SUCCESS;\n+    }\n+\n+    public boolean hasActionErrors() {\n+        return validationAware.hasActionErrors();\n+    }\n+\n+    public boolean hasActionMessages() {\n+        return validationAware.hasActionMessages();\n+    }\n+\n+    public boolean hasErrors() {\n+        return validationAware.hasErrors();\n+    }\n+\n+    public boolean hasFieldErrors() {\n+        return validationAware.hasFieldErrors();\n+    }\n+\n+    /**\n+     * Clears field errors. Useful for Continuations and other situations\n+     * where you might want to clear parts of the state on the same action.\n+     */\n+    public void clearFieldErrors() {\n+        validationAware.clearFieldErrors();\n+    }\n+\n+    /**\n+     * Clears action errors. Useful for Continuations and other situations\n+     * where you might want to clear parts of the state on the same action.\n+     */\n+    public void clearActionErrors() {\n+        validationAware.clearActionErrors();\n+    }\n+\n+    /**\n+     * Clears messages. Useful for Continuations and other situations\n+     * where you might want to clear parts of the state on the same action.\n+     */\n+    public void clearMessages() {\n+        validationAware.clearMessages();\n+    }\n+\n+    /**\n+     * Clears all errors. Useful for Continuations and other situations\n+     * where you might want to clear parts of the state on the same action.\n+     */\n+    public void clearErrors() {\n+        validationAware.clearErrors();\n+    }\n+\n+    /**\n+     * Clears all errors and messages. Useful for Continuations and other situations\n+     * where you might want to clear parts of the state on the same action.\n+     */\n+    public void clearErrorsAndMessages() {\n+        validationAware.clearErrorsAndMessages();\n+    }\n+\n+    /**\n+     * A default implementation that validates nothing.\n+     * Subclasses should override this method to provide validations.\n+     */\n+    public void validate() {\n+    }\n+\n+    @Override\n+    public Object clone() throws CloneNotSupportedException {\n+        return super.clone();\n+    }\n+\n+    /**\n+     * <!-- START SNIPPET: pause-method -->\n+     * Stops the action invocation immediately (by throwing a PauseException) and causes the action invocation to return\n+     * the specified result, such as {@link #SUCCESS}, {@link #INPUT}, etc.\n+     * <p/>\n+     * <p/>\n+     * The next time this action is invoked (and using the same continuation ID), the method will resume immediately\n+     * after where this method was called, with the entire call stack in the execute method restored.\n+     * <p/>\n+     * <p/>\n+     * Note: this method can <b>only</b> be called within the {@link #execute()} method.\n+     * <!-- END SNIPPET: pause-method -->\n+     *\n+     * @param result the result to return - the same type of return value in the {@link #execute()} method.\n+     */\n+    public void pause(String result) {\n+    }\n+\n+    /**\n+     * If called first time it will create {@link com.opensymphony.xwork2.TextProviderFactory},\n+     * inject dependency (if {@link com.opensymphony.xwork2.inject.Container} is accesible) into in,\n+     * then will create new {@link com.opensymphony.xwork2.TextProvider} and store it in a field\n+     * for future references and at the returns reference to that field\n+     *\n+     * @return reference to field with TextProvider\n+     */\n+    private TextProvider getTextProvider() {\n+        if (textProvider == null) {\n+            TextProviderFactory tpf = new TextProviderFactory();\n+            if (container != null) {\n+                container.inject(tpf);\n+            }\n+            textProvider = tpf.createInstance(getClass(), this);\n+        }\n+        return textProvider;\n+    }\n+\n+    @Inject\n+    public void setContainer(Container container) {\n+        this.container = container;\n+    }\n+\n+}"
        },
        {
            "sha": "ec54b97c767fa05828d4411a7fcdedd6fded1480",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/CompositeTextProvider.java",
            "status": "added",
            "additions": 267,
            "deletions": 0,
            "changes": 267,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FCompositeTextProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FCompositeTextProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FCompositeTextProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,267 @@\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * This is a composite {@link TextProvider} that takes in an array or {@link java.util.List} of {@link TextProvider}s, it will\n+ * consult each of them in order to get a composite result. To know how each method behaves, please refer to the\n+ * javadoc for each methods.\n+ *\n+ * @author tmjee\n+ * @version $Date$ $Id$\n+ */\n+public class CompositeTextProvider implements TextProvider {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(CompositeTextProvider.class);\n+\n+    private List<TextProvider> textProviders = new ArrayList<TextProvider>();\n+\n+    /**\n+     * Instantiates a {@link CompositeTextProvider} with some predefined <code>textProviders</code>.\n+     *\n+     * @param textProviders\n+     */\n+    public CompositeTextProvider(List<TextProvider> textProviders) {\n+        this.textProviders.addAll(textProviders);\n+    }\n+\n+    /**\n+     * Instantiates a {@link CompositeTextProvider} with some predefined <code>textProviders</code>.\n+     *\n+     * @param textProviders\n+     */\n+    public CompositeTextProvider(TextProvider[] textProviders) {\n+        this(Arrays.asList(textProviders));\n+    }\n+\n+    /**\n+     * @param key The key to lookup in ressource bundles.\n+     * @return <tt>true</tt>, if the requested key is found in one of the ressource bundles.\n+     * @see {@link com.opensymphony.xwork2.TextProvider#hasKey(String)}\n+     *      It will consult each individual {@link TextProvider}s and return true if either one of the\n+     *      {@link TextProvider} has such a <code>key></code> else false.\n+     */\n+    public boolean hasKey(String key) {\n+        // if there's a key in either text providers we are ok, else try the next text provider\n+        for (TextProvider tp : textProviders) {\n+            if (tp.hasKey(key)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>\n+     *\n+     * @param key The key to lookup in ressource bundles.\n+     * @return The i18n text for the requested key.\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String)}\n+     */\n+    public String getText(String key) {\n+        return getText(key, key, Collections.emptyList());\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code> before returning <code>defaultValue</code> if every else fails.\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String)}\n+     */\n+    public String getText(String key, String defaultValue) {\n+        return getText(key, defaultValue, Collections.emptyList());\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>, before returining <code>defaultValue</code>\n+     * if every else fails.\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @param obj\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String, String)}\n+     */\n+    public String getText(String key, String defaultValue, final String obj) {\n+        return getText(key, defaultValue, new ArrayList<Object>() {\n+            {\n+                add(obj);\n+            }\n+\n+\n+        });\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>.\n+     *\n+     * @param key\n+     * @param args\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, java.util.List)}\n+     */\n+    public String getText(String key, List<Object> args) {\n+        return getText(key, key, args);\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>.\n+     *\n+     * @param key\n+     * @param args\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String[])}\n+     */\n+    public String getText(String key, String[] args) {\n+        return getText(key, key, args);\n+    }\n+\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>, before returining <code>defaultValue</code>\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @param args\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText#getText(String, String, java.util.List)}\n+     */\n+    public String getText(String key, String defaultValue, List<Object> args) {\n+        // if there's one text provider that gives us a msg not the same as defaultValue\n+        // for this key, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            String msg = textProvider.getText(key, defaultValue, args);\n+            if (msg != null && (!msg.equals(defaultValue))) {\n+                return msg;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>, before returining <code>defaultValue</code>.\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @param args\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String, String[])}\n+     */\n+    public String getText(String key, String defaultValue, String[] args) {\n+        // if there's one text provider that gives us a msg not the same as defaultValue\n+        // for this key, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            String msg = textProvider.getText(key, defaultValue, args);\n+            if (msg != null && (!msg.equals(defaultValue))) {\n+                return msg;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>, before returining <code>defaultValue</code>\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @param args\n+     * @param stack\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String, java.util.List, com.opensymphony.xwork2.util.OgnlValueStack)}\n+     */\n+    public String getText(String key, String defaultValue, List<Object> args, ValueStack stack) {\n+        // if there's one text provider that gives us a msg not the same as defaultValue\n+        // for this key, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            String msg = textProvider.getText(key, defaultValue, args, stack);\n+            if (msg != null && (!msg.equals(defaultValue))) {\n+                return msg;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first valid message for this\n+     * <code>key</code>, before returining <code>defaultValue</code>\n+     *\n+     * @param key\n+     * @param defaultValue\n+     * @param args\n+     * @param stack\n+     * @return\n+     * @see {@link com.opensymphony.xwork2.TextProvider#getText(String, String, String[], com.opensymphony.xwork2.util.ValueStack)}\n+     */\n+    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n+        // if there's one text provider that gives us a msg not the same as defaultValue\n+        // for this key, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            String msg = textProvider.getText(key, defaultValue, args, stack);\n+            if (msg != null && (!msg.equals(defaultValue))) {\n+                return msg;\n+            }\n+        }\n+        return defaultValue;\n+    }\n+\n+\n+    /**\n+     * It will consult each {@link TextProvider}s and return the first non-null {@link ResourceBundle}.\n+     *\n+     * @param bundleName\n+     * @return\n+     * @see {@link TextProvider#getTexts(String)}\n+     */\n+    public ResourceBundle getTexts(String bundleName) {\n+        // if there's one text provider that gives us a non-null resource bunlde for this bundleName, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            ResourceBundle bundle = textProvider.getTexts(bundleName);\n+            if (bundle != null) {\n+                return bundle;\n+            }\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * It will consult each {@link com.opensymphony.xwork2.TextProvider}s and return the first non-null {@link ResourceBundle}.\n+     *\n+     * @return\n+     * @see {@link TextProvider#getTexts()}\n+     */\n+    public ResourceBundle getTexts() {\n+        // if there's one text provider that gives us a non-null resource bundle, we are ok, else try the next\n+        // text provider\n+        for (TextProvider textProvider : textProviders) {\n+            ResourceBundle bundle = textProvider.getTexts();\n+            if (bundle != null) {\n+                return bundle;\n+            }\n+        }\n+        return null;\n+    }\n+}\n+\n+"
        },
        {
            "sha": "0a6b237dbf7a54632b991ebc63586f3af165cb39",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/DefaultActionInvocation.java",
            "status": "added",
            "additions": 487,
            "deletions": 0,
            "changes": 487,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionInvocation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionInvocation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionInvocation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,487 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.config.entities.InterceptorMapping;\n+import com.opensymphony.xwork2.config.entities.ResultConfig;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.interceptor.PreResultListener;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.ValueStackFactory;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.profiling.UtilTimerStack;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * The Default ActionInvocation implementation\n+ *\n+ * @author Rainer Hermanns\n+ * @author tmjee\n+ * @version $Date$ $Id$\n+ * @see com.opensymphony.xwork2.DefaultActionProxy\n+ */\n+public class DefaultActionInvocation implements ActionInvocation {\n+\n+    private static final long serialVersionUID = -585293628862447329L;\n+\n+    //static {\n+    //    if (ObjectFactory.getContinuationPackage() != null) {\n+    //        continuationHandler = new ContinuationHandler();\n+    //    }\n+    //}\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultActionInvocation.class);\n+\n+    private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];\n+\n+    protected Object action;\n+    protected ActionProxy proxy;\n+    protected List<PreResultListener> preResultListeners;\n+    protected Map<String, Object> extraContext;\n+    protected ActionContext invocationContext;\n+    protected Iterator<InterceptorMapping> interceptors;\n+    protected ValueStack stack;\n+    protected Result result;\n+    protected Result explicitResult;\n+    protected String resultCode;\n+    protected boolean executed = false;\n+    protected boolean pushAction = true;\n+    protected ObjectFactory objectFactory;\n+    protected ActionEventListener actionEventListener;\n+    protected ValueStackFactory valueStackFactory;\n+    protected Container container;\n+    private Configuration configuration;\n+    protected UnknownHandlerManager unknownHandlerManager;\n+\n+    public DefaultActionInvocation(final Map<String, Object> extraContext, final boolean pushAction) {\n+        DefaultActionInvocation.this.extraContext = extraContext;\n+        DefaultActionInvocation.this.pushAction = pushAction;\n+    }\n+\n+    @Inject\n+    public void setUnknownHandlerManager(UnknownHandlerManager unknownHandlerManager) {\n+        this.unknownHandlerManager = unknownHandlerManager;\n+    }\n+\n+    @Inject\n+    public void setValueStackFactory(ValueStackFactory fac) {\n+        this.valueStackFactory = fac;\n+    }\n+\n+    @Inject\n+    public void setConfiguration(Configuration configuration) {\n+        this.configuration = configuration;\n+    }\n+\n+    @Inject\n+    public void setObjectFactory(ObjectFactory fac) {\n+        this.objectFactory = fac;\n+    }\n+\n+    @Inject\n+    public void setContainer(Container cont) {\n+        this.container = cont;\n+    }\n+\n+    @Inject(required=false)\n+    public void setActionEventListener(ActionEventListener listener) {\n+        this.actionEventListener = listener;\n+    }\n+\n+    public Object getAction() {\n+        return action;\n+    }\n+\n+    public boolean isExecuted() {\n+        return executed;\n+    }\n+\n+    public ActionContext getInvocationContext() {\n+        return invocationContext;\n+    }\n+\n+    public ActionProxy getProxy() {\n+        return proxy;\n+    }\n+\n+    /**\n+     * If the DefaultActionInvocation has been executed before and the Result is an instance of ActionChainResult, this method\n+     * will walk down the chain of ActionChainResults until it finds a non-chain result, which will be returned. If the\n+     * DefaultActionInvocation's result has not been executed before, the Result instance will be created and populated with\n+     * the result params.\n+     *\n+     * @return a Result instance\n+     * @throws Exception\n+     */\n+    public Result getResult() throws Exception {\n+        Result returnResult = result;\n+\n+        // If we've chained to other Actions, we need to find the last result\n+        while (returnResult instanceof ActionChainResult) {\n+            ActionProxy aProxy = ((ActionChainResult) returnResult).getProxy();\n+\n+            if (aProxy != null) {\n+                Result proxyResult = aProxy.getInvocation().getResult();\n+\n+                if ((proxyResult != null) && (aProxy.getExecuteResult())) {\n+                    returnResult = proxyResult;\n+                } else {\n+                    break;\n+                }\n+            } else {\n+                break;\n+            }\n+        }\n+\n+        return returnResult;\n+    }\n+\n+    public String getResultCode() {\n+        return resultCode;\n+    }\n+\n+    public void setResultCode(String resultCode) {\n+        if (isExecuted())\n+            throw new IllegalStateException(\"Result has already been executed.\");\n+\n+        this.resultCode = resultCode;\n+    }\n+\n+\n+    public ValueStack getStack() {\n+        return stack;\n+    }\n+\n+    /**\n+     * Register a com.opensymphony.xwork2.interceptor.PreResultListener to be notified after the Action is executed and before the\n+     * Result is executed. The ActionInvocation implementation must guarantee that listeners will be called in the order\n+     * in which they are registered. Listener registration and execution does not need to be thread-safe.\n+     *\n+     * @param listener\n+     */\n+    public void addPreResultListener(PreResultListener listener) {\n+        if (preResultListeners == null) {\n+            preResultListeners = new ArrayList<PreResultListener>(1);\n+        }\n+\n+        preResultListeners.add(listener);\n+    }\n+\n+    public Result createResult() throws Exception {\n+\n+        if (explicitResult != null) {\n+            Result ret = explicitResult;\n+            explicitResult = null;\n+\n+            return ret;\n+        }\n+        ActionConfig config = proxy.getConfig();\n+        Map<String, ResultConfig> results = config.getResults();\n+\n+        ResultConfig resultConfig = null;\n+\n+        try {\n+            resultConfig = results.get(resultCode);\n+        } catch (NullPointerException e) {\n+            // swallow\n+        }\n+        \n+        if (resultConfig == null) {\n+            // If no result is found for the given resultCode, try to get a wildcard '*' match.\n+            resultConfig = results.get(\"*\");\n+        }\n+\n+        if (resultConfig != null) {\n+            try {\n+                return objectFactory.buildResult(resultConfig, invocationContext.getContextMap());\n+            } catch (Exception e) {\n+                LOG.error(\"There was an exception while instantiating the result of type \" + resultConfig.getClassName(), e);\n+                throw new XWorkException(e, resultConfig);\n+            }\n+        } else if (resultCode != null && !Action.NONE.equals(resultCode) && unknownHandlerManager.hasUnknownHandlers()) {\n+            return unknownHandlerManager.handleUnknownResult(invocationContext, proxy.getActionName(), proxy.getConfig(), resultCode);\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * @throws ConfigurationException If no result can be found with the returned code\n+     */\n+    public String invoke() throws Exception {\n+        String profileKey = \"invoke: \";\n+        try {\n+            UtilTimerStack.push(profileKey);\n+\n+            if (executed) {\n+                throw new IllegalStateException(\"Action has already executed\");\n+            }\n+\n+            if (interceptors.hasNext()) {\n+                final InterceptorMapping interceptor = (InterceptorMapping) interceptors.next();\n+                String interceptorMsg = \"interceptor: \" + interceptor.getName();\n+                UtilTimerStack.push(interceptorMsg);\n+                try {\n+                                resultCode = interceptor.getInterceptor().intercept(DefaultActionInvocation.this);\n+                            }\n+                finally {\n+                    UtilTimerStack.pop(interceptorMsg);\n+                }\n+            } else {\n+                resultCode = invokeActionOnly();\n+            }\n+\n+            // this is needed because the result will be executed, then control will return to the Interceptor, which will\n+            // return above and flow through again\n+            if (!executed) {\n+                if (preResultListeners != null) {\n+                    for (Object preResultListener : preResultListeners) {\n+                        PreResultListener listener = (PreResultListener) preResultListener;\n+\n+                        String _profileKey = \"preResultListener: \";\n+                        try {\n+                            UtilTimerStack.push(_profileKey);\n+                            listener.beforeResult(this, resultCode);\n+                        }\n+                        finally {\n+                            UtilTimerStack.pop(_profileKey);\n+                        }\n+                    }\n+                }\n+\n+                // now execute the result, if we're supposed to\n+                if (proxy.getExecuteResult()) {\n+                    executeResult();\n+                }\n+\n+                executed = true;\n+            }\n+\n+            return resultCode;\n+        }\n+        finally {\n+            UtilTimerStack.pop(profileKey);\n+        }\n+    }\n+\n+    public String invokeActionOnly() throws Exception {\n+        return invokeAction(getAction(), proxy.getConfig());\n+    }\n+\n+    protected void createAction(Map<String, Object> contextMap) {\n+        // load action\n+        String timerKey = \"actionCreate: \" + proxy.getActionName();\n+        try {\n+            UtilTimerStack.push(timerKey);\n+            action = objectFactory.buildAction(proxy.getActionName(), proxy.getNamespace(), proxy.getConfig(), contextMap);\n+        } catch (InstantiationException e) {\n+            throw new XWorkException(\"Unable to intantiate Action!\", e, proxy.getConfig());\n+        } catch (IllegalAccessException e) {\n+            throw new XWorkException(\"Illegal access to constructor, is it public?\", e, proxy.getConfig());\n+        } catch (Exception e) {\n+            String gripe = \"\";\n+\n+            if (proxy == null) {\n+                gripe = \"Whoa!  No ActionProxy instance found in current ActionInvocation.  This is bad ... very bad\";\n+            } else if (proxy.getConfig() == null) {\n+                gripe = \"Sheesh.  Where'd that ActionProxy get to?  I can't find it in the current ActionInvocation!?\";\n+            } else if (proxy.getConfig().getClassName() == null) {\n+                gripe = \"No Action defined for '\" + proxy.getActionName() + \"' in namespace '\" + proxy.getNamespace() + \"'\";\n+            } else {\n+                gripe = \"Unable to instantiate Action, \" + proxy.getConfig().getClassName() + \",  defined for '\" + proxy.getActionName() + \"' in namespace '\" + proxy.getNamespace() + \"'\";\n+            }\n+\n+            gripe += (((\" -- \" + e.getMessage()) != null) ? e.getMessage() : \" [no message in exception]\");\n+            throw new XWorkException(gripe, e, proxy.getConfig());\n+        } finally {\n+            UtilTimerStack.pop(timerKey);\n+        }\n+\n+        if (actionEventListener != null) {\n+            action = actionEventListener.prepare(action, stack);\n+        }\n+    }\n+\n+    protected Map<String, Object> createContextMap() {\n+        Map<String, Object> contextMap;\n+\n+        if ((extraContext != null) && (extraContext.containsKey(ActionContext.VALUE_STACK))) {\n+            // In case the ValueStack was passed in\n+            stack = (ValueStack) extraContext.get(ActionContext.VALUE_STACK);\n+\n+            if (stack == null) {\n+                throw new IllegalStateException(\"There was a null Stack set into the extra params.\");\n+            }\n+\n+            contextMap = stack.getContext();\n+        } else {\n+            // create the value stack\n+            // this also adds the ValueStack to its context\n+            stack = valueStackFactory.createValueStack();\n+\n+            // create the action context\n+            contextMap = stack.getContext();\n+        }\n+\n+        // put extraContext in\n+        if (extraContext != null) {\n+            contextMap.putAll(extraContext);\n+        }\n+\n+        //put this DefaultActionInvocation into the context map\n+        contextMap.put(ActionContext.ACTION_INVOCATION, this);\n+        contextMap.put(ActionContext.CONTAINER, container);\n+\n+        return contextMap;\n+    }\n+\n+    /**\n+     * Uses getResult to get the final Result and executes it\n+     *\n+     * @throws ConfigurationException If not result can be found with the returned code\n+     */\n+    private void executeResult() throws Exception {\n+        result = createResult();\n+\n+        String timerKey = \"executeResult: \" + getResultCode();\n+        try {\n+            UtilTimerStack.push(timerKey);\n+            if (result != null) {\n+                result.execute(this);\n+            } else if (resultCode != null && !Action.NONE.equals(resultCode)) {\n+                throw new ConfigurationException(\"No result defined for action \" + getAction().getClass().getName()\n+                        + \" and result \" + getResultCode(), proxy.getConfig());\n+            } else {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"No result returned for action \" + getAction().getClass().getName() + \" at \" + proxy.getConfig().getLocation());\n+                }\n+            }\n+        } finally {\n+            UtilTimerStack.pop(timerKey);\n+        }\n+    }\n+\n+    public void init(ActionProxy proxy) {\n+        this.proxy = proxy;\n+        Map<String, Object> contextMap = createContextMap();\n+\n+        // Setting this so that other classes, like object factories, can use the ActionProxy and other\n+        // contextual information to operate\n+        ActionContext actionContext = ActionContext.getContext();\n+\n+        if (actionContext != null) {\n+            actionContext.setActionInvocation(this);\n+        }\n+\n+        createAction(contextMap);\n+\n+        if (pushAction) {\n+            stack.push(action);\n+            contextMap.put(\"action\", action);\n+        }\n+\n+        invocationContext = new ActionContext(contextMap);\n+        invocationContext.setName(proxy.getActionName());\n+\n+        // get a new List so we don't get problems with the iterator if someone changes the list\n+        List<InterceptorMapping> interceptorList = new ArrayList<InterceptorMapping>(proxy.getConfig().getInterceptors());\n+        interceptors = interceptorList.iterator();\n+    }\n+\n+    protected String invokeAction(Object action, ActionConfig actionConfig) throws Exception {\n+        String methodName = proxy.getMethod();\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Executing action method = \" + actionConfig.getMethodName());\n+        }\n+\n+        String timerKey = \"invokeAction: \" + proxy.getActionName();\n+        try {\n+            UtilTimerStack.push(timerKey);\n+\n+            boolean methodCalled = false;\n+            Object methodResult = null;\n+            Method method = null;\n+            try {\n+                method = getAction().getClass().getMethod(methodName, EMPTY_CLASS_ARRAY);\n+            } catch (NoSuchMethodException e) {\n+                // hmm -- OK, try doXxx instead\n+                try {\n+                    String altMethodName = \"do\" + methodName.substring(0, 1).toUpperCase() + methodName.substring(1);\n+                    method = getAction().getClass().getMethod(altMethodName, EMPTY_CLASS_ARRAY);\n+                } catch (NoSuchMethodException e1) {\n+                    // well, give the unknown handler a shot\n+                    if (unknownHandlerManager.hasUnknownHandlers()) {\n+                        try {\n+                            methodResult = unknownHandlerManager.handleUnknownMethod(action, methodName);\n+                            methodCalled = true;\n+                        } catch (NoSuchMethodException e2) {\n+                            // throw the original one\n+                            throw e;\n+                        }\n+                    } else {\n+                        throw e;\n+                    }\n+                }\n+            }\n+\n+            if (!methodCalled) {\n+                methodResult = method.invoke(action, new Object[0]);\n+            }\n+\n+            if (methodResult instanceof Result) {\n+                this.explicitResult = (Result) methodResult;\n+\n+                // Wire the result automatically\n+                container.inject(explicitResult);\n+                return null;\n+            } else {\n+                return (String) methodResult;\n+            }\n+        } catch (NoSuchMethodException e) {\n+            throw new IllegalArgumentException(\"The \" + methodName + \"() is not defined in action \" + getAction().getClass() + \"\");\n+        } catch (InvocationTargetException e) {\n+            // We try to return the source exception.\n+            Throwable t = e.getTargetException();\n+\n+            if (actionEventListener != null) {\n+                String result = actionEventListener.handleException(t, getStack());\n+                if (result != null) {\n+                    return result;\n+                }\n+            }\n+            if (t instanceof Exception) {\n+                throw (Exception) t;\n+            } else {\n+                throw e;\n+            }\n+        } finally {\n+            UtilTimerStack.pop(timerKey);\n+        }\n+    }\n+\n+\n+}"
        },
        {
            "sha": "ef0d3b4d03b10f8f4fe6c61409480a097155ec08",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/DefaultActionProxy.java",
            "status": "added",
            "additions": 204,
            "deletions": 0,
            "changes": 204,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxy.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxy.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxy.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,204 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.profiling.UtilTimerStack;\n+\n+import java.io.Serializable;\n+import java.util.Locale;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+\n+/**\n+ * The Default ActionProxy implementation\n+ *\n+ * @author Rainer Hermanns\n+ * @author Revised by <a href=\"mailto:hu_pengfei@yahoo.com.cn\">Henry Hu</a>\n+ * @author tmjee\n+ * \n+ * @version $Date$ $Id$\n+ * @since 2005-8-6\n+ */\n+public class DefaultActionProxy implements ActionProxy, Serializable {\n+\t\n+\tprivate static final long serialVersionUID = 3293074152487468527L;\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(DefaultActionProxy.class);\n+\n+    protected Configuration configuration;\n+    protected ActionConfig config;\n+    protected ActionInvocation invocation;\n+    protected UnknownHandlerManager unknownHandlerManager;\n+    protected String actionName;\n+    protected String namespace;\n+    protected String method;\n+    protected boolean executeResult;\n+    protected boolean cleanupContext;\n+\n+    protected ObjectFactory objectFactory;\n+\n+    protected ActionEventListener actionEventListener;\n+\n+    /**\n+     * This constructor is private so the builder methods (create*) should be used to create an DefaultActionProxy.\n+     * <p/>\n+     * The reason for the builder methods is so that you can use a subclass to create your own DefaultActionProxy instance\n+     * (like a RMIActionProxy).\n+     */\n+    protected DefaultActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n+        \n+        this.invocation = inv;\n+\t\tthis.cleanupContext = cleanupContext;\n+\t\tif (LOG.isDebugEnabled()) {\n+\t\t\tLOG.debug(\"Creating an DefaultActionProxy for namespace \" + namespace + \" and action name \" + actionName);\n+\t\t}\n+\n+\t\tthis.actionName = actionName;\n+\t\tthis.namespace = namespace;\n+\t\tthis.executeResult = executeResult;\n+        this.method = methodName;\n+    }\n+    \n+    @Inject\n+    public void setObjectFactory(ObjectFactory factory) {\n+        this.objectFactory = factory;\n+    }\n+    \n+    @Inject\n+    public void setConfiguration(Configuration config) {\n+        this.configuration = config;\n+    }\n+    \n+    @Inject\n+    public void setUnknownHandler(UnknownHandlerManager unknownHandlerManager) {\n+        this.unknownHandlerManager = unknownHandlerManager;\n+    }\n+    \n+    @Inject(required=false) \n+    public void setActionEventListener(ActionEventListener listener) {\n+        this.actionEventListener = listener;\n+    }\n+\n+    public Object getAction() {\n+        return invocation.getAction();\n+    }\n+\n+    public String getActionName() {\n+        return actionName;\n+    }\n+\n+    public ActionConfig getConfig() {\n+        return config;\n+    }\n+    \n+    public void setExecuteResult(boolean executeResult) {\n+        this.executeResult = executeResult;\n+    }\n+\n+    public boolean getExecuteResult() {\n+        return executeResult;\n+    }\n+\n+    public ActionInvocation getInvocation() {\n+        return invocation;\n+    }\n+\n+    public String getNamespace() {\n+        return namespace;\n+    }\n+\n+    public String execute() throws Exception {\n+        ActionContext nestedContext = ActionContext.getContext();\n+        ActionContext.setContext(invocation.getInvocationContext());\n+\n+        String retCode = null;\n+\n+        String profileKey = \"execute: \";\n+        try {\n+        \tUtilTimerStack.push(profileKey);\n+        \t\n+            retCode = invocation.invoke();\n+        } finally {\n+            if (cleanupContext) {\n+                ActionContext.setContext(nestedContext);\n+            }\n+            UtilTimerStack.pop(profileKey);\n+        }\n+\n+        return retCode;\n+    }\n+\n+\n+    public String getMethod() {\n+        return method;\n+    }\n+\n+    private void resolveMethod() {\n+        // if the method is set to null, use the one from the configuration\n+        // if the one from the configuration is also null, use \"execute\"\n+        if (StringUtils.isEmpty(this.method)) {\n+            this.method = config.getMethodName();\n+            if (StringUtils.isEmpty(this.method)) {\n+                this.method = \"execute\";\n+            }\n+        }\n+    }\n+\n+    protected void prepare()  {\n+        String profileKey = \"create DefaultActionProxy: \";\n+        try {\n+            UtilTimerStack.push(profileKey);\n+            config = configuration.getRuntimeConfiguration().getActionConfig(namespace, actionName);\n+    \n+            if (config == null && unknownHandlerManager.hasUnknownHandlers()) {\n+                config = unknownHandlerManager.handleUnknownAction(namespace, actionName);\n+            }\n+            if (config == null) {\n+                String message;\n+    \n+                if ((namespace != null) && (namespace.trim().length() > 0)) {\n+                    message = LocalizedTextUtil.findDefaultText(XWorkMessages.MISSING_PACKAGE_ACTION_EXCEPTION, Locale.getDefault(), new String[]{\n+                        namespace, actionName\n+                    });\n+                } else {\n+                    message = LocalizedTextUtil.findDefaultText(XWorkMessages.MISSING_ACTION_EXCEPTION, Locale.getDefault(), new String[]{\n+                        actionName\n+                    });\n+                }\n+                throw new ConfigurationException(message);\n+            }\n+\n+            resolveMethod();\n+            \n+            if (!config.isAllowedMethod(method)) {\n+                throw new ConfigurationException(\"Invalid method: \"+method+\" for action \"+actionName);\n+            }\n+\n+            invocation.init(this);\n+\n+        } finally {\n+            UtilTimerStack.pop(profileKey);\n+        }\n+    }\n+}"
        },
        {
            "sha": "ba0e8fa3f6265a8acc34041173bd959c0b2d5fbe",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/DefaultActionProxyFactory.java",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxyFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxyFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultActionProxyFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,74 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.Inject;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * Default factory for {@link com.opensymphony.xwork2.ActionProxyFactory}.\n+ *\n+ * @author Jason Carreira\n+ */\n+public class DefaultActionProxyFactory implements ActionProxyFactory {\n+\n+    protected Container container;\n+    \n+    public DefaultActionProxyFactory() {\n+        super();\n+    }\n+    \n+    @Inject\n+    public void setContainer(Container container) {\n+        this.container = container;\n+    }\n+    \n+    public ActionProxy createActionProxy(String namespace, String actionName, Map<String, Object> extraContext) {\n+        return createActionProxy(namespace, actionName, null, extraContext, true, true);\n+    }\n+\n+    public ActionProxy createActionProxy(String namespace, String actionName, String methodName, Map<String, Object> extraContext) {\n+        return createActionProxy(namespace, actionName, methodName, extraContext, true, true);\n+    }\n+\n+    public ActionProxy createActionProxy(String namespace, String actionName, Map<String, Object> extraContext, boolean executeResult, boolean cleanupContext) {\n+        return createActionProxy(namespace, actionName, null, extraContext, executeResult, cleanupContext);\n+    }\n+\n+    public ActionProxy createActionProxy(String namespace, String actionName, String methodName, Map<String, Object> extraContext, boolean executeResult, boolean cleanupContext) {\n+        \n+        ActionInvocation inv = new DefaultActionInvocation(extraContext, true);\n+        container.inject(inv);\n+        return createActionProxy(inv, namespace, actionName, methodName, executeResult, cleanupContext);\n+    }\n+    \n+    public ActionProxy createActionProxy(ActionInvocation inv, String namespace, String actionName, boolean executeResult, boolean cleanupContext) {\n+        \n+        return createActionProxy(inv, namespace, actionName, null, executeResult, cleanupContext);\n+    }\n+\n+    public ActionProxy createActionProxy(ActionInvocation inv, String namespace, String actionName, String methodName, boolean executeResult, boolean cleanupContext) {\n+\n+        DefaultActionProxy proxy = new DefaultActionProxy(inv, namespace, actionName, methodName, executeResult, cleanupContext);\n+        container.inject(proxy);\n+        proxy.prepare();\n+        return proxy;\n+    }\n+\n+}"
        },
        {
            "sha": "02d72ec46de7f09f10ade66b03a8aa695ced3fba",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/DefaultTextProvider.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultTextProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultTextProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultTextProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,146 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.io.Serializable;\n+import java.text.MessageFormat;\n+import java.util.ArrayList;\n+import java.util.Arrays;\n+import java.util.List;\n+import java.util.ResourceBundle;\n+\n+/**\n+ * DefaultTextProvider gets texts from only the default resource bundles associated with the\n+ * LocalizedTextUtil.\n+ *\n+ * @author Jason Carreira <jcarreira@gmail.com>\n+ * @author Rainer Hermanns\n+ * @see LocalizedTextUtil#addDefaultResourceBundle(String)\n+ */\n+public class DefaultTextProvider implements TextProvider, Serializable, Unchainable {\n+\n+    private static final Object[] EMPTY_ARGS = new Object[0];\n+\n+    public DefaultTextProvider() {\n+    }\n+\n+    public boolean hasKey(String key) {\n+        return getText(key) != null;\n+    }\n+\n+    public String getText(String key) {\n+        return LocalizedTextUtil.findDefaultText(key, ActionContext.getContext().getLocale());\n+    }\n+\n+    public String getText(String key, String defaultValue) {\n+        String text = getText(key);\n+        if (text == null) {\n+            return defaultValue;\n+        }\n+        return text;\n+    }\n+\n+    public String getText(String key, List<Object> args) {\n+        Object[] params;\n+        if (args != null) {\n+            params = args.toArray();\n+        } else {\n+            params = EMPTY_ARGS;\n+        }\n+\n+        return LocalizedTextUtil.findDefaultText(key, ActionContext.getContext().getLocale(), params);\n+    }\n+\n+    public String getText(String key, String[] args) {\n+        Object[] params;\n+        if (args != null) {\n+            params = args;\n+        } else {\n+            params = EMPTY_ARGS;\n+        }\n+\n+        return LocalizedTextUtil.findDefaultText(key, ActionContext.getContext().getLocale(), params);\n+    }\n+\n+    public String getText(String key, String defaultValue, List<Object> args) {\n+        String text = getText(key, args);\n+        if(text == null && defaultValue == null) {\n+            defaultValue = key;\n+        }\n+        if (text == null && defaultValue != null) {\n+\n+            MessageFormat format = new MessageFormat(defaultValue);\n+            format.setLocale(ActionContext.getContext().getLocale());\n+            format.applyPattern(defaultValue);\n+\n+            Object[] params;\n+            if (args != null) {\n+                params = args.toArray();\n+            } else {\n+                params = EMPTY_ARGS;\n+            }\n+\n+            return format.format(params);\n+        }\n+        return text;        \n+    }\n+\n+    public String getText(String key, String defaultValue, String[] args) {\n+        String text = getText(key, args);\n+        if (text == null) {\n+            MessageFormat format = new MessageFormat(defaultValue);\n+            format.setLocale(ActionContext.getContext().getLocale());\n+            format.applyPattern(defaultValue);\n+\n+            if (args == null) {\n+                return format.format(EMPTY_ARGS);\n+            }\n+\n+            return format.format(args);\n+        }\n+        return text;\n+    }\n+\n+\n+    public String getText(String key, String defaultValue, String obj) {\n+        List<Object> args = new ArrayList<Object>(1);\n+        args.add(obj);\n+        return getText(key, defaultValue, args);\n+    }\n+\n+    public String getText(String key, String defaultValue, List<Object> args, ValueStack stack) {\n+        //we're not using the value stack here\n+        return getText(key, defaultValue, args);\n+    }\n+\n+    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n+        //we're not using the value stack here\n+        List<Object> values = new ArrayList<Object>(Arrays.asList(args));\n+        return getText(key, defaultValue, values);\n+    }\n+\n+    public ResourceBundle getTexts(String bundleName) {\n+        return LocalizedTextUtil.findResourceBundle(bundleName, ActionContext.getContext().getLocale());\n+    }\n+\n+    public ResourceBundle getTexts() {\n+        return null;\n+    }\n+\n+}"
        },
        {
            "sha": "057a0019fe3a19e0924f83903a7e61b6a6c9f992",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/DefaultUnknownHandlerManager.java",
            "status": "added",
            "additions": 132,
            "deletions": 0,
            "changes": 132,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultUnknownHandlerManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultUnknownHandlerManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FDefaultUnknownHandlerManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,132 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.Set;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.Result;\n+import com.opensymphony.xwork2.UnknownHandler;\n+import com.opensymphony.xwork2.UnknownHandlerManager;\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.Inject;\n+\n+/**\n+ * Default implementation of UnknownHandlerManager\n+ *\n+ * @see com.opensymphony.xwork2.UnknownHandlerManager\n+ */\n+public class DefaultUnknownHandlerManager implements UnknownHandlerManager {\n+    protected ArrayList<UnknownHandler> unknownHandlers;\n+    private Configuration configuration;\n+    private Container container;\n+\n+    @Inject\n+    public void setConfiguration(Configuration configuration) {\n+        this.configuration = configuration;\n+        build();\n+    }\n+\n+    @Inject\n+    public void setContainer(Container container) {\n+        this.container = container;\n+        build();\n+    }\n+\n+    /**\n+     * Builds a list of UnknowHandlers in the order specified by the configured \"unknown-handler-stack\".\n+     * If \"unknown-handler-stack\" was not configured, all UnknowHandlers will be returned, in no specific order\n+     */\n+    protected void build() {\n+        if (configuration != null && container != null) {\n+            List<UnknownHandlerConfig> unkownHandlerStack = configuration.getUnknownHandlerStack();\n+            unknownHandlers = new ArrayList<UnknownHandler>();\n+\n+            if (unkownHandlerStack != null && !unkownHandlerStack.isEmpty()) {\n+                //get UnknownHandlers in the specified order\n+                for (UnknownHandlerConfig unknownHandlerConfig : unkownHandlerStack) {\n+                    UnknownHandler uh = container.getInstance(UnknownHandler.class, unknownHandlerConfig.getName());\n+                    unknownHandlers.add(uh);\n+                }\n+            } else {\n+                //add all available UnknownHandlers\n+                Set<String> unknowHandlerNames = container.getInstanceNames(UnknownHandler.class);\n+                if (unknowHandlerNames != null) {\n+                    for (String unknowHandlerName : unknowHandlerNames) {\n+                        UnknownHandler uh = container.getInstance(UnknownHandler.class, unknowHandlerName);\n+                        unknownHandlers.add(uh);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n+     */\n+    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) {\n+        for (UnknownHandler unknownHandler : unknownHandlers) {\n+            Result result = unknownHandler.handleUnknownResult(actionContext, actionName, actionConfig, resultCode);\n+            if (result != null)\n+                return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n+     *\n+     * @throws NoSuchMethodException\n+     */\n+    public Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException {\n+        for (UnknownHandler unknownHandler : unknownHandlers) {\n+            Object result = unknownHandler.handleUnknownActionMethod(action, methodName);\n+            if (result != null)\n+                return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    /**\n+     * Iterate over UnknownHandlers and return the result of the first one that can handle it\n+     *\n+     * @throws NoSuchMethodException\n+     */\n+    public ActionConfig handleUnknownAction(String namespace, String actionName) {\n+        for (UnknownHandler unknownHandler : unknownHandlers) {\n+            ActionConfig result = unknownHandler.handleUnknownAction(namespace, actionName);\n+            if (result != null)\n+                return result;\n+        }\n+\n+        return null;\n+    }\n+\n+    public boolean hasUnknownHandlers() {\n+        return unknownHandlers != null && !unknownHandlers.isEmpty();\n+    }\n+\n+    public List<UnknownHandler> getUnknownHandlers() {\n+        return unknownHandlers;\n+    }\n+}"
        },
        {
            "sha": "eb556f5a4839cedcc1d12562b611971694db1391",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/InvalidMetadataException.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FInvalidMetadataException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FInvalidMetadataException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FInvalidMetadataException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+/**\n+ * <code>InvalidMetadataException</code>\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Id$\n+ */\n+public class InvalidMetadataException extends RuntimeException {\n+\n+    /**\n+\t * Create a new <code>InvalidMetadataException</code> with the supplied error message.\n+     * \n+\t * @param msg the error message\n+\t */\n+\tpublic InvalidMetadataException(String msg) {\n+\t\tsuper(msg);\n+\t}\n+}"
        },
        {
            "sha": "6fc4ea981a2474e91314398a4e60d5d7035aff77",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/LocaleProvider.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FLocaleProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FLocaleProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FLocaleProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.util.Locale;\n+\n+\n+/**\n+ * Indicates that the implementing class can provide its own {@link Locale}.\n+ * <p/>\n+ * This is useful for when an action may wish override the default locale. All that is\n+ * needed is to implement this interface and return your own custom locale.\n+ * The {@link TextProvider} interface uses this interface heavily for retrieving\n+ * internationalized messages from resource bundles.\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface LocaleProvider {\n+\n+    /**\n+     * Gets the provided locale.\n+     *\n+     * @return  the locale.\n+     */\n+    Locale getLocale();\n+\n+}"
        },
        {
            "sha": "3eea89bce033babd5789d4a0e3ec272cc020c611",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/MockActionInvocation.java",
            "status": "added",
            "additions": 26,
            "deletions": 0,
            "changes": 26,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FMockActionInvocation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FMockActionInvocation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FMockActionInvocation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,26 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2;\n+\n+/**\n+ * Mock for an {@link ActionInvocation}.\n+ *\n+ * @author plightbo\n+ * @deprecated Please use @see com.opensymphony.xwork2.mock.MockActionInvocation instead\n+ */\n+@Deprecated public class MockActionInvocation extends com.opensymphony.xwork2.mock.MockActionInvocation {\n+}"
        },
        {
            "sha": "2f5f6c7ef24111bbc2730776c049292314460b64",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ModelDriven.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FModelDriven.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FModelDriven.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FModelDriven.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+\n+/**\n+ * ModelDriven Actions provide a model object to be pushed onto the ValueStack\n+ * in addition to the Action itself, allowing a FormBean type approach like Struts.\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface ModelDriven<T> {\n+\n+    /**\n+     * Gets the model to be pushed onto the ValueStack instead of the Action itself.\n+     *\n+     * @return the model\n+     */\n+    T getModel();\n+\n+}"
        },
        {
            "sha": "34a0159dc353357e8b3d4528c7a0b0085ad7ebe3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ObjectFactory.java",
            "status": "added",
            "additions": 262,
            "deletions": 0,
            "changes": 262,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FObjectFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FObjectFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FObjectFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,262 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.config.entities.InterceptorConfig;\n+import com.opensymphony.xwork2.config.entities.ResultConfig;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.interceptor.Interceptor;\n+import com.opensymphony.xwork2.util.ClassLoaderUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionException;\n+import com.opensymphony.xwork2.util.reflection.ReflectionExceptionHandler;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+import com.opensymphony.xwork2.validator.Validator;\n+\n+import java.io.Serializable;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * ObjectFactory is responsible for building the core framework objects. Users may register their \n+ * own implementation of the ObjectFactory to control instantiation of these Objects.\n+ * <p/>\n+ * This default implementation uses the {@link #buildBean(Class,java.util.Map) buildBean} \n+ * method to create all classes (interceptors, actions, results, etc).\n+ * <p/>\n+ *\n+ * @author Jason Carreira\n+ */\n+public class ObjectFactory implements Serializable {\n+    private static final Logger LOG = LoggerFactory.getLogger(ObjectFactory.class);\n+\n+    private transient ClassLoader ccl;\n+    private Container container;\n+    protected ReflectionProvider reflectionProvider;\n+\n+    @Inject(value=\"objectFactory.classloader\", required=false)\n+    public void setClassLoader(ClassLoader cl) {\n+        this.ccl = cl;\n+    }\n+    \n+    @Inject\n+    public void setReflectionProvider(ReflectionProvider prov) {\n+        this.reflectionProvider = prov;\n+    }\n+\n+    public ObjectFactory() {\n+    }\n+    \n+    public ObjectFactory(ReflectionProvider prov) {\n+        this.reflectionProvider = prov;\n+    }\n+    \n+    @Inject\n+    public void setContainer(Container container) {\n+        this.container = container;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.1\n+     */\n+    @Deprecated public static ObjectFactory getObjectFactory() {\n+        return ActionContext.getContext().getContainer().getInstance(ObjectFactory.class);\n+    }\n+\n+    /**\n+     * Allows for ObjectFactory implementations that support\n+     * Actions without no-arg constructors.\n+     *\n+     * @return true if no-arg constructor is required, false otherwise\n+     */\n+    public boolean isNoArgConstructorRequired() {\n+        return true;\n+    }\n+\n+    /**\n+     * Utility method to obtain the class matched to className. Caches look ups so that subsequent\n+     * lookups will be faster.\n+     *\n+     * @param className The fully qualified name of the class to return\n+     * @return The class itself\n+     * @throws ClassNotFoundException\n+     */\n+    public Class getClassInstance(String className) throws ClassNotFoundException {\n+        if (ccl != null) {\n+            return ccl.loadClass(className);\n+        }\n+\n+        return ClassLoaderUtil.loadClass(className, this.getClass());\n+    }\n+\n+    /**\n+     * Build an instance of the action class to handle a particular request (eg. web request)\n+     * @param actionName the name the action configuration is set up with in the configuration\n+     * @param namespace the namespace the action is configured in\n+     * @param config the action configuration found in the config for the actionName / namespace\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     * @return instance of the action class to handle a web request\n+     * @throws Exception\n+     */\n+    public Object buildAction(String actionName, String namespace, ActionConfig config, Map<String, Object> extraContext) throws Exception {\n+        return buildBean(config.getClassName(), extraContext);\n+    }\n+\n+    /**\n+     * Build a generic Java object of the given type.\n+     *\n+     * @param clazz the type of Object to build\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     */\n+    public Object buildBean(Class clazz, Map<String, Object> extraContext) throws Exception {\n+        return clazz.newInstance();\n+    }\n+\n+    /**\n+     * @param obj\n+     */\n+    protected Object injectInternalBeans(Object obj) {\n+        if (obj != null && container != null) {\n+            container.inject(obj);\n+        }\n+        return obj;\n+    }\n+\n+    /**\n+     * Build a generic Java object of the given type.\n+     *\n+     * @param className the type of Object to build\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     */\n+    public Object buildBean(String className, Map<String, Object> extraContext) throws Exception {\n+        return buildBean(className, extraContext, true);\n+    }\n+    \n+    /**\n+     * Build a generic Java object of the given type.\n+     *\n+     * @param className the type of Object to build\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     */\n+    public Object buildBean(String className, Map<String, Object> extraContext, boolean injectInternal) throws Exception {\n+        Class clazz = getClassInstance(className);\n+        Object obj = buildBean(clazz, extraContext);\n+        if (injectInternal) {\n+            injectInternalBeans(obj);\n+        }\n+        return obj;\n+    }\n+\n+    /**\n+     * Builds an Interceptor from the InterceptorConfig and the Map of\n+     * parameters from the interceptor reference. Implementations of this method\n+     * should ensure that the Interceptor is parameterized with both the\n+     * parameters from the Interceptor config and the interceptor ref Map (the\n+     * interceptor ref params take precedence), and that the Interceptor.init()\n+     * method is called on the Interceptor instance before it is returned.\n+     *\n+     * @param interceptorConfig    the InterceptorConfig from the configuration\n+     * @param interceptorRefParams a Map of params provided in the Interceptor reference in the\n+     *                             Action mapping or InterceptorStack definition\n+     */\n+    public Interceptor buildInterceptor(InterceptorConfig interceptorConfig, Map<String, String> interceptorRefParams) throws ConfigurationException {\n+        String interceptorClassName = interceptorConfig.getClassName();\n+        Map<String, String> thisInterceptorClassParams = interceptorConfig.getParams();\n+        Map<String, String> params = (thisInterceptorClassParams == null) ? new HashMap<String, String>() : new HashMap<String, String>(thisInterceptorClassParams);\n+        params.putAll(interceptorRefParams);\n+\n+        String message;\n+        Throwable cause;\n+\n+        try {\n+            // interceptor instances are long-lived and used across user sessions, so don't try to pass in any extra context\n+            Interceptor interceptor = (Interceptor) buildBean(interceptorClassName, null);\n+            reflectionProvider.setProperties(params, interceptor);\n+            interceptor.init();\n+\n+            return interceptor;\n+        } catch (InstantiationException e) {\n+            cause = e;\n+            message = \"Unable to instantiate an instance of Interceptor class [\" + interceptorClassName + \"].\";\n+        } catch (IllegalAccessException e) {\n+            cause = e;\n+            message = \"IllegalAccessException while attempting to instantiate an instance of Interceptor class [\" + interceptorClassName + \"].\";\n+        } catch (ClassCastException e) {\n+            cause = e;\n+            message = \"Class [\" + interceptorClassName + \"] does not implement com.opensymphony.xwork2.interceptor.Interceptor\";\n+        } catch (Exception e) {\n+            cause = e;\n+            message = \"Caught Exception while registering Interceptor class \" + interceptorClassName;\n+        } catch (NoClassDefFoundError e) {\n+            cause = e;\n+            message = \"Could not load class \" + interceptorClassName + \". Perhaps it exists but certain dependencies are not available?\";\n+        }\n+\n+        throw new ConfigurationException(message, cause, interceptorConfig);\n+    }\n+\n+    /**\n+     * Build a Result using the type in the ResultConfig and set the parameters in the ResultConfig.\n+     *\n+     * @param resultConfig the ResultConfig found for the action with the result code returned\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     */\n+    public Result buildResult(ResultConfig resultConfig, Map<String, Object> extraContext) throws Exception {\n+        String resultClassName = resultConfig.getClassName();\n+        Result result = null;\n+\n+        if (resultClassName != null) {\n+            result = (Result) buildBean(resultClassName, extraContext);\n+            Map<String, String> params = resultConfig.getParams();\n+            if (params != null) {\n+                for (Map.Entry<String, String> paramEntry : params.entrySet()) {\n+                    try {\n+                        reflectionProvider.setProperty(paramEntry.getKey(), paramEntry.getValue(), result, extraContext, true);\n+                    } catch (ReflectionException ex) {\n+                        if (result instanceof ReflectionExceptionHandler) {\n+                            ((ReflectionExceptionHandler) result).handle(ex);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Build a Validator of the given type and set the parameters on it\n+     *\n+     * @param className the type of Validator to build\n+     * @param params    property name -> value Map to set onto the Validator instance\n+     * @param extraContext a Map of extra context which uses the same keys as the {@link com.opensymphony.xwork2.ActionContext}\n+     */\n+    public Validator buildValidator(String className, Map<String, String> params, Map<String, Object> extraContext) throws Exception {\n+        Validator validator = (Validator) buildBean(className, null);\n+        reflectionProvider.setProperties(params, validator);\n+\n+        return validator;\n+    }\n+\n+    static class ContinuationsClassLoader extends ClassLoader {\n+        \n+    }\n+}"
        },
        {
            "sha": "58a2412cda9bc21804c7e8fc47491739e384b01b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/Preparable.java",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FPreparable.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FPreparable.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FPreparable.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,35 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+\n+/**\n+ * Preparable Actions will have their <code>prepare()</code> method called if the {@link com.opensymphony.xwork2.interceptor.PrepareInterceptor}\n+ * is applied to the ActionConfig.\n+ *\n+ * @author Jason Carreira\n+ * @see com.opensymphony.xwork2.interceptor.PrepareInterceptor\n+ */\n+public interface Preparable {\n+\n+    /**\n+     * This method is called to allow the action to prepare itself.\n+     *\n+     * @throws Exception thrown if a system level exception occurs.\n+     */\n+    void prepare() throws Exception;\n+    \n+}"
        },
        {
            "sha": "1415e716e7fc653d6a6149e39f9875c6097b9cc8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ResourceBundleTextProvider.java",
            "status": "added",
            "additions": 48,
            "deletions": 0,
            "changes": 48,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResourceBundleTextProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResourceBundleTextProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResourceBundleTextProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,48 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.util.ResourceBundle;\n+\n+/**\n+ * Extension Interface for TextProvider to help supporting ResourceBundles.\n+ *\n+ * @author Rene Gielen\n+ */\n+public interface ResourceBundleTextProvider extends TextProvider {\n+\n+    /**\n+     * Set the resource bundle to use.\n+     *\n+     * @param bundle the bundle to use.\n+     */\n+    void setBundle(ResourceBundle bundle);\n+\n+    /**\n+     * Set the class to use for reading the resource bundle.\n+     *\n+     * @param clazz the class to use for loading.\n+     */\n+    void setClazz(Class clazz);\n+\n+    /**\n+     * Set the LocaleProvider to use.\n+     *\n+     * @param localeProvider the LocaleProvider to use.\n+     */\n+    void setLocaleProvider(LocaleProvider localeProvider);\n+\n+}"
        },
        {
            "sha": "3d65377660c97ec2b39e41662c5aa29e44980af3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/Result.java",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResult.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResult.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FResult.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,45 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * All results (except for <code>Action.NONE</code>) of an {@link Action} are mapped to a View implementation.\n+ * <p/>\n+ * Examples of Views might be:\n+ * <ul>\n+ * <li>SwingPanelView - pops up a new Swing panel</li>\n+ * <li>ActionChainView - executes another action</li>\n+ * <li>SerlvetRedirectView - redirects the HTTP response to a URL</li>\n+ * <li>ServletDispatcherView - dispatches the HTTP response to a URL</li>\n+ * </ul>\n+ *\n+ * @author plightbo\n+ */\n+public interface Result extends Serializable {\n+\n+    /**\n+     * Represents a generic interface for all action execution results.\n+     * Whether that be displaying a webpage, generating an email, sending a JMS message, etc.\n+     *\n+     * @param invocation  the invocation context.\n+     * @throws Exception can be thrown.\n+     */\n+    public void execute(ActionInvocation invocation) throws Exception;\n+\n+}"
        },
        {
            "sha": "823e764befc0f9a33ef307b4b8e06b2091e7ee1d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/TestNGXWorkTestCase.java",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTestNGXWorkTestCase.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTestNGXWorkTestCase.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTestNGXWorkTestCase.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationManager;\n+import com.opensymphony.xwork2.config.ConfigurationProvider;\n+import com.opensymphony.xwork2.config.impl.MockConfiguration;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.util.XWorkTestCaseHelper;\n+import org.testng.annotations.AfterTest;\n+import org.testng.annotations.BeforeTest;\n+\n+/**\n+ * Base test class for TestNG unit tests.  Provides common XWork variables\n+ * and performs XWork setup and teardown processes\n+ */\n+public class TestNGXWorkTestCase {\n+\n+    protected ConfigurationManager configurationManager;\n+    protected Configuration configuration;\n+    protected Container container;\n+    protected ActionProxyFactory actionProxyFactory;\n+\n+    @BeforeTest\n+    protected void setUp() throws Exception {\n+        configurationManager = XWorkTestCaseHelper.setUp();\n+        configuration = new MockConfiguration();\n+        ((MockConfiguration) configuration).selfRegister();\n+        container = configuration.getContainer();\n+        actionProxyFactory = container.getInstance(ActionProxyFactory.class);\n+    }\n+\n+    @AfterTest\n+    protected void tearDown() throws Exception {\n+        XWorkTestCaseHelper.tearDown(configurationManager);\n+        configurationManager = null;\n+        configuration = null;\n+        container = null;\n+        actionProxyFactory = null;\n+    }\n+\n+    protected void loadConfigurationProviders(ConfigurationProvider... providers) {\n+        configurationManager = XWorkTestCaseHelper.loadConfigurationProviders(configurationManager, providers);\n+        configuration = configurationManager.getConfiguration();\n+        container = configuration.getContainer();\n+        actionProxyFactory = container.getInstance(ActionProxyFactory.class);\n+    }\n+}"
        },
        {
            "sha": "742eb4609ab71fc08a27f0bef4ef4ee56e135586",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/TextProvider.java",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.util.List;\n+import java.util.ResourceBundle;\n+\n+\n+/**\n+ * Provides access to {@link ResourceBundle}s and their underlying text messages.\n+ * Implementing classes can delegate {@link TextProviderSupport}. Messages will be\n+ * searched in multiple resource bundles, startinag with the one associated with\n+ * this particular class (action in most cases), continuing to try the message\n+ * bundle associated with each superclass as well. It will stop once a bundle is\n+ * found that contains the given text. This gives a cascading style that allow\n+ * global texts to be defined for an application base class.\n+ * <p/>\n+ * You can override {@link LocaleProvider#getLocale()} to change the behaviour of how\n+ * to choose locale for the bundles that are returned. Typically you would\n+ * use the {@link LocaleProvider} interface to get the users configured locale.\n+ * <p/>\n+ * When you want to use your own implementation for Struts 2 project you have to define following\n+ * bean and constant in struts.xml:\n+ * &lt;bean class=&quot;org.demo.MyTextProvider&quot; name=&quot;myTextProvider&quot; type=&quot;com.opensymphony.xwork2.TextProvider&quot; /&gt;\n+ * &lt;constant name=&quot;struts.xworkTextProvider&quot; value=&quot;myTextProvider&quot; /&gt;\n+ * <p/>\n+ * if you want to also use your implemntation for framework's messages define another constant (remember to put\n+ * into it all framework messages)\n+ * &lt;constant name=&quot;system&quot; value=&quot;myTextProvider&quot; /&gt;\n+ * <p/>\n+ * Take a look on {@link com.opensymphony.xwork2.ActionSupport} for example TextProvider implemntation.\n+ *\n+ * @author Jason Carreira\n+ * @author Rainer Hermanns\n+ * @see LocaleProvider\n+ * @see TextProviderSupport\n+ */\n+public interface TextProvider {\n+\n+    /**\n+     * Checks if a message key exists.\n+     *\n+     * @param key message key to check for\n+     * @return boolean true if key exists, false otherwise.\n+     */\n+    boolean hasKey(String key);\n+\n+    /**\n+     * Gets a message based on a message key, or null if no message is found.\n+     *\n+     * @param key the resource bundle key that is to be searched for\n+     * @return the message as found in the resource bundle, or null if none is found.\n+     */\n+    String getText(String key);\n+\n+    /**\n+     * Gets a message based on a key, or, if the message is not found, a supplied\n+     * default value is returned.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue);\n+\n+    /**\n+     * Gets a message based on a key using the supplied obj, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param obj          obj to be used in a {@link java.text.MessageFormat} message\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue, String obj);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or null if no message is found.\n+     *\n+     * @param key  the resource bundle key that is to be searched for\n+     * @param args a list args to be used in a {@link java.text.MessageFormat} message\n+     * @return the message as found in the resource bundle, or null if none is found.\n+     */\n+    String getText(String key, List<Object> args);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or null if no message is found.\n+     *\n+     * @param key  the resource bundle key that is to be searched for\n+     * @param args an array args to be used in a {@link java.text.MessageFormat} message\n+     * @return the message as found in the resource bundle, or null if none is found.\n+     */\n+    String getText(String key, String[] args);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue, List<Object> args);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue, String[] args);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned. Instead of using the value stack in the ActionContext\n+     * this version of the getText() method uses the provided value stack.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n+     * @param stack        the value stack to use for finding the text\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue, List<Object> args, ValueStack stack);\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned. Instead of using the value stack in the ActionContext\n+     * this version of the getText() method uses the provided value stack.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n+     * @param stack        the value stack to use for finding the text\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    String getText(String key, String defaultValue, String[] args, ValueStack stack);\n+\n+    /**\n+     * Get the named bundle, such as \"com/acme/Foo\".\n+     *\n+     * @param bundleName the name of the resource bundle, such as <code>\"com/acme/Foo\"</code>.\n+     * @return the bundle\n+     */\n+    ResourceBundle getTexts(String bundleName);\n+\n+    /**\n+     * Get the resource bundle associated with the implementing class (usually an action).\n+     *\n+     * @return the bundle\n+     */\n+    ResourceBundle getTexts();\n+}"
        },
        {
            "sha": "bcb6d932b7080b099bae446fc1bb5ed5988346fc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/TextProviderFactory.java",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,62 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.inject.Inject;\n+\n+import java.util.ResourceBundle;\n+\n+/**\n+ * This factory enables users to provide and correctly initialize a custom TextProvider.\n+ *\n+ * @author Oleg Gorobets\n+ * @author Rene Gielen\n+ */\n+public class TextProviderFactory {\n+\n+    private TextProvider textProvider;\n+\n+    @Inject\n+    public void setTextProvider(TextProvider textProvider) {\n+        this.textProvider = textProvider;\n+    }\n+\n+    protected TextProvider getTextProvider() {\n+        if (this.textProvider == null) {\n+            return new TextProviderSupport();\n+        } else {\n+            return textProvider;\n+        }\n+    }\n+\n+    public TextProvider createInstance(Class clazz, LocaleProvider provider) {\n+        TextProvider instance = getTextProvider();\n+        if (instance instanceof ResourceBundleTextProvider) {\n+            ((ResourceBundleTextProvider) instance).setClazz(clazz);\n+            ((ResourceBundleTextProvider) instance).setLocaleProvider(provider);\n+        }\n+        return instance;\n+    }\n+\n+    public TextProvider createInstance(ResourceBundle bundle, LocaleProvider provider) {\n+        TextProvider instance = getTextProvider();\n+        if (instance instanceof ResourceBundleTextProvider) {\n+            ((ResourceBundleTextProvider) instance).setBundle(bundle);\n+            ((ResourceBundleTextProvider) instance).setLocaleProvider(provider);\n+        }\n+        return instance;\n+    }\n+}"
        },
        {
            "sha": "188976610f7bd83987d7aa1a0efcc81a5c48aef6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/TextProviderSupport.java",
            "status": "added",
            "additions": 327,
            "deletions": 0,
            "changes": 327,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderSupport.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderSupport.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FTextProviderSupport.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,327 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * Default TextProvider implementation.\n+ *\n+ * @author Jason Carreira\n+ * @author Rainer Hermanns\n+ */\n+public class TextProviderSupport implements ResourceBundleTextProvider {\n+\n+    private Class clazz;\n+    private LocaleProvider localeProvider;\n+    private ResourceBundle bundle;\n+\n+    /**\n+     * Default constructor\n+     */\n+    public TextProviderSupport() {\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param clazz    a clazz to use for reading the resource bundle.\n+     * @param provider a locale provider.\n+     */\n+    public TextProviderSupport(Class clazz, LocaleProvider provider) {\n+        this.clazz = clazz;\n+        this.localeProvider = provider;\n+    }\n+\n+    /**\n+     * Constructor.\n+     *\n+     * @param bundle   the resource bundle.\n+     * @param provider a locale provider.\n+     */\n+    public TextProviderSupport(ResourceBundle bundle, LocaleProvider provider) {\n+        this.bundle = bundle;\n+        this.localeProvider = provider;\n+    }\n+\n+    /**\n+     * @param bundle the resource bundle.\n+     */\n+    public void setBundle(ResourceBundle bundle) {\n+        this.bundle = bundle;\n+    }\n+\n+    /**\n+     * @param clazz a clazz to use for reading the resource bundle.\n+     */\n+    public void setClazz(Class clazz) {\n+        this.clazz = clazz;\n+    }\n+\n+\n+    /**\n+     * @param localeProvider a locale provider.\n+     */\n+    public void setLocaleProvider(LocaleProvider localeProvider) {\n+        this.localeProvider = localeProvider;\n+    }\n+\n+\n+    /**\n+     * Checks if a key is available in the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class.\n+     */\n+    public boolean hasKey(String key) {\n+    \tString message;\n+    \tif (clazz != null) {\n+            message =  LocalizedTextUtil.findText(clazz, key, getLocale(), null, new Object[0] );\n+        } else {\n+            message = LocalizedTextUtil.findText(bundle, key, getLocale(), null, new Object[0]);\n+        }\n+    \treturn message != null;\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class.\n+     *\n+     * @param key name of text to be found\n+     * @return value of named text\n+     */\n+    public String getText(String key) {\n+        return getText(key, key, Collections.emptyList());\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key    name of text to be found\n+     * @param defaultValue the default value which will be returned if no text is found\n+     * @return value of named text\n+     */\n+    public String getText(String key, String defaultValue) {\n+        return getText(key, defaultValue, Collections.emptyList());\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key    name of text to be found\n+     * @param defaultValue the default value which will be returned if no text is found\n+     * @return value of named text\n+     */\n+    public String getText(String key, String defaultValue, String arg) {\n+        List<Object> args = new ArrayList<Object>();\n+        args.add(arg);\n+        return getText(key, defaultValue, args);\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key name of text to be found\n+     * @param args      a List of args to be used in a MessageFormat message\n+     * @return value of named text\n+     */\n+    public String getText(String key, List<Object> args) {\n+        return getText(key, key, args);\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key name of text to be found\n+     * @param args      an array of args to be used in a MessageFormat message\n+     * @return value of named text\n+     */\n+    public String getText(String key, String[] args) {\n+        return getText(key, key, args);\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key    name of text to be found\n+     * @param defaultValue the default value which will be returned if no text is found\n+     * @param args         a List of args to be used in a MessageFormat message\n+     * @return value of named text\n+     */\n+    public String getText(String key, String defaultValue, List<Object> args) {\n+        Object[] argsArray = ((args != null && !args.equals(Collections.emptyList())) ? args.toArray() : null);\n+        if (clazz != null) {\n+            return LocalizedTextUtil.findText(clazz, key, getLocale(), defaultValue, argsArray);\n+        } else {\n+            return LocalizedTextUtil.findText(bundle, key, getLocale(), defaultValue, argsArray);\n+        }\n+    }\n+\n+    /**\n+     * Get a text from the resource bundles associated with this action.\n+     * The resource bundles are searched, starting with the one associated\n+     * with this particular action, and testing all its superclasses' bundles.\n+     * It will stop once a bundle is found that contains the given text. This gives\n+     * a cascading style that allow global texts to be defined for an application base\n+     * class. If no text is found for this text name, the default value is returned.\n+     *\n+     * @param key          name of text to be found\n+     * @param defaultValue the default value which will be returned if no text is found\n+     * @param args         an array of args to be used in a MessageFormat message\n+     * @return value of named text\n+     */\n+    public String getText(String key, String defaultValue, String[] args) {\n+        if (clazz != null) {\n+            return LocalizedTextUtil.findText(clazz, key, getLocale(), defaultValue, args);\n+        } else {\n+            return LocalizedTextUtil.findText(bundle, key, getLocale(), defaultValue, args);\n+        }\n+    }\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned. Instead of using the value stack in the ActionContext\n+     * this version of the getText() method uses the provided value stack.\n+     *\n+     * @param key    the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         a list args to be used in a {@link java.text.MessageFormat} message\n+     * @param stack        the value stack to use for finding the text\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    public String getText(String key, String defaultValue, List<Object> args, ValueStack stack) {\n+        Object[] argsArray = ((args != null) ? args.toArray() : null);\n+        Locale locale;\n+        if (stack == null){\n+        \tlocale = getLocale();\n+        }else{\n+        \tlocale = (Locale) stack.getContext().get(ActionContext.LOCALE);\n+        }\n+        if (locale == null) {\n+            locale = getLocale();\n+        }\n+        if (clazz != null) {\n+            return LocalizedTextUtil.findText(clazz, key, locale, defaultValue, argsArray, stack);\n+        } else {\n+            return LocalizedTextUtil.findText(bundle, key, locale, defaultValue, argsArray, stack);\n+        }\n+    }\n+\n+\n+    /**\n+     * Gets a message based on a key using the supplied args, as defined in\n+     * {@link java.text.MessageFormat}, or, if the message is not found, a supplied\n+     * default value is returned. Instead of using the value stack in the ActionContext\n+     * this version of the getText() method uses the provided value stack.\n+     *\n+     * @param key          the resource bundle key that is to be searched for\n+     * @param defaultValue the default value which will be returned if no message is found\n+     * @param args         an array args to be used in a {@link java.text.MessageFormat} message\n+     * @param stack        the value stack to use for finding the text\n+     * @return the message as found in the resource bundle, or defaultValue if none is found\n+     */\n+    public String getText(String key, String defaultValue, String[] args, ValueStack stack) {\n+        Locale locale;\n+        if (stack == null){\n+        \tlocale = getLocale();\n+        }else{\n+        \tlocale = (Locale) stack.getContext().get(ActionContext.LOCALE);\n+        }\n+        if (locale == null) {\n+            locale = getLocale();\n+        }\n+        if (clazz != null) {\n+            return LocalizedTextUtil.findText(clazz, key, locale, defaultValue, args, stack);\n+        } else {\n+            return LocalizedTextUtil.findText(bundle, key, locale, defaultValue, args, stack);\n+        }\n+\n+    }\n+\n+    /**\n+     * Get the named bundle.\n+     * <p/>\n+     * You can override the getLocale() methodName to change the behaviour of how\n+     * to choose locale for the bundles that are returned. Typically you would\n+     * use the TextProvider interface to get the users configured locale, or use\n+     * your own methodName to allow the user to select the locale and store it in\n+     * the session (by using the SessionAware interface).\n+     *\n+     * @param aBundleName bundle name\n+     * @return a resource bundle\n+     */\n+    public ResourceBundle getTexts(String aBundleName) {\n+        return LocalizedTextUtil.findResourceBundle(aBundleName, getLocale());\n+    }\n+\n+    /**\n+     * Get the resource bundle associated with this action.\n+     * This will be based on the actual subclass that is used.\n+     *\n+     * @return resouce bundle\n+     */\n+    public ResourceBundle getTexts() {\n+        if (clazz != null) {\n+            return getTexts(clazz.getName());\n+        }\n+        return bundle;\n+    }\n+\n+    /**\n+     * Get's the locale from the localeProvider.\n+     *\n+     * @return the locale from the localeProvider.\n+     */\n+    private Locale getLocale() {\n+        return localeProvider.getLocale();\n+    }\n+}"
        },
        {
            "sha": "19d88ef4fb1d128199fe7364b91faa53759fda42",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/Unchainable.java",
            "status": "added",
            "additions": 25,
            "deletions": 0,
            "changes": 25,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnchainable.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnchainable.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnchainable.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,25 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2;\n+\n+/**\n+ * Simple marker interface to indicate an object should <b>not</b> have its properties copied during chaining.\n+ *\n+ * @see com.opensymphony.xwork2.interceptor.ChainingInterceptor\n+ */\n+public interface Unchainable {\n+}"
        },
        {
            "sha": "033c0d6f5f57ca0e62255ef29535fe7851055b65",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/UnknownHandler.java",
            "status": "added",
            "additions": 60,
            "deletions": 0,
            "changes": 60,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandler.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandler.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandler.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,60 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+\n+/**\n+ * Handles cases when the result or action is unknown.\n+ * <p/>\n+ * This allows other classes like Struts plugins to provide intelligent defaults easier.\n+ */\n+public interface UnknownHandler {\n+    \n+    /**\n+     * Handles the case when an action configuration is unknown.  Implementations can return a new ActionConfig\n+     * to be used to process the request.\n+     * \n+     * @param namespace The namespace\n+     * @param actionName The action name\n+     * @return An generated ActionConfig, can return <tt>null</tt>\n+     * @throws XWorkException\n+     */\n+    public ActionConfig handleUnknownAction(String namespace, String actionName) throws XWorkException;\n+    \n+    /**\n+     * Handles the case when a result cannot be found for an action and result code. \n+     * \n+     * @param actionContext The action context\n+     * @param actionName The action name\n+     * @param actionConfig The action config\n+     * @param resultCode The returned result code\n+     * @return A result to be executed, can return <tt>null</tt>\n+     * @throws XWorkException\n+     */\n+    public Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode) throws XWorkException;\n+    \n+    /**\n+     * Handles the case when an action method cannot be found.  This method is responsible both for finding the method and executing it.\n+     * \n+     * @since 2.1\n+     * @param action The action object\n+     * @param methodName The method name to call\n+     * @return The result returned from invoking the action method\n+     * @throws NoSuchMethodException If the method cannot be found\n+     */\n+\tpublic Object handleUnknownActionMethod(Object action, String methodName) throws NoSuchMethodException;\n+}"
        },
        {
            "sha": "325c0ffe82ed9dc84fafc7fc211c742114ade8a2",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/UnknownHandlerManager.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandlerManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandlerManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FUnknownHandlerManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,37 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+\n+import java.util.List;\n+\n+/**\n+ * An unknown handler manager contains a list of UnknownHandler and iterates on them by order\n+ *\n+ * @see com.opensymphony.xwork2.DefaultUnknownHandlerManager\n+ */\n+public interface UnknownHandlerManager {\n+    Result handleUnknownResult(ActionContext actionContext, String actionName, ActionConfig actionConfig, String resultCode);\n+\n+    Object handleUnknownMethod(Object action, String methodName) throws NoSuchMethodException;\n+\n+    ActionConfig handleUnknownAction(String namespace, String actionName);\n+\n+    boolean hasUnknownHandlers();\n+\n+    List<UnknownHandler> getUnknownHandlers();\n+}"
        },
        {
            "sha": "889a28440160883ec81b8c99e8973c50bffe4887",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/Validateable.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidateable.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidateable.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidateable.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+\n+/**\n+ * Provides an interface in which a call for a validation check can be done.\n+ *\n+ * @author Jason Carreira\n+ * @see ActionSupport\n+ * @see com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor\n+ */\n+public interface Validateable {\n+\n+    /**\n+     * Performs validation.\n+     */\n+    void validate();\n+\n+}"
        },
        {
            "sha": "4ae5e842eadb8b6d33bf4a4bff6af4a87c011429",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ValidationAware.java",
            "status": "added",
            "additions": 130,
            "deletions": 0,
            "changes": 130,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAware.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAware.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAware.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,130 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.util.Collection;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * ValidationAware classes can accept Action (class level) or field level error messages. Action level messages are kept\n+ * in a Collection. Field level error messages are kept in a Map from String field name to a List of field error msgs.\n+ *\n+ * @author plightbo \n+ */\n+public interface ValidationAware {\n+\n+    /**\n+     * Set the Collection of Action-level String error messages.\n+     *\n+     * @param errorMessages Collection of String error messages\n+     */\n+    void setActionErrors(Collection<String> errorMessages);\n+\n+    /**\n+     * Get the Collection of Action-level error messages for this action. Error messages should not\n+     * be added directly here, as implementations are free to return a new Collection or an\n+     * Unmodifiable Collection.\n+     *\n+     * @return Collection of String error messages\n+     */\n+    Collection<String> getActionErrors();\n+\n+    /**\n+     * Set the Collection of Action-level String messages (not errors).\n+     *\n+     * @param messages Collection of String messages (not errors).\n+     */\n+    void setActionMessages(Collection<String> messages);\n+\n+    /**\n+     * Get the Collection of Action-level messages for this action. Messages should not be added\n+     * directly here, as implementations are free to return a new Collection or an Unmodifiable\n+     * Collection.\n+     *\n+     * @return Collection of String messages\n+     */\n+    Collection<String> getActionMessages();\n+\n+    /**\n+     * Set the field error map of fieldname (String) to Collection of String error messages.\n+     *\n+     * @param errorMap field error map\n+     */\n+    void setFieldErrors(Map<String, List<String>> errorMap);\n+\n+    /**\n+     * Get the field specific errors associated with this action. Error messages should not be added\n+     * directly here, as implementations are free to return a new Collection or an Unmodifiable\n+     * Collection.\n+     *\n+     * @return Map with errors mapped from fieldname (String) to Collection of String error messages\n+     */\n+    Map<String, List<String>> getFieldErrors();\n+\n+    /**\n+     * Add an Action-level error message to this Action.\n+     *\n+     * @param anErrorMessage  the error message\n+     */\n+    void addActionError(String anErrorMessage);\n+\n+    /**\n+     * Add an Action-level message to this Action.\n+     *\n+     * @param aMessage  the message\n+     */\n+    void addActionMessage(String aMessage);\n+\n+    /**\n+     * Add an error message for a given field.\n+     *\n+     * @param fieldName    name of field\n+     * @param errorMessage the error message\n+     */\n+    void addFieldError(String fieldName, String errorMessage);\n+\n+    /**\n+     * Check whether there are any Action-level error messages.\n+     *\n+     * @return true if any Action-level error messages have been registered\n+     */\n+    boolean hasActionErrors();\n+\n+    /**\n+     * Checks whether there are any Action-level messages.\n+     *\n+     * @return true if any Action-level messages have been registered\n+     */\n+    boolean hasActionMessages();\n+\n+    /**\n+     * Checks whether there are any action errors or field errors.\n+     * <p/>\n+     * <b>Note</b>: that this does not have the same meaning as in WW 1.x.\n+     *\n+     * @return <code>(hasActionErrors() || hasFieldErrors())</code>\n+     */\n+    boolean hasErrors();\n+\n+    /**\n+     * Check whether there are any field errors associated with this action.\n+     *\n+     * @return whether there are any field errors\n+     */\n+    boolean hasFieldErrors();\n+\n+}"
        },
        {
            "sha": "27eb93d7035877eb0ba5426718ec500ab9366dae",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ValidationAwareSupport.java",
            "status": "added",
            "additions": 169,
            "deletions": 0,
            "changes": 169,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAwareSupport.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAwareSupport.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FValidationAwareSupport.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,169 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+/**\n+ * Provides a default implementation of ValidationAware. Returns new collections for\n+ * errors and messages (defensive copy).\n+ *\n+ * @author Jason Carreira\n+ * @author tm_jee\n+ * @version $Date$ $Id$\n+ */\n+public class ValidationAwareSupport implements ValidationAware, Serializable {\n+\n+    private Collection<String> actionErrors;\n+    private Collection<String> actionMessages;\n+    private Map<String, List<String>> fieldErrors;\n+\n+\n+    public synchronized void setActionErrors(Collection<String> errorMessages) {\n+        this.actionErrors = errorMessages;\n+    }\n+\n+    public synchronized Collection<String> getActionErrors() {\n+        return new ArrayList<String>(internalGetActionErrors());\n+    }\n+\n+    public synchronized void setActionMessages(Collection<String> messages) {\n+        this.actionMessages = messages;\n+    }\n+\n+    public synchronized Collection<String> getActionMessages() {\n+        return new ArrayList<String>(internalGetActionMessages());\n+    }\n+\n+    public synchronized void setFieldErrors(Map<String, List<String>> errorMap) {\n+        this.fieldErrors = errorMap;\n+    }\n+\n+    public synchronized Map<String, List<String>> getFieldErrors() {\n+        return new LinkedHashMap<String, List<String>>(internalGetFieldErrors());\n+    }\n+\n+    public synchronized void addActionError(String anErrorMessage) {\n+        internalGetActionErrors().add(anErrorMessage);\n+    }\n+\n+    public synchronized void addActionMessage(String aMessage) {\n+        internalGetActionMessages().add(aMessage);\n+    }\n+\n+    public synchronized void addFieldError(String fieldName, String errorMessage) {\n+        final Map<String, List<String>> errors = internalGetFieldErrors();\n+        List<String> thisFieldErrors = errors.get(fieldName);\n+\n+        if (thisFieldErrors == null) {\n+            thisFieldErrors = new ArrayList<String>();\n+            errors.put(fieldName, thisFieldErrors);\n+        }\n+\n+        thisFieldErrors.add(errorMessage);\n+    }\n+\n+    public synchronized boolean hasActionErrors() {\n+        return (actionErrors != null) && !actionErrors.isEmpty();\n+    }\n+\n+    public synchronized boolean hasActionMessages() {\n+        return (actionMessages != null) && !actionMessages.isEmpty();\n+    }\n+\n+    public synchronized boolean hasErrors() {\n+        return (hasActionErrors() || hasFieldErrors());\n+    }\n+\n+    public synchronized boolean hasFieldErrors() {\n+        return (fieldErrors != null) && !fieldErrors.isEmpty();\n+    }\n+\n+    private Collection<String> internalGetActionErrors() {\n+        if (actionErrors == null) {\n+            actionErrors = new ArrayList<String>();\n+        }\n+\n+        return actionErrors;\n+    }\n+\n+    private Collection<String> internalGetActionMessages() {\n+        if (actionMessages == null) {\n+            actionMessages = new ArrayList<String>();\n+        }\n+\n+        return actionMessages;\n+    }\n+\n+    private Map<String, List<String>> internalGetFieldErrors() {\n+        if (fieldErrors == null) {\n+            fieldErrors = new LinkedHashMap<String, List<String>>();\n+        }\n+\n+        return fieldErrors;\n+    }\n+\n+    /**\n+     * Clears field errors map.\n+     * <p/>\n+     * Will clear the map that contains field errors.\n+     */\n+    public synchronized void clearFieldErrors() {\n+        internalGetFieldErrors().clear();\n+    }\n+\n+    /**\n+     * Clears action errors list.\n+     * <p/>\n+     * Will clear the list that contains action errors.\n+     */\n+    public synchronized void clearActionErrors() {\n+        internalGetActionErrors().clear();\n+    }\n+\n+    /**\n+     * Clears messages list.\n+     * <p/>\n+     * Will clear the list that contains action messages.\n+     */\n+    public synchronized void clearMessages() {\n+        internalGetActionMessages().clear();\n+    }\n+\n+    /**\n+     * Clears all error list/maps.\n+     * <p/>\n+     * Will clear the map and list that contain\n+     * field errors and action errors.\n+     */\n+    public synchronized void clearErrors() {\n+        internalGetFieldErrors().clear();\n+        internalGetActionErrors().clear();\n+    }\n+\n+    /**\n+     * Clears all error and messages list/maps.\n+     * <p/>\n+     * Will clear the maps/lists that contain\n+     * field errors, action errors and action messages.\n+     */\n+    public synchronized void clearErrorsAndMessages() {\n+        internalGetFieldErrors().clear();\n+        internalGetActionErrors().clear();\n+        internalGetActionMessages().clear();\n+    }\n+}"
        },
        {
            "sha": "fddc75bc638636f0fecd4d0401e4f75f1dc3d460",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/XWork.java",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWork.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWork.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWork.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationManager;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+\n+/**\n+ * Simple facade to make using XWork standalone easier\n+ */\n+public class XWork {\n+    \n+    ConfigurationManager configurationManager;\n+    \n+    public XWork() {\n+        this(new ConfigurationManager());\n+    }\n+    \n+    public XWork(ConfigurationManager mgr) {\n+        this.configurationManager = mgr;\n+    }\n+    \n+    public void setLoggerFactory(LoggerFactory factory) {\n+        LoggerFactory.setLoggerFactory(factory);\n+    }\n+    \n+    /**\n+     * Executes an action\n+     * \n+     * @param namespace The namespace\n+     * @param name The action name\n+     * @param method The method name\n+     * @throws Exception If anything goes wrong\n+     */\n+    public void executeAction(String namespace, String name, String method) throws XWorkException {\n+        Map<String, Object> extraContext = Collections.emptyMap();\n+        executeAction(namespace, name, method, extraContext);\n+    }\n+    \n+    /**\n+     * Executes an action with extra context information\n+     * \n+     * @param namespace The namespace\n+     * @param name The action name\n+     * @param method The method name\n+     * @param extraContext A map of extra context information\n+     * @throws Exception If anything goes wrong\n+     */\n+    public void executeAction(String namespace, String name, String method, Map<String, Object> extraContext) throws XWorkException {\n+        Configuration config = configurationManager.getConfiguration();\n+        try {\n+            ActionProxy proxy = config.getContainer().getInstance(ActionProxyFactory.class).createActionProxy(\n+                    namespace, name, method, extraContext, true, false);\n+        \n+            proxy.execute();\n+        } catch (Exception e) {\n+            throw new XWorkException(e);\n+        } finally {\n+            ActionContext.setContext(null);\n+        }\n+    }\n+}"
        },
        {
            "sha": "3242ce9e6af6a630c20e9846b20b0fe0bbbe63fb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/XWorkException.java",
            "status": "added",
            "additions": 154,
            "deletions": 0,
            "changes": 154,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,154 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.util.location.Locatable;\n+import com.opensymphony.xwork2.util.location.Location;\n+import com.opensymphony.xwork2.util.location.LocationUtils;\n+\n+\n+/**\n+ * A generic runtime exception that optionally contains Location information \n+ *\n+ * @author Jason Carreira\n+ */\n+public class XWorkException extends RuntimeException implements Locatable {\n+\n+    private Location location;\n+\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with no detail message.\n+     */\n+    public XWorkException() {\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public XWorkException(String s) {\n+        this(s, null, null);\n+    }\n+    \n+    /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message and target.\n+     *\n+     * @param s the detail message.\n+     * @param target the target of the exception.\n+     */\n+    public XWorkException(String s, Object target) {\n+        this(s, (Throwable) null, target);\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with the root cause\n+     *\n+     * @param cause The wrapped exception\n+     */\n+    public XWorkException(Throwable cause) {\n+        this(null, cause, null);\n+    }\n+    \n+    /**\n+     * Constructs a <code>XWorkException</code> with the root cause and target\n+     *\n+     * @param cause The wrapped exception\n+     * @param target The target of the exception\n+     */\n+    public XWorkException(Throwable cause, Object target) {\n+        this(null, cause, target);\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message and exception cause.\n+     *\n+     * @param s the detail message.\n+     * @param cause the wrapped exception\n+     */\n+    public XWorkException(String s, Throwable cause) {\n+        this(s, cause, null);\n+    }\n+    \n+    \n+     /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message, cause, and target\n+     *\n+     * @param s the detail message.\n+     * @param cause The wrapped exception\n+     * @param target The target of the exception\n+     */\n+    public XWorkException(String s, Throwable cause, Object target) {\n+        super(s, cause);\n+        \n+        this.location = LocationUtils.getLocation(target);\n+        if (this.location == Location.UNKNOWN) {\n+            this.location = LocationUtils.getLocation(cause);\n+        }\n+    }\n+\n+\n+    /**\n+     * Gets the underlying cause\n+     * \n+     * @return the underlying cause, <tt>null</tt> if no cause\n+     * @deprecated Use {@link #getCause()} \n+     */\n+    @Deprecated public Throwable getThrowable() {\n+        return getCause();\n+    }\n+\n+\n+    /**\n+     * Gets the location of the error, if available\n+     *\n+     * @return the location, <tt>null</tt> if not available \n+     */\n+    public Location getLocation() {\n+        return this.location;\n+    }\n+    \n+    \n+    /**\n+     * Returns a short description of this throwable object, including the \n+     * location. If no detailed message is available, it will use the message\n+     * of the underlying exception if available.\n+     *\n+     * @return a string representation of this <code>Throwable</code>.\n+     */\n+    @Override\n+    public String toString() {\n+        String msg = getMessage();\n+        if (msg == null && getCause() != null) {\n+            msg = getCause().getMessage();\n+        }\n+\n+        if (location != null) {\n+            if (msg != null) {\n+                return msg + \" - \" + location.toString();\n+            } else {\n+                return location.toString();\n+            }\n+        } else {\n+            return msg;\n+        }\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "d187acc5105a7c8f75bd365bae8df1d5e14ae41c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/XWorkMessages.java",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkMessages.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkMessages.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkMessages.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2;\n+\n+\n+/**\n+ * Contains constants for some default XWork messages.\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface XWorkMessages {\n+\n+    public static final String ACTION_EXECUTION_ERROR             = \"xwork.error.action.execution\";\n+    public static final String MISSING_ACTION_EXCEPTION           = \"xwork.exception.missing-action\";\n+    public static final String MISSING_PACKAGE_ACTION_EXCEPTION   = \"xwork.exception.missing-package-action\";\n+    public static final String DEFAULT_INVALID_FIELDVALUE         = \"xwork.default.invalid.fieldvalue\";\n+\n+}"
        },
        {
            "sha": "c9b4e32f97d501c31373c4e09fcea4508658f241",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/XWorkTestCase.java",
            "status": "added",
            "additions": 90,
            "deletions": 0,
            "changes": 90,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkTestCase.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkTestCase.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2FXWorkTestCase.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,90 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.ConfigurationManager;\n+import com.opensymphony.xwork2.config.ConfigurationProvider;\n+import com.opensymphony.xwork2.inject.*;\n+import com.opensymphony.xwork2.test.StubConfigurationProvider;\n+import com.opensymphony.xwork2.util.XWorkTestCaseHelper;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+import junit.framework.TestCase;\n+\n+\n+/**\n+ * Base JUnit TestCase to extend for XWork specific JUnit tests. Uses \n+ * the generic test setup for logic.\n+ *\n+ * @author plightbo\n+ */\n+public abstract class XWorkTestCase extends TestCase {\n+    \n+    protected ConfigurationManager configurationManager;\n+    protected Configuration configuration;\n+    protected Container container;\n+    protected ActionProxyFactory actionProxyFactory;\n+    \n+    public XWorkTestCase() {\n+        super();\n+    }\n+    \n+    @Override\n+    protected void setUp() throws Exception {\n+        configurationManager = XWorkTestCaseHelper.setUp();\n+        configuration = configurationManager.getConfiguration();\n+        container = configuration.getContainer();\n+        actionProxyFactory = container.getInstance(ActionProxyFactory.class);\n+    }\n+    \n+    @Override\n+    protected void tearDown() throws Exception {\n+        XWorkTestCaseHelper.tearDown(configurationManager);\n+        configurationManager = null;\n+        configuration = null;\n+        container = null;\n+        actionProxyFactory = null;\n+    }\n+    \n+    protected void loadConfigurationProviders(ConfigurationProvider... providers) {\n+        configurationManager = XWorkTestCaseHelper.loadConfigurationProviders(configurationManager, providers);\n+        configuration = configurationManager.getConfiguration();\n+        container = configuration.getContainer();\n+        actionProxyFactory = container.getInstance(ActionProxyFactory.class);\n+    }\n+    \n+    protected void loadButAdd(final Class<?> type, final Object impl) {\n+        loadButAdd(type, Container.DEFAULT_NAME, impl);\n+    }\n+    \n+    protected void loadButAdd(final Class<?> type, final String name, final Object impl) {\n+        loadConfigurationProviders(new StubConfigurationProvider() {\n+            @Override\n+            public void register(ContainerBuilder builder,\n+                    LocatableProperties props) throws ConfigurationException {\n+                builder.factory(type, name, new Factory() {\n+                    public Object create(Context context) throws Exception {\n+                        return impl;\n+                    }\n+                    \n+                }, Scope.SINGLETON);\n+            }\n+        });\n+    }\n+    \n+}"
        },
        {
            "sha": "be1359d5eab1af83e5a601611182a72ffa00b9ef",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/Configuration.java",
            "status": "added",
            "additions": 98,
            "deletions": 0,
            "changes": 98,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfiguration.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfiguration.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfiguration.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,98 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.config.entities.PackageConfig;\n+import com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\n+import com.opensymphony.xwork2.inject.Container;\n+\n+import java.io.Serializable;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * XWork configuration.\n+ *\n+ * @author Mike\n+ */\n+public interface Configuration extends Serializable {\n+\n+    void rebuildRuntimeConfiguration();\n+\n+    PackageConfig getPackageConfig(String name);\n+\n+    Set<String> getPackageConfigNames();\n+\n+    Map<String, PackageConfig> getPackageConfigs();\n+\n+    /**\n+     * The current runtime configuration. Currently, if changes have been made to the Configuration since the last\n+     * time buildRuntimeConfiguration() was called, you'll need to make sure to.\n+     *\n+     * @return the current runtime configuration\n+     */\n+    RuntimeConfiguration getRuntimeConfiguration();\n+\n+    void addPackageConfig(String name, PackageConfig packageConfig);\n+\n+    /**\n+     * Removes a package from the the list of packages. Changes to the configuration won't take effect until buildRuntimeConfiguration\n+     * is called.\n+     * @param packageName the name of the package to remove\n+     * @return the package removed (if any)\n+     */\n+    PackageConfig removePackageConfig(String packageName);\n+\n+    /**\n+     * Allow the Configuration to clean up any resources that have been used.\n+     */\n+    void destroy();\n+\n+    /**\n+     * @deprecated Since 2.1\n+     * @param providers\n+     * @throws ConfigurationException\n+     */\n+    @Deprecated void reload(List<ConfigurationProvider> providers) throws ConfigurationException;\n+    \n+    /**\n+     * @since 2.1\n+     * @param containerProviders\n+     * @throws ConfigurationException\n+     */\n+    List<PackageProvider> reloadContainer(List<ContainerProvider> containerProviders) throws ConfigurationException;\n+\n+    /**\n+     * @return the container\n+     */\n+    Container getContainer();\n+\n+    Set<String> getLoadedFileNames();\n+\n+    /**\n+     * @since 2.1\n+     * @return list of unknown handlers\n+     */\n+    List<UnknownHandlerConfig> getUnknownHandlerStack();\n+\n+    /**\n+     * @since 2.1\n+     * @param unknownHandlerStack\n+     */\n+    void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack);\n+}"
        },
        {
            "sha": "fcbb11bc8eb9a98728afade27c49a089e1a68ac3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ConfigurationException.java",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,87 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.XWorkException;\n+\n+\n+/**\n+ * ConfigurationException\n+ *\n+ * @author Jason Carreira\n+ */\n+public class ConfigurationException extends XWorkException {\n+\n+    /**\n+     * Constructs a <code>ConfigurationException</code> with no detail message.\n+     */\n+    public ConfigurationException() {\n+    }\n+\n+    /**\n+     * Constructs a <code>ConfigurationException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public ConfigurationException(String s) {\n+        super(s);\n+    }\n+    \n+    /**\n+     * Constructs a <code>ConfigurationException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public ConfigurationException(String s, Object target) {\n+        super(s, target);\n+    }\n+\n+    /**\n+     * Constructs a <code>ConfigurationException</code> with no detail message.\n+     */\n+    public ConfigurationException(Throwable cause) {\n+        super(cause);\n+    }\n+    \n+    /**\n+     * Constructs a <code>ConfigurationException</code> with no detail message.\n+     */\n+    public ConfigurationException(Throwable cause, Object target) {\n+        super(cause, target);\n+    }\n+\n+    /**\n+     * Constructs a <code>ConfigurationException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public ConfigurationException(String s, Throwable cause) {\n+        super(s, cause);\n+    }\n+    \n+    /**\n+     * Constructs a <code>ConfigurationException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public ConfigurationException(String s, Throwable cause, Object target) {\n+        super(s, cause, target);\n+    }\n+}"
        },
        {
            "sha": "84d89e94097fb28e8e2083b0ebf0ce9a72573e3e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ConfigurationManager.java",
            "status": "added",
            "additions": 271,
            "deletions": 0,
            "changes": 271,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,271 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.config.impl.DefaultConfiguration;\n+import com.opensymphony.xwork2.config.providers.XWorkConfigurationProvider;\n+import com.opensymphony.xwork2.config.providers.XmlConfigurationProvider;\n+import com.opensymphony.xwork2.util.FileManager;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+import java.util.concurrent.CopyOnWriteArrayList;\n+import java.util.concurrent.locks.Lock;\n+import java.util.concurrent.locks.ReentrantLock;\n+\n+\n+/**\n+ * ConfigurationManager - central for XWork Configuration management, including\n+ * its ConfigurationProvider.\n+ *\n+ * @author Jason Carreira\n+ * @author tm_jee\n+ * @version $Date$ $Id$\n+ */\n+public class ConfigurationManager {\n+\n+    protected static final Logger LOG = LoggerFactory.getLogger(ConfigurationManager.class);\n+    protected Configuration configuration;\n+    protected Lock providerLock = new ReentrantLock();\n+    private List<ContainerProvider> containerProviders = new CopyOnWriteArrayList<ContainerProvider>();\n+    private List<PackageProvider> packageProviders = new CopyOnWriteArrayList<PackageProvider>();\n+    protected String defaultFrameworkBeanName;\n+\n+    public ConfigurationManager() {\n+        this(\"xwork\");\n+    }\n+    \n+    public ConfigurationManager(String name) {\n+        this.defaultFrameworkBeanName = name;\n+    }\n+\n+    /**\n+     * Get the current XWork configuration object.  By default an instance of DefaultConfiguration will be returned\n+     *\n+     * @see com.opensymphony.xwork2.config.impl.DefaultConfiguration\n+     */\n+    public synchronized Configuration getConfiguration() {\n+        if (configuration == null) {\n+            setConfiguration(new DefaultConfiguration(defaultFrameworkBeanName));\n+            try {\n+                configuration.reloadContainer(getContainerProviders());\n+            } catch (ConfigurationException e) {\n+                setConfiguration(null);\n+                throw new ConfigurationException(\"Unable to load configuration.\", e);\n+            }\n+        } else {\n+            conditionalReload();\n+        }\n+\n+        return configuration;\n+    }\n+\n+    public synchronized void setConfiguration(Configuration configuration) {\n+        this.configuration = configuration;\n+    }\n+    \n+    /**\n+     * Get the current list of ConfigurationProviders. If no custom ConfigurationProviders have been added, this method\n+     * will return a list containing only the default ConfigurationProvider, XMLConfigurationProvider.  if a custom\n+     * ConfigurationProvider has been added, then the XmlConfigurationProvider must be added by hand.\n+     * </p>\n+     * <p/>\n+     * WARNING: This returns only ContainerProviders that can be cast into ConfigurationProviders\n+     *\n+     * @return the list of registered ConfigurationProvider objects\n+     * @see ConfigurationProvider\n+     * @deprecated Since 2.1, use {@link #getContainerProviders()}\n+     */\n+    @Deprecated public List<ConfigurationProvider> getConfigurationProviders() {\n+        List<ContainerProvider> contProviders = getContainerProviders();\n+        List<ConfigurationProvider> providers = new ArrayList<ConfigurationProvider>();\n+        for (ContainerProvider prov : contProviders) {\n+            if (prov instanceof ConfigurationProvider) {\n+                providers.add((ConfigurationProvider) prov);\n+            }\n+        }\n+        return providers;\n+    }\n+\n+    /**\n+     * Get the current list of ConfigurationProviders. If no custom ConfigurationProviders have been added, this method\n+     * will return a list containing only the default ConfigurationProvider, XMLConfigurationProvider.  if a custom\n+     * ConfigurationProvider has been added, then the XmlConfigurationProvider must be added by hand.\n+     * </p>\n+     * <p/>\n+     * TODO: the lazy instantiation of XmlConfigurationProvider should be refactored to be elsewhere.  the behavior described above seems unintuitive.\n+     *\n+     * @return the list of registered ConfigurationProvider objects\n+     * @see ConfigurationProvider\n+     */\n+    public List<ContainerProvider> getContainerProviders() {\n+        providerLock.lock();\n+        try {\n+            if (containerProviders.size() == 0) {\n+                containerProviders.add(new XWorkConfigurationProvider());\n+                containerProviders.add(new XmlConfigurationProvider(\"xwork.xml\", false));\n+            }\n+\n+            return containerProviders;\n+        } finally {\n+            providerLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * Set the list of configuration providers\n+     *\n+     * @param configurationProviders\n+     * @deprecated Since 2.1, use {@link #setContainerProvider()}\n+     */\n+    @Deprecated public void setConfigurationProviders(List<ConfigurationProvider> configurationProviders) {\n+        // Silly copy necessary due to lack of ability to cast generic lists\n+        List<ContainerProvider> contProviders = new ArrayList<ContainerProvider>();\n+        contProviders.addAll(configurationProviders);\n+        \n+        setContainerProviders(contProviders);\n+    }\n+        \n+    /**\n+     * Set the list of configuration providers\n+     *\n+     * @param containerProviders\n+     */\n+    public void setContainerProviders(List<ContainerProvider> containerProviders) {\n+        providerLock.lock();\n+        try {\n+            this.containerProviders = new CopyOnWriteArrayList<ContainerProvider>(containerProviders);\n+        } finally {\n+            providerLock.unlock();\n+        }\n+    }\n+\n+    /**\n+     * adds a configuration provider to the List of ConfigurationProviders.  a given ConfigurationProvider may be added\n+     * more than once\n+     *\n+     * @param provider the ConfigurationProvider to register\n+     * @deprecated Since 2.1, use {@link #addContainerProvider()}\n+     */\n+    @Deprecated public void addConfigurationProvider(ConfigurationProvider provider) {\n+        addContainerProvider(provider);\n+    }\n+        \n+    /**\n+     * adds a configuration provider to the List of ConfigurationProviders.  a given ConfigurationProvider may be added\n+     * more than once\n+     *\n+     * @param provider the ConfigurationProvider to register\n+     */\n+    public void addContainerProvider(ContainerProvider provider) {\n+        if (!containerProviders.contains(provider)) {\n+            containerProviders.add(provider);\n+        }\n+    }\n+    \n+    /**\n+     * clears the registered ConfigurationProviders.  this method will call destroy() on each of the registered\n+     * ConfigurationProviders\n+     *\n+     * @see com.opensymphony.xwork2.config.ConfigurationProvider#destroy\n+     * @deprecated Since 2.1, use {@link #clearContainerProviders()}\n+     */\n+    @Deprecated public void clearConfigurationProviders() {\n+        clearContainerProviders();\n+    }\n+    \n+    public void clearContainerProviders() {\n+        for (ContainerProvider containerProvider : containerProviders) {\n+            try {\n+                containerProvider.destroy();\n+            }\n+            catch(Exception e) {\n+                LOG.warn(\"error while destroying container provider [\"+containerProvider+\"]\", e);\n+            }\n+        }\n+        containerProviders.clear();\n+    }\n+\n+    /**\n+     * Destroy its managing Configuration instance\n+     */\n+    public synchronized void destroyConfiguration() {\n+        clearConfigurationProviders(); // let's destroy the ConfigurationProvider first\n+        containerProviders = new CopyOnWriteArrayList<ContainerProvider>();\n+        if (configuration != null)\n+            configuration.destroy(); // let's destroy it first, before nulling it.\n+        configuration = null;\n+    }\n+\n+\n+    /**\n+     * Reloads the Configuration files if the configuration files indicate that they need to be reloaded.\n+     */\n+    public synchronized void conditionalReload() {\n+        if (FileManager.isReloadingConfigs()) {\n+            boolean reload;\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Checking ConfigurationProviders for reload.\");\n+            }\n+\n+            reload = false;\n+\n+            List<ContainerProvider> providers = getContainerProviders();\n+            for (ContainerProvider provider : providers) {\n+                if (provider.needsReload()) {\n+                    if (LOG.isInfoEnabled()) {\n+                        LOG.info(\"Detected container provider \"+provider+\" needs to be reloaded.  Reloading all providers.\");\n+                    }\n+                    reload = true;\n+\n+                    //break;\n+                }\n+            }\n+            \n+            if (packageProviders != null && reload) {\n+                for (PackageProvider provider : packageProviders) {\n+                    if (provider.needsReload()) {\n+                        if (LOG.isInfoEnabled()) {\n+                            LOG.info(\"Detected package provider \"+provider+\" needs to be reloaded.  Reloading all providers.\");\n+                        }\n+                        reload = true;\n+    \n+                        //break;\n+                    }\n+                }\n+            }\n+\n+            if (reload) {\n+            \tfor (ContainerProvider containerProvider : containerProviders) {\n+                \ttry {\n+                \t\tcontainerProvider.destroy();\n+                \t}\n+                \tcatch(Exception e) {\n+                \t\tLOG.warn(\"error while destroying configuration provider [\"+containerProvider+\"]\", e);\n+                \t}\n+                }\n+                packageProviders = configuration.reloadContainer(providers);\n+            }\n+        }\n+    }\n+    \n+    public synchronized void reload() {\n+        packageProviders = getConfiguration().reloadContainer(getContainerProviders());\n+    }\n+}"
        },
        {
            "sha": "146532bf5792e70f35d38b6829410925a2a2066c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ConfigurationProvider.java",
            "status": "added",
            "additions": 22,
            "deletions": 0,
            "changes": 22,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,22 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+/**\n+ * Interface to be implemented by all forms of XWork configuration classes.\n+ */\n+public interface ConfigurationProvider extends ContainerProvider, PackageProvider {\n+}"
        },
        {
            "sha": "679f6d86c907e2885d07f3104129db9516517ba3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ConfigurationUtil.java",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FConfigurationUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.config.entities.PackageConfig;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.List;\n+import java.util.StringTokenizer;\n+\n+\n+/**\n+ * ConfigurationUtil\n+ *\n+ * @author Jason Carreira\n+ *         Created May 23, 2003 11:22:49 PM\n+ */\n+public class ConfigurationUtil {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ConfigurationUtil.class);\n+\n+\n+    private ConfigurationUtil() {\n+    }\n+\n+\n+    public static List<PackageConfig> buildParentsFromString(Configuration configuration, String parent) {\n+        if ((parent == null) || (\"\".equals(parent))) {\n+            return Collections.emptyList();\n+        }\n+\n+        StringTokenizer tokenizer = new StringTokenizer(parent, \", \");\n+        List<PackageConfig> parents = new ArrayList<PackageConfig>();\n+\n+        while (tokenizer.hasMoreTokens()) {\n+            String parentName = tokenizer.nextToken().trim();\n+\n+            if (!\"\".equals(parentName)) {\n+                PackageConfig parentPackageContext = configuration.getPackageConfig(parentName);\n+\n+                if (parentPackageContext != null) {\n+                    parents.add(parentPackageContext);\n+                }\n+            }\n+        }\n+\n+        return parents;\n+    }\n+}"
        },
        {
            "sha": "de943f0a192fb0e2b9cb2e482e7e39ad199aa6f8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ContainerProvider.java",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FContainerProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FContainerProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FContainerProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,57 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.inject.ContainerBuilder;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+\n+\n+/**\n+ * Provides beans and constants/properties for the Container\n+ * \n+ * @since 2.1\n+ */\n+public interface ContainerProvider {\n+\n+    /**\n+     * Called before removed from the configuration manager\n+     */\n+    public void destroy();\n+    \n+    /**\n+     * Initializes with the configuration\n+     * @param configuration The configuration\n+     * @throws ConfigurationException If anything goes wrong\n+     */\n+    public void init(Configuration configuration) throws ConfigurationException;\n+    \n+    /**\n+     * Tells whether the ContainerProvider should reload its configuration\n+     *\n+     * @return <tt>true</tt>, whether the ContainerProvider should reload its configuration, <tt>false</tt>otherwise.\n+     */\n+    public boolean needsReload();\n+    \n+    /**\n+     * Registers beans and properties for the Container\n+     * \n+     * @param builder The builder to register beans with\n+     * @param props The properties to register constants with\n+     * @throws ConfigurationException If anything goes wrong\n+     */\n+    public void register(ContainerBuilder builder, LocatableProperties props) throws ConfigurationException;\n+    \n+}"
        },
        {
            "sha": "dd0dfaeaa7b190248c44a47487b2636748c75341",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/PackageProvider.java",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FPackageProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FPackageProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FPackageProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,46 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+/**\n+ * Provides configuration packages.  The separate init and loadPackages calls are due to the need to \n+ * preserve backwards compatibility with the 2.0 {@link ConfigurationProvider} interface\n+ * \n+ * @since 2.1\n+ */\n+public interface PackageProvider {\n+    \n+    /**\n+     * Initializes with the configuration\n+     * @param configuration The configuration\n+     * @throws ConfigurationException If anything goes wrong\n+     */\n+    public void init(Configuration configuration) throws ConfigurationException;\n+    \n+    /**\n+     * Tells whether the PackageProvider should reload its configuration\n+     *\n+     * @return <tt>true</tt>, whether the PackageProvider should reload its configuration, <tt>false</tt>otherwise.\n+     */\n+    public boolean needsReload();\n+\n+    /**\n+     * Loads the packages for the configuration.\n+     * @throws ConfigurationException\n+     */\n+    public void loadPackages() throws ConfigurationException;\n+    \n+}"
        },
        {
            "sha": "00f1adb7bb56d67d80c3fd14744b1e6146a72255",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/ReferenceResolverException.java",
            "status": "added",
            "additions": 43,
            "deletions": 0,
            "changes": 43,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FReferenceResolverException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FReferenceResolverException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FReferenceResolverException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,43 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.XWorkException;\n+\n+\n+/**\n+ * Exception when a reference can't be resolved.\n+ *\n+ * @author Mike\n+ */\n+public class ReferenceResolverException extends XWorkException {\n+\n+    public ReferenceResolverException() {\n+        super();\n+    }\n+\n+    public ReferenceResolverException(String s) {\n+        super(s);\n+    }\n+\n+    public ReferenceResolverException(String s, Throwable cause) {\n+        super(s, cause);\n+    }\n+\n+    public ReferenceResolverException(Throwable cause) {\n+        super(cause);\n+    }\n+}"
        },
        {
            "sha": "f24c766ccbd1b57ac498e82819082124e3b5b704",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/RuntimeConfiguration.java",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FRuntimeConfiguration.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FRuntimeConfiguration.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2FRuntimeConfiguration.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,53 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config;\n+\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+\n+import java.io.Serializable;\n+import java.util.Map;\n+\n+\n+/**\n+ * RuntimeConfiguration\n+ *\n+ * @author Jason Carreira\n+ *         Created Feb 25, 2003 10:56:02 PM\n+ */\n+public interface RuntimeConfiguration extends Serializable {\n+\n+    /**\n+     * get the fully expanded ActionConfig for a specified namespace and (action) name\n+     *\n+     * @param namespace the namespace of the Action.  if this is null, then the empty namespace, \"\", will be used\n+     * @param name      the name of the Action.  may not be null.\n+     * @return the requested ActionConfig or null if there was no ActionConfig associated with the specified namespace\n+     *         and name\n+     */\n+    ActionConfig getActionConfig(String namespace, String name);\n+\n+    /**\n+     * returns a Map of all the registered ActionConfigs.  Again, these ActionConfigs are fully expanded so that any\n+     * inherited interceptors, results, etc. will be included\n+     *\n+     * @return a Map of Map keyed by namespace and name respectively such that\n+     *         <pre>\n+     *                 ActionConfig config = (ActionConfig)((Map)getActionConfigs.get(namespace)).get(name);\n+     *                 </pre>\n+     *         should return a valid config for valid namespace/name pairs\n+     */\n+    Map<String, Map<String, ActionConfig>> getActionConfigs();\n+}"
        },
        {
            "sha": "94f0b0ee7e6c43be9b32bee9da70548dc7418576",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/ActionConfig.java",
            "status": "added",
            "additions": 339,
            "deletions": 0,
            "changes": 339,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FActionConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FActionConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FActionConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,339 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+\n+/**\n+ * Contains everything needed to configure and execute an action:\n+ * <ul>\n+ * <li>methodName - the method name to execute on the action. If this is null, the Action will be cast to the Action\n+ * Interface and the execute() method called</li>\n+ * <li>clazz - the class name for the action</li>\n+ * <li>params - the params to be set for this action just before execution</li>\n+ * <li>results - the result map {String -> View class}</li>\n+ * <li>resultParameters - params for results {String -> Map}</li>\n+ * <li>typeConverter - the Ognl TypeConverter to use when getting/setting properties</li>\n+ * </ul>\n+ *\n+ * @author Mike\n+ * @author Rainer Hermanns\n+ * @version $Revision$\n+ */\n+public class ActionConfig extends Located implements Serializable {\n+\n+    public static final String WILDCARD = \"*\";\n+\n+    protected List<InterceptorMapping> interceptors; // a list of interceptorMapping Objects eg. List<InterceptorMapping>\n+    protected Map<String,String> params;\n+    protected Map<String, ResultConfig> results;\n+    protected List<ExceptionMappingConfig> exceptionMappings;\n+    protected String className;\n+    protected String methodName;\n+    protected String packageName;\n+    protected String name;\n+    protected Set<String> allowedMethods;\n+\n+    protected ActionConfig(String packageName, String name, String className) {\n+        this.packageName = packageName;\n+        this.name = name;\n+        this.className = className;\n+        params = new LinkedHashMap<String, String>();\n+        results = new LinkedHashMap<String, ResultConfig>();\n+        interceptors = new ArrayList<InterceptorMapping>();\n+        exceptionMappings = new ArrayList<ExceptionMappingConfig>();\n+        allowedMethods = new HashSet<String>();\n+        allowedMethods.add(WILDCARD);\n+    }\n+\n+    /**\n+     * Clones an ActionConfig, copying data into new maps and lists\n+     * @param orig The ActionConfig to clone\n+     * @Since 2.1\n+     */\n+    protected ActionConfig(ActionConfig orig) {\n+        this.name = orig.name;\n+        this.className = orig.className;\n+        this.methodName = orig.methodName;\n+        this.packageName = orig.packageName;\n+        this.params = new LinkedHashMap<String,String>(orig.params);\n+        this.interceptors = new ArrayList<InterceptorMapping>(orig.interceptors);\n+        this.results = new LinkedHashMap<String,ResultConfig>(orig.results);\n+        this.exceptionMappings = new ArrayList<ExceptionMappingConfig>(orig.exceptionMappings);\n+        this.allowedMethods = new HashSet<String>(orig.allowedMethods);\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getClassName() {\n+        return className;\n+    }\n+\n+    public List<ExceptionMappingConfig> getExceptionMappings() {\n+        return exceptionMappings;\n+    }\n+\n+    public List<InterceptorMapping> getInterceptors() {\n+        return interceptors;\n+    }\n+\n+    public Set<String> getAllowedMethods() {\n+        return allowedMethods;\n+    }\n+\n+    /**\n+     * Returns name of the action method\n+     *\n+     * @return name of the method to execute\n+     */\n+    public String getMethodName() {\n+        return methodName;\n+    }\n+\n+    /**\n+     * @return Returns the packageName.\n+     */\n+    public String getPackageName() {\n+        return packageName;\n+    }\n+\n+    public Map<String, String> getParams() {\n+        return params;\n+    }\n+\n+    public Map<String, ResultConfig> getResults() {\n+        return results;\n+    }\n+\n+    public boolean isAllowedMethod(String method) {\n+        if (allowedMethods.size() == 1 && WILDCARD.equals(allowedMethods.iterator().next())) {\n+            return true;\n+        } else {\n+            return allowedMethods.contains(method);\n+        }\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof ActionConfig)) {\n+            return false;\n+        }\n+\n+        final ActionConfig actionConfig = (ActionConfig) o;\n+\n+        if ((className != null) ? (!className.equals(actionConfig.className)) : (actionConfig.className != null)) {\n+            return false;\n+        }\n+\n+        if ((name != null) ? (!name.equals(actionConfig.name)) : (actionConfig.name != null)) {\n+            return false;\n+        }\n+\n+        if ((interceptors != null) ? (!interceptors.equals(actionConfig.interceptors)) : (actionConfig.interceptors != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((methodName != null) ? (!methodName.equals(actionConfig.methodName)) : (actionConfig.methodName != null)) {\n+            return false;\n+        }\n+\n+        if ((params != null) ? (!params.equals(actionConfig.params)) : (actionConfig.params != null)) {\n+            return false;\n+        }\n+\n+        if ((results != null) ? (!results.equals(actionConfig.results)) : (actionConfig.results != null)) {\n+            return false;\n+        }\n+\n+        if ((allowedMethods != null) ? (!allowedMethods.equals(actionConfig.allowedMethods)) : (actionConfig.allowedMethods != null)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+\n+    @Override public int hashCode() {\n+        int result;\n+        result = (interceptors != null ? interceptors.hashCode() : 0);\n+        result = 31 * result + (params != null ? params.hashCode() : 0);\n+        result = 31 * result + (results != null ? results.hashCode() : 0);\n+        result = 31 * result + (exceptionMappings != null ? exceptionMappings.hashCode() : 0);\n+        result = 31 * result + (className != null ? className.hashCode() : 0);\n+        result = 31 * result + (methodName != null ? methodName.hashCode() : 0);\n+        result = 31 * result + (packageName != null ? packageName.hashCode() : 0);\n+        result = 31 * result + (name != null ? name.hashCode() : 0);\n+        result = 31 * result + (allowedMethods != null ? allowedMethods.hashCode() : 0);\n+        return result;\n+    }\n+\n+    @Override public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"{ActionConfig \");\n+        sb.append(name).append(\" (\");\n+        sb.append(className);\n+        if (methodName != null) {\n+            sb.append(\".\").append(methodName).append(\"()\");\n+        }\n+        sb.append(\")\");\n+        sb.append(\" - \").append(location);\n+        sb.append(\"}\");\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static class Builder implements InterceptorListHolder{\n+\n+        private ActionConfig target;\n+\n+        public Builder(ActionConfig toClone) {\n+            target = new ActionConfig(toClone);\n+        }\n+\n+        public Builder(String packageName, String name, String className) {\n+            target = new ActionConfig(packageName, name, className);\n+        }\n+\n+        public Builder packageName(String name) {\n+            target.packageName = name;\n+            return this;\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder className(String name) {\n+            target.className = name;\n+            return this;\n+        }\n+\n+        public Builder defaultClassName(String name) {\n+        \tif (StringUtils.isEmpty(target.className)) {\n+        \t  \ttarget.className = name;\n+        \t}\n+            return this;\n+        }\n+        \n+        public Builder methodName(String method) {\n+            target.methodName = method;\n+            return this;\n+        }\n+\n+        public Builder addExceptionMapping(ExceptionMappingConfig exceptionMapping) {\n+            target.exceptionMappings.add(exceptionMapping);\n+            return this;\n+        }\n+\n+        public Builder addExceptionMappings(Collection<? extends ExceptionMappingConfig> mappings) {\n+            target.exceptionMappings.addAll(mappings);\n+            return this;\n+        }\n+\n+        public Builder exceptionMappings(Collection<? extends ExceptionMappingConfig> mappings) {\n+            target.exceptionMappings.clear();\n+            target.exceptionMappings.addAll(mappings);\n+            return this;\n+        }\n+\n+        public Builder addInterceptor(InterceptorMapping interceptor) {\n+            target.interceptors.add(interceptor);\n+            return this;\n+        }\n+\n+        public Builder addInterceptors(List<InterceptorMapping> interceptors) {\n+            target.interceptors.addAll(interceptors);\n+            return this;\n+        }\n+\n+        public Builder interceptors(List<InterceptorMapping> interceptors) {\n+            target.interceptors.clear();\n+            target.interceptors.addAll(interceptors);\n+            return this;\n+        }\n+\n+        public Builder addParam(String name, String value) {\n+            target.params.put(name, value);\n+            return this;\n+        }\n+\n+        public Builder addParams(Map<String,String> params) {\n+            target.params.putAll(params);\n+            return this;\n+        }\n+\n+        public Builder addResultConfig(ResultConfig resultConfig) {\n+            target.results.put(resultConfig.getName(), resultConfig);\n+            return this;\n+        }\n+\n+        public Builder addResultConfigs(Collection<ResultConfig> configs) {\n+            for (ResultConfig rc : configs) {\n+                target.results.put(rc.getName(), rc);\n+            }\n+            return this;\n+        }\n+\n+        public Builder addResultConfigs(Map<String,ResultConfig> configs) {\n+            target.results.putAll(configs);\n+            return this;\n+        }\n+\n+        public Builder addAllowedMethod(String methodName) {\n+            target.allowedMethods.add(methodName);\n+            return this;\n+        }\n+\n+        public Builder addAllowedMethod(Collection<String> methods) {\n+            target.allowedMethods.addAll(methods);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public ActionConfig build() {\n+            target.params = Collections.unmodifiableMap(target.params);\n+            target.results = Collections.unmodifiableMap(target.results);\n+            target.interceptors = Collections.unmodifiableList(target.interceptors);\n+            target.exceptionMappings = Collections.unmodifiableList(target.exceptionMappings);\n+            target.allowedMethods = Collections.unmodifiableSet(target.allowedMethods);\n+            ActionConfig result = target;\n+            target = new ActionConfig(target);\n+            return result;\n+        }\n+    }\n+}"
        },
        {
            "sha": "2d09d5ddb7de59ddcc70029682eddd22b57effd8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/ExceptionMappingConfig.java",
            "status": "added",
            "additions": 172,
            "deletions": 0,
            "changes": 172,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FExceptionMappingConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FExceptionMappingConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FExceptionMappingConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,172 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Configuration for exception mapping.\n+ *\n+ * @author Rainer Hermanns\n+ * @author Matthew E. Porter (matthew dot porter at metissian dot com)\n+ */\n+public class ExceptionMappingConfig extends Located implements Serializable {\n+\n+    private String name;\n+    private String exceptionClassName;\n+    private String result;\n+    private Map<String,String> params;\n+\n+\n+    protected ExceptionMappingConfig(String name, String exceptionClassName, String result) {\n+        this.name = name;\n+        this.exceptionClassName = exceptionClassName;\n+        this.result = result;\n+        this.params = new LinkedHashMap<String,String>();\n+    }\n+\n+    protected ExceptionMappingConfig(ExceptionMappingConfig target) {\n+        this.name = target.name;\n+        this.exceptionClassName = target.exceptionClassName;\n+        this.result = target.result;\n+        this.params = new LinkedHashMap<String,String>(target.params);\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getExceptionClassName() {\n+        return exceptionClassName;\n+    }\n+\n+    public String getResult() {\n+        return result;\n+    }\n+\n+    public Map<String,String> getParams() {\n+        return params;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof ExceptionMappingConfig)) {\n+            return false;\n+        }\n+\n+        final ExceptionMappingConfig exceptionMappingConfig = (ExceptionMappingConfig) o;\n+\n+        if ((name != null) ? (!name.equals(exceptionMappingConfig.name)) : (exceptionMappingConfig.name != null)) {\n+            return false;\n+        }\n+\n+        if ((exceptionClassName != null) ? (!exceptionClassName.equals(exceptionMappingConfig.exceptionClassName)) : (exceptionMappingConfig.exceptionClassName != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((result != null) ? (!result.equals(exceptionMappingConfig.result)) : (exceptionMappingConfig.result != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((params != null) ? (!params.equals(exceptionMappingConfig.params)) : (exceptionMappingConfig.params != null))\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int hashCode;\n+        hashCode = ((name != null) ? name.hashCode() : 0);\n+        hashCode = (29 * hashCode) + ((exceptionClassName != null) ? exceptionClassName.hashCode() : 0);\n+        hashCode = (29 * hashCode) + ((result != null) ? result.hashCode() : 0);\n+        hashCode = (29 * hashCode) + ((params != null) ? params.hashCode() : 0);\n+\n+        return hashCode;\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static class Builder{\n+\n+        private ExceptionMappingConfig target;\n+\n+        public Builder(ExceptionMappingConfig toClone) {\n+            target = new ExceptionMappingConfig(toClone);\n+        }\n+\n+        public Builder(String name, String exceptionClassName, String result) {\n+            target = new ExceptionMappingConfig(name, exceptionClassName, result);\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder exceptionClassName(String name) {\n+            target.exceptionClassName = name;\n+            return this;\n+        }\n+\n+        public Builder result(String result) {\n+            target.result = result;\n+            return this;\n+        }\n+\n+        public Builder addParam(String name, String value) {\n+            target.params.put(name, value);\n+            return this;\n+        }\n+\n+        public Builder addParams(Map<String,String> params) {\n+            target.params.putAll(params);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public ExceptionMappingConfig build() {\n+            target.params = Collections.unmodifiableMap(target.params);\n+            ExceptionMappingConfig result = target;\n+            target = new ExceptionMappingConfig(target);\n+            return result;\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "2b951c01b743108bfbf748f18d66f4312c3e13f3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/InterceptorConfig.java",
            "status": "added",
            "additions": 151,
            "deletions": 0,
            "changes": 151,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+/**\n+ * Configuration for Interceptors.\n+ * <p/>\n+ * In the xml configuration file this is defined as the <code>interceptors</code> tag.\n+ *\n+ * @author Mike\n+ */\n+public class InterceptorConfig extends Located implements Serializable {\n+\n+    Map<String,String> params;\n+    String className;\n+    String name;\n+\n+\n+    protected InterceptorConfig(String name, String className) {\n+        this.params = new LinkedHashMap<String,String>();\n+        this.name = name;\n+        this.className = className;\n+    }\n+\n+    protected InterceptorConfig(InterceptorConfig orig) {\n+        this.name = orig.name;\n+        this.className = orig.className;\n+        this.params = new LinkedHashMap<String,String>(orig.params);\n+    }\n+\n+\n+    public String getClassName() {\n+        return className;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String,String> getParams() {\n+        return params;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof InterceptorConfig)) {\n+            return false;\n+        }\n+\n+        final InterceptorConfig interceptorConfig = (InterceptorConfig) o;\n+\n+        if ((className != null) ? (!className.equals(interceptorConfig.className)) : (interceptorConfig.className != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((name != null) ? (!name.equals(interceptorConfig.name)) : (interceptorConfig.name != null)) {\n+            return false;\n+        }\n+\n+        if ((params != null) ? (!params.equals(interceptorConfig.params)) : (interceptorConfig.params != null)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = ((name != null) ? name.hashCode() : 0);\n+        result = (29 * result) + ((className != null) ? className.hashCode() : 0);\n+        result = (29 * result) + ((params != null) ? params.hashCode() : 0);\n+\n+        return result;\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static final class Builder {\n+        private InterceptorConfig target;\n+\n+        public Builder(String name, String className) {\n+            target = new InterceptorConfig(name, className);\n+        }\n+\n+        public Builder(InterceptorConfig orig) {\n+            target = new InterceptorConfig(orig);\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder className(String name) {\n+            target.className = name;\n+            return this;\n+        }\n+\n+        public Builder addParam(String name, String value) {\n+            target.params.put(name, value);\n+            return this;\n+        }\n+\n+        public Builder addParams(Map<String,String> params) {\n+            target.params.putAll(params);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public InterceptorConfig build() {\n+            target.params = Collections.unmodifiableMap(target.params);\n+            InterceptorConfig result = target;\n+            target = new InterceptorConfig(target);\n+            return result;\n+        }\n+    }\n+}"
        },
        {
            "sha": "432311626f7989ec492252f56ddbd1c94c8f694a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/InterceptorListHolder.java",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorListHolder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorListHolder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorListHolder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,31 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import java.util.List;\n+\n+/**\n+ * InterceptorListHolder\n+ *\n+ * @author Jason Carreira\n+ *         Created Jun 1, 2003 1:02:48 AM\n+ */\n+public interface InterceptorListHolder {\n+\n+    InterceptorListHolder addInterceptor(InterceptorMapping interceptor);\n+\n+    InterceptorListHolder addInterceptors(List<InterceptorMapping> interceptors);\n+}"
        },
        {
            "sha": "aa7496095380fdf3236e4fe7a9c960acd1b53b6c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/InterceptorLocator.java",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorLocator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorLocator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorLocator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,14 @@\n+package com.opensymphony.xwork2.config.entities;\n+\n+/**\n+ * Defines an object that can be used to retrieve interceptor configuration\n+ */\n+public interface InterceptorLocator {\n+\n+    /**\n+     * Gets an interceptor configuration object.\n+     * @param name The interceptor or interceptor stack name\n+     * @return Either an {@link InterceptorConfig} or {@link InterceptorStackConfig} object\n+     */\n+    Object getInterceptorConfig(String name);\n+}"
        },
        {
            "sha": "2871e8c6ab71cd91efb422064bcffc498eb48e99",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/InterceptorMapping.java",
            "status": "added",
            "additions": 65,
            "deletions": 0,
            "changes": 65,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorMapping.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorMapping.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorMapping.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,65 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.interceptor.Interceptor;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * <code>InterceptorMapping</code>\n+ *\n+ * @author <a href=\"mailto:hermanns@aixcept.de\">Rainer Hermanns</a>\n+ * @version $Id$\n+ */\n+public class InterceptorMapping implements Serializable {\n+\n+    private String name;\n+    private Interceptor interceptor;\n+\n+    public InterceptorMapping(String name, Interceptor interceptor) {\n+        this.name = name;\n+        this.interceptor = interceptor;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Interceptor getInterceptor() {\n+        return interceptor;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        final InterceptorMapping that = (InterceptorMapping) o;\n+\n+        if (name != null ? !name.equals(that.name) : that.name != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = (name != null ? name.hashCode() : 0);\n+        return result;\n+    }\n+}"
        },
        {
            "sha": "bb833720a5835f42e09aeb69cf74131e05db7149",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/InterceptorStackConfig.java",
            "status": "added",
            "additions": 173,
            "deletions": 0,
            "changes": 173,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorStackConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorStackConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FInterceptorStackConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,173 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n+\n+\n+/**\n+ * Configuration for InterceptorStack.\n+ * <p/>\n+ * In the xml configuration file this is defined as the <code>interceptor-stack</code> tag.\n+ *\n+ * @author Mike\n+ * @author Rainer Hermanns\n+ */\n+public class InterceptorStackConfig extends Located implements Serializable {\n+\n+    private static final long serialVersionUID = 2897260918170270343L;\n+\n+    /**\n+     * A list of InterceptorMapping object\n+     */\n+    private List<InterceptorMapping> interceptors;\n+    private String name;\n+\n+\n+    /**\n+     * Creates an InterceptorStackConfig object.\n+     */\n+    protected InterceptorStackConfig() {\n+        this.interceptors = new ArrayList<InterceptorMapping>();\n+    }\n+\n+    /**\n+     * Creates an InterceptorStackConfig object with a particular <code>name</code>.\n+     *\n+     * @param name\n+     */\n+    protected InterceptorStackConfig(InterceptorStackConfig orig) {\n+        this.name = orig.name;\n+        this.interceptors = new ArrayList<InterceptorMapping>(orig.interceptors);\n+    }\n+\n+\n+    /**\n+     * Returns a <code>Collection</code> of InterceptorMapping objects.\n+     *\n+     * @return\n+     */\n+    public Collection<InterceptorMapping> getInterceptors() {\n+        return interceptors;\n+    }\n+\n+    /**\n+     * Get the name of this interceptor stack configuration.\n+     *\n+     * @return String\n+     */\n+    public String getName() {\n+        return name;\n+    }\n+\n+    /**\n+     * An InterceptorStackConfig object is equals with <code>o</code> only if\n+     * <ul>\n+     * <li>o is an InterceptorStackConfig object</li>\n+     * <li>both names are equals</li>\n+     * <li>all of their <code>InterceptorMapping</code>s are equals</li>\n+     * </ul>\n+     */\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof InterceptorStackConfig)) {\n+            return false;\n+        }\n+\n+        final InterceptorStackConfig interceptorStackConfig = (InterceptorStackConfig) o;\n+\n+        if ((interceptors != null) ? (!interceptors.equals(interceptorStackConfig.interceptors)) : (interceptorStackConfig.interceptors != null)) {\n+            return false;\n+        }\n+\n+        if ((name != null) ? (!name.equals(interceptorStackConfig.name)) : (interceptorStackConfig.name != null)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Generate hashcode based on <code>InterceptorStackConfig</code>'s name and its\n+     * <code>InterceptorMapping</code>s.\n+     */\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = ((name != null) ? name.hashCode() : 0);\n+        result = (29 * result) + ((interceptors != null) ? interceptors.hashCode() : 0);\n+\n+        return result;\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static class Builder implements InterceptorListHolder {\n+        private InterceptorStackConfig target;\n+\n+        public Builder(String name) {\n+            target = new InterceptorStackConfig();\n+            target.name = name;\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        /**\n+         * Add an <code>InterceptorMapping</code> object.\n+         */\n+        public Builder addInterceptor(InterceptorMapping interceptor) {\n+            target.interceptors.add(interceptor);\n+            return this;\n+        }\n+\n+        /**\n+         * Add a List of <code>InterceptorMapping</code> objects.\n+         */\n+        public Builder addInterceptors(List<InterceptorMapping> interceptors) {\n+            target.interceptors.addAll(interceptors);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public InterceptorStackConfig build() {\n+            target.interceptors = Collections.unmodifiableList(target.interceptors);\n+            InterceptorStackConfig result = target;\n+            target = new InterceptorStackConfig(target);\n+            return result;\n+        }\n+    }\n+}"
        },
        {
            "sha": "6ca513525b9a10f81a5ce085a6cb66f7709d5764",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/PackageConfig.java",
            "status": "added",
            "additions": 616,
            "deletions": 0,
            "changes": 616,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FPackageConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FPackageConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FPackageConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,616 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+\n+/**\n+ * Configuration for Package.\n+ * <p/>\n+ * In the xml configuration file this is defined as the <code>package</code> tag.\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Revision$\n+ */\n+public class PackageConfig extends Located implements Comparable, Serializable, InterceptorLocator {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(PackageConfig.class);\n+\n+    private Map<String, ActionConfig> actionConfigs;\n+    private Map<String, ResultConfig> globalResultConfigs;\n+    private Map<String, Object> interceptorConfigs;\n+    private Map<String, ResultTypeConfig> resultTypeConfigs;\n+    private List<ExceptionMappingConfig> globalExceptionMappingConfigs;\n+    private List<PackageConfig> parents;\n+    private String defaultInterceptorRef;\n+    private String defaultActionRef;\n+    private String defaultResultType;\n+    private String defaultClassRef;\n+    private String name;\n+    private String namespace = \"\";\n+    private boolean isAbstract = false;\n+    private boolean needsRefresh;\n+\n+\n+    protected PackageConfig(String name) {\n+        this.name = name;\n+        actionConfigs = new LinkedHashMap<String, ActionConfig>();\n+        globalResultConfigs = new LinkedHashMap<String, ResultConfig>();\n+        interceptorConfigs = new LinkedHashMap<String, Object>();\n+        resultTypeConfigs = new LinkedHashMap<String, ResultTypeConfig>();\n+        globalExceptionMappingConfigs = new ArrayList<ExceptionMappingConfig>();\n+        parents = new ArrayList<PackageConfig>();\n+    }\n+\n+\n+    protected PackageConfig(PackageConfig orig) {\n+        this.defaultInterceptorRef = orig.defaultInterceptorRef;\n+        this.defaultActionRef = orig.defaultActionRef;\n+        this.defaultResultType = orig.defaultResultType;\n+        this.defaultClassRef = orig.defaultClassRef;\n+        this.name = orig.name;\n+        this.namespace = orig.namespace;\n+        this.isAbstract = orig.isAbstract;\n+        this.needsRefresh = orig.needsRefresh;\n+        this.actionConfigs = new LinkedHashMap<String, ActionConfig>(orig.actionConfigs);\n+        this.globalResultConfigs = new LinkedHashMap<String, ResultConfig>(orig.globalResultConfigs);\n+        this.interceptorConfigs = new LinkedHashMap<String, Object>(orig.interceptorConfigs);\n+        this.resultTypeConfigs = new LinkedHashMap<String, ResultTypeConfig>(orig.resultTypeConfigs);\n+        this.globalExceptionMappingConfigs = new ArrayList<ExceptionMappingConfig>(orig.globalExceptionMappingConfigs);\n+        this.parents = new ArrayList<PackageConfig>(orig.parents);\n+    }\n+\n+    public boolean isAbstract() {\n+        return isAbstract;\n+    }\n+\n+    public Map<String, ActionConfig> getActionConfigs() {\n+        return actionConfigs;\n+    }\n+\n+    /**\n+     * returns the Map of all the ActionConfigs available in the current package.\n+     * ActionConfigs defined in ancestor packages will be included in this Map.\n+     *\n+     * @return a Map of ActionConfig Objects with the action name as the key\n+     * @see ActionConfig\n+     */\n+    public Map<String, ActionConfig> getAllActionConfigs() {\n+        Map<String, ActionConfig> retMap = new LinkedHashMap<String, ActionConfig>();\n+\n+        if (!parents.isEmpty()) {\n+            for (PackageConfig parent : parents) {\n+                retMap.putAll(parent.getAllActionConfigs());\n+            }\n+        }\n+\n+        retMap.putAll(getActionConfigs());\n+\n+        return retMap;\n+    }\n+\n+    /**\n+     * returns the Map of all the global ResultConfigs available in the current package.\n+     * Global ResultConfigs defined in ancestor packages will be included in this Map.\n+     *\n+     * @return a Map of Result Objects with the result name as the key\n+     * @see ResultConfig\n+     */\n+    public Map<String, ResultConfig> getAllGlobalResults() {\n+        Map<String, ResultConfig> retMap = new LinkedHashMap<String, ResultConfig>();\n+\n+        if (!parents.isEmpty()) {\n+            for (PackageConfig parentConfig : parents) {\n+                retMap.putAll(parentConfig.getAllGlobalResults());\n+            }\n+        }\n+\n+        retMap.putAll(getGlobalResultConfigs());\n+\n+        return retMap;\n+    }\n+\n+    /**\n+     * returns the Map of all InterceptorConfigs and InterceptorStackConfigs available in the current package.\n+     * InterceptorConfigs defined in ancestor packages will be included in this Map.\n+     *\n+     * @return a Map of InterceptorConfig and InterceptorStackConfig Objects with the ref-name as the key\n+     * @see InterceptorConfig\n+     * @see InterceptorStackConfig\n+     */\n+    public Map<String, Object> getAllInterceptorConfigs() {\n+        Map<String, Object> retMap = new LinkedHashMap<String, Object>();\n+\n+        if (!parents.isEmpty()) {\n+            for (PackageConfig parentContext : parents) {\n+                retMap.putAll(parentContext.getAllInterceptorConfigs());\n+            }\n+        }\n+\n+        retMap.putAll(getInterceptorConfigs());\n+\n+        return retMap;\n+    }\n+\n+    /**\n+     * returns the Map of all the ResultTypeConfigs available in the current package.\n+     * ResultTypeConfigs defined in ancestor packages will be included in this Map.\n+     *\n+     * @return a Map of ResultTypeConfig Objects with the result type name as the key\n+     * @see ResultTypeConfig\n+     */\n+    public Map<String, ResultTypeConfig> getAllResultTypeConfigs() {\n+        Map<String, ResultTypeConfig> retMap = new LinkedHashMap<String, ResultTypeConfig>();\n+\n+        if (!parents.isEmpty()) {\n+            for (PackageConfig parentContext : parents) {\n+                retMap.putAll(parentContext.getAllResultTypeConfigs());\n+            }\n+        }\n+\n+        retMap.putAll(getResultTypeConfigs());\n+\n+        return retMap;\n+    }\n+\n+    /**\n+     * returns the List of all the ExceptionMappingConfigs available in the current package.\n+     * ExceptionMappingConfigs defined in ancestor packages will be included in this list.\n+     *\n+     * @return a List of ExceptionMappingConfigs Objects with the result type name as the key\n+     * @see ExceptionMappingConfig\n+     */\n+    public List<ExceptionMappingConfig> getAllExceptionMappingConfigs() {\n+        List<ExceptionMappingConfig> allExceptionMappings = new ArrayList<ExceptionMappingConfig>();\n+\n+        if (!parents.isEmpty()) {\n+            for (PackageConfig parentContext : parents) {\n+                allExceptionMappings.addAll(parentContext.getAllExceptionMappingConfigs());\n+            }\n+        }\n+\n+        allExceptionMappings.addAll(getGlobalExceptionMappingConfigs());\n+\n+        return allExceptionMappings;\n+    }\n+\n+\n+    public String getDefaultInterceptorRef() {\n+        return defaultInterceptorRef;\n+    }\n+\n+    public String getDefaultActionRef() {\n+        return defaultActionRef;\n+    }\n+\n+    public String getDefaultClassRef() {\n+    \tif((defaultClassRef == null) && !parents.isEmpty()) {\n+            for (PackageConfig parent : parents) {\n+                String parentDefault = parent.getDefaultClassRef();\n+                if (parentDefault != null) {\n+                    return parentDefault;\n+                }\n+            }\n+    \t}\n+    \treturn defaultClassRef;\n+    }\n+    \n+    /**\n+     * Returns the default result type for this package.\n+     */\n+    public String getDefaultResultType() {\n+        return defaultResultType;\n+    }\n+\n+    /**\n+     * gets the default interceptor-ref name. If this is not set on this PackageConfig, it searches the parent\n+     * PackageConfigs in order until it finds one.\n+     */\n+    public String getFullDefaultInterceptorRef() {\n+        if ((defaultInterceptorRef == null) && !parents.isEmpty()) {\n+            for (PackageConfig parent : parents) {\n+                String parentDefault = parent.getFullDefaultInterceptorRef();\n+\n+                if (parentDefault != null) {\n+                    return parentDefault;\n+                }\n+            }\n+        }\n+\n+        return defaultInterceptorRef;\n+    }\n+\n+    /**\n+     * gets the default action-ref name. If this is not set on this PackageConfig, it searches the parent\n+     * PackageConfigs in order until it finds one.\n+     */\n+    public String getFullDefaultActionRef() {\n+        if ((defaultActionRef == null) && !parents.isEmpty()) {\n+            for (PackageConfig parent : parents) {\n+                String parentDefault = parent.getFullDefaultActionRef();\n+\n+                if (parentDefault != null) {\n+                    return parentDefault;\n+                }\n+            }\n+        }\n+        return defaultActionRef;\n+    }\n+\n+    /**\n+     * Returns the default result type for this package.\n+     * <p/>\n+     * If there is no default result type, but this package has parents - we will try to\n+     * look up the default result type of a parent.\n+     */\n+    public String getFullDefaultResultType() {\n+        if ((defaultResultType == null) && !parents.isEmpty()) {\n+            for (PackageConfig parent : parents) {\n+                String parentDefault = parent.getFullDefaultResultType();\n+\n+                if (parentDefault != null) {\n+                    return parentDefault;\n+                }\n+            }\n+        }\n+\n+        return defaultResultType;\n+    }\n+\n+    /**\n+     * gets the global ResultConfigs local to this package\n+     *\n+     * @return a Map of ResultConfig objects keyed by result name\n+     * @see ResultConfig\n+     */\n+    public Map<String, ResultConfig> getGlobalResultConfigs() {\n+        return globalResultConfigs;\n+    }\n+\n+    /**\n+     * gets the InterceptorConfigs and InterceptorStackConfigs local to this package\n+     *\n+     * @return a Map of InterceptorConfig and InterceptorStackConfig objects keyed by ref-name\n+     * @see InterceptorConfig\n+     * @see InterceptorStackConfig\n+     */\n+    public Map<String, Object> getInterceptorConfigs() {\n+        return interceptorConfigs;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public String getNamespace() {\n+        return namespace;\n+    }\n+\n+    public List<PackageConfig> getParents() {\n+        return new ArrayList<PackageConfig>(parents);\n+    }\n+\n+    /**\n+     * gets the ResultTypeConfigs local to this package\n+     *\n+     * @return a Map of ResultTypeConfig objects keyed by result name\n+     * @see ResultTypeConfig\n+     */\n+    public Map<String, ResultTypeConfig> getResultTypeConfigs() {\n+        return resultTypeConfigs;\n+    }\n+\n+\n+    public boolean isNeedsRefresh() {\n+        return needsRefresh;\n+    }\n+\n+    /**\n+     * gets the ExceptionMappingConfigs local to this package\n+     *\n+     * @return a Map of ExceptionMappingConfig objects keyed by result name\n+     * @see ExceptionMappingConfig\n+     */\n+    public List<ExceptionMappingConfig> getGlobalExceptionMappingConfigs() {\n+        return globalExceptionMappingConfigs;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof PackageConfig)) {\n+            return false;\n+        }\n+\n+        final PackageConfig packageConfig = (PackageConfig) o;\n+\n+        if (isAbstract != packageConfig.isAbstract) {\n+            return false;\n+        }\n+\n+        if ((actionConfigs != null) ? (!actionConfigs.equals(packageConfig.actionConfigs)) : (packageConfig.actionConfigs != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((defaultResultType != null) ? (!defaultResultType.equals(packageConfig.defaultResultType)) : (packageConfig.defaultResultType != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((defaultClassRef != null) ? (!defaultClassRef.equals(packageConfig.defaultClassRef)) : (packageConfig.defaultClassRef != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((globalResultConfigs != null) ? (!globalResultConfigs.equals(packageConfig.globalResultConfigs)) : (packageConfig.globalResultConfigs != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((interceptorConfigs != null) ? (!interceptorConfigs.equals(packageConfig.interceptorConfigs)) : (packageConfig.interceptorConfigs != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((name != null) ? (!name.equals(packageConfig.name)) : (packageConfig.name != null)) {\n+            return false;\n+        }\n+\n+        if ((namespace != null) ? (!namespace.equals(packageConfig.namespace)) : (packageConfig.namespace != null)) {\n+            return false;\n+        }\n+\n+        if ((parents != null) ? (!parents.equals(packageConfig.parents)) : (packageConfig.parents != null)) {\n+            return false;\n+        }\n+\n+        if ((resultTypeConfigs != null) ? (!resultTypeConfigs.equals(packageConfig.resultTypeConfigs)) : (packageConfig.resultTypeConfigs != null))\n+        {\n+            return false;\n+        }\n+\n+        if ((globalExceptionMappingConfigs != null) ? (!globalExceptionMappingConfigs.equals(packageConfig.globalExceptionMappingConfigs)) : (packageConfig.globalExceptionMappingConfigs != null))\n+        {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = ((name != null) ? name.hashCode() : 0);\n+        result = (29 * result) + ((parents != null) ? parents.hashCode() : 0);\n+        result = (29 * result) + ((actionConfigs != null) ? actionConfigs.hashCode() : 0);\n+        result = (29 * result) + ((globalResultConfigs != null) ? globalResultConfigs.hashCode() : 0);\n+        result = (29 * result) + ((interceptorConfigs != null) ? interceptorConfigs.hashCode() : 0);\n+        result = (29 * result) + ((resultTypeConfigs != null) ? resultTypeConfigs.hashCode() : 0);\n+        result = (29 * result) + ((globalExceptionMappingConfigs != null) ? globalExceptionMappingConfigs.hashCode() : 0);\n+        result = (29 * result) + ((defaultResultType != null) ? defaultResultType.hashCode() : 0);\n+        result = (29 * result) + ((defaultClassRef != null) ? defaultClassRef.hashCode() : 0);\n+        result = (29 * result) + ((namespace != null) ? namespace.hashCode() : 0);\n+        result = (29 * result) + (isAbstract ? 1 : 0);\n+\n+        return result;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        return \"{PackageConfig Name:\" + name + \" namespace:\" + namespace + \" parents:\" + parents + \"}\";\n+    }\n+\n+    public int compareTo(Object o) {\n+        PackageConfig other = (PackageConfig) o;\n+        String full = namespace + \"!\" + name;\n+        String otherFull = other.namespace + \"!\" + other.name;\n+\n+        // note, this isn't perfect (could come from different parents), but it is \"good enough\"\n+        return full.compareTo(otherFull);\n+    }\n+\n+    public Object getInterceptorConfig(String name) {\n+        return getAllInterceptorConfigs().get(name);\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static class Builder implements InterceptorLocator {\n+\n+        private PackageConfig target;\n+\n+        public Builder(String name) {\n+            target = new PackageConfig(name);\n+        }\n+\n+        public Builder(PackageConfig config) {\n+            target = new PackageConfig(config);\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder isAbstract(boolean isAbstract) {\n+            target.isAbstract = isAbstract;\n+            return this;\n+        }\n+\n+        public Builder defaultInterceptorRef(String name) {\n+            target.defaultInterceptorRef = name;\n+            return this;\n+        }\n+\n+        public Builder defaultActionRef(String name) {\n+            target.defaultActionRef = name;\n+            return this;\n+        }\n+\n+        public Builder defaultClassRef( String defaultClassRef ) {\n+            target.defaultClassRef = defaultClassRef;\n+            return this;\n+        }\n+\n+        /**\n+         * sets the default Result type for this package\n+         *\n+         * @param defaultResultType\n+         */\n+        public Builder defaultResultType(String defaultResultType) {\n+            target.defaultResultType = defaultResultType;\n+            return this;\n+        }\n+\n+        public Builder namespace(String namespace) {\n+            if (namespace == null) {\n+                target.namespace = \"\";\n+            } else {\n+                target.namespace = namespace;\n+            }\n+            return this;\n+        }\n+\n+        public Builder needsRefresh(boolean needsRefresh) {\n+            target.needsRefresh = needsRefresh;\n+            return this;\n+        }\n+\n+        public Builder addActionConfig(String name, ActionConfig action) {\n+            target.actionConfigs.put(name, action);\n+            return this;\n+        }\n+\n+        public Builder addParents(List<PackageConfig> parents) {\n+            for (PackageConfig config : parents) {\n+                addParent(config);\n+            }\n+            return this;\n+        }\n+\n+        public Builder addGlobalResultConfig(ResultConfig resultConfig) {\n+            target.globalResultConfigs.put(resultConfig.getName(), resultConfig);\n+            return this;\n+        }\n+\n+        public Builder addGlobalResultConfigs(Map<String, ResultConfig> resultConfigs) {\n+            target.globalResultConfigs.putAll(resultConfigs);\n+            return this;\n+        }\n+\n+        public Builder addExceptionMappingConfig(ExceptionMappingConfig exceptionMappingConfig) {\n+            target.globalExceptionMappingConfigs.add(exceptionMappingConfig);\n+            return this;\n+        }\n+\n+        public Builder addGlobalExceptionMappingConfigs(List<ExceptionMappingConfig> exceptionMappingConfigs) {\n+            target.globalExceptionMappingConfigs.addAll(exceptionMappingConfigs);\n+            return this;\n+        }\n+\n+        public Builder addInterceptorConfig(InterceptorConfig config) {\n+            target.interceptorConfigs.put(config.getName(), config);\n+            return this;\n+        }\n+\n+        public Builder addInterceptorStackConfig(InterceptorStackConfig config) {\n+            target.interceptorConfigs.put(config.getName(), config);\n+            return this;\n+        }\n+\n+        public Builder addParent(PackageConfig parent) {\n+            if (this.equals(parent)) {\n+                LOG.error(\"A package cannot extend itself: \" + target.name);\n+            }\n+\n+            target.parents.add(0, parent);\n+            return this;\n+        }\n+\n+        public Builder addResultTypeConfig(ResultTypeConfig config) {\n+            target.resultTypeConfigs.put(config.getName(), config);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public boolean isNeedsRefresh() {\n+            return target.needsRefresh;\n+        }\n+\n+        public String getDefaultClassRef() {\n+            return target.defaultClassRef;\n+        }\n+\n+        public String getName() {\n+            return target.name;\n+        }\n+\n+        public String getNamespace() {\n+            return target.namespace;\n+        }\n+\n+        public String getFullDefaultResultType() {\n+            return target.getFullDefaultResultType();\n+        }\n+\n+        public ResultTypeConfig getResultType(String type) {\n+            return target.getAllResultTypeConfigs().get(type);\n+        }\n+\n+\n+\n+        public Object getInterceptorConfig(String name) {\n+            return target.getAllInterceptorConfigs().get(name);\n+        }\n+\n+        public PackageConfig build() {\n+            target.actionConfigs = Collections.unmodifiableMap(target.actionConfigs);\n+            target.globalResultConfigs = Collections.unmodifiableMap(target.globalResultConfigs);\n+            target.interceptorConfigs = Collections.unmodifiableMap(target.interceptorConfigs);\n+            target.resultTypeConfigs = Collections.unmodifiableMap(target.resultTypeConfigs);\n+            target.globalExceptionMappingConfigs = Collections.unmodifiableList(target.globalExceptionMappingConfigs);\n+            target.parents = Collections.unmodifiableList(target.parents);\n+\n+            PackageConfig result = target;\n+            target = new PackageConfig(result);\n+            return result;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            return \"[BUILDER] \"+target.toString();\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "42b6cb3f6d2c5069796aaa50b70ac5781bab1546",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/Parameterizable.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FParameterizable.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FParameterizable.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FParameterizable.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import java.util.Map;\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ * <p/>\n+ * Actions implementing Parameterizable will receive a map of the static parameters defined in the action\n+ * configuration.\n+ * <p/>\n+ * <p/> The {@link com.opensymphony.xwork2.interceptor.StaticParametersInterceptor} must be in the action's interceptor\n+ * queue for this to work.\n+ * <p/>\n+ * <!-- END SNIPPET: javadoc -->\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface Parameterizable {\n+\n+    public void addParam(String name, String value);\n+\n+    void setParams(Map<String, String> params);\n+\n+    Map<String, String> getParams();\n+}"
        },
        {
            "sha": "70c91dbfd7559fb85b7feb38237b6af3936f820b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/ResultConfig.java",
            "status": "added",
            "additions": 151,
            "deletions": 0,
            "changes": 151,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,151 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * Configuration for Result.\n+ * <p/>\n+ * In the xml configuration file this is defined as the <code>result</code> tag.\n+ *\n+ * @author Mike\n+ */\n+public class ResultConfig extends Located implements Serializable {\n+\n+    private Map<String,String> params;\n+    private String className;\n+    private String name;\n+\n+\n+    protected ResultConfig(String name, String className) {\n+        this.name = name;\n+        this.className = className;\n+        params = new LinkedHashMap<String, String>();\n+    }\n+\n+    protected ResultConfig(ResultConfig orig) {\n+        this.params = orig.params;\n+        this.name = orig.name;\n+        this.className = orig.className;\n+    }\n+\n+    public String getClassName() {\n+        return className;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String,String> getParams() {\n+        return params;\n+    }\n+\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof ResultConfig)) {\n+            return false;\n+        }\n+\n+        final ResultConfig resultConfig = (ResultConfig) o;\n+\n+        if ((className != null) ? (!className.equals(resultConfig.className)) : (resultConfig.className != null)) {\n+            return false;\n+        }\n+\n+        if ((name != null) ? (!name.equals(resultConfig.name)) : (resultConfig.name != null)) {\n+            return false;\n+        }\n+\n+        if ((params != null) ? (!params.equals(resultConfig.params)) : (resultConfig.params != null)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = ((name != null) ? name.hashCode() : 0);\n+        result = (29 * result) + ((className != null) ? className.hashCode() : 0);\n+        result = (29 * result) + ((params != null) ? params.hashCode() : 0);\n+\n+        return result;\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static final class Builder {\n+        private ResultConfig target;\n+\n+        public Builder(String name, String className) {\n+            target = new ResultConfig(name, className);\n+        }\n+\n+        public Builder(ResultConfig orig) {\n+            target = new ResultConfig(orig);\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder className(String name) {\n+            target.className = name;\n+            return this;\n+        }\n+\n+         public Builder addParam(String name, String value) {\n+            target.params.put(name, value);\n+            return this;\n+        }\n+\n+        public Builder addParams(Map<String,String> params) {\n+            target.params.putAll(params);\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public ResultConfig build() {\n+            target.params = Collections.unmodifiableMap(target.params);\n+            ResultConfig result = target;\n+            target = new ResultConfig(target);\n+            return result;\n+        }\n+    }\n+}"
        },
        {
            "sha": "a5c25dc899e4a3cc389eace52621b5b2bc018002",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/ResultTypeConfig.java",
            "status": "added",
            "additions": 161,
            "deletions": 0,
            "changes": 161,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultTypeConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultTypeConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FResultTypeConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.Location;\n+\n+import java.io.Serializable;\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * Configuration class for result types.\n+ * <p/>\n+ * In the xml configuration file this is defined as the <code>result-type</code> tag.\n+ *\n+ * @author Mike\n+ * @author Rainer Hermanns\n+ * @author Neo\n+ */\n+public class ResultTypeConfig extends Located implements Serializable {\n+\n+    private String className;\n+    private String name;\n+    private String defaultResultParam;\n+\n+    private Map<String,String> params;\n+\n+    protected ResultTypeConfig(String name, String className) {\n+        this.name = name;\n+        this.className = className;\n+        params = new LinkedHashMap<String,String>();\n+    }\n+\n+    protected ResultTypeConfig(ResultTypeConfig orig) {\n+        this.name = orig.name;\n+        this.className = orig.className;\n+        this.defaultResultParam = orig.defaultResultParam;\n+        this.params = orig.params;\n+    }\n+\n+\n+    public void setDefaultResultParam(String defaultResultParam) {\n+    \tthis.defaultResultParam = defaultResultParam;\n+    }\n+    \n+    public String getDefaultResultParam() {\n+    \treturn this.defaultResultParam;\n+    }\n+\n+    /**\n+     * @deprecated Since 2.1, use {@link #getClassName()} instead\n+     */\n+    @Deprecated public String getClazz() {\n+        return className;\n+    }\n+\n+    public String getClassName() {\n+        return className;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public Map<String,String> getParams() {\n+        return this.params;\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) return true;\n+        if (o == null || getClass() != o.getClass()) return false;\n+\n+        final ResultTypeConfig that = (ResultTypeConfig) o;\n+\n+        if (className != null ? !className.equals(that.className) : that.className != null) return false;\n+        if (name != null ? !name.equals(that.name) : that.name != null) return false;\n+        if (params != null ? !params.equals(that.params) : that.params != null) return false;\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        int result;\n+        result = (className != null ? className.hashCode() : 0);\n+        result = 29 * result + (name != null ? name.hashCode() : 0);\n+        result = 29 * result + (params != null ? params.hashCode() : 0);\n+        return result;\n+    }\n+\n+    /**\n+     * The builder for this object.  An instance of this object is the only way to construct a new instance.  The\n+     * purpose is to enforce the immutability of the object.  The methods are structured in a way to support chaining.\n+     * After setting any values you need, call the {@link #build()} method to create the object.\n+     */\n+    public static final class Builder {\n+        private ResultTypeConfig target;\n+\n+        public Builder(String name, String className) {\n+            target = new ResultTypeConfig(name, className);\n+        }\n+\n+        public Builder(ResultTypeConfig orig) {\n+            target = new ResultTypeConfig(orig);\n+        }\n+\n+        public Builder name(String name) {\n+            target.name = name;\n+            return this;\n+        }\n+\n+        public Builder className(String name) {\n+            target.className = name;\n+            return this;\n+        }\n+\n+         public Builder addParam(String name, String value) {\n+            target.params.put(name, value);\n+            return this;\n+        }\n+\n+        public Builder addParams(Map<String,String> params) {\n+            target.params.putAll(params);\n+            return this;\n+        }\n+\n+        public Builder defaultResultParam(String defaultResultParam) {\n+            target.defaultResultParam = defaultResultParam;\n+            return this;\n+        }\n+\n+        public Builder location(Location loc) {\n+            target.location = loc;\n+            return this;\n+        }\n+\n+        public ResultTypeConfig build() {\n+            target.params = Collections.unmodifiableMap(target.params);\n+            ResultTypeConfig result = target;\n+            target = new ResultTypeConfig(target);\n+            return result;\n+        }\n+    }\n+}"
        },
        {
            "sha": "8ab1843f1a26da311ce76c18416575f28a5f8ea6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/UnknownHandlerConfig.java",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FUnknownHandlerConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FUnknownHandlerConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2FUnknownHandlerConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.entities;\n+\n+public class UnknownHandlerConfig {\n+    private String name;\n+\n+    public UnknownHandlerConfig(String name) {\n+        this.name = name;\n+    }\n+\n+    public String getName() {\n+        return name;\n+    }\n+\n+    public void setName(String name) {\n+        this.name = name;\n+    }\n+}"
        },
        {
            "sha": "d05a357625f319973134b386398648fb90ed0605",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/entities/package.html",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fentities%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,18 @@\n+<body>\n+\n+<p>\n+Configuration entity classes.  All objects ending in \"Config\" are immutable and must be constructed using\n+their inner \"Builder\" class.  For example, a PackageConfig object can be created via:\n+</p>\n+<pre>\n+    PackageConfig config = new PackageConfig.Builder(\"myPackage\").build();\n+</pre>\n+<p>\n+    The methods on the builder object are chainable to support constructions like this:\n+</p>\n+<pre>\n+    ResultConfig config = new ResultConfig.Builder(\"success\", \"myapp.MyResult\")\n+        .addParam(\"location\", \"/foo.jsp\")\n+        .build();\n+</pre>\n+</body>"
        },
        {
            "sha": "4ad23321f62fdd3f24d0d43a1d6630c17979e23b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/AbstractMatcher.java",
            "status": "added",
            "additions": 278,
            "deletions": 0,
            "changes": 278,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FAbstractMatcher.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FAbstractMatcher.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FAbstractMatcher.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,278 @@\n+/*\n+ * $Id$\n+ *\n+ * Copyright 2003,2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.util.PatternMatcher;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.io.Serializable;\n+import java.util.*;\n+\n+import org.apache.commons.lang.math.NumberUtils;\n+\n+/**\n+ * <p> Matches patterns against pre-compiled wildcard expressions pulled from\n+ * target objects. It uses the wildcard matcher from the Apache Cocoon\n+ * project. Patterns will be matched in the order they were added. The first \n+ * match wins, so more specific patterns should be defined before less specific \n+ * patterns.\n+ * \n+ * @since 2.1\n+ */\n+public abstract class AbstractMatcher<E> implements Serializable {\n+    /**\n+     * <p> The logging instance </p>\n+     */\n+    private static final Logger log = LoggerFactory.getLogger(AbstractMatcher.class);\n+\n+    /**\n+     * <p> Handles all wildcard pattern matching. </p>\n+     */\n+    PatternMatcher<Object> wildcard;\n+\n+    /**\n+     * <p> The compiled patterns and their associated target objects </p>\n+     */\n+    List<Mapping<E>> compiledPatterns = new ArrayList<Mapping<E>>();;\n+    \n+    public AbstractMatcher(PatternMatcher<?> helper) {\n+        this.wildcard = (PatternMatcher<Object>) helper;\n+    }\n+\n+    /**\n+     * <p>\n+     * Finds and precompiles the wildcard patterns. Patterns will be evaluated\n+     * in the order they were added. Only patterns that actually contain a\n+     * wildcard will be compiled.\n+     * </p>\n+     * \n+     * <p>\n+     * Patterns can optionally be matched \"loosely\". When the end of the pattern\n+     * matches \\*[^*]\\*$ (wildcard, no wildcard, wildcard), if the pattern\n+     * fails, it is also matched as if the last two characters didn't exist. The\n+     * goal is to support the legacy \"*!*\" syntax, where the \"!*\" is optional.\n+     * </p>\n+     * \n+     * @param name The pattern\n+     * @param target The object to associate with the pattern\n+     * @param looseMatch\n+     *            To loosely match wildcards or not\n+     */\n+    public void addPattern(String name, E target, boolean looseMatch) {\n+\n+        Object pattern;\n+\n+        if (!wildcard.isLiteral(name)) {\n+            if (looseMatch && (name.length() > 0) && (name.charAt(0) == '/')) {\n+                name = name.substring(1);\n+            }\n+\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Compiling pattern '\" + name + \"'\");\n+            }\n+\n+            pattern = wildcard.compilePattern(name);\n+            compiledPatterns.add(new Mapping<E>(name, pattern, target));\n+\n+            if (looseMatch) {\n+                int lastStar = name.lastIndexOf('*');\n+                if (lastStar > 1 && lastStar == name.length() - 1) {\n+                    if (name.charAt(lastStar - 1) != '*') {\n+                        pattern = wildcard.compilePattern(name.substring(0, lastStar - 1));\n+                        compiledPatterns.add(new Mapping<E>(name, pattern, target));\n+                    }\n+                }\n+            }\n+        }\n+    }\n+    \n+    public void freeze() {\n+        compiledPatterns = Collections.unmodifiableList(new ArrayList<Mapping<E>>());\n+    }\n+\n+    /**\n+     * <p> Matches the path against the compiled wildcard patterns. </p>\n+     *\n+     * @param potentialMatch The portion of the request URI for selecting a config.\n+     * @return The action config if matched, else null\n+     */\n+    public E match(String potentialMatch) {\n+        E config = null;\n+\n+        if (compiledPatterns.size() > 0) {\n+            if (log.isDebugEnabled()) {\n+                log.debug(\"Attempting to match '\" + potentialMatch\n+                    + \"' to a wildcard pattern, \"+ compiledPatterns.size()\n+                    + \" available\");\n+            }\n+\n+            Map<String,String> vars = new LinkedHashMap<String,String>();\n+            for (Mapping<E> m : compiledPatterns) {\n+                if (wildcard.match(vars, potentialMatch, m.getPattern())) {\n+                    if (log.isDebugEnabled()) {\n+                        log.debug(\"Value matches pattern '\"\n+                            + m.getOriginalPattern() + \"'\");\n+                    }\n+\n+                    config =\n+                        convert(potentialMatch, m.getTarget(), vars);\n+                    break;\n+                }\n+            }\n+        }\n+\n+        return config;\n+    }\n+\n+    /**\n+     * <p> Clones the target object and its children, replacing various\n+     * properties with the values of the wildcard-matched strings. </p>\n+     *\n+     * @param path The requested path\n+     * @param orig The original object\n+     * @param vars A Map of wildcard-matched strings\n+     * @return A cloned object with appropriate properties replaced with\n+     *         wildcard-matched values\n+     */\n+    protected abstract E convert(String path, E orig, Map<String, String> vars);\n+\n+    /**\n+     * <p> Replaces parameter values\n+     * </p>\n+     *\n+     * @param orig  The original parameters with placehold values\n+     * @param vars  A Map of wildcard-matched strings\n+     */\n+    protected Map<String,String> replaceParameters(Map<String, String> orig, Map<String,String> vars) {\n+        Map<String,String> map = new LinkedHashMap<String,String>();\n+        \n+        //this will set the group index references, like {1}\n+        for (String key : orig.keySet()) {\n+            map.put(key, convertParam(orig.get(key), vars));\n+        }\n+        \n+        //the values map will contain entries like name->\"Lex Luthor\" and 1->\"Lex Luthor\"\n+        //now add the non-numeric values\n+        for (String key: vars.keySet()) {\n+            if (!NumberUtils.isNumber(key)) {\n+                map.put(key, vars.get(key));\n+            }\n+        }\n+        \n+        return map;\n+    }\n+\n+    /**\n+     * <p> Inserts into a value wildcard-matched strings where specified\n+     * with the {x} syntax.  If a wildcard-matched value isn't found, the\n+     * replacement token is turned into an empty string. \n+     * </p>\n+     *\n+     * @param val  The value to convert\n+     * @param vars A Map of wildcard-matched strings\n+     * @return The new value\n+     */\n+    protected String convertParam(String val, Map<String, String> vars) {\n+        if (val == null) {\n+            return null;\n+        } \n+        \n+        int len = val.length();\n+        StringBuilder ret = new StringBuilder();\n+        char c;\n+        String varVal;\n+        for (int x=0; x<len; x++) {\n+            c = val.charAt(x);\n+            if (x < len - 2 && \n+                    c == '{' && '}' == val.charAt(x+2)) {\n+                varVal = (String)vars.get(String.valueOf(val.charAt(x + 1)));\n+                if (varVal != null) {\n+                    ret.append(varVal);\n+                } \n+                x += 2;\n+            } else {\n+                ret.append(c);\n+            }\n+        }\n+        \n+        return ret.toString();\n+    }\n+\n+    /**\n+     * <p> Stores a compiled wildcard pattern and the object it came\n+     * from. </p>\n+     */\n+    private static class Mapping<E> implements Serializable {\n+        /**\n+         * <p> The original pattern. </p>\n+         */\n+        private String original;\n+\n+        \n+        /**\n+         * <p> The compiled pattern. </p>\n+         */\n+        private Object pattern;\n+\n+        /**\n+         * <p> The original object. </p>\n+         */\n+        private E config;\n+\n+        /**\n+         * <p> Contructs a read-only Mapping instance. </p>\n+         *\n+         * @param original The original pattern\n+         * @param pattern The compiled pattern\n+         * @param config  The original object\n+         */\n+        public Mapping(String original, Object pattern, E config) {\n+            this.original = original;\n+            this.pattern = pattern;\n+            this.config = config;\n+        }\n+\n+        /**\n+         * <p> Gets the compiled wildcard pattern. </p>\n+         *\n+         * @return The compiled pattern\n+         */\n+        public Object getPattern() {\n+            return this.pattern;\n+        }\n+\n+        /**\n+         * <p> Gets the object that contains the pattern. </p>\n+         *\n+         * @return The associated object\n+         */\n+        public E getTarget() {\n+            return this.config;\n+        }\n+        \n+        /**\n+         * <p> Gets the original wildcard pattern. </p>\n+         *\n+         * @return The original pattern\n+         */\n+        public String getOriginalPattern() {\n+            return this.original;\n+        }\n+    }\n+}"
        },
        {
            "sha": "3058b032c88a1b19667a914b19879f005878d4bc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/ActionConfigMatcher.java",
            "status": "added",
            "additions": 148,
            "deletions": 0,
            "changes": 148,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FActionConfigMatcher.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FActionConfigMatcher.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FActionConfigMatcher.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,148 @@\n+/*\n+ * $Id$\n+ *\n+ * Copyright 2003,2004 The Apache Software Foundation.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.config.entities.ExceptionMappingConfig;\n+import com.opensymphony.xwork2.config.entities.ResultConfig;\n+import com.opensymphony.xwork2.util.PatternMatcher;\n+import com.opensymphony.xwork2.util.WildcardHelper;\n+\n+import java.io.Serializable;\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+/**\n+ * <p> Matches paths against pre-compiled wildcard expressions pulled from\n+ * action configs. It uses the wildcard matcher from the Apache Cocoon\n+ * project. Patterns will be matched in the order they exist in the \n+ * config file. The first match wins, so more specific patterns should be\n+ * defined before less specific patterns.\n+ */\n+public class ActionConfigMatcher extends AbstractMatcher<ActionConfig> implements Serializable {\n+   \n+    /**\n+     * <p> Finds and precompiles the wildcard patterns from the ActionConfig\n+     * \"path\" attributes. ActionConfig's will be evaluated in the order they\n+     * exist in the config file. Only paths that actually contain a\n+     * wildcard will be compiled. Patterns will matched strictly.</p>\n+     *\n+     * @param configs An array of ActionConfig's to process\n+     * @deprecated Since 2.1, use {@link #ActionConfigMatcher(PatternMatcher, Map, boolean)} instead\n+     */\n+    @Deprecated public ActionConfigMatcher(Map<String, ActionConfig> configs) {\n+        this(configs, false);\n+    }\n+    \n+    /**\n+     * <p> Finds and precompiles the wildcard patterns from the ActionConfig\n+     * \"path\" attributes. ActionConfig's will be evaluated in the order they\n+     * exist in the config file. Only paths that actually contain a\n+     * wildcard will be compiled. </p>\n+     * \n+     * <p>Patterns can optionally be matched \"loosely\".  When\n+     * the end of the pattern matches \\*[^*]\\*$ (wildcard, no wildcard,\n+     * wildcard), if the pattern fails, it is also matched as if the \n+     * last two characters didn't exist.  The goal is to support the \n+     * legacy \"*!*\" syntax, where the \"!*\" is optional.</p> \n+     *\n+     * @param configs An array of ActionConfig's to process\n+     * @param looseMatch To loosely match wildcards or not\n+     * @deprecated Since 2.1, use {@link #ActionConfigMatcher(PatternMatcher, Map, boolean)} instead\n+     */\n+    @Deprecated public ActionConfigMatcher(Map<String, ActionConfig> configs,\n+            boolean looseMatch) {\n+\n+        this(new WildcardHelper(), configs, looseMatch);\n+    }\n+    \n+    /**\n+     * <p> Finds and precompiles the wildcard patterns from the ActionConfig\n+     * \"path\" attributes. ActionConfig's will be evaluated in the order they\n+     * exist in the config file. Only paths that actually contain a\n+     * wildcard will be compiled. </p>\n+     * \n+     * <p>Patterns can optionally be matched \"loosely\".  When\n+     * the end of the pattern matches \\*[^*]\\*$ (wildcard, no wildcard,\n+     * wildcard), if the pattern fails, it is also matched as if the \n+     * last two characters didn't exist.  The goal is to support the \n+     * legacy \"*!*\" syntax, where the \"!*\" is optional.</p> \n+     *\n+     * @param configs An array of ActionConfig's to process\n+     * @param looseMatch To loosely match wildcards or not\n+     */\n+    public ActionConfigMatcher(PatternMatcher<?> patternMatcher,\n+            Map<String, ActionConfig> configs,\n+            boolean looseMatch) {\n+        super(patternMatcher);\n+        for (String name : configs.keySet()) {\n+            addPattern(name, configs.get(name), looseMatch);\n+        }\n+    }\n+\n+    /**\n+     * <p> Clones the ActionConfig and its children, replacing various\n+     * properties with the values of the wildcard-matched strings. </p>\n+     *\n+     * @param path The requested path\n+     * @param orig The original ActionConfig\n+     * @param vars A Map of wildcard-matched strings\n+     * @return A cloned ActionConfig with appropriate properties replaced with\n+     *         wildcard-matched values\n+     */\n+    @Override public ActionConfig convert(String path, ActionConfig orig,\n+        Map<String, String> vars) {\n+        \n+        String className = convertParam(orig.getClassName(), vars);\n+        String methodName = convertParam(orig.getMethodName(), vars);\n+        String pkgName = convertParam(orig.getPackageName(), vars);\n+        \n+        Map<String,String> params = replaceParameters(orig.getParams(), vars);\n+        \n+        Map<String,ResultConfig> results = new LinkedHashMap<String,ResultConfig>();\n+        for (String name : orig.getResults().keySet()) {\n+            ResultConfig result = orig.getResults().get(name);\n+            name = convertParam(name, vars);\n+            ResultConfig r = new ResultConfig.Builder(name, convertParam(result.getClassName(), vars))\n+                    .addParams(replaceParameters(result.getParams(), vars))\n+                    .build();\n+            results.put(name, r);\n+        }\n+        \n+        List<ExceptionMappingConfig> exs = new ArrayList<ExceptionMappingConfig>();\n+        for (ExceptionMappingConfig ex : orig.getExceptionMappings()) {\n+            String name = convertParam(ex.getName(), vars);\n+            String exClassName = convertParam(ex.getExceptionClassName(), vars);\n+            String exResult = convertParam(ex.getResult(), vars);\n+            Map<String,String> exParams = replaceParameters(ex.getParams(), vars);\n+            ExceptionMappingConfig e = new ExceptionMappingConfig.Builder(name, exClassName, exResult).addParams(exParams).build();\n+            exs.add(e);\n+        }\n+        \n+        return new ActionConfig.Builder(pkgName, orig.getName(), className)\n+                .methodName(methodName)\n+                .addParams(params)\n+                .addResultConfigs(results)\n+                .addInterceptors(orig.getInterceptors())\n+                .addExceptionMappings(exs)\n+                .location(orig.getLocation())\n+                .build();\n+    }\n+}"
        },
        {
            "sha": "f77da0aa62fef9635d2faf63eec20cf77f0b0b23",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/DefaultConfiguration.java",
            "status": "added",
            "additions": 484,
            "deletions": 0,
            "changes": 484,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FDefaultConfiguration.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FDefaultConfiguration.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FDefaultConfiguration.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,484 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.DefaultTextProvider;\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.TextProvider;\n+import com.opensymphony.xwork2.config.*;\n+import com.opensymphony.xwork2.config.entities.*;\n+import com.opensymphony.xwork2.config.providers.InterceptorBuilder;\n+import com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\n+import com.opensymphony.xwork2.conversion.impl.DefaultObjectTypeDeterminer;\n+import com.opensymphony.xwork2.conversion.impl.XWorkBasicConverter;\n+import com.opensymphony.xwork2.conversion.impl.XWorkConverter;\n+import com.opensymphony.xwork2.inject.*;\n+import com.opensymphony.xwork2.ognl.OgnlReflectionProvider;\n+import com.opensymphony.xwork2.ognl.OgnlUtil;\n+import com.opensymphony.xwork2.ognl.OgnlValueStackFactory;\n+import com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;\n+import com.opensymphony.xwork2.util.CompoundRoot;\n+import com.opensymphony.xwork2.util.PatternMatcher;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.ValueStackFactory;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+import ognl.PropertyAccessor;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * DefaultConfiguration\n+ *\n+ * @author Jason Carreira\n+ *         Created Feb 24, 2003 7:38:06 AM\n+ */\n+public class DefaultConfiguration implements Configuration {\n+\n+    protected static final Logger LOG = LoggerFactory.getLogger(DefaultConfiguration.class);\n+\n+\n+    // Programmatic Action Configurations\n+    protected Map<String, PackageConfig> packageContexts = new LinkedHashMap<String, PackageConfig>();\n+    protected RuntimeConfiguration runtimeConfiguration;\n+    protected Container container;\n+    protected String defaultFrameworkBeanName;\n+    protected Set<String> loadedFileNames = new TreeSet<String>();\n+    protected List<UnknownHandlerConfig> unknownHandlerStack;\n+\n+\n+    ObjectFactory objectFactory;\n+\n+    public DefaultConfiguration() {\n+        this(\"xwork\");\n+    }\n+\n+    public DefaultConfiguration(String defaultBeanName) {\n+        this.defaultFrameworkBeanName = defaultBeanName;\n+    }\n+\n+\n+    public PackageConfig getPackageConfig(String name) {\n+        return packageContexts.get(name);\n+    }\n+\n+    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n+        return unknownHandlerStack;\n+    }\n+\n+    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n+        this.unknownHandlerStack = unknownHandlerStack;\n+    }\n+\n+    public Set<String> getPackageConfigNames() {\n+        return packageContexts.keySet();\n+    }\n+\n+    public Map<String, PackageConfig> getPackageConfigs() {\n+        return packageContexts;\n+    }\n+\n+    public Set<String> getLoadedFileNames() {\n+        return loadedFileNames;\n+    }\n+\n+    public RuntimeConfiguration getRuntimeConfiguration() {\n+        return runtimeConfiguration;\n+    }\n+\n+    /**\n+     * @return the container\n+     */\n+    public Container getContainer() {\n+        return container;\n+    }\n+\n+    public void addPackageConfig(String name, PackageConfig packageContext) {\n+        PackageConfig check = packageContexts.get(name);\n+        if (check != null) {\n+            if (check.getLocation() != null && packageContext.getLocation() != null\n+                    && check.getLocation().equals(packageContext.getLocation())) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"The package name '\" + name\n+                    + \"' is already been loaded by the same location and could be removed: \"\n+                    + packageContext.getLocation());\n+                }\n+            } else {\n+                throw new ConfigurationException(\"The package name '\" + name\n+                        + \"' at location \"+packageContext.getLocation()\n+                        + \" is already been used by another package at location \" + check.getLocation(),\n+                        packageContext);\n+            }\n+        }\n+        packageContexts.put(name, packageContext);\n+    }\n+\n+    public PackageConfig removePackageConfig(String packageName) {\n+        return packageContexts.remove(packageName);\n+    }\n+\n+    /**\n+     * Allows the configuration to clean up any resources used\n+     */\n+    public void destroy() {\n+        packageContexts.clear();\n+        loadedFileNames.clear();\n+    }\n+\n+    public void rebuildRuntimeConfiguration() {\n+        runtimeConfiguration = buildRuntimeConfiguration();\n+    }\n+\n+    /**\n+     * Calls the ConfigurationProviderFactory.getConfig() to tell it to reload the configuration and then calls\n+     * buildRuntimeConfiguration().\n+     *\n+     * @throws ConfigurationException\n+     */\n+    public synchronized void reload(List<ConfigurationProvider> providers) throws ConfigurationException {\n+\n+        // Silly copy necessary due to lack of ability to cast generic lists\n+        List<ContainerProvider> contProviders = new ArrayList<ContainerProvider>();\n+        contProviders.addAll(providers);\n+\n+        reloadContainer(contProviders);\n+    }\n+\n+    /**\n+     * Calls the ConfigurationProviderFactory.getConfig() to tell it to reload the configuration and then calls\n+     * buildRuntimeConfiguration().\n+     *\n+     * @throws ConfigurationException\n+     */\n+    public synchronized List<PackageProvider> reloadContainer(List<ContainerProvider> providers) throws ConfigurationException {\n+        packageContexts.clear();\n+        loadedFileNames.clear();\n+        List<PackageProvider> packageProviders = new ArrayList<PackageProvider>();\n+\n+        ContainerProperties props = new ContainerProperties();\n+        ContainerBuilder builder = new ContainerBuilder();\n+        for (final ContainerProvider containerProvider : providers)\n+        {\n+            containerProvider.init(this);\n+            containerProvider.register(builder, props);\n+        }\n+        props.setConstants(builder);\n+\n+        builder.factory(Configuration.class, new Factory<Configuration>() {\n+            public Configuration create(Context context) throws Exception {\n+                return DefaultConfiguration.this;\n+            }\n+        });\n+\n+        ActionContext oldContext = ActionContext.getContext();\n+        try {\n+            // Set the bootstrap container for the purposes of factory creation\n+            Container bootstrap = createBootstrapContainer();\n+            setContext(bootstrap);\n+            container = builder.create(false);\n+            setContext(container);\n+            objectFactory = container.getInstance(ObjectFactory.class);\n+\n+            // Process the configuration providers first\n+            for (final ContainerProvider containerProvider : providers)\n+            {\n+                if (containerProvider instanceof PackageProvider) {\n+                    container.inject(containerProvider);\n+                    ((PackageProvider)containerProvider).loadPackages();\n+                    packageProviders.add((PackageProvider)containerProvider);\n+                }\n+            }\n+\n+            // Then process any package providers from the plugins\n+            Set<String> packageProviderNames = container.getInstanceNames(PackageProvider.class);\n+            if (packageProviderNames != null) {\n+                for (String name : packageProviderNames) {\n+                    PackageProvider provider = container.getInstance(PackageProvider.class, name);\n+                    provider.init(this);\n+                    provider.loadPackages();\n+                    packageProviders.add(provider);\n+                }\n+            }\n+\n+            rebuildRuntimeConfiguration();\n+        } finally {\n+            if (oldContext == null) {\n+                ActionContext.setContext(null);\n+            }\n+        }\n+        return packageProviders;\n+    }\n+\n+    protected ActionContext setContext(Container cont) {\n+        ActionContext context = ActionContext.getContext();\n+        if (context == null) {\n+            ValueStack vs = cont.getInstance(ValueStackFactory.class).createValueStack();\n+            context = new ActionContext(vs.getContext());\n+            ActionContext.setContext(context);\n+        }\n+        return context;\n+    }\n+\n+    protected Container createBootstrapContainer() {\n+        ContainerBuilder builder = new ContainerBuilder();\n+        builder.factory(ObjectFactory.class, Scope.SINGLETON);\n+        builder.factory(ReflectionProvider.class, OgnlReflectionProvider.class, Scope.SINGLETON);\n+        builder.factory(ValueStackFactory.class, OgnlValueStackFactory.class, Scope.SINGLETON);\n+        builder.factory(XWorkConverter.class, Scope.SINGLETON);\n+        builder.factory(XWorkBasicConverter.class, Scope.SINGLETON);\n+        builder.factory(TextProvider.class, \"system\", DefaultTextProvider.class, Scope.SINGLETON);\n+        builder.factory(ObjectTypeDeterminer.class, DefaultObjectTypeDeterminer.class, Scope.SINGLETON);\n+        builder.factory(PropertyAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON);\n+        builder.factory(OgnlUtil.class, Scope.SINGLETON);\n+        builder.constant(\"devMode\", \"false\");\n+        builder.constant(\"logMissingProperties\", \"false\");\n+        return builder.create(true);\n+    }\n+\n+    /**\n+     * This builds the internal runtime configuration used by Xwork for finding and configuring Actions from the\n+     * programmatic configuration data structures. All of the old runtime configuration will be discarded and rebuilt.\n+     *\n+     * <p>\n+     * It basically flattens the data structures to make the information easier to access.  It will take\n+     * an {@link ActionConfig} and combine its data with all inherited dast.  For example, if the {@link ActionConfig}\n+     * is in a package that contains a global result and it also contains a result, the resulting {@link ActionConfig}\n+     * will have two results.\n+     */\n+    protected synchronized RuntimeConfiguration buildRuntimeConfiguration() throws ConfigurationException {\n+        Map<String, Map<String, ActionConfig>> namespaceActionConfigs = new LinkedHashMap<String, Map<String, ActionConfig>>();\n+        Map<String, String> namespaceConfigs = new LinkedHashMap<String, String>();\n+\n+        for (PackageConfig packageConfig : packageContexts.values()) {\n+\n+            if (!packageConfig.isAbstract()) {\n+                String namespace = packageConfig.getNamespace();\n+                Map<String, ActionConfig> configs = namespaceActionConfigs.get(namespace);\n+\n+                if (configs == null) {\n+                    configs = new LinkedHashMap<String, ActionConfig>();\n+                }\n+\n+                Map<String, ActionConfig> actionConfigs = packageConfig.getAllActionConfigs();\n+\n+                for (Object o : actionConfigs.keySet()) {\n+                    String actionName = (String) o;\n+                    ActionConfig baseConfig = actionConfigs.get(actionName);\n+                    configs.put(actionName, buildFullActionConfig(packageConfig, baseConfig));\n+                }\n+\n+\n+\n+                namespaceActionConfigs.put(namespace, configs);\n+                if (packageConfig.getFullDefaultActionRef() != null) {\n+                    namespaceConfigs.put(namespace, packageConfig.getFullDefaultActionRef());\n+                }\n+            }\n+        }\n+\n+        return new RuntimeConfigurationImpl(namespaceActionConfigs, namespaceConfigs);\n+    }\n+\n+    private void setDefaultResults(Map<String, ResultConfig> results, PackageConfig packageContext) {\n+        String defaultResult = packageContext.getFullDefaultResultType();\n+\n+        for (Map.Entry<String, ResultConfig> entry : results.entrySet()) {\n+\n+            if (entry.getValue() == null) {\n+                ResultTypeConfig resultTypeConfig = packageContext.getAllResultTypeConfigs().get(defaultResult);\n+                entry.setValue(new ResultConfig.Builder(null, resultTypeConfig.getClassName()).build());\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Builds the full runtime actionconfig with all of the defaults and inheritance\n+     *\n+     * @param packageContext the PackageConfig which holds the base config we're building from\n+     * @param baseConfig     the ActionConfig which holds only the configuration specific to itself, without the defaults\n+     *                       and inheritance\n+     * @return a full ActionConfig for runtime configuration with all of the inherited and default params\n+     * @throws com.opensymphony.xwork2.config.ConfigurationException\n+     *\n+     */\n+    private ActionConfig buildFullActionConfig(PackageConfig packageContext, ActionConfig baseConfig) throws ConfigurationException {\n+        Map<String, String> params = new TreeMap<String, String>(baseConfig.getParams());\n+        Map<String, ResultConfig> results = new TreeMap<String, ResultConfig>();\n+\n+        if (!baseConfig.getPackageName().equals(packageContext.getName()) && packageContexts.containsKey(baseConfig.getPackageName())) {\n+            results.putAll(packageContexts.get(baseConfig.getPackageName()).getAllGlobalResults());\n+        } else {\n+            results.putAll(packageContext.getAllGlobalResults());\n+        }\n+\n+       \tresults.putAll(baseConfig.getResults());\n+\n+        setDefaultResults(results, packageContext);\n+\n+        List<InterceptorMapping> interceptors = new ArrayList<InterceptorMapping>(baseConfig.getInterceptors());\n+\n+        if (interceptors.size() <= 0) {\n+            String defaultInterceptorRefName = packageContext.getFullDefaultInterceptorRef();\n+\n+            if (defaultInterceptorRefName != null) {\n+                interceptors.addAll(InterceptorBuilder.constructInterceptorReference(new PackageConfig.Builder(packageContext), defaultInterceptorRefName,\n+                        new LinkedHashMap<String, String>(), packageContext.getLocation(), objectFactory));\n+            }\n+        }\n+\n+\n+\n+        return new ActionConfig.Builder(baseConfig)\n+            .addParams(params)\n+            .addResultConfigs(results)\n+            .defaultClassName(packageContext.getDefaultClassRef())  // fill in default if non class has been provided\n+            .interceptors(interceptors)\n+            .addExceptionMappings(packageContext.getAllExceptionMappingConfigs())\n+            .build();\n+    }\n+\n+\n+    private class RuntimeConfigurationImpl implements RuntimeConfiguration {\n+        private Map<String, Map<String, ActionConfig>> namespaceActionConfigs;\n+        private Map<String, ActionConfigMatcher> namespaceActionConfigMatchers;\n+        private NamespaceMatcher namespaceMatcher;\n+        private Map<String, String> namespaceConfigs;\n+\n+        public RuntimeConfigurationImpl(Map<String, Map<String, ActionConfig>> namespaceActionConfigs, Map<String, String> namespaceConfigs) {\n+            this.namespaceActionConfigs = namespaceActionConfigs;\n+            this.namespaceConfigs = namespaceConfigs;\n+\n+            PatternMatcher<int[]> matcher = container.getInstance(PatternMatcher.class);\n+\n+            this.namespaceActionConfigMatchers = new LinkedHashMap<String, ActionConfigMatcher>();\n+            this.namespaceMatcher = new NamespaceMatcher(matcher, namespaceActionConfigs.keySet());\n+\n+            for (String ns : namespaceActionConfigs.keySet()) {\n+                namespaceActionConfigMatchers.put(ns,\n+                        new ActionConfigMatcher(matcher,\n+                                namespaceActionConfigs.get(ns), true));\n+            }\n+        }\n+\n+\n+        /**\n+         * Gets the configuration information for an action name, or returns null if the\n+         * name is not recognized.\n+         *\n+         * @param name      the name of the action\n+         * @param namespace the namespace for the action or null for the empty namespace, \"\"\n+         * @return the configuration information for action requested\n+         */\n+        public synchronized ActionConfig getActionConfig(String namespace, String name) {\n+            ActionConfig config = findActionConfigInNamespace(namespace, name);\n+\n+            // try wildcarded namespaces\n+            if (config == null) {\n+                NamespaceMatch match = namespaceMatcher.match(namespace);\n+                if (match != null) {\n+                    config = findActionConfigInNamespace(match.getPattern(), name);\n+\n+                    // If config found, place all the matches found in the namespace processing in the action's parameters\n+                    if (config != null) {\n+                        config = new ActionConfig.Builder(config)\n+                                .addParams(match.getVariables())\n+                                .build();\n+                    }\n+                }\n+            }\n+\n+            // fail over to empty namespace\n+            if ((config == null) && (namespace != null) && (!\"\".equals(namespace.trim()))) {\n+                config = findActionConfigInNamespace(\"\", name);\n+            }\n+\n+\n+            return config;\n+        }\n+\n+        ActionConfig findActionConfigInNamespace(String namespace, String name) {\n+            ActionConfig config = null;\n+            if (namespace == null) {\n+                namespace = \"\";\n+            }\n+            Map<String, ActionConfig> actions = namespaceActionConfigs.get(namespace);\n+            if (actions != null) {\n+                config = actions.get(name);\n+                // Check wildcards\n+                if (config == null) {\n+                    config = namespaceActionConfigMatchers.get(namespace).match(name);\n+                    // fail over to default action\n+                    if (config == null) {\n+                        String defaultActionRef = namespaceConfigs.get(namespace);\n+                        if (defaultActionRef != null) {\n+                            config = actions.get(defaultActionRef);\n+                        }\n+                    }\n+                }\n+            }\n+            return config;\n+        }\n+\n+        /**\n+         * Gets the configuration settings for every action.\n+         *\n+         * @return a Map of namespace - > Map of ActionConfig objects, with the key being the action name\n+         */\n+        public synchronized Map<String, Map<String, ActionConfig>>  getActionConfigs() {\n+            return namespaceActionConfigs;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder buff = new StringBuilder(\"RuntimeConfiguration - actions are\\n\");\n+\n+            for (String namespace : namespaceActionConfigs.keySet()) {\n+                Map<String, ActionConfig> actionConfigs = namespaceActionConfigs.get(namespace);\n+\n+                for (String s : actionConfigs.keySet()) {\n+                    buff.append(namespace).append(\"/\").append(s).append(\"\\n\");\n+                }\n+            }\n+\n+            return buff.toString();\n+        }\n+    }\n+\n+    class ContainerProperties extends LocatableProperties {\n+        private static final long serialVersionUID = -7320625750836896089L;\n+\n+        @Override\n+        public Object setProperty(String key, String value) {\n+            String oldValue = getProperty(key);\n+            if (oldValue != null && !oldValue.equals(value) && !defaultFrameworkBeanName.equals(oldValue)) {\n+                LOG.info(\"Overriding property \"+key+\" - old value: \"+oldValue+\" new value: \"+value);\n+            }\n+            return super.setProperty(key, value);\n+        }\n+\n+        public void setConstants(ContainerBuilder builder) {\n+            for (Object keyobj : keySet()) {\n+                String key = (String)keyobj;\n+                builder.factory(String.class, key,\n+                        new LocatableConstantFactory<String>(getProperty(key), getPropertyLocation(key)));\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "eb218f8592f479cc4dc3b41b4d76b32365c9e2c7",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/LocatableConstantFactory.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableConstantFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableConstantFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableConstantFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * \n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.inject.Context;\n+import com.opensymphony.xwork2.inject.Factory;\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.LocationUtils;\n+\n+/**\n+ * Factory that remembers where a constant came from\n+ */\n+public class LocatableConstantFactory<T> extends Located implements Factory {\n+    T constant;\n+    public LocatableConstantFactory(T constant, Object location) {\n+        this.constant = constant;\n+        setLocation(LocationUtils.getLocation(location));\n+    }\n+    \n+    public T create(Context ignored) {\n+        return constant;\n+    }\n+    \n+    @Override\n+    public String toString() {\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(super.toString());\n+        sb.append(\" defined at \");\n+        sb.append(getLocation().toString());\n+        return sb.toString();\n+    }\n+\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "2f95dfe701127e53334b2bcdbf75dae97b007cfb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/LocatableFactory.java",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FLocatableFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,52 @@\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.inject.Context;\n+import com.opensymphony.xwork2.inject.Factory;\n+import com.opensymphony.xwork2.inject.Scope;\n+import com.opensymphony.xwork2.util.location.Located;\n+import com.opensymphony.xwork2.util.location.LocationUtils;\n+\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * Attaches location information to the factory.\n+ */\n+public class LocatableFactory<T> extends Located implements Factory<T> {\n+\n+\n+    private Class implementation;\n+    private Class type;\n+    private String name;\n+    private Scope scope;\n+\n+    public LocatableFactory(String name, Class type, Class implementation, Scope scope, Object location) {\n+        this.implementation = implementation;\n+        this.type = type;\n+        this.name = name;\n+        this.scope = scope;\n+        setLocation(LocationUtils.getLocation(location));\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    public T create(Context context) {\n+        Object obj = context.getContainer().inject(implementation);\n+        return (T) obj;\n+    }\n+\n+    @Override\n+    public String toString() {\n+        String fields = new LinkedHashMap<String, Object>() {\n+            {\n+                put(\"type\", type);\n+                put(\"name\", name);\n+                put(\"implementation\", implementation);\n+                put(\"scope\", scope);\n+            }\n+        }.toString();\n+        StringBuilder sb = new StringBuilder(fields);\n+        sb.append(super.toString());\n+        sb.append(\" defined at \");\n+        sb.append(getLocation().toString());\n+        return sb.toString();\n+    }\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "9059c2bb3d29fc275c8c05eb10f659b58e0d7533",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/MockConfiguration.java",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FMockConfiguration.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FMockConfiguration.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FMockConfiguration.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,125 @@\n+/*\n+ * Copyright 2002-2003,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.ConfigurationProvider;\n+import com.opensymphony.xwork2.config.ContainerProvider;\n+import com.opensymphony.xwork2.config.PackageProvider;\n+import com.opensymphony.xwork2.config.RuntimeConfiguration;\n+import com.opensymphony.xwork2.config.entities.PackageConfig;\n+import com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\n+import com.opensymphony.xwork2.config.providers.XWorkConfigurationProvider;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.ContainerBuilder;\n+import com.opensymphony.xwork2.inject.Scope;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+\n+/**\n+ * Simple configuration used for unit testing\n+ */\n+public class MockConfiguration implements Configuration {\n+\n+    private Map<String, PackageConfig> packages = new HashMap<String, PackageConfig>();\n+    private Set<String> loadedFiles = new HashSet<String>();\n+    private Container container;\n+    protected List<UnknownHandlerConfig> unknownHandlerStack;\n+    private ContainerBuilder builder;\n+\n+    public MockConfiguration() {\n+        builder = new ContainerBuilder();\n+    }\n+\n+    public void selfRegister() {\n+        //this cannot be done in the constructor, as it causes an infinite loop\n+        builder.factory(Configuration.class, MockConfiguration.class, Scope.SINGLETON);\n+        LocatableProperties props = new LocatableProperties();\n+        new XWorkConfigurationProvider().register(builder, props);\n+        builder.constant(\"devMode\", \"false\");\n+        container = builder.create(true);\n+    }\n+\n+    public PackageConfig getPackageConfig(String name) {\n+        return packages.get(name);\n+    }\n+\n+    public Set<String> getPackageConfigNames() {\n+        return packages.keySet();\n+    }\n+\n+    public Map<String, PackageConfig> getPackageConfigs() {\n+        return packages;\n+    }\n+\n+    public RuntimeConfiguration getRuntimeConfiguration() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void addPackageConfig(String name, PackageConfig packageContext) {\n+        packages.put(name, packageContext);\n+    }\n+\n+    public void buildRuntimeConfiguration() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void destroy() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void rebuildRuntimeConfiguration() {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public void reload(List<ConfigurationProvider> providers) throws ConfigurationException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public PackageConfig removePackageConfig(String name) {\n+        return packages.remove(name);\n+    }\n+\n+    public Container getContainer() {\n+        return container;\n+    }\n+\n+    public Set<String> getLoadedFileNames() {\n+        return loadedFiles;\n+    }\n+\n+    public List<PackageProvider> reloadContainer(\n+            List<ContainerProvider> containerProviders)\n+            throws ConfigurationException {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public List<UnknownHandlerConfig> getUnknownHandlerStack() {\n+        return unknownHandlerStack;\n+    }\n+\n+    public void setUnknownHandlerStack(List<UnknownHandlerConfig> unknownHandlerStack) {\n+        this.unknownHandlerStack = unknownHandlerStack;\n+    }\n+\n+}"
        },
        {
            "sha": "52a08867ac5dfae6c0365cdf989548cf9ef43e3e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/NamespaceMatch.java",
            "status": "added",
            "additions": 47,
            "deletions": 0,
            "changes": 47,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatch.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatch.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatch.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,47 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import java.util.Map;\n+\n+/**\n+ * Represents a match from a namespace pattern matching.\n+ *\n+ * @Since 2.1\n+ */\n+public class NamespaceMatch {\n+    private String pattern;\n+    private Map<String,String> variables;\n+\n+    public NamespaceMatch(String pattern, Map<String, String> variables) {\n+        this.pattern = pattern;\n+        this.variables = variables;\n+    }\n+\n+    /**\n+     * @return The pattern that was matched\n+     */\n+    public String getPattern() {\n+        return pattern;\n+    }\n+\n+    /**\n+     * @return The variables containing the matched values\n+     */\n+    public Map<String, String> getVariables() {\n+        return variables;\n+    }\n+}"
        },
        {
            "sha": "3d64c3370f6ba360b7ae5025ccaae2a97bab3a84",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/NamespaceMatcher.java",
            "status": "added",
            "additions": 51,
            "deletions": 0,
            "changes": 51,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatcher.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatcher.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2FNamespaceMatcher.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,51 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.impl;\n+\n+import com.opensymphony.xwork2.util.PatternMatcher;\n+\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * Matches namespace strings against a wildcard pattern matcher\n+ *\n+ * @Since 2.1\n+ */\n+public class NamespaceMatcher extends AbstractMatcher<NamespaceMatch> {\n+     public NamespaceMatcher(PatternMatcher<?> patternMatcher,\n+            Set<String> namespaces) {\n+        super(patternMatcher);\n+        for (String name : namespaces) {\n+            if (!patternMatcher.isLiteral(name)) {\n+                addPattern(name, new NamespaceMatch(name, null), false);\n+            }\n+        }\n+    }\n+\n+    @Override\n+    protected NamespaceMatch convert(String path, NamespaceMatch orig, Map<String, String> vars) {\n+        /*Map<String,String> origVars = (Map<String,String>)vars;\n+        Map<String,String> map = new HashMap<String,String>();\n+        for (Map.Entry<String,String> entry : origVars.entrySet()) {\n+            if (entry.getKey().length() == 1) {\n+                map.put(\"ns\"+entry.getKey(), entry.getValue());\n+            }\n+        }\n+        */\n+        return new NamespaceMatch(orig.getPattern(), vars);\n+    }\n+}"
        },
        {
            "sha": "cdfed5f83ed5a5ee1689af1c6eeff4a6296f9651",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/impl/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fimpl%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Configuration implementation classes.</body>"
        },
        {
            "sha": "a3de692bc794a5b1306b0db9414acb34b03da23c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Configuration core classes.</body>"
        },
        {
            "sha": "102f08ef7bf516ea2d84d65d74804a261570ab04",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/providers/InterceptorBuilder.java",
            "status": "added",
            "additions": 215,
            "deletions": 0,
            "changes": 215,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FInterceptorBuilder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FInterceptorBuilder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FInterceptorBuilder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,215 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.providers;\n+\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.entities.InterceptorConfig;\n+import com.opensymphony.xwork2.config.entities.InterceptorLocator;\n+import com.opensymphony.xwork2.config.entities.InterceptorMapping;\n+import com.opensymphony.xwork2.config.entities.InterceptorStackConfig;\n+import com.opensymphony.xwork2.interceptor.Interceptor;\n+import com.opensymphony.xwork2.util.location.Location;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.ArrayList;\n+import java.util.LinkedHashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+\n+/**\n+ * Builds a list of interceptors referenced by the refName in the supplied PackageConfig.\n+ *\n+ * @author Mike\n+ * @author Rainer Hermanns\n+ * @author tmjee\n+ * @version $Date$ $Id$\n+ */\n+public class InterceptorBuilder {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(InterceptorBuilder.class);\n+\n+\n+    /**\n+     * Builds a list of interceptors referenced by the refName in the supplied PackageConfig (InterceptorMapping object).\n+     *\n+     * @param interceptorLocator\n+     * @param refName\n+     * @param refParams\n+     * @return list of interceptors referenced by the refName in the supplied PackageConfig (InterceptorMapping object).\n+     * @throws ConfigurationException\n+     */\n+    public static List<InterceptorMapping> constructInterceptorReference(InterceptorLocator interceptorLocator,\n+                                                                         String refName, Map<String,String> refParams, Location location, ObjectFactory objectFactory) throws ConfigurationException {\n+        Object referencedConfig = interceptorLocator.getInterceptorConfig(refName);\n+        List<InterceptorMapping> result = new ArrayList<InterceptorMapping>();\n+\n+        if (referencedConfig == null) {\n+            throw new ConfigurationException(\"Unable to find interceptor class referenced by ref-name \" + refName, location);\n+        } else {\n+            if (referencedConfig instanceof InterceptorConfig) {\n+                InterceptorConfig config = (InterceptorConfig) referencedConfig;\n+                Interceptor inter = null;\n+                try {\n+\n+                    inter = objectFactory.buildInterceptor(config, refParams);\n+                    result.add(new InterceptorMapping(refName, inter));\n+                } catch (ConfigurationException ex) {\n+                    LOG.warn(\"Unable to load config class \" + config.getClassName() + \" at \" +\n+                            ex.getLocation() + \" probably due to a missing jar, which might \" +\n+                            \"be fine if you never plan to use the \" + config.getName() + \" interceptor\");\n+                    LOG.error(\"Actual exception\", ex);\n+                }\n+\n+            } else if (referencedConfig instanceof InterceptorStackConfig) {\n+                InterceptorStackConfig stackConfig = (InterceptorStackConfig) referencedConfig;\n+\n+                if ((refParams != null) && (refParams.size() > 0)) {\n+                    result = constructParameterizedInterceptorReferences(interceptorLocator, stackConfig, refParams, objectFactory);\n+                } else {\n+                    result.addAll(stackConfig.getInterceptors());\n+                }\n+\n+            } else {\n+                LOG.error(\"Got unexpected type for interceptor \" + refName + \". Got \" + referencedConfig);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Builds a list of interceptors referenced by the refName in the supplied PackageConfig overriding the properties\n+     * of the referenced interceptor with refParams.\n+     *\n+     * @param interceptorLocator\n+     * @param stackConfig\n+     * @param refParams          The overridden interceptor properies\n+     * @return list of interceptors referenced by the refName in the supplied PackageConfig overridden with refParams.\n+     */\n+    private static List<InterceptorMapping> constructParameterizedInterceptorReferences(\n+            InterceptorLocator interceptorLocator, InterceptorStackConfig stackConfig, Map<String,String> refParams,\n+            ObjectFactory objectFactory) {\n+        List<InterceptorMapping> result;\n+        Map<String, Map<String, String>> params = new LinkedHashMap<String, Map<String, String>>();\n+\n+        /*\n+         * We strip\n+         *\n+         * <interceptor-ref name=\"someStack\">\n+         *    <param name=\"interceptor1.param1\">someValue</param>\n+         *    <param name=\"interceptor1.param2\">anotherValue</param>\n+         * </interceptor-ref>\n+         *\n+         * down to map\n+         *  interceptor1 -> [param1 -> someValue, param2 -> anotherValue]\n+         *\n+         * or\n+         * <interceptor-ref name=\"someStack\">\n+         *    <param name=\"interceptorStack1.interceptor1.param1\">someValue</param>\n+         *    <param name=\"interceptorStack1.interceptor1.param2\">anotherValue</param>\n+         * </interceptor-ref>\n+         *\n+         * down to map\n+         *  interceptorStack1 -> [interceptor1.param1 -> someValue, interceptor1.param2 -> anotherValue]\n+         *\n+         */\n+        for (String key : refParams.keySet()) {\n+            String value = refParams.get(key);\n+\n+            try {\n+                String name = key.substring(0, key.indexOf('.'));\n+                key = key.substring(key.indexOf('.') + 1);\n+\n+                Map<String, String> map;\n+                if (params.containsKey(name)) {\n+                    map = params.get(name);\n+                } else {\n+                    map = new LinkedHashMap<String, String>();\n+                }\n+\n+                map.put(key, value);\n+                params.put(name, map);\n+\n+            } catch (Exception e) {\n+                LOG.warn(\"No interceptor found for name = \" + key);\n+            }\n+        }\n+\n+        result = new ArrayList<InterceptorMapping>(stackConfig.getInterceptors());\n+\n+        for (String key : params.keySet()) {\n+\n+            Map<String, String> map = params.get(key);\n+\n+\n+            Object interceptorCfgObj = interceptorLocator.getInterceptorConfig(key);\n+\n+            /*\n+             * Now we attempt to separate out param that refers to Interceptor\n+             * and Interceptor stack, eg.\n+             *\n+             * <interceptor-ref name=\"someStack\">\n+             *    <param name=\"interceptor1.param1\">someValue</param>\n+             *    ...\n+             * </interceptor-ref>\n+             *\n+             *  vs\n+             *\n+             *  <interceptor-ref name=\"someStack\">\n+             *    <param name=\"interceptorStack1.interceptor1.param1\">someValue</param>\n+             *    ...\n+             *  </interceptor-ref>\n+             */\n+            if (interceptorCfgObj instanceof InterceptorConfig) {  //  interceptor-ref param refer to an interceptor\n+                InterceptorConfig cfg = (InterceptorConfig) interceptorCfgObj;\n+                Interceptor interceptor = objectFactory.buildInterceptor(cfg, map);\n+\n+                InterceptorMapping mapping = new InterceptorMapping(key, interceptor);\n+                if (result != null && result.contains(mapping)) {\n+                    // if an existing interceptor mapping exists,\n+                    // we remove from the result Set, just to make sure\n+                    // there's always one unique mapping.\n+                    int index = result.indexOf(mapping);\n+                    result.set(index, mapping);\n+                } else {\n+                    result.add(mapping);\n+                }\n+            } else\n+            if (interceptorCfgObj instanceof InterceptorStackConfig) {  // interceptor-ref param refer to an interceptor stack\n+\n+                // If its an interceptor-stack, we call this method recursively untill,\n+                // all the params (eg. interceptorStack1.interceptor1.param etc.)\n+                // are resolved down to a specific interceptor.\n+\n+                InterceptorStackConfig stackCfg = (InterceptorStackConfig) interceptorCfgObj;\n+                List<InterceptorMapping> tmpResult = constructParameterizedInterceptorReferences(interceptorLocator, stackCfg, map, objectFactory);\n+                for (InterceptorMapping tmpInterceptorMapping : tmpResult) {\n+                    if (result.contains(tmpInterceptorMapping)) {\n+                        int index = result.indexOf(tmpInterceptorMapping);\n+                        result.set(index, tmpInterceptorMapping);\n+                    } else {\n+                        result.add(tmpInterceptorMapping);\n+                    }\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+}"
        },
        {
            "sha": "bd3539860243eed1236ef0b4818c962c8775c3ae",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/providers/XWorkConfigurationProvider.java",
            "status": "added",
            "additions": 120,
            "deletions": 0,
            "changes": 120,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXWorkConfigurationProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXWorkConfigurationProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXWorkConfigurationProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,120 @@\n+package com.opensymphony.xwork2.config.providers;\n+\n+import com.opensymphony.xwork2.ActionProxyFactory;\n+import com.opensymphony.xwork2.DefaultActionProxyFactory;\n+import com.opensymphony.xwork2.DefaultTextProvider;\n+import com.opensymphony.xwork2.DefaultUnknownHandlerManager;\n+import com.opensymphony.xwork2.TextProvider;\n+import com.opensymphony.xwork2.TextProviderSupport;\n+import com.opensymphony.xwork2.UnknownHandlerManager;\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.ConfigurationProvider;\n+import com.opensymphony.xwork2.conversion.NullHandler;\n+import com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\n+import com.opensymphony.xwork2.conversion.impl.DefaultObjectTypeDeterminer;\n+import com.opensymphony.xwork2.conversion.impl.InstantiatingNullHandler;\n+import com.opensymphony.xwork2.conversion.impl.XWorkBasicConverter;\n+import com.opensymphony.xwork2.conversion.impl.XWorkConverter;\n+import com.opensymphony.xwork2.inject.ContainerBuilder;\n+import com.opensymphony.xwork2.inject.Scope;\n+import com.opensymphony.xwork2.ognl.ObjectProxy;\n+import com.opensymphony.xwork2.ognl.OgnlReflectionContextFactory;\n+import com.opensymphony.xwork2.ognl.OgnlReflectionProvider;\n+import com.opensymphony.xwork2.ognl.OgnlUtil;\n+import com.opensymphony.xwork2.ognl.OgnlValueStackFactory;\n+import com.opensymphony.xwork2.ognl.accessor.CompoundRootAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.ObjectAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.ObjectProxyPropertyAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkCollectionPropertyAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkEnumerationAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkIteratorPropertyAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkListPropertyAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkMapPropertyAccessor;\n+import com.opensymphony.xwork2.ognl.accessor.XWorkMethodAccessor;\n+import com.opensymphony.xwork2.util.CompoundRoot;\n+import com.opensymphony.xwork2.util.PatternMatcher;\n+import com.opensymphony.xwork2.util.ValueStackFactory;\n+import com.opensymphony.xwork2.util.WildcardHelper;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+import com.opensymphony.xwork2.util.reflection.ReflectionContextFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+import com.opensymphony.xwork2.validator.ActionValidatorManager;\n+import com.opensymphony.xwork2.validator.AnnotationActionValidatorManager;\n+import com.opensymphony.xwork2.validator.DefaultActionValidatorManager;\n+import com.opensymphony.xwork2.validator.DefaultValidatorFactory;\n+import com.opensymphony.xwork2.validator.DefaultValidatorFileParser;\n+import com.opensymphony.xwork2.validator.ValidatorFactory;\n+import com.opensymphony.xwork2.validator.ValidatorFileParser;\n+import ognl.MethodAccessor;\n+import ognl.PropertyAccessor;\n+\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Enumeration;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.Iterator;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Set;\n+\n+public class XWorkConfigurationProvider implements ConfigurationProvider {\n+\n+    public void destroy() {\n+    }\n+\n+    public void init(Configuration configuration) throws ConfigurationException {\n+    }\n+\n+    public void loadPackages() throws ConfigurationException {\n+    }\n+\n+    public boolean needsReload() {\n+        return false;\n+    }\n+\n+    public void register(ContainerBuilder builder, LocatableProperties props)\n+            throws ConfigurationException {\n+\n+        builder.factory(com.opensymphony.xwork2.ObjectFactory.class)\n+                .factory(ActionProxyFactory.class, DefaultActionProxyFactory.class, Scope.SINGLETON)\n+                .factory(ObjectTypeDeterminer.class, DefaultObjectTypeDeterminer.class, Scope.SINGLETON)\n+                .factory(XWorkConverter.class, Scope.SINGLETON)\n+                .factory(ValueStackFactory.class, OgnlValueStackFactory.class, Scope.SINGLETON)\n+                .factory(ValidatorFactory.class, DefaultValidatorFactory.class, Scope.SINGLETON)\n+                .factory(ValidatorFileParser.class, DefaultValidatorFileParser.class, Scope.SINGLETON)\n+                .factory(PatternMatcher.class, WildcardHelper.class, Scope.SINGLETON)\n+                .factory(ReflectionProvider.class, OgnlReflectionProvider.class, Scope.SINGLETON)\n+                .factory(ReflectionContextFactory.class, OgnlReflectionContextFactory.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, Object.class.getName(), ObjectAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, Iterator.class.getName(), XWorkIteratorPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, Enumeration.class.getName(), XWorkEnumerationAccessor.class, Scope.SINGLETON)\n+                .factory(UnknownHandlerManager.class, DefaultUnknownHandlerManager.class, Scope.SINGLETON)\n+\n+                        // silly workarounds for ognl since there is no way to flush its caches\n+                .factory(PropertyAccessor.class, List.class.getName(), XWorkListPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, ArrayList.class.getName(), XWorkListPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, HashSet.class.getName(), XWorkCollectionPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, Set.class.getName(), XWorkCollectionPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, HashMap.class.getName(), XWorkMapPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, Map.class.getName(), XWorkMapPropertyAccessor.class, Scope.SINGLETON)\n+\n+                .factory(PropertyAccessor.class, Collection.class.getName(), XWorkCollectionPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(PropertyAccessor.class, ObjectProxy.class.getName(), ObjectProxyPropertyAccessor.class, Scope.SINGLETON)\n+                .factory(MethodAccessor.class, Object.class.getName(), XWorkMethodAccessor.class, Scope.SINGLETON)\n+                .factory(MethodAccessor.class, CompoundRoot.class.getName(), CompoundRootAccessor.class, Scope.SINGLETON)\n+                .factory(NullHandler.class, Object.class.getName(), InstantiatingNullHandler.class, Scope.SINGLETON)\n+                .factory(ActionValidatorManager.class, AnnotationActionValidatorManager.class, Scope.SINGLETON)\n+                .factory(ActionValidatorManager.class, \"no-annotations\", DefaultActionValidatorManager.class, Scope.SINGLETON)\n+                .factory(TextProvider.class, \"system\", DefaultTextProvider.class, Scope.SINGLETON)\n+                .factory(TextProvider.class, TextProviderSupport.class, Scope.SINGLETON)\n+                .factory(OgnlUtil.class, Scope.SINGLETON)\n+                .factory(XWorkBasicConverter.class, Scope.SINGLETON);\n+        props.setProperty(\"devMode\", Boolean.FALSE.toString());\n+        props.setProperty(\"logMissingProperties\", Boolean.FALSE.toString());\n+        props.setProperty(\"enableOGNLExpressionCache\", Boolean.TRUE.toString());\n+    }\n+\n+}"
        },
        {
            "sha": "a35faebf8ea333278b6f8cc949b47c0758de2078",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/providers/XmlConfigurationProvider.java",
            "status": "added",
            "additions": 1004,
            "deletions": 0,
            "changes": 1004,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlConfigurationProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlConfigurationProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlConfigurationProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,1004 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.providers;\n+\n+import com.opensymphony.xwork2.Action;\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.XWorkException;\n+import com.opensymphony.xwork2.config.Configuration;\n+import com.opensymphony.xwork2.config.ConfigurationException;\n+import com.opensymphony.xwork2.config.ConfigurationProvider;\n+import com.opensymphony.xwork2.config.ConfigurationUtil;\n+import com.opensymphony.xwork2.config.entities.*;\n+import com.opensymphony.xwork2.config.entities.UnknownHandlerConfig;\n+import com.opensymphony.xwork2.config.impl.LocatableFactory;\n+import com.opensymphony.xwork2.inject.Container;\n+import com.opensymphony.xwork2.inject.ContainerBuilder;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.inject.Scope;\n+import com.opensymphony.xwork2.util.*;\n+import com.opensymphony.xwork2.util.location.LocatableProperties;\n+import com.opensymphony.xwork2.util.location.Location;\n+import com.opensymphony.xwork2.util.location.LocationUtils;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import org.w3c.dom.Document;\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.xml.sax.InputSource;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.reflect.Modifier;\n+import java.net.URL;\n+import java.util.*;\n+\n+\n+/**\n+ * Looks in the classpath for an XML file, \"xwork.xml\" by default,\n+ * and uses it for the XWork configuration.\n+ *\n+ * @author tmjee\n+ * @author Rainer Hermanns\n+ * @author Neo\n+ * @version $Revision$\n+ */\n+public class XmlConfigurationProvider implements ConfigurationProvider {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(XmlConfigurationProvider.class);\n+\n+    private List<Document> documents;\n+    private Set<String> includedFileNames;\n+    private String configFileName;\n+    private ObjectFactory objectFactory;\n+\n+    private Set<String> loadedFileUrls = new HashSet<String>();\n+    private boolean errorIfMissing;\n+    private Map<String, String> dtdMappings;\n+    private Configuration configuration;\n+    private boolean throwExceptionOnDuplicateBeans = true;\n+\n+    public XmlConfigurationProvider() {\n+        this(\"xwork.xml\", true);\n+    }\n+\n+    public XmlConfigurationProvider(String filename) {\n+        this(filename, true);\n+    }\n+\n+    public XmlConfigurationProvider(String filename, boolean errorIfMissing) {\n+        this.configFileName = filename;\n+        this.errorIfMissing = errorIfMissing;\n+\n+        Map<String, String> mappings = new HashMap<String, String>();\n+        mappings.put(\"-//OpenSymphony Group//XWork 2.1.3//EN\", \"xwork-2.1.3.dtd\");\n+        mappings.put(\"-//OpenSymphony Group//XWork 2.1//EN\", \"xwork-2.1.dtd\");\n+        mappings.put(\"-//OpenSymphony Group//XWork 2.0//EN\", \"xwork-2.0.dtd\");\n+        mappings.put(\"-//OpenSymphony Group//XWork 1.1.1//EN\", \"xwork-1.1.1.dtd\");\n+        mappings.put(\"-//OpenSymphony Group//XWork 1.1//EN\", \"xwork-1.1.dtd\");\n+        mappings.put(\"-//OpenSymphony Group//XWork 1.0//EN\", \"xwork-1.0.dtd\");\n+        setDtdMappings(mappings);\n+    }\n+\n+    public void setThrowExceptionOnDuplicateBeans(boolean val) {\n+        this.throwExceptionOnDuplicateBeans = val;\n+    }\n+\n+    public void setDtdMappings(Map<String, String> mappings) {\n+        this.dtdMappings = Collections.unmodifiableMap(mappings);\n+    }\n+\n+    @Inject\n+    public void setObjectFactory(ObjectFactory objectFactory) {\n+        this.objectFactory = objectFactory;\n+    }\n+\n+    /**\n+     * Returns an unmodifiable map of DTD mappings\n+     */\n+    public Map<String, String> getDtdMappings() {\n+        return dtdMappings;\n+    }\n+\n+    public void init(Configuration configuration) {\n+        this.configuration = configuration;\n+        this.includedFileNames = configuration.getLoadedFileNames();\n+        loadDocuments(configFileName);\n+    }\n+\n+    public void destroy() {\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+        if (this == o) {\n+            return true;\n+        }\n+\n+        if (!(o instanceof XmlConfigurationProvider)) {\n+            return false;\n+        }\n+\n+        final XmlConfigurationProvider xmlConfigurationProvider = (XmlConfigurationProvider) o;\n+\n+        if ((configFileName != null) ? (!configFileName.equals(xmlConfigurationProvider.configFileName)) : (xmlConfigurationProvider.configFileName != null)) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+        return ((configFileName != null) ? configFileName.hashCode() : 0);\n+    }\n+\n+    private void loadDocuments(String configFileName) {\n+        try {\n+            loadedFileUrls.clear();\n+            documents = loadConfigurationFiles(configFileName, null);\n+        } catch (ConfigurationException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new ConfigurationException(\"Error loading configuration file \" + configFileName, e);\n+        }\n+    }\n+\n+    public void register(ContainerBuilder containerBuilder, LocatableProperties props) throws ConfigurationException {\n+        LOG.info(\"Parsing configuration file [\" + configFileName + \"]\");\n+        Map<String, Node> loadedBeans = new HashMap<String, Node>();\n+        for (Document doc : documents) {\n+            Element rootElement = doc.getDocumentElement();\n+            NodeList children = rootElement.getChildNodes();\n+            int childSize = children.getLength();\n+\n+            for (int i = 0; i < childSize; i++) {\n+                Node childNode = children.item(i);\n+\n+                if (childNode instanceof Element) {\n+                    Element child = (Element) childNode;\n+\n+                    final String nodeName = child.getNodeName();\n+\n+                    if (\"bean\".equals(nodeName)) {\n+                        String type = child.getAttribute(\"type\");\n+                        String name = child.getAttribute(\"name\");\n+                        String impl = child.getAttribute(\"class\");\n+                        String onlyStatic = child.getAttribute(\"static\");\n+                        String scopeStr = child.getAttribute(\"scope\");\n+                        boolean optional = \"true\".equals(child.getAttribute(\"optional\"));\n+                        Scope scope = Scope.SINGLETON;\n+                        if (\"default\".equals(scopeStr)) {\n+                            scope = Scope.DEFAULT;\n+                        } else if (\"request\".equals(scopeStr)) {\n+                            scope = Scope.REQUEST;\n+                        } else if (\"session\".equals(scopeStr)) {\n+                            scope = Scope.SESSION;\n+                        } else if (\"singleton\".equals(scopeStr)) {\n+                            scope = Scope.SINGLETON;\n+                        } else if (\"thread\".equals(scopeStr)) {\n+                            scope = Scope.THREAD;\n+                        }\n+\n+                        if (StringUtils.isEmpty(name)) {\n+                            name = Container.DEFAULT_NAME;\n+                        }\n+\n+                        try {\n+                            Class cimpl = ClassLoaderUtil.loadClass(impl, getClass());\n+                            Class ctype = cimpl;\n+                            if (StringUtils.isNotEmpty(type)) {\n+                                ctype = ClassLoaderUtil.loadClass(type, getClass());\n+                            }\n+                            if (\"true\".equals(onlyStatic)) {\n+                                // Force loading of class to detect no class def found exceptions\n+                                cimpl.getDeclaredClasses();\n+                                containerBuilder.injectStatics(cimpl);\n+                            } else {\n+                                if (containerBuilder.contains(ctype, name)) {\n+                                    Location loc = LocationUtils.getLocation(loadedBeans.get(ctype.getName() + name));\n+                                    if (throwExceptionOnDuplicateBeans) {\n+                                        throw new ConfigurationException(\"Bean type \" + ctype + \" with the name \" +\n+                                                name + \" has already been loaded by \" + loc, child);\n+                                    }\n+                                }\n+\n+                                // Force loading of class to detect no class def found exceptions\n+                                cimpl.getDeclaredConstructors();\n+\n+                                if (LOG.isDebugEnabled()) {\n+                                    LOG.debug(\"Loaded type:\" + type + \" name:\" + name + \" impl:\" + impl);\n+                                }\n+                                containerBuilder.factory(ctype, name, new LocatableFactory(name, ctype, cimpl, scope, childNode), scope);\n+                            }\n+                            loadedBeans.put(ctype.getName() + name, child);\n+                        } catch (Throwable ex) {\n+                            if (!optional) {\n+                                throw new ConfigurationException(\"Unable to load bean: type:\" + type + \" class:\" + impl, ex, childNode);\n+                            } else {\n+                                LOG.debug(\"Unable to load optional class: \" + ex);\n+                            }\n+                        }\n+                    } else if (\"constant\".equals(nodeName)) {\n+                        String name = child.getAttribute(\"name\");\n+                        String value = child.getAttribute(\"value\");\n+                        props.setProperty(name, value, childNode);\n+                    } else if (nodeName.equals(\"unknown-handler-stack\")) {\n+                        List<UnknownHandlerConfig> unknownHandlerStack = new ArrayList<UnknownHandlerConfig>();\n+                        NodeList unknownHandlers = child.getElementsByTagName(\"unknown-handler-ref\");\n+                        int unknownHandlersSize = unknownHandlers.getLength();\n+\n+                        for (int k = 0; k < unknownHandlersSize; k++) {\n+                            Element unknownHandler = (Element) unknownHandlers.item(k);\n+                            unknownHandlerStack.add(new UnknownHandlerConfig(unknownHandler.getAttribute(\"name\")));\n+                        }\n+\n+                        if (!unknownHandlerStack.isEmpty())\n+                            configuration.setUnknownHandlerStack(unknownHandlerStack);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    public void loadPackages() throws ConfigurationException {\n+        List<Element> reloads = new ArrayList<Element>();\n+        for (Document doc : documents) {\n+            Element rootElement = doc.getDocumentElement();\n+            NodeList children = rootElement.getChildNodes();\n+            int childSize = children.getLength();\n+\n+            for (int i = 0; i < childSize; i++) {\n+                Node childNode = children.item(i);\n+\n+                if (childNode instanceof Element) {\n+                    Element child = (Element) childNode;\n+\n+                    final String nodeName = child.getNodeName();\n+\n+                    if (\"package\".equals(nodeName)) {\n+                        PackageConfig cfg = addPackage(child);\n+                        if (cfg.isNeedsRefresh()) {\n+                            reloads.add(child);\n+                        }\n+                    }\n+                }\n+            }\n+            loadExtraConfiguration(doc);\n+        }\n+\n+        if (reloads.size() > 0) {\n+            reloadRequiredPackages(reloads);\n+        }\n+\n+        for (Document doc : documents) {\n+            loadExtraConfiguration(doc);\n+        }\n+\n+        documents.clear();\n+        configuration = null;\n+    }\n+\n+    private void reloadRequiredPackages(List<Element> reloads) {\n+        if (reloads.size() > 0) {\n+            List<Element> result = new ArrayList<Element>();\n+            for (Element pkg : reloads) {\n+                PackageConfig cfg = addPackage(pkg);\n+                if (cfg.isNeedsRefresh()) {\n+                    result.add(pkg);\n+                }\n+            }\n+            if ((result.size() > 0) && (result.size() != reloads.size())) {\n+                reloadRequiredPackages(result);\n+                return;\n+            }\n+\n+            // Print out error messages for all misconfigured inheritence packages\n+            if (result.size() > 0) {\n+                for (Element rp : result) {\n+                    String parent = rp.getAttribute(\"extends\");\n+                    if (parent != null) {\n+                        List<PackageConfig> parents = ConfigurationUtil.buildParentsFromString(configuration, parent);\n+                        if (parents != null && parents.size() <= 0) {\n+                            LOG.error(\"Unable to find parent packages \" + parent);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Tells whether the ConfigurationProvider should reload its configuration. This method should only be called\n+     * if ConfigurationManager.isReloadingConfigs() is true.\n+     *\n+     * @return true if the file has been changed since the last time we read it\n+     */\n+    public boolean needsReload() {\n+\n+        for (String url : loadedFileUrls) {\n+            if (FileManager.fileNeedsReloading(url)) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    protected void addAction(Element actionElement, PackageConfig.Builder packageContext) throws ConfigurationException {\n+        String name = actionElement.getAttribute(\"name\");\n+        String className = actionElement.getAttribute(\"class\");\n+        String methodName = actionElement.getAttribute(\"method\");\n+        Location location = DomHelper.getLocationObject(actionElement);\n+\n+        if (location == null) {\n+            LOG.warn(\"location null for \" + className);\n+        }\n+        //methodName should be null if it's not set\n+        methodName = (methodName.trim().length() > 0) ? methodName.trim() : null;\n+\n+        // if there isnt a class name specified for an <action/> then try to\n+        // use the default-class-ref from the <package/>\n+        if (StringUtils.isEmpty(className)) {\n+            // if there is a package default-class-ref use that, otherwise use action support\n+           /* if (StringUtils.isNotEmpty(packageContext.getDefaultClassRef())) {\n+                className = packageContext.getDefaultClassRef();\n+            } else {\n+                className = ActionSupport.class.getName();\n+            }*/\n+\n+        } else {\n+            if (!verifyAction(className, name, location)) {\n+                if (LOG.isErrorEnabled())\n+                    LOG.error(\"Unable to verify action [#0] with class [#1], from [#2]\", name, className, location.toString());\n+                return;\n+            }\n+        }\n+\n+\n+\n+        Map<String, ResultConfig> results;\n+        try {\n+            results = buildResults(actionElement, packageContext);\n+        } catch (ConfigurationException e) {\n+            throw new ConfigurationException(\"Error building results for action \" + name + \" in namespace \" + packageContext.getNamespace(), e, actionElement);\n+        }\n+\n+        List<InterceptorMapping> interceptorList = buildInterceptorList(actionElement, packageContext);\n+\n+        List<ExceptionMappingConfig> exceptionMappings = buildExceptionMappings(actionElement, packageContext);\n+\n+        ActionConfig actionConfig = new ActionConfig.Builder(packageContext.getName(), name, className)\n+                .methodName(methodName)\n+                .addResultConfigs(results)\n+                .addInterceptors(interceptorList)\n+                .addExceptionMappings(exceptionMappings)\n+                .addParams(XmlHelper.getParams(actionElement))\n+                .location(location)\n+                .build();\n+        packageContext.addActionConfig(name, actionConfig);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Loaded \" + (StringUtils.isNotEmpty(packageContext.getNamespace()) ? (packageContext.getNamespace() + \"/\") : \"\") + name + \" in '\" + packageContext.getName() + \"' package:\" + actionConfig);\n+        }\n+    }\n+\n+    protected boolean verifyAction(String className, String name, Location loc) {\n+        if (className.indexOf('{') > -1) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Action class [\" + className + \"] contains a wildcard \" +\n+                        \"replacement value, so it can't be verified\");\n+            }\n+            return true;\n+        }\n+        try {\n+            if (objectFactory.isNoArgConstructorRequired()) {\n+                Class clazz = objectFactory.getClassInstance(className);\n+                if (!Modifier.isPublic(clazz.getModifiers())) {\n+                    throw new ConfigurationException(\"Action class [\" + className + \"] is not public\", loc);\n+                }\n+                clazz.getConstructor(new Class[]{});\n+            }\n+        } catch (ClassNotFoundException e) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Class not found for action [\" + className + \"]\", e);\n+            }\n+            throw new ConfigurationException(\"Action class [\" + className + \"] not found\", loc);\n+        } catch (NoSuchMethodException e) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"No constructor found for action [\" + className + \"]\", e);\n+            }\n+            throw new ConfigurationException(\"Action class [\" + className + \"] does not have a public no-arg constructor\", e, loc);\n+        } catch (RuntimeException ex) {\n+            // Probably not a big deal, like request or session-scoped Spring 2 beans that need a real request\n+            LOG.info(\"Unable to verify action class [\" + className + \"] exists at initialization\");\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Action verification cause\", ex);\n+            }\n+        } catch (Exception ex) {\n+            // Default to failing fast\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Unable to verify action class [\" + className + \"]\", ex);\n+            }\n+            throw new ConfigurationException(ex, loc);\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Create a PackageConfig from an XML element representing it.\n+     */\n+    protected PackageConfig addPackage(Element packageElement) throws ConfigurationException {\n+        PackageConfig.Builder newPackage = buildPackageContext(packageElement);\n+\n+        if (newPackage.isNeedsRefresh()) {\n+            return newPackage.build();\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Loaded \" + newPackage);\n+        }\n+\n+        // add result types (and default result) to this package\n+        addResultTypes(newPackage, packageElement);\n+\n+        // load the interceptors and interceptor stacks for this package\n+        loadInterceptors(newPackage, packageElement);\n+\n+        // load the default interceptor reference for this package\n+        loadDefaultInterceptorRef(newPackage, packageElement);\n+\n+        // load the default class ref for this package\n+        loadDefaultClassRef(newPackage, packageElement);\n+\n+        // load the global result list for this package\n+        loadGlobalResults(newPackage, packageElement);\n+\n+        // load the global exception handler list for this package\n+        loadGobalExceptionMappings(newPackage, packageElement);\n+\n+        // get actions\n+        NodeList actionList = packageElement.getElementsByTagName(\"action\");\n+\n+        for (int i = 0; i < actionList.getLength(); i++) {\n+            Element actionElement = (Element) actionList.item(i);\n+            addAction(actionElement, newPackage);\n+        }\n+\n+        // load the default action reference for this package\n+        loadDefaultActionRef(newPackage, packageElement);\n+\n+        PackageConfig cfg = newPackage.build();\n+        configuration.addPackageConfig(cfg.getName(), cfg);\n+        return cfg;\n+    }\n+\n+    protected void addResultTypes(PackageConfig.Builder packageContext, Element element) {\n+        NodeList resultTypeList = element.getElementsByTagName(\"result-type\");\n+\n+        for (int i = 0; i < resultTypeList.getLength(); i++) {\n+            Element resultTypeElement = (Element) resultTypeList.item(i);\n+            String name = resultTypeElement.getAttribute(\"name\");\n+            String className = resultTypeElement.getAttribute(\"class\");\n+            String def = resultTypeElement.getAttribute(\"default\");\n+\n+            Location loc = DomHelper.getLocationObject(resultTypeElement);\n+\n+            Class clazz = verifyResultType(className, loc);\n+            if (clazz != null) {\n+                String paramName = null;\n+                try {\n+                    paramName = (String) clazz.getField(\"DEFAULT_PARAM\").get(null);\n+                }\n+                catch (Throwable t) {\n+                    // if we get here, the result type doesn't have a default param defined.\n+                }\n+                ResultTypeConfig.Builder resultType = new ResultTypeConfig.Builder(name, className).defaultResultParam(paramName)\n+                        .location(DomHelper.getLocationObject(resultTypeElement));\n+\n+                Map<String, String> params = XmlHelper.getParams(resultTypeElement);\n+\n+                if (!params.isEmpty()) {\n+                    resultType.addParams(params);\n+                }\n+                packageContext.addResultTypeConfig(resultType.build());\n+\n+                // set the default result type\n+                if (\"true\".equals(def)) {\n+                    packageContext.defaultResultType(name);\n+                }\n+            }\n+        }\n+    }\n+\n+    protected Class verifyResultType(String className, Location loc) {\n+        try {\n+            return objectFactory.getClassInstance(className);\n+        } catch (ClassNotFoundException e) {\n+            LOG.warn(\"Result class [\" + className + \"] doesn't exist (ClassNotFoundException) at \" +\n+                    loc.toString() + \", ignoring\", e);\n+        } catch (NoClassDefFoundError e) {\n+            LOG.warn(\"Result class [\" + className + \"] doesn't exist (NoClassDefFoundError) at \" +\n+                    loc.toString() + \", ignoring\", e);\n+        }\n+\n+        return null;\n+    }\n+\n+    protected List<InterceptorMapping> buildInterceptorList(Element element, PackageConfig.Builder context) throws ConfigurationException {\n+        List<InterceptorMapping> interceptorList = new ArrayList<InterceptorMapping>();\n+        NodeList interceptorRefList = element.getElementsByTagName(\"interceptor-ref\");\n+\n+        for (int i = 0; i < interceptorRefList.getLength(); i++) {\n+            Element interceptorRefElement = (Element) interceptorRefList.item(i);\n+\n+            if (interceptorRefElement.getParentNode().equals(element) || interceptorRefElement.getParentNode().getNodeName().equals(element.getNodeName())) {\n+                List<InterceptorMapping> interceptors = lookupInterceptorReference(context, interceptorRefElement);\n+                interceptorList.addAll(interceptors);\n+            }\n+        }\n+\n+        return interceptorList;\n+    }\n+\n+    /**\n+     * This method builds a package context by looking for the parents of this new package.\n+     * <p/>\n+     * If no parents are found, it will return a root package.\n+     */\n+    protected PackageConfig.Builder buildPackageContext(Element packageElement) {\n+        String parent = packageElement.getAttribute(\"extends\");\n+        String abstractVal = packageElement.getAttribute(\"abstract\");\n+        boolean isAbstract = Boolean.valueOf(abstractVal).booleanValue();\n+        String name = StringUtils.defaultString(packageElement.getAttribute(\"name\"));\n+        String namespace = StringUtils.defaultString(packageElement.getAttribute(\"namespace\"));\n+\n+\n+        if (StringUtils.isNotEmpty(packageElement.getAttribute(\"externalReferenceResolver\"))) {\n+            throw new ConfigurationException(\"The 'externalReferenceResolver' attribute has been removed.  Please use \" +\n+                    \"a custom ObjectFactory or Interceptor.\", packageElement);\n+        }\n+\n+        PackageConfig.Builder cfg = new PackageConfig.Builder(name)\n+                .namespace(namespace)\n+                .isAbstract(isAbstract)\n+                .location(DomHelper.getLocationObject(packageElement));\n+\n+\n+        if (StringUtils.isNotEmpty(StringUtils.defaultString(parent))) { // has parents, let's look it up\n+\n+            List<PackageConfig> parents = ConfigurationUtil.buildParentsFromString(configuration, parent);\n+\n+            if (parents.size() <= 0) {\n+                cfg.needsRefresh(true);\n+            } else {\n+                cfg.addParents(parents);\n+            }\n+        }\n+\n+        return cfg;\n+    }\n+\n+    /**\n+     * Build a map of ResultConfig objects from below a given XML element.\n+     */\n+    protected Map<String, ResultConfig> buildResults(Element element, PackageConfig.Builder packageContext) {\n+        NodeList resultEls = element.getElementsByTagName(\"result\");\n+\n+        Map<String, ResultConfig> results = new LinkedHashMap<String, ResultConfig>();\n+\n+        for (int i = 0; i < resultEls.getLength(); i++) {\n+            Element resultElement = (Element) resultEls.item(i);\n+\n+            if (resultElement.getParentNode().equals(element) || resultElement.getParentNode().getNodeName().equals(element.getNodeName())) {\n+                String resultName = resultElement.getAttribute(\"name\");\n+                String resultType = resultElement.getAttribute(\"type\");\n+\n+                // if you don't specify a name on <result/>, it defaults to \"success\"\n+                if (StringUtils.isEmpty(resultName)) {\n+                    resultName = Action.SUCCESS;\n+                }\n+\n+                // there is no result type, so let's inherit from the parent package\n+                if (StringUtils.isEmpty(resultType)) {\n+                    resultType = packageContext.getFullDefaultResultType();\n+\n+                    // now check if there is a result type now\n+                    if (StringUtils.isEmpty(resultType)) {\n+                        // uh-oh, we have a problem\n+                        throw new ConfigurationException(\"No result type specified for result named '\"\n+                                + resultName + \"', perhaps the parent package does not specify the result type?\", resultElement);\n+                    }\n+                }\n+\n+\n+                ResultTypeConfig config = packageContext.getResultType(resultType);\n+\n+                if (config == null) {\n+                    throw new ConfigurationException(\"There is no result type defined for type '\" + resultType\n+                            + \"' mapped with name '\" + resultName + \"'.\"\n+                            + \"  Did you mean '\" + guessResultType(resultType) + \"'?\", resultElement);\n+                }\n+\n+                String resultClass = config.getClazz();\n+\n+                // invalid result type specified in result definition\n+                if (resultClass == null) {\n+                    throw new ConfigurationException(\"Result type '\" + resultType + \"' is invalid\");\n+                }\n+\n+                Map<String, String> resultParams = XmlHelper.getParams(resultElement);\n+\n+                if (resultParams.size() == 0) // maybe we just have a body - therefore a default parameter\n+                {\n+                    // if <result ...>something</result> then we add a parameter of 'something' as this is the most used result param\n+                    if (resultElement.getChildNodes().getLength() >= 1) {\n+                        resultParams = new LinkedHashMap<String, String>();\n+\n+                        String paramName = config.getDefaultResultParam();\n+                        if (paramName != null) {\n+                            StringBuilder paramValue = new StringBuilder();\n+                            for (int j = 0; j < resultElement.getChildNodes().getLength(); j++) {\n+                                if (resultElement.getChildNodes().item(j).getNodeType() == Node.TEXT_NODE) {\n+                                    String val = resultElement.getChildNodes().item(j).getNodeValue();\n+                                    if (val != null) {\n+                                        paramValue.append(val);\n+                                    }\n+                                }\n+                            }\n+                            String val = paramValue.toString().trim();\n+                            if (val.length() > 0) {\n+                                resultParams.put(paramName, val);\n+                            }\n+                        } else {\n+                            LOG.warn(\"no default parameter defined for result of type \" + config.getName());\n+                        }\n+                    }\n+                }\n+\n+                // create new param map, so that the result param can override the config param\n+                Map<String, String> params = new LinkedHashMap<String, String>();\n+                Map<String, String> configParams = config.getParams();\n+                if (configParams != null) {\n+                    params.putAll(configParams);\n+                }\n+                params.putAll(resultParams);\n+\n+                ResultConfig resultConfig = new ResultConfig.Builder(resultName, resultClass)\n+                        .addParams(params)\n+                        .location(DomHelper.getLocationObject(element))\n+                        .build();\n+                results.put(resultConfig.getName(), resultConfig);\n+            }\n+        }\n+\n+        return results;\n+    }\n+\n+    protected String guessResultType(String type) {\n+        StringBuilder sb = null;\n+        if (type != null) {\n+            sb = new StringBuilder();\n+            boolean capNext = false;\n+            for (int x=0; x<type.length(); x++) {\n+                char c = type.charAt(x);\n+                if (c == '-') {\n+                    capNext = true;\n+                    continue;\n+                } else if (Character.isLowerCase(c) && capNext) {\n+                    c = Character.toUpperCase(c);\n+                    capNext = false;\n+                }\n+                sb.append(c);\n+            }\n+        }\n+        return (sb != null ? sb.toString() : null);\n+    }\n+\n+    /**\n+     * Build a map of ResultConfig objects from below a given XML element.\n+     */\n+    protected List<ExceptionMappingConfig> buildExceptionMappings(Element element, PackageConfig.Builder packageContext) {\n+        NodeList exceptionMappingEls = element.getElementsByTagName(\"exception-mapping\");\n+\n+        List<ExceptionMappingConfig> exceptionMappings = new ArrayList<ExceptionMappingConfig>();\n+\n+        for (int i = 0; i < exceptionMappingEls.getLength(); i++) {\n+            Element ehElement = (Element) exceptionMappingEls.item(i);\n+\n+            if (ehElement.getParentNode().equals(element) || ehElement.getParentNode().getNodeName().equals(element.getNodeName())) {\n+                String emName = ehElement.getAttribute(\"name\");\n+                String exceptionClassName = ehElement.getAttribute(\"exception\");\n+                String exceptionResult = ehElement.getAttribute(\"result\");\n+\n+                Map<String, String> params = XmlHelper.getParams(ehElement);\n+\n+                if (StringUtils.isEmpty(emName)) {\n+                    emName = exceptionResult;\n+                }\n+\n+                ExceptionMappingConfig ehConfig = new ExceptionMappingConfig.Builder(emName, exceptionClassName, exceptionResult)\n+                        .addParams(params)\n+                        .location(DomHelper.getLocationObject(ehElement))\n+                        .build();\n+                exceptionMappings.add(ehConfig);\n+            }\n+        }\n+\n+        return exceptionMappings;\n+    }\n+\n+\n+    protected void loadDefaultInterceptorRef(PackageConfig.Builder packageContext, Element element) {\n+        NodeList resultTypeList = element.getElementsByTagName(\"default-interceptor-ref\");\n+\n+        if (resultTypeList.getLength() > 0) {\n+            Element defaultRefElement = (Element) resultTypeList.item(0);\n+            packageContext.defaultInterceptorRef(defaultRefElement.getAttribute(\"name\"));\n+        }\n+    }\n+\n+    protected void loadDefaultActionRef(PackageConfig.Builder packageContext, Element element) {\n+        NodeList resultTypeList = element.getElementsByTagName(\"default-action-ref\");\n+\n+        if (resultTypeList.getLength() > 0) {\n+            Element defaultRefElement = (Element) resultTypeList.item(0);\n+            packageContext.defaultActionRef(defaultRefElement.getAttribute(\"name\"));\n+        }\n+    }\n+\n+    /**\n+     * Load all of the global results for this package from the XML element.\n+     */\n+    protected void loadGlobalResults(PackageConfig.Builder packageContext, Element packageElement) {\n+        NodeList globalResultList = packageElement.getElementsByTagName(\"global-results\");\n+\n+        if (globalResultList.getLength() > 0) {\n+            Element globalResultElement = (Element) globalResultList.item(0);\n+            Map<String, ResultConfig> results = buildResults(globalResultElement, packageContext);\n+            packageContext.addGlobalResultConfigs(results);\n+        }\n+    }\n+\n+    protected void loadDefaultClassRef(PackageConfig.Builder packageContext, Element element) {\n+        NodeList defaultClassRefList = element.getElementsByTagName(\"default-class-ref\");\n+        if (defaultClassRefList.getLength() > 0) {\n+            Element defaultClassRefElement = (Element) defaultClassRefList.item(0);\n+            packageContext.defaultClassRef(defaultClassRefElement.getAttribute(\"class\"));\n+        }\n+    }\n+\n+    /**\n+     * Load all of the global results for this package from the XML element.\n+     */\n+    protected void loadGobalExceptionMappings(PackageConfig.Builder packageContext, Element packageElement) {\n+        NodeList globalExceptionMappingList = packageElement.getElementsByTagName(\"global-exception-mappings\");\n+\n+        if (globalExceptionMappingList.getLength() > 0) {\n+            Element globalExceptionMappingElement = (Element) globalExceptionMappingList.item(0);\n+            List<ExceptionMappingConfig> exceptionMappings = buildExceptionMappings(globalExceptionMappingElement, packageContext);\n+            packageContext.addGlobalExceptionMappingConfigs(exceptionMappings);\n+        }\n+    }\n+\n+    //    protected void loadIncludes(Element rootElement, DocumentBuilder db) throws Exception {\n+    //        NodeList includeList = rootElement.getElementsByTagName(\"include\");\n+    //\n+    //        for (int i = 0; i < includeList.getLength(); i++) {\n+    //            Element includeElement = (Element) includeList.item(i);\n+    //            String fileName = includeElement.getAttribute(\"file\");\n+    //            includedFileNames.add(fileName);\n+    //            loadConfigurationFile(fileName, db);\n+    //        }\n+    //    }\n+    protected InterceptorStackConfig loadInterceptorStack(Element element, PackageConfig.Builder context) throws ConfigurationException {\n+        String name = element.getAttribute(\"name\");\n+\n+        InterceptorStackConfig.Builder config = new InterceptorStackConfig.Builder(name)\n+                .location(DomHelper.getLocationObject(element));\n+        NodeList interceptorRefList = element.getElementsByTagName(\"interceptor-ref\");\n+\n+        for (int j = 0; j < interceptorRefList.getLength(); j++) {\n+            Element interceptorRefElement = (Element) interceptorRefList.item(j);\n+            List<InterceptorMapping> interceptors = lookupInterceptorReference(context, interceptorRefElement);\n+            config.addInterceptors(interceptors);\n+        }\n+\n+        return config.build();\n+    }\n+\n+    protected void loadInterceptorStacks(Element element, PackageConfig.Builder context) throws ConfigurationException {\n+        NodeList interceptorStackList = element.getElementsByTagName(\"interceptor-stack\");\n+\n+        for (int i = 0; i < interceptorStackList.getLength(); i++) {\n+            Element interceptorStackElement = (Element) interceptorStackList.item(i);\n+\n+            InterceptorStackConfig config = loadInterceptorStack(interceptorStackElement, context);\n+\n+            context.addInterceptorStackConfig(config);\n+        }\n+    }\n+\n+    protected void loadInterceptors(PackageConfig.Builder context, Element element) throws ConfigurationException {\n+        NodeList interceptorList = element.getElementsByTagName(\"interceptor\");\n+\n+        for (int i = 0; i < interceptorList.getLength(); i++) {\n+            Element interceptorElement = (Element) interceptorList.item(i);\n+            String name = interceptorElement.getAttribute(\"name\");\n+            String className = interceptorElement.getAttribute(\"class\");\n+\n+            Map<String, String> params = XmlHelper.getParams(interceptorElement);\n+            InterceptorConfig config = new InterceptorConfig.Builder(name, className)\n+                    .addParams(params)\n+                    .location(DomHelper.getLocationObject(interceptorElement))\n+                    .build();\n+\n+            context.addInterceptorConfig(config);\n+        }\n+\n+        loadInterceptorStacks(element, context);\n+    }\n+\n+    //    protected void loadPackages(Element rootElement) throws ConfigurationException {\n+    //        NodeList packageList = rootElement.getElementsByTagName(\"package\");\n+    //\n+    //        for (int i = 0; i < packageList.getLength(); i++) {\n+    //            Element packageElement = (Element) packageList.item(i);\n+    //            addPackage(packageElement);\n+    //        }\n+    //    }\n+    private List<Document> loadConfigurationFiles(String fileName, Element includeElement) {\n+        List<Document> docs = new ArrayList<Document>();\n+        List<Document> finalDocs = new ArrayList<Document>();\n+        if (!includedFileNames.contains(fileName)) {\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Loading action configurations from: \" + fileName);\n+            }\n+\n+            includedFileNames.add(fileName);\n+\n+            Iterator<URL> urls = null;\n+            InputStream is = null;\n+\n+            IOException ioException = null;\n+            try {\n+                urls = getConfigurationUrls(fileName);\n+            } catch (IOException ex) {\n+                ioException = ex;\n+            }\n+\n+            if (urls == null || !urls.hasNext()) {\n+                if (errorIfMissing) {\n+                    throw new ConfigurationException(\"Could not open files of the name \" + fileName, ioException);\n+                } else {\n+                    LOG.info(\"Unable to locate configuration files of the name \"\n+                            + fileName + \", skipping\");\n+                    return docs;\n+                }\n+            }\n+\n+            URL url = null;\n+            while (urls.hasNext()) {\n+                try {\n+                    url = urls.next();\n+                    is = FileManager.loadFile(url);\n+\n+                    InputSource in = new InputSource(is);\n+\n+                    in.setSystemId(url.toString());\n+\n+                    docs.add(DomHelper.parse(in, dtdMappings));\n+                } catch (XWorkException e) {\n+                    if (includeElement != null) {\n+                        throw new ConfigurationException(\"Unable to load \" + url, e, includeElement);\n+                    } else {\n+                        throw new ConfigurationException(\"Unable to load \" + url, e);\n+                    }\n+                } catch (Exception e) {\n+                    final String s = \"Caught exception while loading file \" + fileName;\n+                    throw new ConfigurationException(s, e, includeElement);\n+                } finally {\n+                    if (is != null) {\n+                        try {\n+                            is.close();\n+                        } catch (IOException e) {\n+                            LOG.error(\"Unable to close input stream\", e);\n+                        }\n+                    }\n+                }\n+            }\n+\n+            //sort the documents, according to the \"order\" attribute\n+            Collections.sort(docs, new Comparator<Document>() {\n+                public int compare(Document doc1, Document doc2) {\n+                    return XmlHelper.getLoadOrder(doc1).compareTo(XmlHelper.getLoadOrder(doc2));\n+                }\n+            });\n+\n+            for (Document doc : docs) {\n+                Element rootElement = doc.getDocumentElement();\n+                NodeList children = rootElement.getChildNodes();\n+                int childSize = children.getLength();\n+\n+                for (int i = 0; i < childSize; i++) {\n+                    Node childNode = children.item(i);\n+\n+                    if (childNode instanceof Element) {\n+                        Element child = (Element) childNode;\n+\n+                        final String nodeName = child.getNodeName();\n+\n+                        if (\"include\".equals(nodeName)) {\n+                            String includeFileName = child.getAttribute(\"file\");\n+                            if (includeFileName.indexOf('*') != -1) {\n+                                // handleWildCardIncludes(includeFileName, docs, child);\n+                                ClassPathFinder wildcardFinder = new ClassPathFinder();\n+                                wildcardFinder.setPattern(includeFileName);\n+                                Vector<String> wildcardMatches = wildcardFinder.findMatches();\n+                                for (String match : wildcardMatches) {\n+                                    finalDocs.addAll(loadConfigurationFiles(match, child));\n+                                }\n+                            } else {\n+                                finalDocs.addAll(loadConfigurationFiles(includeFileName, child));\n+                            }\n+                        }\n+                    }\n+                }\n+                finalDocs.add(doc);\n+                loadedFileUrls.add(url.toString());\n+            }\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Loaded action configuration from: \" + fileName);\n+            }\n+        }\n+        return finalDocs;\n+    }\n+\n+    protected Iterator<URL> getConfigurationUrls(String fileName) throws IOException {\n+        return ClassLoaderUtil.getResources(fileName, XmlConfigurationProvider.class, false);\n+    }\n+\n+    /**\n+     * Allows subclasses to load extra information from the document\n+     *\n+     * @param doc The configuration document\n+     */\n+    protected void loadExtraConfiguration(Document doc) {\n+        // no op\n+    }\n+\n+    /**\n+     * Looks up the Interceptor Class from the interceptor-ref name and creates an instance, which is added to the\n+     * provided List, or, if this is a ref to a stack, it adds the Interceptor instances from the List to this stack.\n+     *\n+     * @param interceptorRefElement Element to pull interceptor ref data from\n+     * @param context               The PackageConfig to lookup the interceptor from\n+     * @return A list of Interceptor objects\n+     */\n+    private List<InterceptorMapping> lookupInterceptorReference(PackageConfig.Builder context, Element interceptorRefElement) throws ConfigurationException {\n+        String refName = interceptorRefElement.getAttribute(\"name\");\n+        Map<String, String> refParams = XmlHelper.getParams(interceptorRefElement);\n+\n+        Location loc = LocationUtils.getLocation(interceptorRefElement);\n+        return InterceptorBuilder.constructInterceptorReference(context, refName, refParams, loc, objectFactory);\n+    }\n+\n+    List<Document> getDocuments() {\n+        return documents;\n+    }\n+}"
        },
        {
            "sha": "7dd24e6f4c054068c10ed61c047a7e29878562a1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/providers/XmlHelper.java",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlHelper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlHelper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2FXmlHelper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,128 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.config.providers;\n+\n+import org.w3c.dom.Element;\n+import org.w3c.dom.Node;\n+import org.w3c.dom.NodeList;\n+import org.w3c.dom.Document;\n+import org.apache.commons.lang.StringUtils;\n+\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * XML utilities.\n+ *\n+ * @author Mike\n+ */\n+public class XmlHelper {\n+\n+\n+    /**\n+     * This method will find all the parameters under this <code>paramsElement</code> and return them as\n+     * Map<String, String>. For example,\n+     * <pre>\n+     *   <result ... >\n+     *      <param name=\"param1\">value1</param>\n+     *      <param name=\"param2\">value2</param>\n+     *      <param name=\"param3\">value3</param>\n+     *   </result>\n+     * </pre>\n+     * will returns a Map<String, String> with the following key, value pairs :-\n+     * <ul>\n+     * <li>param1 - value1</li>\n+     * <li>param2 - value2</li>\n+     * <li>param3 - value3</li>\n+     * </ul>\n+     *\n+     * @param paramsElement\n+     * @return\n+     */\n+    public static Map<String, String> getParams(Element paramsElement) {\n+        LinkedHashMap<String, String> params = new LinkedHashMap<String, String>();\n+\n+        if (paramsElement == null) {\n+            return params;\n+        }\n+\n+        NodeList childNodes = paramsElement.getChildNodes();\n+\n+        for (int i = 0; i < childNodes.getLength(); i++) {\n+            Node childNode = childNodes.item(i);\n+\n+            if ((childNode.getNodeType() == Node.ELEMENT_NODE) && \"param\".equals(childNode.getNodeName())) {\n+                Element paramElement = (Element) childNode;\n+                String paramName = paramElement.getAttribute(\"name\");\n+\n+                String val = getContent(paramElement);\n+                if (val.length() > 0) {\n+                    params.put(paramName, val);\n+                }\n+            }\n+        }\n+\n+        return params;\n+    }\n+\n+    /**\n+     * This method will return the content of this particular <code>element</code>.\n+     * For example,\n+     * <p/>\n+     * <pre>\n+     *    <result>something_1</result>\n+     * </pre>\n+     * When the {@link org.w3c.dom.Element} <code>&lt;result&gt;</code> is passed in as\n+     * argument (<code>element</code> to this method, it returns the content of it,\n+     * namely, <code>something_1</code> in the example above.\n+     *\n+     * @return\n+     */\n+    public static String getContent(Element element) {\n+        StringBuilder paramValue = new StringBuilder();\n+        NodeList childNodes = element.getChildNodes();\n+        for (int j = 0; j < childNodes.getLength(); j++) {\n+            Node currentNode = childNodes.item(j);\n+            if (currentNode != null &&\n+                    currentNode.getNodeType() == Node.TEXT_NODE) {\n+                String val = currentNode.getNodeValue();\n+                if (val != null) {\n+                    paramValue.append(val.trim());\n+                }\n+            }\n+        }\n+        return paramValue.toString().trim();\n+    }\n+\n+    /**\n+     * Return the value of the \"order\" attribute from the root element\n+     */\n+     public static Integer getLoadOrder(Document doc) {\n+        Element rootElement = doc.getDocumentElement();\n+        String number = rootElement.getAttribute(\"order\");\n+        if (StringUtils.isNotBlank(number)) {\n+            try {\n+                return Integer.parseInt(number);\n+            } catch (NumberFormatException e) {\n+                return Integer.MAX_VALUE;\n+            }\n+        } else {\n+            //no order specified\n+            return Integer.MAX_VALUE;\n+        }\n+    }\n+}"
        },
        {
            "sha": "946fc4ef8ad18d63da4e4dabb17f43255e2a04a6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/config/providers/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconfig%2Fproviders%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Configuration provider classes.</body>"
        },
        {
            "sha": "86d71f0d2cc07f166dbbd7870575733db8a0dd01",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/NullHandler.java",
            "status": "added",
            "additions": 54,
            "deletions": 0,
            "changes": 54,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FNullHandler.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FNullHandler.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FNullHandler.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,54 @@\n+//--------------------------------------------------------------------------\n+//Copyright (c) 1998-2004, Drew Davidson and Luke Blanshard\n+//All rights reserved.\n+//\n+//Redistribution and use in source and binary forms, with or without\n+//modification, are permitted provided that the following conditions are\n+//met:\n+//\n+//Redistributions of source code must retain the above copyright notice,\n+//this list of conditions and the following disclaimer.\n+//Redistributions in binary form must reproduce the above copyright\n+//notice, this list of conditions and the following disclaimer in the\n+//documentation and/or other materials provided with the distribution.\n+//Neither the name of the Drew Davidson nor the names of its contributors\n+//may be used to endorse or promote products derived from this software\n+//without specific prior written permission.\n+//\n+//THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//\"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+//FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+//COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+//INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+//BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+//OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+//AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+//OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n+//THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n+//DAMAGE.\n+//--------------------------------------------------------------------------\n+package com.opensymphony.xwork2.conversion;\n+\n+import java.util.Map;\n+\n+/**\n+* Interface for handling null results from Chains.\n+* Object has the opportunity to substitute an object for the\n+* null and continue.\n+* @author Luke Blanshard (blanshlu@netscape.net)\n+* @author Drew Davidson (drew@ognl.org)\n+*/\n+public interface NullHandler\n+{\n+    /**\n+        Method called on target returned null.\n+     */\n+    public Object nullMethodResult(Map<String, Object> context, Object target, String methodName, Object[] args);\n+    \n+    /**\n+        Property in target evaluated to null.  Property can be a constant\n+        String property name or a DynamicSubscript.\n+     */\n+    public Object nullPropertyValue(Map<String, Object> context, Object target, Object property);\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "fe2b74840da2ee96c8d5bcd58f238402af1e9c2a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/ObjectTypeDeterminer.java",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FObjectTypeDeterminer.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FObjectTypeDeterminer.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FObjectTypeDeterminer.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,36 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion;\n+\n+/**\n+ * Determines what the key and and element class of a Map or Collection should be. For Maps, the elements are the\n+ * values. For Collections, the elements are the elements of the collection.\n+ * <p/>\n+ * See the implementations for javadoc description for the methods as they are dependent on the concrete implementation.\n+ *\n+ * @author Gabriel Zimmerman\n+ */\n+public interface ObjectTypeDeterminer {\n+\n+    public Class getKeyClass(Class parentClass, String property);\n+\n+    public Class getElementClass(Class parentClass, String property, Object key);\n+\n+    public String getKeyProperty(Class parentClass, String property);\n+    \n+    public boolean shouldCreateIfNew(Class parentClass,  String property,  Object target, String keyProperty, boolean isIndexAccessed);\n+\n+}"
        },
        {
            "sha": "033ee7337679bd55df2477df7aade0c08af6b534",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/TypeConversionException.java",
            "status": "added",
            "additions": 61,
            "deletions": 0,
            "changes": 61,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConversionException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConversionException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConversionException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,61 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion;\n+\n+import com.opensymphony.xwork2.XWorkException;\n+\n+\n+/**\n+ * TypeConversionException should be thrown by any TypeConverters which fail to convert values\n+ *\n+ * @author Jason Carreira\n+ *         Created Oct 3, 2003 12:18:33 AM\n+ */\n+public class TypeConversionException extends XWorkException {\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with no detail  message.\n+     */\n+    public TypeConversionException() {\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public TypeConversionException(String s) {\n+        super(s);\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with no detail  message.\n+     */\n+    public TypeConversionException(Throwable cause) {\n+        super(cause);\n+    }\n+\n+    /**\n+     * Constructs a <code>XWorkException</code> with the specified\n+     * detail message.\n+     *\n+     * @param s the detail message.\n+     */\n+    public TypeConversionException(String s, Throwable cause) {\n+        super(s, cause);\n+    }\n+}"
        },
        {
            "sha": "0fb67d78a7a72981f3e9aba8463381daf7fcb387",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/TypeConverter.java",
            "status": "added",
            "additions": 64,
            "deletions": 0,
            "changes": 64,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2FTypeConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,64 @@\n+//--------------------------------------------------------------------------\n+//  Copyright (c) 1998-2004, Drew Davidson and Luke Blanshard\n+//  All rights reserved.\n+//\n+//  Redistribution and use in source and binary forms, with or without\n+//  modification, are permitted provided that the following conditions are\n+//  met:\n+//\n+//  Redistributions of source code must retain the above copyright notice,\n+//  this list of conditions and the following disclaimer.\n+//  Redistributions in binary form must reproduce the above copyright\n+//  notice, this list of conditions and the following disclaimer in the\n+//  documentation and/or other materials provided with the distribution.\n+//  Neither the name of the Drew Davidson nor the names of its contributors\n+//  may be used to endorse or promote products derived from this software\n+//  without specific prior written permission.\n+//\n+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+//  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+//  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+//  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n+//  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n+//  DAMAGE.\n+//--------------------------------------------------------------------------\n+package com.opensymphony.xwork2.conversion;\n+\n+import java.lang.reflect.Member;\n+import java.util.Map;\n+\n+/**\n+ * Interface for accessing the type conversion facilities within a context.\n+ * \n+ * This interface was copied from OGNL's TypeConverter\n+ * \n+ * @author Luke Blanshard (blanshlu@netscape.net)\n+ * @author Drew Davidson (drew@ognl.org)\n+ */\n+public interface TypeConverter\n+{\n+    /**\n+       * Converts the given value to a given type.  The OGNL context, target, member and\n+       * name of property being set are given.  This method should be able to handle\n+       * conversion in general without any context, target, member or property name specified.\n+       * @param context context under which the conversion is being done\n+       * @param target target object in which the property is being set\n+       * @param member member (Constructor, Method or Field) being set\n+       * @param propertyName property name being set\n+       * @param value value to be converted\n+       * @param toType type to which value is converted\n+       * @return Converted value of type toType or TypeConverter.NoConversionPossible to indicate that the\n+                 conversion was not possible.\n+     */\n+    public Object convertValue(Map<String, Object> context, Object target, Member member, String propertyName, Object value, Class toType);\n+    \n+    public static final Object NO_CONVERSION_POSSIBLE = \"ognl.NoConversionPossible\";\n+    \n+    public static final String TYPE_CONVERTER_CONTEXT_KEY = \"_typeConverter\";\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "90d2ab848df9a62e9d0fe297af3da8e1d0a9e6b4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/annotations/Conversion.java",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversion.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversion.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversion.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,79 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * <p/>A marker annotation for type conversions at Type level.\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Annotation usage:</u>\n+ *\n+ * <!-- START SNIPPET: usage -->\n+ * <p/>The Conversion annotation must be applied at Type level.\n+ * <!-- END SNIPPET: usage -->\n+ *\n+ * <p/> <u>Annotation parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ * <table>\n+ * <thead>\n+ * <tr>\n+ * <th>Parameter</th>\n+ * <th>Required</th>\n+ * <th>Default</th>\n+ * <th>Description</th>\n+ * </tr>\n+ * </thead>\n+ * <tbody>\n+ * <tr>\n+ * <td>conversion</td>\n+ * <td>no</td>\n+ * <td>&nbsp;</td>\n+ * <td>used for Type Conversions applied at Type level.</td>\n+ * </tr>\n+ * </tbody>\n+ * </table>\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &#64;Conversion()\n+ * public class ConversionAction implements Action {\n+ * }\n+ *\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Id$\n+ */\n+@Target({ElementType.TYPE})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface Conversion {\n+\n+    /**\n+     * Allow Type Conversions being applied at Type level.\n+     */\n+    TypeConversion[] conversions() default {};\n+}"
        },
        {
            "sha": "e30bea48aac56031c2f440345e3d54111429f19e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/annotations/ConversionRule.java",
            "status": "added",
            "additions": 33,
            "deletions": 0,
            "changes": 33,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionRule.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionRule.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionRule.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,33 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.annotations;\n+\n+/**\n+ * <code>ConversionRule</code>\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Id$\n+ */\n+public enum ConversionRule {\n+\n+    PROPERTY, COLLECTION, MAP, KEY, KEY_PROPERTY, ELEMENT, CREATE_IF_NULL;\n+\n+    @Override\n+    public String toString() {\n+        return super.toString().toUpperCase();\n+    }\n+}\n+"
        },
        {
            "sha": "d80a926860474436a1dd569e1b0827ce7279c5dc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/annotations/ConversionType.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionType.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionType.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FConversionType.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.annotations;\n+\n+/**\n+ * <code>ConversionType</code>\n+ *\n+ * @author <a href=\"mailto:hermanns@aixcept.de\">Rainer Hermanns</a>\n+ * @version $Id$\n+ */\n+public enum ConversionType {\n+\n+\n+    APPLICATION, CLASS;\n+\n+    @Override\n+    public String toString() {\n+        return super.toString().toUpperCase();\n+    }\n+\n+}"
        },
        {
            "sha": "a857d49f006111008292571120255445caca7d5d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/annotations/TypeConversion.java",
            "status": "added",
            "additions": 178,
            "deletions": 0,
            "changes": 178,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FTypeConversion.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FTypeConversion.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2FTypeConversion.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,178 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.annotations;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import java.lang.annotation.RetentionPolicy;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * <p/>This annotation is used for class and application wide conversion rules.\n+ * <p>\n+ * Class wide conversion:<br/>\n+ * The conversion rules will be assembled in a file called <code>XXXAction-conversion.properties</code>\n+ * within the same package as the related action class.\n+ * Set type to: <code>type = ConversionType.CLASS</code>\n+ * </p>\n+ * <p>\n+ * Allication wide conversion:<br/>\n+ * The conversion rules will be assembled within the <code>xwork-conversion.properties</code> file within the classpath root.\n+ * Set type to: <code>type = ConversionType.APPLICATION</code>\n+ * <p/>\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Annotation usage:</u>\n+ *\n+ * <!-- START SNIPPET: usage -->\n+ * The TypeConversion annotation can be applied at property and method level.\n+ * <!-- END SNIPPET: usage -->\n+ *\n+ * <p/> <u>Annotation parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ * <table>\n+ * <thead>\n+ * <tr>\n+ * <th>Parameter</th>\n+ * <th>Required</th>\n+ * <th>Default</th>\n+ * <th>Description</th>\n+ * </tr>\n+ * </thead>\n+ * <tbody>\n+ * <tr>\n+ * <td>key</td>\n+ * <td>no</td>\n+ * <td>The annotated property/key name</td>\n+ * <td>The optional property name mostly used within TYPE level annotations.</td>\n+ * </tr>\n+ * <tr>\n+ * <td>type</td>\n+ * <td>no</td>\n+ * <td>ConversionType.CLASS</td>\n+ * <td>Enum value of ConversionType.  Determines whether the conversion should be applied at application or class level.</td>\n+ * </tr>\n+ * <tr>\n+ * <td>rule</td>\n+ * <td>no</td>\n+ * <td>ConversionRule.PROPERTY</td>\n+ * <td>Enum value of ConversionRule. The ConversionRule can be a property, a Collection or a Map.</td>\n+ * </tr>\n+ * <tr>\n+ * <td>converter</td>\n+ * <td>either this or value</td>\n+ * <td>&nbsp;</td>\n+ * <td>The class name of the TypeConverter to be used as converter.</td>\n+ * </tr>\n+ * <tr>\n+ * <td>value</td>\n+ * <td>either converter or this</td>\n+ * <td>&nbsp;</td>\n+ * <td>The value to set for ConversionRule.KEY_PROPERTY.</td>\n+ * </tr>\n+ * </tbody>\n+ * </table>\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &#64;Conversion()\n+ * public class ConversionAction implements Action {\n+ *\n+ *   private String convertInt;\n+ *\n+ *   private String convertDouble;\n+ *   private List users = null;\n+ *\n+ *   private HashMap keyValues = null;\n+ *\n+ *   &#64;TypeConversion(type = ConversionType.APPLICATION, converter = \"com.opensymphony.xwork2.util.XWorkBasicConverter\")\n+ *   public void setConvertInt( String convertInt ) {\n+ *       this.convertInt = convertInt;\n+ *   }\n+ *\n+ *   &#64;TypeConversion(converter = \"com.opensymphony.xwork2.util.XWorkBasicConverter\")\n+ *   public void setConvertDouble( String convertDouble ) {\n+ *       this.convertDouble = convertDouble;\n+ *   }\n+ *\n+ *   &#64;TypeConversion(rule = ConversionRule.COLLECTION, converter = \"java.util.String\")\n+ *   public void setUsers( List users ) {\n+ *       this.users = users;\n+ *   }\n+ *\n+ *   &#64;TypeConversion(rule = ConversionRule.MAP, converter = \"java.math.BigInteger\")\n+ *   public void setKeyValues( HashMap keyValues ) {\n+ *       this.keyValues = keyValues;\n+ *   }\n+ *\n+ *   &#64;TypeConversion(type = ConversionType.APPLICATION, property = \"java.util.Date\", converter = \"com.opensymphony.xwork2.util.XWorkBasicConverter\")\n+ *   public String execute() throws Exception {\n+ *       return SUCCESS;\n+ *   }\n+ * }\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Id$\n+ */\n+@Target({ ElementType.METHOD})\n+@Retention(RetentionPolicy.RUNTIME)\n+public @interface TypeConversion {\n+\n+    /**\n+     * The optional key name used within TYPE level annotations.\n+     * Defaults to the property name.\n+     */\n+    String key() default \"\";\n+\n+    /**\n+     * The ConversionType can be either APPLICATION or CLASS.\n+     * Defaults to CLASS.\n+     *\n+     * Note: If you use ConversionType.APPLICATION, you can not set a value!\n+     */\n+    ConversionType type() default ConversionType.CLASS;\n+\n+    /**\n+     * The ConversionRule can be a PROPERTY, KEY, KEY_PROPERTY, ELEMENT, COLLECTION (deprecated) or a MAP.\n+     * Note: Collection and Map vonversion rules can be determined via com.opensymphony.xwork2.util.DefaultObjectTypeDeterminer.\n+     *\n+     * @see com.opensymphony.xwork2.conversion.impl.DefaultObjectTypeDeterminer\n+     */\n+    ConversionRule rule() default ConversionRule.PROPERTY;\n+\n+    /**\n+     * The class of the TypeConverter to be used as converter.\n+     *\n+     * Note: This can not be used with ConversionRule.KEY_PROPERTY! \n+     */\n+    String converter() default \"\";\n+\n+    /**\n+     * If used with ConversionRule.KEY_PROPERTY specify a value here!\n+     *\n+     * Note: If you use ConversionType.APPLICATION, you can not set a value!\n+     */\n+    String value() default \"\";\n+\n+}"
        },
        {
            "sha": "e2a91d0a1a45c5ccedbfb42bc8b9885984a183d5",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/annotations/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fannotations%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Type conversion annotations.</body>"
        },
        {
            "sha": "988e4634eed58682cd278255f8647c60176a9072",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/AnnotationXWorkConverter.java",
            "status": "added",
            "additions": 91,
            "deletions": 0,
            "changes": 91,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FAnnotationXWorkConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FAnnotationXWorkConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FAnnotationXWorkConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,91 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ * <p/>\n+ * Type conversion is great for situations where you need to turn a String in to a more complex object. Because the web\n+ * is type-agnostic (everything is a string in HTTP), XWork's type conversion features are very useful. For instance,\n+ * if you were prompting a user to enter in coordinates in the form of a string (such as \"3, 22\"), you could have\n+ * XWork do the conversion both from String to Point and from Point to String.\n+ * <p/>\n+ * <p/> Using this \"point\" example, if your action (or another compound object in which you are setting properties on)\n+ * has a corresponding ClassName-conversion.properties file, XWork will use the configured type converters for\n+ * conversion to and from strings. So turning \"3, 22\" in to new Point(3, 22) is done by merely adding the following\n+ * entry to <b>ClassName-conversion.properties</b> (Note that the PointConverter should impl the TypeConverter\n+ * interface):\n+ * <p/>\n+ * <p/><b>point = com.acme.PointConverter</b>\n+ * <p/>\n+ * <p/> Your type converter should be sure to check what class type it is being requested to convert. Because it is used\n+ * for both to and from strings, you will need to split the conversion method in to two parts: one that turns Strings in\n+ * to Points, and one that turns Points in to Strings.\n+ * <p/>\n+ * <p/> After this is done, you can now reference your point (using &lt;ww:property value=\"post\"/&gt; in JSP or ${point}\n+ * in FreeMarker) and it will be printed as \"3, 22\" again. As such, if you submit this back to an action, it will be\n+ * converted back to a Point once again.\n+ * <p/>\n+ * <p/> In some situations you may wish to apply a type converter globally. This can be done by editing the file\n+ * <b>xwork-conversion.properties</b> in the root of your class path (typically WEB-INF/classes) and providing a\n+ * property in the form of the class name of the object you wish to convert on the left hand side and the class name of\n+ * the type converter on the right hand side. For example, providing a type converter for all Point objects would mean\n+ * adding the following entry:\n+ * <p/>\n+ * <p/><b>com.acme.Point = com.acme.PointConverter</b>\n+ * <p/>\n+ * <!-- END SNIPPET: javadoc -->\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: i18n-note -->\n+ * <p/>\n+ * Type conversion should not be used as a substitute for i18n. It is not recommended to use this feature to print out\n+ * properly formatted dates. Rather, you should use the i18n features of XWork (and consult the JavaDocs for JDK's\n+ * MessageFormat object) to see how a properly formatted date should be displayed.\n+ * <p/>\n+ * <!-- END SNIPPET: i18n-note -->\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: error-reporting -->\n+ * <p/>\n+ * Any error that occurs during type conversion may or may not wish to be reported. For example, reporting that the\n+ * input \"abc\" could not be converted to a number might be important. On the other hand, reporting that an empty string,\n+ * \"\", cannot be converted to a number might not be important - especially in a web environment where it is hard to\n+ * distinguish between a user not entering a value vs. entering a blank value.\n+ * <p/>\n+ * <p/> By default, all conversion errors are reported using the generic i18n key <b>xwork.default.invalid.fieldvalue</b>,\n+ * which you can override (the default text is <i>Invalid field value for field \"xxx\"</i>, where xxx is the field name)\n+ * in your global i18n resource bundle.\n+ * <p/>\n+ * <p/>However, sometimes you may wish to override this message on a per-field basis. You can do this by adding an i18n\n+ * key associated with just your action (Action.properties) using the pattern <b>invalid.fieldvalue.xxx</b>, where xxx\n+ * is the field name.\n+ * <p/>\n+ * <p/>It is important to know that none of these errors are actually reported directly. Rather, they are added to a map\n+ * called <i>conversionErrors</i> in the ActionContext. There are several ways this map can then be accessed and the\n+ * errors can be reported accordingly.\n+ * <p/>\n+ * <!-- END SNIPPET: error-reporting -->\n+ *\n+ * @author <a href=\"mailto:plightbo@gmail.com\">Pat Lightbody</a>\n+ * @author Rainer Hermanns\n+ * @see com.opensymphony.xwork2.conversion.impl.XWorkConverter\n+ * @deprecated Since XWork 2.0.4, the implementation of XWorkConverter handles the processing of annotations.\n+ */\n+@Deprecated public class AnnotationXWorkConverter extends XWorkConverter {\n+}"
        },
        {
            "sha": "d4b7e0010050c5bb48643b3f14bcc07f5d7d223d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/DefaultObjectTypeDeterminer.java",
            "status": "added",
            "additions": 360,
            "deletions": 0,
            "changes": 360,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultObjectTypeDeterminer.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultObjectTypeDeterminer.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultObjectTypeDeterminer.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,360 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.CreateIfNull;\n+import com.opensymphony.xwork2.util.Element;\n+import com.opensymphony.xwork2.util.Key;\n+import com.opensymphony.xwork2.util.KeyProperty;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionException;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+\n+import java.beans.IntrospectionException;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Field;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.ParameterizedType;\n+import java.lang.reflect.Type;\n+import java.util.Map;\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ *\n+ * This {@link ObjectTypeDeterminer} looks at the <b>Class-conversion.properties</b> for entries that indicated what\n+ * objects are contained within Maps and Collections. For Collections, such as Lists, the element is specified using the\n+ * pattern <b>Element_xxx</b>, where xxx is the field name of the collection property in your action or object. For\n+ * Maps, both the key and the value may be specified by using the pattern <b>Key_xxx</b> and <b>Element_xxx</b>,\n+ * respectively.\n+ *\n+ * <p/> From WebWork 2.1.x, the <b>Collection_xxx</b> format is still supported and honored, although it is deprecated\n+ * and will be removed eventually.\n+ *\n+ * <!-- END SNIPPET: javadoc -->\n+ * \n+ *\n+ * @author Gabriel Zimmerman\n+ */\n+public class DefaultObjectTypeDeterminer implements ObjectTypeDeterminer {\n+    \n+\n+    protected static final Logger LOG = LoggerFactory.getLogger(DefaultObjectTypeDeterminer.class);\n+\n+    public static final String KEY_PREFIX = \"Key_\";\n+    public static final String ELEMENT_PREFIX = \"Element_\";\n+    public static final String KEY_PROPERTY_PREFIX = \"KeyProperty_\";\n+    public static final String CREATE_IF_NULL_PREFIX = \"CreateIfNull_\";\n+    public static final String DEPRECATED_ELEMENT_PREFIX = \"Collection_\";\n+    \n+    private ReflectionProvider reflectionProvider;\n+    private XWorkConverter xworkConverter;\n+    \n+    @Inject\n+    public DefaultObjectTypeDeterminer(@Inject XWorkConverter conv, @Inject ReflectionProvider prov) {\n+        this.reflectionProvider = prov;\n+        this.xworkConverter = conv;\n+        \n+    }\n+    \n+    /**\n+     * Determines the key class by looking for the value of @Key annotation for the given class.\n+     * If no annotation is found, the key class is determined by using the generic parametrics.\n+     *\n+     * As fallback, it determines the key class by looking for the value of Key_${property} in the properties\n+     * file for the given class.\n+     *\n+     * @param parentClass the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property    the property of the Map or Collection for the given parent class\n+     * @see com.opensymphony.xwork2.conversion.ObjectTypeDeterminer#getKeyClass(Class, String)\n+     */\n+    public Class getKeyClass(Class parentClass, String property) {\n+        Key annotation = getAnnotation(parentClass, property, Key.class);\n+\n+        if (annotation != null) {\n+            return annotation.value();\n+        }\n+\n+        Class clazz = getClass(parentClass, property, false);\n+\n+        if (clazz != null) {\n+            return clazz;\n+        }\n+\n+        return (Class) xworkConverter.getConverter(parentClass, KEY_PREFIX + property);\n+    }\n+\n+\n+    /**\n+     * Determines the element class by looking for the value of @Element annotation for the given\n+     * class.\n+     * If no annotation is found, the element class is determined by using the generic parametrics.\n+     *\n+     * As fallback, it determines the key class by looking for the value of Element_${property} in the properties\n+     * file for the given class. Also looks for the deprecated Collection_${property}\n+     *\n+     * @param parentClass the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property    the property of the Map or Collection for the given parent class\n+     * @see com.opensymphony.xwork2.conversion.ObjectTypeDeterminer#getElementClass(Class, String, Object)\n+     */\n+    public Class getElementClass(Class parentClass, String property, Object key) {\n+        Element annotation = getAnnotation(parentClass, property, Element.class);\n+\n+        if (annotation != null) {\n+            return annotation.value();\n+        }\n+\n+        Class clazz = getClass(parentClass, property, true);\n+\n+        if (clazz != null) {\n+            return clazz;\n+        }\n+\n+        clazz = (Class) xworkConverter.getConverter(parentClass, ELEMENT_PREFIX + property);\n+\n+        if (clazz == null) {\n+            clazz = (Class) xworkConverter\n+                    .getConverter(parentClass, DEPRECATED_ELEMENT_PREFIX + property);\n+\n+            if (clazz != null) {\n+                LOG.info(\"The Collection_xxx pattern for collection type conversion is deprecated. Please use Element_xxx!\");\n+            }\n+        }\n+        return clazz;\n+\n+    }\n+\n+\n+    /**\n+     * Determines the key property for a Collection by getting it from the @KeyProperty annotation.\n+     *\n+     * As fallback, it determines the String key property for a Collection by getting it from the conversion properties\n+     * file using the KeyProperty_ prefix. KeyProperty_${property}=somePropertyOfBeansInTheSet\n+     *\n+     * @param parentClass the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property    the property of the Map or Collection for the given parent class\n+     * @see com.opensymphony.xwork2.conversion.ObjectTypeDeterminer#getKeyProperty(Class, String)\n+     */\n+    public String getKeyProperty(Class parentClass, String property) {\n+        KeyProperty annotation = getAnnotation(parentClass, property, KeyProperty.class);\n+\n+        if (annotation != null) {\n+            return annotation.value();\n+        }\n+\n+        return (String) xworkConverter.getConverter(parentClass, KEY_PROPERTY_PREFIX + property);\n+    }\n+\n+\n+    /**\n+     * Determines the createIfNull property for a Collection or Map by getting it from the @CreateIfNull annotation.\n+     *\n+     * As fallback, it determines the boolean CreateIfNull property for a Collection or Map by getting it from the\n+     * conversion properties file using the CreateIfNull_ prefix. CreateIfNull_${property}=true|false\n+     *\n+     * @param parentClass     the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property        the property of the Map or Collection for the given parent class\n+     * @param target          the target object\n+     * @param keyProperty     the keyProperty value\n+     * @param isIndexAccessed <tt>true</tt>, if the collection or map is accessed via index, <tt>false</tt> otherwise.\n+     * @return <tt>true</tt>, if the Collection or Map should be created, <tt>false</tt> otherwise.\n+     * @see ObjectTypeDeterminer#getKeyProperty(Class, String)\n+     */\n+    public boolean shouldCreateIfNew(Class parentClass,\n+                                     String property,\n+                                     Object target,\n+                                     String keyProperty,\n+                                     boolean isIndexAccessed) {\n+\n+        CreateIfNull annotation = getAnnotation(parentClass, property, CreateIfNull.class);\n+\n+        if (annotation != null) {\n+            return annotation.value();\n+        }\n+\n+        String configValue = (String) xworkConverter.getConverter(parentClass, CREATE_IF_NULL_PREFIX + property);\n+        //check if a value is in the config\n+        if (configValue!=null) {\n+            if (\"true\".equalsIgnoreCase(configValue)) {\n+                return true;\n+            }\n+            if (\"false\".equalsIgnoreCase(configValue)) {\n+                return false;\n+            }\n+        }\n+\n+        //default values depend on target type\n+        //and whether this is accessed by an index\n+        //in the case of List\n+        if ((target instanceof Map) || isIndexAccessed) {\n+            return true;\n+        }\telse {\n+            return false;\n+        }\n+\n+    }\n+\n+    /**\n+     * Retrieves an annotation for the specified property of field, setter or getter.\n+     *\n+     * @param <T>             the annotation type to be retrieved\n+     * @param parentClass     the class\n+     * @param property        the property\n+     * @param annotationClass the annotation\n+     * @return the field or setter/getter annotation or <code>null</code> if not found\n+     */\n+    protected <T extends Annotation> T getAnnotation(Class parentClass, String property, Class<T> annotationClass) {\n+        T annotation = null;\n+        Field field = reflectionProvider.getField(parentClass, property);\n+\n+        if (field != null) {\n+            annotation = field.getAnnotation(annotationClass);\n+        }\n+        if (annotation == null) { // HINT: try with setter\n+            annotation = getAnnotationFromSetter(parentClass, property, annotationClass);\n+        }\n+        if (annotation == null) { // HINT: try with getter\n+            annotation = getAnnotationFromGetter(parentClass, property, annotationClass);\n+        }\n+\n+        return annotation;\n+    }\n+\n+    /**\n+     * Retrieves an annotation for the specified field of getter.\n+     *\n+     * @param parentClass     the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property        the property of the Map or Collection for the given parent class\n+     * @param annotationClass The annotation\n+     * @return concrete Annotation instance or <tt>null</tt> if none could be retrieved.\n+     */\n+    private <T extends Annotation>T getAnnotationFromGetter(Class parentClass, String property, Class<T> annotationClass) {\n+        try {\n+            Method getter = reflectionProvider.getGetMethod(parentClass, property);\n+\n+            if (getter != null) {\n+                return getter.getAnnotation(annotationClass);\n+            }\n+        }\n+        catch (ReflectionException ognle) {\n+            ; // ignore\n+        }\n+        catch (IntrospectionException ie) {\n+            ; // ignore\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Retrieves an annotation for the specified field of setter.\n+     *\n+     * @param parentClass     the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property        the property of the Map or Collection for the given parent class\n+     * @param annotationClass The annotation\n+     * @return concrete Annotation instance or <tt>null</tt> if none could be retrieved.\n+     */\n+    private <T extends Annotation>T getAnnotationFromSetter(Class parentClass, String property, Class<T> annotationClass) {\n+        try {\n+            Method setter = reflectionProvider.getSetMethod(parentClass, property);\n+\n+            if (setter != null) {\n+                return setter.getAnnotation(annotationClass);\n+            }\n+        }\n+        catch (ReflectionException ognle) {\n+            ; // ignore\n+        }\n+        catch (IntrospectionException ie) {\n+            ; // ignore\n+        }\n+        return null;\n+    }\n+\n+    /**\n+     * Returns the class for the given field via generic type check.\n+     *\n+     * @param parentClass the Class which contains as a property the Map or Collection we are finding the key for.\n+     * @param property    the property of the Map or Collection for the given parent class\n+     * @param element     <tt>true</tt> for indexed types and Maps.\n+     * @return Class of the specified field.\n+     */\n+    private Class getClass(Class parentClass, String property, boolean element) {\n+\n+\n+        try {\n+\n+            Field field = reflectionProvider.getField(parentClass, property);\n+\n+            Type genericType = null;\n+\n+            // Check fields first\n+            if (field != null) {\n+                genericType = field.getGenericType();\n+            }\n+\n+            // Try to get ParameterType from setter method\n+            if (genericType == null || !(genericType instanceof ParameterizedType)) {\n+                try {\n+                    Method setter = reflectionProvider.getSetMethod(parentClass, property);\n+                    genericType = setter.getGenericParameterTypes()[0];\n+                }\n+                catch (ReflectionException ognle) {\n+                    ; // ignore\n+                }\n+                catch (IntrospectionException ie) {\n+                    ; // ignore\n+                }\n+            }\n+\n+            // Try to get ReturnType from getter method\n+            if (genericType == null || !(genericType instanceof ParameterizedType)) {\n+                try {\n+                    Method getter = reflectionProvider.getGetMethod(parentClass, property);\n+                    genericType = getter.getGenericReturnType();\n+                }\n+                catch (ReflectionException ognle) {\n+                    ; // ignore\n+                }\n+                catch (IntrospectionException ie) {\n+                    ; // ignore\n+                }\n+            }\n+\n+            if (genericType instanceof ParameterizedType) {\n+\n+\n+                ParameterizedType type = (ParameterizedType) genericType;\n+\n+                int index = (element && type.getRawType().toString().contains(Map.class.getName())) ? 1 : 0;\n+\n+                Type resultType = type.getActualTypeArguments()[index];\n+\n+                if ( resultType instanceof ParameterizedType) {\n+                    return (Class) ((ParameterizedType) resultType).getRawType();\n+                }\n+                return (Class) resultType;\n+\n+            }\n+        } catch (Exception e) {\n+            if ( LOG.isDebugEnabled()) {\n+                LOG.debug(\"Error while retrieving generic property class for property=\" + property, e);\n+            }\n+        }\n+        return null;\n+    }\n+}"
        },
        {
            "sha": "11b55a86d96ce58b160212ec7bce42215468997e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/DefaultTypeConverter.java",
            "status": "added",
            "additions": 328,
            "deletions": 0,
            "changes": 328,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultTypeConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultTypeConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FDefaultTypeConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,328 @@\n+//--------------------------------------------------------------------------\n+//  Copyright (c) 1998-2004, Drew Davidson and Luke Blanshard\n+//  All rights reserved.\n+//\n+//  Redistribution and use in source and binary forms, with or without\n+//  modification, are permitted provided that the following conditions are\n+//  met:\n+//\n+//  Redistributions of source code must retain the above copyright notice,\n+//  this list of conditions and the following disclaimer.\n+//  Redistributions in binary form must reproduce the above copyright\n+//  notice, this list of conditions and the following disclaimer in the\n+//  documentation and/or other materials provided with the distribution.\n+//  Neither the name of the Drew Davidson nor the names of its contributors\n+//  may be used to endorse or promote products derived from this software\n+//  without specific prior written permission.\n+//\n+//  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS\n+//  \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT\n+//  LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS\n+//  FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE\n+//  COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT,\n+//  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING,\n+//  BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS\n+//  OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED\n+//  AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY,\n+//  OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF\n+//  THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH\n+//  DAMAGE.\n+//--------------------------------------------------------------------------\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.conversion.TypeConverter;\n+import com.opensymphony.xwork2.ognl.XWorkTypeConverterWrapper;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Member;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.util.Collections;\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Default type conversion. Converts among numeric types and also strings.  Contains the basic \n+ * type mapping code from OGNL.\n+ * \n+ * @author Luke Blanshard (blanshlu@netscape.net)\n+ * @author Drew Davidson (drew@ognl.org)\n+ */\n+public class DefaultTypeConverter implements TypeConverter {\n+    private static final String NULL_STRING = \"null\";\n+\n+    private final Map<Class, Object> primitiveDefaults;\n+\n+    public DefaultTypeConverter() {\n+        Map<Class, Object> map = new HashMap<Class, Object>();\n+        map.put(Boolean.TYPE, Boolean.FALSE);\n+        map.put(Byte.TYPE, Byte.valueOf((byte) 0));\n+        map.put(Short.TYPE, Short.valueOf((short) 0));\n+        map.put(Character.TYPE, new Character((char) 0));\n+        map.put(Integer.TYPE, Integer.valueOf(0));\n+        map.put(Long.TYPE, Long.valueOf(0L));\n+        map.put(Float.TYPE, new Float(0.0f));\n+        map.put(Double.TYPE, new Double(0.0));\n+        map.put(BigInteger.class, new BigInteger(\"0\"));\n+        map.put(BigDecimal.class, new BigDecimal(0.0));\n+        primitiveDefaults = Collections.unmodifiableMap(map);\n+    }\n+\n+    public Object convertValue(Map<String, Object> context, Object value, Class toType) {\n+        return convertValue(value, toType);\n+    }\n+\n+    public Object convertValue(Map<String, Object> context, Object target, Member member,\n+            String propertyName, Object value, Class toType) {\n+        return convertValue(context, value, toType);\n+    }\n+    \n+    public TypeConverter getTypeConverter( Map<String, Object> context )\n+    {\n+        Object obj = context.get(TypeConverter.TYPE_CONVERTER_CONTEXT_KEY);\n+        if (obj instanceof TypeConverter) {\n+            return (TypeConverter) obj;\n+            \n+        // for backwards-compatibility\n+        } else if (obj instanceof ognl.TypeConverter) {\n+            return new XWorkTypeConverterWrapper((ognl.TypeConverter) obj);\n+        }\n+        return null; \n+    }\n+\n+    /**\n+     * Returns the value converted numerically to the given class type\n+     * \n+     * This method also detects when arrays are being converted and converts the\n+     * components of one array to the type of the other.\n+     * \n+     * @param value\n+     *            an object to be converted to the given type\n+     * @param toType\n+     *            class type to be converted to\n+     * @return converted value of the type given, or value if the value cannot\n+     *         be converted to the given type.\n+     */\n+    public Object convertValue(Object value, Class toType) {\n+        Object result = null;\n+\n+        if (value != null) {\n+            /* If array -> array then convert components of array individually */\n+            if (value.getClass().isArray() && toType.isArray()) {\n+                Class componentType = toType.getComponentType();\n+\n+                result = Array.newInstance(componentType, Array\n+                        .getLength(value));\n+                for (int i = 0, icount = Array.getLength(value); i < icount; i++) {\n+                    Array.set(result, i, convertValue(Array.get(value, i),\n+                            componentType));\n+                }\n+            } else {\n+                if ((toType == Integer.class) || (toType == Integer.TYPE))\n+                    result = Integer.valueOf((int) longValue(value));\n+                if ((toType == Double.class) || (toType == Double.TYPE))\n+                    result = new Double(doubleValue(value));\n+                if ((toType == Boolean.class) || (toType == Boolean.TYPE))\n+                    result = booleanValue(value) ? Boolean.TRUE : Boolean.FALSE;\n+                if ((toType == Byte.class) || (toType == Byte.TYPE))\n+                    result = Byte.valueOf((byte) longValue(value));\n+                if ((toType == Character.class) || (toType == Character.TYPE))\n+                    result = new Character((char) longValue(value));\n+                if ((toType == Short.class) || (toType == Short.TYPE))\n+                    result = Short.valueOf((short) longValue(value));\n+                if ((toType == Long.class) || (toType == Long.TYPE))\n+                    result = Long.valueOf(longValue(value));\n+                if ((toType == Float.class) || (toType == Float.TYPE))\n+                    result = new Float(doubleValue(value));\n+                if (toType == BigInteger.class)\n+                    result = bigIntValue(value);\n+                if (toType == BigDecimal.class)\n+                    result = bigDecValue(value);\n+                if (toType == String.class)\n+                    result = stringValue(value);\n+                if (Enum.class.isAssignableFrom(toType))\n+                    result = enumValue((Class<Enum>)toType, value);\n+            }\n+        } else {\n+            if (toType.isPrimitive()) {\n+                result = primitiveDefaults.get(toType);\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Evaluates the given object as a boolean: if it is a Boolean object, it's\n+     * easy; if it's a Number or a Character, returns true for non-zero objects;\n+     * and otherwise returns true for non-null objects.\n+     * \n+     * @param value\n+     *            an object to interpret as a boolean\n+     * @return the boolean value implied by the given object\n+     */\n+    public static boolean booleanValue(Object value) {\n+        if (value == null)\n+            return false;\n+        Class c = value.getClass();\n+        if (c == Boolean.class)\n+            return ((Boolean) value).booleanValue();\n+        // if ( c == String.class )\n+        // return ((String)value).length() > 0;\n+        if (c == Character.class)\n+            return ((Character) value).charValue() != 0;\n+        if (value instanceof Number)\n+            return ((Number) value).doubleValue() != 0;\n+        return true; // non-null\n+    }\n+    \n+    public Enum<?> enumValue(Class toClass, Object o) {\n+        Enum<?> result = null;\n+        if (o == null) {\n+            result = null;\n+        } else if (o instanceof String[]) {\n+            result = Enum.valueOf(toClass, ((String[]) o)[0]);\n+        } else if (o instanceof String) {\n+            result = Enum.valueOf(toClass, (String) o);\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Evaluates the given object as a long integer.\n+     * \n+     * @param value\n+     *            an object to interpret as a long integer\n+     * @return the long integer value implied by the given object\n+     * @throws NumberFormatException\n+     *             if the given object can't be understood as a long integer\n+     */\n+    public static long longValue(Object value) throws NumberFormatException {\n+        if (value == null)\n+            return 0L;\n+        Class c = value.getClass();\n+        if (c.getSuperclass() == Number.class)\n+            return ((Number) value).longValue();\n+        if (c == Boolean.class)\n+            return ((Boolean) value).booleanValue() ? 1 : 0;\n+        if (c == Character.class)\n+            return ((Character) value).charValue();\n+        return Long.parseLong(stringValue(value, true));\n+    }\n+\n+    /**\n+     * Evaluates the given object as a double-precision floating-point number.\n+     * \n+     * @param value\n+     *            an object to interpret as a double\n+     * @return the double value implied by the given object\n+     * @throws NumberFormatException\n+     *             if the given object can't be understood as a double\n+     */\n+    public static double doubleValue(Object value) throws NumberFormatException {\n+        if (value == null)\n+            return 0.0;\n+        Class c = value.getClass();\n+        if (c.getSuperclass() == Number.class)\n+            return ((Number) value).doubleValue();\n+        if (c == Boolean.class)\n+            return ((Boolean) value).booleanValue() ? 1 : 0;\n+        if (c == Character.class)\n+            return ((Character) value).charValue();\n+        String s = stringValue(value, true);\n+\n+        return (s.length() == 0) ? 0.0 : Double.parseDouble(s);\n+        /*\n+         * For 1.1 parseDouble() is not available\n+         */\n+        // return Double.valueOf( value.toString() ).doubleValue();\n+    }\n+\n+    /**\n+     * Evaluates the given object as a BigInteger.\n+     * \n+     * @param value\n+     *            an object to interpret as a BigInteger\n+     * @return the BigInteger value implied by the given object\n+     * @throws NumberFormatException\n+     *             if the given object can't be understood as a BigInteger\n+     */\n+    public static BigInteger bigIntValue(Object value)\n+            throws NumberFormatException {\n+        if (value == null)\n+            return BigInteger.valueOf(0L);\n+        Class c = value.getClass();\n+        if (c == BigInteger.class)\n+            return (BigInteger) value;\n+        if (c == BigDecimal.class)\n+            return ((BigDecimal) value).toBigInteger();\n+        if (c.getSuperclass() == Number.class)\n+            return BigInteger.valueOf(((Number) value).longValue());\n+        if (c == Boolean.class)\n+            return BigInteger.valueOf(((Boolean) value).booleanValue() ? 1 : 0);\n+        if (c == Character.class)\n+            return BigInteger.valueOf(((Character) value).charValue());\n+        return new BigInteger(stringValue(value, true));\n+    }\n+\n+    /**\n+     * Evaluates the given object as a BigDecimal.\n+     * \n+     * @param value\n+     *            an object to interpret as a BigDecimal\n+     * @return the BigDecimal value implied by the given object\n+     * @throws NumberFormatException\n+     *             if the given object can't be understood as a BigDecimal\n+     */\n+    public static BigDecimal bigDecValue(Object value)\n+            throws NumberFormatException {\n+        if (value == null)\n+            return BigDecimal.valueOf(0L);\n+        Class c = value.getClass();\n+        if (c == BigDecimal.class)\n+            return (BigDecimal) value;\n+        if (c == BigInteger.class)\n+            return new BigDecimal((BigInteger) value);\n+        if (c.getSuperclass() == Number.class)\n+            return new BigDecimal(((Number) value).doubleValue());\n+        if (c == Boolean.class)\n+            return BigDecimal.valueOf(((Boolean) value).booleanValue() ? 1 : 0);\n+        if (c == Character.class)\n+            return BigDecimal.valueOf(((Character) value).charValue());\n+        return new BigDecimal(stringValue(value, true));\n+    }\n+\n+    /**\n+     * Evaluates the given object as a String and trims it if the trim flag is\n+     * true.\n+     * \n+     * @param value\n+     *            an object to interpret as a String\n+     * @return the String value implied by the given object as returned by the\n+     *         toString() method, or \"null\" if the object is null.\n+     */\n+    public static String stringValue(Object value, boolean trim) {\n+        String result;\n+\n+        if (value == null) {\n+            result = NULL_STRING;\n+        } else {\n+            result = value.toString();\n+            if (trim) {\n+                result = result.trim();\n+            }\n+        }\n+        return result;\n+    }\n+\n+    /**\n+     * Evaluates the given object as a String.\n+     * \n+     * @param value\n+     *            an object to interpret as a String\n+     * @return the String value implied by the given object as returned by the\n+     *         toString() method, or \"null\" if the object is null.\n+     */\n+    public static String stringValue(Object value) {\n+        return stringValue(value, false);\n+    }\n+}"
        },
        {
            "sha": "949eede71b9df4f5d9cf7fd922dd96941c3c8d5e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/EnumTypeConverter.java",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FEnumTypeConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FEnumTypeConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FEnumTypeConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * <code>EnumTypeConverter</code>\n+ *\n+ * <!-- START SNIPPET: description -->\n+ * This class converts java 5 enums to String and from String[] to enum.\n+ * <p/>\n+ * One of Java 5's improvements is providing enumeration facility.\n+ * Up to now, there existed no enumerations. The only way to simulate was the so-called int Enum pattern:\n+ * {code}\n+ * public static final int SEASON_WINTER = 0;\n+ * public static final int SEASON_SPRING = 1;\n+ * public static final int SEASON_SUMMER = 2;\n+ * public static final int SEASON_FALL   = 3;\n+ * {code}\n+ * <p/>\n+ * Java 5.0 now provides the following construct:\n+ * {code}\n+ * public static enum Season { WINTER, SPRING, SUMMER, FALL };\n+ * {code}\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <!-- START SNIPPET: example -->\n+ * h3. Implementing Java 5 Enumeration Type Conversion\n+ * <p/>\n+ * 1. myAction-conversion.properties*\n+ * <p/>\n+ * Place a myAction-conversion.properties-file in the path of your Action.\n+ * Add the following entry to the properties-file:\n+ * {code}\n+ * nameOfYourField=fullyClassifiedNameOfYourConverter\n+ * {code}\n+ * &nbsp;\n+ * <p/>\n+ * 2. myAction.java*\n+ * Your action contains the _enumeration_:\n+ * {code}\n+ * public enum Criticality {DEBUG, INFO, WARNING, ERROR, FATAL}\n+ * {code}\n+ * &nbsp;\n+ * * Your action contains the _private field_:\n+ * {code}\n+ * private myEnum myFieldForEnum;\n+ * {code}\n+ * &nbsp;\n+ * Your action contains _getters and setters_ for your field:\n+ * {code}\n+ * public myEnum getCriticality() {\n+ *         return myFieldForEnum;\n+ *     }\n+ *\n+ *     public void setCriticality(myEnum myFieldForEnum) {\n+ *         this.myFieldForEnum= myFieldForEnum;\n+ *     }\n+ * {code}\n+ * <p/>\n+ * 3. JSP*\n+ * <p/>\n+ * &nbsp;&nbsp;&nbsp; In your jsp you can access an enumeration value just normal by using the known <ww:property>-Tag:\n+ * {code}\n+ * <ww:property value=\"myField\"/>\n+ * {code}\n+ * <!-- END SNIPPET: example -->\n+ *\n+ * @author Tamara Cattivelli\n+ * @author <a href=\"mailto:hermanns@aixcept.de\">Rainer Hermanns</a>\n+ * @version $Id$\n+ * @deprecated Since Struts 2.1.0 as enum support is now built into XWork\n+ */\n+@Deprecated public class EnumTypeConverter extends DefaultTypeConverter {\n+\n+    /**\n+     * Converts the given object to a given type. How this is to be done is implemented in toClass. The OGNL context, o\n+     * and toClass are given. This method should be able to handle conversion in general without any context or object\n+     * specified.\n+     *\n+     * @param context - OGNL context under which the conversion is being done\n+     * @param o       - the object to be converted\n+     * @param toClass - the class that contains the code to convert to enumeration\n+     * @return Converted value of type declared in toClass or TypeConverter.NoConversionPossible to indicate that the\n+     *         conversion was not possible.\n+     */\n+    @Override\n+    public Object convertValue(Map<String, Object> context, Object o, Class toClass) {\n+        if (o instanceof String[]) {\n+            return convertFromString(((String[]) o)[0], toClass);\n+        } else if (o instanceof String) {\n+            return convertFromString((String) o, toClass);\n+        }\n+\n+        return super.convertValue(context, o, toClass);\n+    }\n+\n+    /**\n+     * Converts one or more String values to the specified class.\n+     * @param value - the String values to be converted, such as those submitted from an HTML form\n+     * @param toClass - the class to convert to\n+     * @return the converted object\n+     */\n+    public java.lang.Enum convertFromString(String value, Class toClass) {\n+        return Enum.valueOf(toClass, value);\n+    }\n+\n+}\n\\ No newline at end of file"
        },
        {
            "sha": "69f1ced7852efeed70c9a30f4c5b934eb7de54b8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/GenericsObjectTypeDeterminer.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FGenericsObjectTypeDeterminer.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FGenericsObjectTypeDeterminer.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FGenericsObjectTypeDeterminer.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,38 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+\n+\n+/**\n+ * GenericsObjectTypeDeterminer\n+ *\n+ * @author Patrick Lightbody\n+ * @author Rainer Hermanns\n+ * @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+ * \n+ * @deprecated Use DefaultObjectTypeDeterminer instead. Since XWork 2.0.4 the DefaultObjectTypeDeterminer handles the\n+ *             annotation processing.\n+ */\n+@Deprecated public class GenericsObjectTypeDeterminer extends DefaultObjectTypeDeterminer {\n+\n+    public GenericsObjectTypeDeterminer(XWorkConverter conv,\n+            XWorkBasicConverter basicConv, ReflectionProvider prov) {\n+        super(conv, prov);\n+    }\n+}"
        },
        {
            "sha": "11f723f77d73fd7d3c8a51abe3224ca800ca8d7c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/InstantiatingNullHandler.java",
            "status": "added",
            "additions": 161,
            "deletions": 0,
            "changes": 161,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FInstantiatingNullHandler.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FInstantiatingNullHandler.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FInstantiatingNullHandler.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,161 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.conversion.NullHandler;\n+import com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+\n+import java.beans.PropertyDescriptor;\n+import java.util.*;\n+\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ *\n+ * Provided that the key {@link ReflectionContextState#CREATE_NULL_OBJECTS} is in the action context with a value of true (this key is set\n+ * only during the execution of the {@link com.opensymphony.xwork2.interceptor.ParametersInterceptor}), OGNL expressions\n+ * that have caused a NullPointerException will be temporarily stopped for evaluation while the system automatically\n+ * tries to solve the null references by automatically creating the object.\n+ *\n+ * <p/> The following rules are used when handling null references:\n+ *\n+ * <ul>\n+ *\n+ * <li>If the property is declared <i>exactly</i> as a {@link Collection} or {@link List}, then an ArrayList shall be\n+ * returned and assigned to the null references.</li>\n+ *\n+ * <li>If the property is declared as a {@link Map}, then a HashMap will be returned and assigned to the null\n+ * references.</li>\n+ *\n+ * <li>If the null property is a simple bean with a no-arg constructor, it will simply be created using the {@link\n+ * ObjectFactory#buildBean(java.lang.Class, java.util.Map)} method.</li>\n+ *\n+ * </ul>\n+ *\n+ * <!-- END SNIPPET: javadoc -->\n+ *\n+ * <!-- START SNIPPET: example -->\n+ *\n+ * For example, if a form element has a text field named <b>person.name</b> and the expression <i>person</i> evaluates\n+ * to null, then this class will be invoked. Because the <i>person</i> expression evaluates to a <i>Person</i> class, a\n+ * new Person is created and assigned to the null reference. Finally, the name is set on that object and the overall\n+ * effect is that the system automatically created a Person object for you, set it by calling setUsers() and then\n+ * finally called getUsers().setName() as you would typically expect.\n+ *\n+ * <!-- END SNIPPET: example>\n+ *\n+ * @author Matt Ho\n+ * @author Patrick Lightbody\n+ */\n+public class InstantiatingNullHandler implements NullHandler {\n+\n+    /**\n+     * @deprecated Use {@link ReflectionContextState#CREATE_NULL_OBJECTS} instead\n+     */\n+    @Deprecated public static final String CREATE_NULL_OBJECTS = ReflectionContextState.CREATE_NULL_OBJECTS;\n+    private static final Logger LOG = LoggerFactory.getLogger(InstantiatingNullHandler.class);\n+    private ReflectionProvider reflectionProvider;\n+    private ObjectFactory objectFactory;\n+    private ObjectTypeDeterminer objectTypeDeterminer;\n+\n+    @Inject\n+    public void setObjectTypeDeterminer(ObjectTypeDeterminer det) {\n+        this.objectTypeDeterminer = det;\n+    }\n+\n+    @Inject\n+    public void setReflectionProvider(ReflectionProvider prov) {\n+        this.reflectionProvider = prov;\n+    }\n+\n+    @Inject\n+    public void setObjectFactory(ObjectFactory fac) {\n+        this.objectFactory = fac;\n+    }\n+\n+    public Object nullMethodResult(Map<String, Object> context, Object target, String methodName, Object[] args) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Entering nullMethodResult \");\n+        }\n+\n+        return null;\n+    }\n+\n+    public Object nullPropertyValue(Map<String, Object> context, Object target, Object property) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Entering nullPropertyValue [target=\"+target+\", property=\"+property+\"]\");\n+        }\n+\n+        boolean c = ReflectionContextState.isCreatingNullObjects(context);\n+\n+        if (!c) {\n+            return null;\n+        }\n+\n+        if ((target == null) || (property == null)) {\n+            return null;\n+        }\n+\n+        try {\n+            String propName = property.toString();\n+            Object realTarget = reflectionProvider.getRealTarget(propName, context, target);\n+            Class clazz = null;\n+\n+            if (realTarget != null) {\n+                PropertyDescriptor pd = reflectionProvider.getPropertyDescriptor(realTarget.getClass(), propName);\n+                if (pd == null) {\n+                    return null;\n+                }\n+\n+                clazz = pd.getPropertyType();\n+            }\n+\n+            if (clazz == null) {\n+                // can't do much here!\n+                return null;\n+            }\n+\n+            Object param = createObject(clazz, realTarget, propName, context);\n+\n+            reflectionProvider.setValue(propName, context, realTarget, param);\n+\n+            return param;\n+        } catch (Exception e) {\n+            LOG.error(\"Could not create and/or set value back on to object\", e);\n+        }\n+\n+        return null;\n+    }\n+\n+    private Object createObject(Class clazz, Object target, String property, Map<String, Object> context) throws Exception {\n+        if (Collection.class.isAssignableFrom(clazz)) {\n+            return new ArrayList();\n+        } else if (clazz == Map.class) {\n+            return new HashMap();\n+        } else if (clazz == EnumMap.class) {\n+            Class keyClass = objectTypeDeterminer.getKeyClass(target.getClass(), property);\n+            return new EnumMap(keyClass);\n+        }\n+\n+        return objectFactory.buildBean(clazz, context);\n+    }\n+}"
        },
        {
            "sha": "639f658ac08716d0f01dc95b078635270796a831",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/XWorkBasicConverter.java",
            "status": "added",
            "additions": 583,
            "deletions": 0,
            "changes": 583,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkBasicConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkBasicConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkBasicConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,583 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.XWorkException;\n+import com.opensymphony.xwork2.conversion.ObjectTypeDeterminer;\n+import com.opensymphony.xwork2.conversion.TypeConverter;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.XWorkList;\n+\n+import java.lang.reflect.Array;\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.Member;\n+import java.math.BigDecimal;\n+import java.math.BigInteger;\n+import java.text.*;\n+import java.util.*;\n+\n+import org.apache.commons.lang.StringUtils;\n+\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ * <p/>\n+ * XWork will automatically handle the most common type conversion for you. This includes support for converting to\n+ * and from Strings for each of the following:\n+ * <p/>\n+ * <ul>\n+ * <li>String</li>\n+ * <li>boolean / Boolean</li>\n+ * <li>char / Character</li>\n+ * <li>int / Integer, float / Float, long / Long, double / Double</li>\n+ * <li>dates - uses the SHORT format for the Locale associated with the current request</li>\n+ * <li>arrays - assuming the individual strings can be coverted to the individual items</li>\n+ * <li>collections - if not object type can be determined, it is assumed to be a String and a new ArrayList is\n+ * created</li>\n+ * </ul>\n+ * <p/> Note that with arrays the type conversion will defer to the type of the array elements and try to convert each\n+ * item individually. As with any other type conversion, if the conversion can't be performed the standard type\n+ * conversion error reporting is used to indicate a problem occured while processing the type conversion.\n+ * <p/>\n+ * <!-- END SNIPPET: javadoc -->\n+ *\n+ * @author <a href=\"mailto:plightbo@gmail.com\">Pat Lightbody</a>\n+ * @author Mike Mosiewicz\n+ * @author Rainer Hermanns\n+ * @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+ */\n+public class XWorkBasicConverter extends DefaultTypeConverter {\n+\n+    private static String MILLISECOND_FORMAT = \".SSS\";\n+    \n+    private ObjectTypeDeterminer objectTypeDeterminer;\n+    private XWorkConverter xworkConverter;\n+    private ObjectFactory objectFactory;\n+\n+    @Inject\n+    public void setObjectTypeDeterminer(ObjectTypeDeterminer det) {\n+        this.objectTypeDeterminer = det;\n+    }\n+    \n+    @Inject\n+    public void setXWorkConverter(XWorkConverter conv) {\n+        this.xworkConverter = conv;\n+    }\n+    \n+    @Inject\n+    public void setObjectFactory(ObjectFactory fac) {\n+        this.objectFactory = fac;\n+    }\n+\n+    @Override\n+    public Object convertValue(Map<String, Object> context, Object o, Member member, String s, Object value, Class toType) {\n+        Object result = null;\n+\n+        if (value == null || toType.isAssignableFrom(value.getClass())) {\n+            // no need to convert at all, right?\n+            return value;\n+        }\n+\n+        if (toType == String.class) {\n+            /* the code below has been disabled as it causes sideffects in Struts2 (XW-512)\n+            // if input (value) is a number then use special conversion method (XW-490)\n+            Class inputType = value.getClass();\n+            if (Number.class.isAssignableFrom(inputType)) {\n+                result = doConvertFromNumberToString(context, value, inputType);\n+                if (result != null) {\n+                    return result;\n+                }\n+            }*/\n+            // okay use default string conversion\n+            result = doConvertToString(context, value);\n+        } else if (toType == boolean.class) {\n+            result = doConvertToBoolean(value);\n+        } else if (toType == Boolean.class) {\n+            result = doConvertToBoolean(value);\n+        } else if (toType.isArray()) {\n+            result = doConvertToArray(context, o, member, s, value, toType);\n+        } else if (Date.class.isAssignableFrom(toType)) {\n+            result = doConvertToDate(context, value, toType);\n+        } else if (Calendar.class.isAssignableFrom(toType)) {\n+            Date dateResult = (Date) doConvertToDate(context, value, Date.class);\n+            if (dateResult != null) {\n+                Calendar calendar = Calendar.getInstance();\n+                calendar.setTime(dateResult);\n+                result = calendar;\n+            } \n+        } else if (Collection.class.isAssignableFrom(toType)) {\n+            result = doConvertToCollection(context, o, member, s, value, toType);\n+        } else if (toType == Character.class) {\n+            result = doConvertToCharacter(value);\n+        } else if (toType == char.class) {\n+            result = doConvertToCharacter(value);\n+        } else if (Number.class.isAssignableFrom(toType) || toType.isPrimitive()) {\n+            result = doConvertToNumber(context, value, toType);\n+        } else if (toType == Class.class) {\n+            result = doConvertToClass(value);\n+        }\n+\n+        if (result == null) {\n+            if (value instanceof Object[]) {\n+                Object[] array = (Object[]) value;\n+\n+                if (array.length >= 1) {\n+                    value = array[0];\n+                } else {\n+                    value = null;\n+                }\n+\n+                // let's try to convert the first element only\n+                result = convertValue(context, o, member, s, value, toType);\n+            } else if (!\"\".equals(value)) { // we've already tried the types we know\n+                result = super.convertValue(context, value, toType);\n+            }\n+\n+            if (result == null && value != null && !\"\".equals(value)) {\n+                throw new XWorkException(\"Cannot create type \" + toType + \" from value \" + value);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private Locale getLocale(Map<String, Object> context) {\n+        if (context == null) {\n+            return Locale.getDefault();\n+        }\n+\n+        Locale locale = (Locale) context.get(ActionContext.LOCALE);\n+\n+        if (locale == null) {\n+            locale = Locale.getDefault();\n+        }\n+\n+        return locale;\n+    }\n+\n+    /**\n+     * Creates a Collection of the specified type.\n+     *\n+     * @param fromObject\n+     * @param propertyName\n+     * @param toType       the type of Collection to create\n+     * @param memberType   the type of object elements in this collection must be\n+     * @param size         the initial size of the collection (ignored if 0 or less)\n+     * @return a Collection of the specified type\n+     */\n+    private Collection createCollection(Object fromObject, String propertyName, Class toType, Class memberType, int size) {\n+//        try {\n+//            Object original = Ognl.getValue(OgnlUtil.compile(propertyName),fromObject);\n+//            if (original instanceof Collection) {\n+//                Collection coll = (Collection) original;\n+//                coll.clear();\n+//                return coll;\n+//            }\n+//        } catch (Exception e) {\n+//            // fail back to creating a new one\n+//        }\n+\n+        Collection result;\n+\n+        if (toType == Set.class) {\n+            if (size > 0) {\n+                result = new HashSet(size);\n+            } else {\n+                result = new HashSet();\n+            }\n+        } else if (toType == SortedSet.class) {\n+            result = new TreeSet();\n+        } else {\n+            if (size > 0) {\n+                result = new XWorkList(objectFactory, xworkConverter, memberType, size);\n+            } else {\n+                result = new XWorkList(objectFactory, xworkConverter, memberType);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private Object doConvertToArray(Map<String, Object> context, Object o, Member member, String s, Object value, Class toType) {\n+        Object result = null;\n+        Class componentType = toType.getComponentType();\n+\n+        if (componentType != null) {\n+            TypeConverter converter = getTypeConverter(context);\n+\n+            if (value.getClass().isArray()) {\n+                int length = Array.getLength(value);\n+                result = Array.newInstance(componentType, length);\n+\n+                for (int i = 0; i < length; i++) {\n+                    Object valueItem = Array.get(value, i);\n+                    Array.set(result, i, converter.convertValue(context, o, member, s, valueItem, componentType));\n+                }\n+            } else {\n+                result = Array.newInstance(componentType, 1);\n+                Array.set(result, 0, converter.convertValue(context, o, member, s, value, componentType));\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    private Object doConvertToCharacter(Object value) {\n+        if (value instanceof String) {\n+            String cStr = (String) value;\n+\n+            return (cStr.length() > 0) ? new Character(cStr.charAt(0)) : null;\n+        }\n+\n+        return null;\n+    }\n+\n+    private Object doConvertToBoolean(Object value) {\n+        if (value instanceof String) {\n+            String bStr = (String) value;\n+\n+            return Boolean.valueOf(bStr);\n+        }\n+\n+        return null;\n+    }\n+\n+    private Class doConvertToClass(Object value) {\n+        Class clazz = null;\n+\n+        if (value instanceof String && value != null && ((String) value).length() > 0) {\n+            try {\n+                clazz = Class.forName((String) value);\n+            } catch (ClassNotFoundException e) {\n+                throw new XWorkException(e.getLocalizedMessage(), e);\n+            }\n+        }\n+\n+        return clazz;\n+    }\n+\n+    private Collection doConvertToCollection(Map<String, Object> context, Object o, Member member, String prop, Object value, Class toType) {\n+        Collection result;\n+        Class memberType = String.class;\n+\n+        if (o != null) {\n+            //memberType = (Class) XWorkConverter.getInstance().getConverter(o.getClass(), XWorkConverter.CONVERSION_COLLECTION_PREFIX + prop);\n+            memberType = objectTypeDeterminer.getElementClass(o.getClass(), prop, null);\n+\n+            if (memberType == null) {\n+                memberType = String.class;\n+            }\n+        }\n+\n+        if (toType.isAssignableFrom(value.getClass())) {\n+            // no need to do anything\n+            result = (Collection) value;\n+        } else if (value.getClass().isArray()) {\n+            Object[] objArray = (Object[]) value;\n+            TypeConverter converter = getTypeConverter(context);\n+            result = createCollection(o, prop, toType, memberType, objArray.length);\n+\n+            for (Object anObjArray : objArray) {\n+                result.add(converter.convertValue(context, o, member, prop, anObjArray, memberType));\n+            }\n+        } else if (Collection.class.isAssignableFrom(value.getClass())) {\n+            Collection col = (Collection) value;\n+            TypeConverter converter = getTypeConverter(context);\n+            result = createCollection(o, prop, toType, memberType, col.size());\n+\n+            for (Object aCol : col) {\n+                result.add(converter.convertValue(context, o, member, prop, aCol, memberType));\n+            }\n+        } else {\n+            result = createCollection(o, prop, toType, memberType, -1);\n+            result.add(value);\n+        }\n+\n+        return result;\n+    }\n+\n+    private Object doConvertToDate(Map<String, Object> context, Object value, Class toType) {\n+        Date result = null;\n+\n+        if (value instanceof String && value != null && ((String) value).length() > 0) {\n+            String sa = (String) value;\n+            Locale locale = getLocale(context);\n+\n+            DateFormat df = null;\n+            if (java.sql.Time.class == toType) {\n+                df = DateFormat.getTimeInstance(DateFormat.MEDIUM, locale);\n+            } else if (java.sql.Timestamp.class == toType) {\n+                Date check = null;\n+                SimpleDateFormat dtfmt = (SimpleDateFormat) DateFormat.getDateTimeInstance(DateFormat.SHORT,\n+                        DateFormat.MEDIUM,\n+                        locale);\n+                SimpleDateFormat fullfmt = new SimpleDateFormat(dtfmt.toPattern() + MILLISECOND_FORMAT,\n+                        locale);\n+\n+                SimpleDateFormat dfmt = (SimpleDateFormat) DateFormat.getDateInstance(DateFormat.SHORT,\n+                        locale);\n+\n+                SimpleDateFormat[] fmts = {fullfmt, dtfmt, dfmt};\n+                for (SimpleDateFormat fmt : fmts) {\n+                    try {\n+                        check = fmt.parse(sa);\n+                        df = fmt;\n+                        if (check != null) {\n+                            break;\n+                        }\n+                    } catch (ParseException ignore) {\n+                    }\n+                }\n+            } else if (java.util.Date.class == toType) {\n+                Date check = null;\n+                DateFormat[] dfs = getDateFormats(locale);\n+                for (DateFormat df1 : dfs) {\n+                    try {\n+                        check = df1.parse(sa);\n+                        df = df1;\n+                        if (check != null) {\n+                            break;\n+                        }\n+                    }\n+                    catch (ParseException ignore) {\n+                    }\n+                }\n+            }\n+            //final fallback for dates without time\n+            if (df == null) {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+            }\n+            try {\n+                df.setLenient(false); // let's use strict parsing (XW-341)\n+                result = df.parse(sa);\n+                if (!(Date.class == toType)) {\n+                    try {\n+                        Constructor constructor = toType.getConstructor(new Class[]{long.class});\n+                        return constructor.newInstance(new Object[]{Long.valueOf(result.getTime())});\n+                    } catch (Exception e) {\n+                        throw new XWorkException(\"Couldn't create class \" + toType + \" using default (long) constructor\", e);\n+                    }\n+                }\n+            } catch (ParseException e) {\n+                throw new XWorkException(\"Could not parse date\", e);\n+            }\n+        } else if (Date.class.isAssignableFrom(value.getClass())) {\n+            result = (Date) value;\n+        }\n+        return result;\n+    }\n+\n+    private DateFormat[] getDateFormats(Locale locale) {\n+        DateFormat dt1 = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.LONG, locale);\n+        DateFormat dt2 = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.MEDIUM, locale);\n+        DateFormat dt3 = DateFormat.getDateTimeInstance(DateFormat.SHORT, DateFormat.SHORT, locale);\n+\n+        DateFormat d1 = DateFormat.getDateInstance(DateFormat.SHORT, locale);\n+        DateFormat d2 = DateFormat.getDateInstance(DateFormat.MEDIUM, locale);\n+        DateFormat d3 = DateFormat.getDateInstance(DateFormat.LONG, locale);\n+\n+        DateFormat rfc3399 = new SimpleDateFormat(\"yyyy-MM-dd'T'HH:mm:ss\");\n+\n+        DateFormat[] dfs = {dt1, dt2, dt3, rfc3399, d1, d2, d3}; //added RFC 3339 date format (XW-473)\n+        return dfs;\n+    }\n+\n+    private Object doConvertToNumber(Map<String, Object> context, Object value, Class toType) {\n+        if (value instanceof String) {\n+            if (toType == BigDecimal.class) {\n+                return new BigDecimal((String) value);\n+            } else if (toType == BigInteger.class) {\n+                return new BigInteger((String) value);\n+            } else if (toType.isPrimitive()) {\n+                Object convertedValue = super.convertValue(context, value, toType);\n+                String stringValue = (String) value;\n+                if (!isInRange((Number)convertedValue, stringValue,  toType))\n+                        throw new XWorkException(\"Overflow or underflow casting: \\\"\" + stringValue + \"\\\" into class \" + convertedValue.getClass().getName());\n+\n+                return convertedValue;\n+            } else {\n+                String stringValue = (String) value;\n+                if (!toType.isPrimitive() && (stringValue == null || stringValue.length() == 0)) {\n+                    return null;\n+                }\n+                NumberFormat numFormat = NumberFormat.getInstance(getLocale(context));\n+                ParsePosition parsePos = new ParsePosition(0);\n+                if (isIntegerType(toType)) {\n+                    numFormat.setParseIntegerOnly(true);\n+                }\n+                numFormat.setGroupingUsed(true);\n+                Number number = numFormat.parse(stringValue, parsePos);\n+\n+                if (parsePos.getIndex() != stringValue.length()) {\n+                    throw new XWorkException(\"Unparseable number: \\\"\" + stringValue + \"\\\" at position \"\n+                            + parsePos.getIndex());\n+                } else {\n+                    if (!isInRange(number, stringValue,  toType))\n+                        throw new XWorkException(\"Overflow or underflow casting: \\\"\" + stringValue + \"\\\" into class \" + number.getClass().getName());\n+                    \n+                    value = super.convertValue(context, number, toType);\n+                }\n+            }\n+        } else if (value instanceof Object[]) {\n+            Object[] objArray = (Object[]) value;\n+\n+            if (objArray.length == 1) {\n+                return doConvertToNumber(context, objArray[0], toType);\n+            }\n+        }\n+\n+        // pass it through DefaultTypeConverter\n+        return super.convertValue(context, value, toType);\n+    }\n+\n+    protected boolean isInRange(Number value, String stringValue, Class toType) {\n+        Number bigValue = null;\n+        Number lowerBound = null;\n+        Number upperBound = null;\n+\n+        try {\n+            if (double.class == toType || Double.class == toType) {\n+                bigValue = new BigDecimal(stringValue);\n+                // Double.MIN_VALUE is the smallest positive non-zero number\n+                lowerBound = BigDecimal.valueOf(Double.MAX_VALUE).negate();\n+                upperBound = BigDecimal.valueOf(Double.MAX_VALUE);\n+            } else if (float.class == toType || Float.class == toType) {\n+                bigValue = new BigDecimal(stringValue);\n+                // Float.MIN_VALUE is the smallest positive non-zero number\n+                lowerBound = BigDecimal.valueOf(Float.MAX_VALUE).negate();\n+                upperBound = BigDecimal.valueOf(Float.MAX_VALUE);\n+            } else if (byte.class == toType || Byte.class == toType) {\n+                bigValue = new BigInteger(stringValue);\n+                lowerBound = BigInteger.valueOf(Byte.MIN_VALUE);\n+                upperBound = BigInteger.valueOf(Byte.MAX_VALUE);\n+            } else if (char.class == toType || Character.class == toType) {\n+                bigValue = new BigInteger(stringValue);\n+                lowerBound = BigInteger.valueOf(Character.MIN_VALUE);\n+                upperBound = BigInteger.valueOf(Character.MAX_VALUE);\n+            } else if (short.class == toType || Short.class == toType) {\n+                bigValue = new BigInteger(stringValue);\n+                lowerBound = BigInteger.valueOf(Short.MIN_VALUE);\n+                upperBound = BigInteger.valueOf(Short.MAX_VALUE);\n+            } else if (int.class == toType || Integer.class == toType) {\n+                bigValue = new BigInteger(stringValue);\n+                lowerBound = BigInteger.valueOf(Integer.MIN_VALUE);\n+                upperBound = BigInteger.valueOf(Integer.MAX_VALUE);\n+            } else if (long.class == toType || Long.class == toType) {\n+                bigValue = new BigInteger(stringValue);\n+                lowerBound = BigInteger.valueOf(Long.MIN_VALUE);\n+                upperBound = BigInteger.valueOf(Long.MAX_VALUE);\n+            }\n+        } catch (NumberFormatException e) {\n+            //shoult it fail here? BigInteger doesnt seem to be so nice parsing numbers as NumberFormat\n+            return true;\n+        }\n+\n+        return ((Comparable)bigValue).compareTo(lowerBound) >= 0 && ((Comparable)bigValue).compareTo(upperBound) <= 0;\n+    }\n+\n+    protected boolean isIntegerType(Class type) {\n+        if (double.class == type || float.class == type || Double.class == type || Float.class == type\n+                || char.class == type || Character.class == type) {\n+            return false;\n+        }\n+\n+        return true;\n+    }\n+\n+    /**\n+     * Converts the input as a number using java's number formatter to a string output.\n+     */\n+    private String doConvertFromNumberToString(Map<String, Object> context, Object value, Class toType) {\n+        // XW-409: If the input is a Number we should format it to a string using the choosen locale and use java's numberformatter\n+        if (Number.class.isAssignableFrom(toType)) {\n+            NumberFormat numFormat = NumberFormat.getInstance(getLocale(context));\n+            if (isIntegerType(toType)) {\n+                numFormat.setParseIntegerOnly(true);\n+            }\n+            numFormat.setGroupingUsed(true);\n+            numFormat.setMaximumFractionDigits(99); // to be sure we include all digits after decimal seperator, otherwise some of the fractions can be chopped\n+\n+            String number = numFormat.format(value);\n+            if (number != null) {\n+                return number;\n+            }\n+        }\n+\n+        return null; // no number\n+    }\n+\n+\n+    private String doConvertToString(Map<String, Object> context, Object value) {\n+        String result = null;\n+\n+        if (value instanceof int[]) {\n+            int[] x = (int[]) value;\n+            List<Integer> intArray = new ArrayList<Integer>(x.length);\n+\n+            for (int aX : x) {\n+                intArray.add(Integer.valueOf(aX));\n+            }\n+\n+            result = StringUtils.join(intArray, \", \");\n+        } else if (value instanceof long[]) {\n+            long[] x = (long[]) value;\n+            List<Long> longArray = new ArrayList<Long>(x.length);\n+\n+            for (long aX : x) {\n+                longArray.add(Long.valueOf(aX));\n+            }\n+\n+            result = StringUtils.join(longArray, \", \");\n+        } else if (value instanceof double[]) {\n+            double[] x = (double[]) value;\n+            List<Double> doubleArray = new ArrayList<Double>(x.length);\n+\n+            for (double aX : x) {\n+                doubleArray.add(new Double(aX));\n+            }\n+\n+            result = StringUtils.join(doubleArray, \", \");\n+        } else if (value instanceof boolean[]) {\n+            boolean[] x = (boolean[]) value;\n+            List<Boolean> booleanArray = new ArrayList<Boolean>(x.length);\n+\n+            for (boolean aX : x) {\n+                booleanArray.add(new Boolean(aX));\n+            }\n+\n+            result = StringUtils.join(booleanArray, \", \");\n+        } else if (value instanceof Date) {\n+            DateFormat df = null;\n+            if (value instanceof java.sql.Time) {\n+                df = DateFormat.getTimeInstance(DateFormat.MEDIUM, getLocale(context));\n+            } else if (value instanceof java.sql.Timestamp) {\n+                SimpleDateFormat dfmt = (SimpleDateFormat) DateFormat.getDateTimeInstance(DateFormat.SHORT,\n+                        DateFormat.MEDIUM,\n+                        getLocale(context));\n+                df = new SimpleDateFormat(dfmt.toPattern() + MILLISECOND_FORMAT);\n+            } else {\n+                df = DateFormat.getDateInstance(DateFormat.SHORT, getLocale(context));\n+            }\n+            result = df.format(value);\n+        } else if (value instanceof String[]) {\n+            result = StringUtils.join((String[]) value, \", \");\n+        }\n+\n+        return result;\n+    }\n+}"
        },
        {
            "sha": "aae1c9df87f8bb7b4fa5e6044c671d78c86ac651",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/impl/XWorkConverter.java",
            "status": "added",
            "additions": 839,
            "deletions": 0,
            "changes": 839,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkConverter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkConverter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fimpl%2FXWorkConverter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,839 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.impl;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ObjectFactory;\n+import com.opensymphony.xwork2.XWorkMessages;\n+import com.opensymphony.xwork2.XWorkException;\n+import com.opensymphony.xwork2.conversion.TypeConverter;\n+import com.opensymphony.xwork2.conversion.annotations.Conversion;\n+import com.opensymphony.xwork2.conversion.annotations.ConversionRule;\n+import com.opensymphony.xwork2.conversion.annotations.ConversionType;\n+import com.opensymphony.xwork2.conversion.annotations.TypeConversion;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.ognl.XWorkTypeConverterWrapper;\n+import com.opensymphony.xwork2.util.*;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n+\n+import java.io.IOException;\n+import java.io.InputStream;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.Member;\n+import java.lang.reflect.Method;\n+import java.net.URL;\n+import java.util.*;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+import java.text.MessageFormat;\n+\n+\n+/**\n+ * XWorkConverter is a singleton used by many of the Struts 2's Ognl extention points,\n+ * such as InstantiatingNullHandler, XWorkListPropertyAccessor etc to do object\n+ * conversion.\n+ * <p/>\n+ * <!-- START SNIPPET: javadoc -->\n+ * <p/>\n+ * Type conversion is great for situations where you need to turn a String in to a more complex object. Because the web\n+ * is type-agnostic (everything is a string in HTTP), Struts 2's type conversion features are very useful. For instance,\n+ * if you were prompting a user to enter in coordinates in the form of a string (such as \"3, 22\"), you could have\n+ * Struts 2 do the conversion both from String to Point and from Point to String.\n+ * <p/>\n+ * <p/> Using this \"point\" example, if your action (or another compound object in which you are setting properties on)\n+ * has a corresponding ClassName-conversion.properties file, Struts 2 will use the configured type converters for\n+ * conversion to and from strings. So turning \"3, 22\" in to new Point(3, 22) is done by merely adding the following\n+ * entry to <b>ClassName-conversion.properties</b> (Note that the PointConverter should impl the TypeConverter\n+ * interface):\n+ * <p/>\n+ * <p/><b>point = com.acme.PointConverter</b>\n+ * <p/>\n+ * <p/> Your type converter should be sure to check what class type it is being requested to convert. Because it is used\n+ * for both to and from strings, you will need to split the conversion method in to two parts: one that turns Strings in\n+ * to Points, and one that turns Points in to Strings.\n+ * <p/>\n+ * <p/> After this is done, you can now reference your point (using &lt;s:property value=\"point\"/&gt; in JSP or ${point}\n+ * in FreeMarker) and it will be printed as \"3, 22\" again. As such, if you submit this back to an action, it will be\n+ * converted back to a Point once again.\n+ * <p/>\n+ * <p/> In some situations you may wish to apply a type converter globally. This can be done by editing the file\n+ * <b>xwork-conversion.properties</b> in the root of your class path (typically WEB-INF/classes) and providing a\n+ * property in the form of the class name of the object you wish to convert on the left hand side and the class name of\n+ * the type converter on the right hand side. For example, providing a type converter for all Point objects would mean\n+ * adding the following entry:\n+ * <p/>\n+ * <p/><b>com.acme.Point = com.acme.PointConverter</b>\n+ * <p/>\n+ * <!-- END SNIPPET: javadoc -->\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: i18n-note -->\n+ * <p/>\n+ * Type conversion should not be used as a substitute for i18n. It is not recommended to use this feature to print out\n+ * properly formatted dates. Rather, you should use the i18n features of Struts 2 (and consult the JavaDocs for JDK's\n+ * MessageFormat object) to see how a properly formatted date should be displayed.\n+ * <p/>\n+ * <!-- END SNIPPET: i18n-note -->\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: error-reporting -->\n+ * <p/>\n+ * Any error that occurs during type conversion may or may not wish to be reported. For example, reporting that the\n+ * input \"abc\" could not be converted to a number might be important. On the other hand, reporting that an empty string,\n+ * \"\", cannot be converted to a number might not be important - especially in a web environment where it is hard to\n+ * distinguish between a user not entering a value vs. entering a blank value.\n+ * <p/>\n+ * <p/> By default, all conversion errors are reported using the generic i18n key <b>xwork.default.invalid.fieldvalue</b>,\n+ * which you can override (the default text is <i>Invalid field value for field \"xxx\"</i>, where xxx is the field name)\n+ * in your global i18n resource bundle.\n+ * <p/>\n+ * <p/>However, sometimes you may wish to override this message on a per-field basis. You can do this by adding an i18n\n+ * key associated with just your action (Action.properties) using the pattern <b>invalid.fieldvalue.xxx</b>, where xxx\n+ * is the field name.\n+ * <p/>\n+ * <p/>It is important to know that none of these errors are actually reported directly. Rather, they are added to a map\n+ * called <i>conversionErrors</i> in the ActionContext. There are several ways this map can then be accessed and the\n+ * errors can be reported accordingly.\n+ * <p/>\n+ * <!-- END SNIPPET: error-reporting -->\n+ *\n+ * @author <a href=\"mailto:plightbo@gmail.com\">Pat Lightbody</a>\n+ * @author Rainer Hermanns\n+ * @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+ * @author tm_jee\n+ * @version $Date$ $Id$\n+ * @see XWorkBasicConverter\n+ */\n+public class XWorkConverter extends DefaultTypeConverter {\n+\n+    protected static final Logger LOG = LoggerFactory.getLogger(XWorkConverter.class);\n+    public static final String REPORT_CONVERSION_ERRORS = \"report.conversion.errors\";\n+    public static final String CONVERSION_PROPERTY_FULLNAME = \"conversion.property.fullName\";\n+    public static final String CONVERSION_ERROR_PROPERTY_PREFIX = \"invalid.fieldvalue.\";\n+    public static final String CONVERSION_COLLECTION_PREFIX = \"Collection_\";\n+\n+    public static final String LAST_BEAN_CLASS_ACCESSED = \"last.bean.accessed\";\n+    public static final String LAST_BEAN_PROPERTY_ACCESSED = \"last.property.accessed\";\n+    public static final String MESSAGE_INDEX_PATTERN = \"\\\\[\\\\d+\\\\]\\\\.\";\n+    public static final String MESSAGE_INDEX_BRACKET_PATTERN = \"[\\\\[\\\\]\\\\.]\";\n+    public static final String PERIOD = \".\";\n+    public static final Pattern messageIndexPattern = Pattern.compile(MESSAGE_INDEX_PATTERN); \n+\n+    /**\n+     * Target class conversion Mappings.\n+     * <pre>\n+     * Map<Class, Map<String, Object>>\n+     *  - Class -> convert to class\n+     *  - Map<String, Object>\n+     *    - String -> property name\n+     *                eg. Element_property, property etc.\n+     *    - Object -> String to represent properties\n+     *                eg. value part of\n+     *                    KeyProperty_property=id\n+     *             -> TypeConverter to represent an Ognl TypeConverter\n+     *                eg. value part of\n+     *                    property=foo.bar.MyConverter\n+     *             -> Class to represent a class\n+     *                eg. value part of\n+     *                    Element_property=foo.bar.MyObject\n+     * </pre>\n+     */\n+    protected HashMap<Class, Map<String, Object>> mappings = new HashMap<Class, Map<String, Object>>(); // action\n+\n+    /**\n+     * Unavailable target class conversion mappings, serves as a simple cache.\n+     */\n+    protected HashSet<Class> noMapping = new HashSet<Class>(); // action\n+\n+    /**\n+     * Record class and its type converter mapping.\n+     * <pre>\n+     * - String - classname as String\n+     * - TypeConverter - instance of TypeConverter\n+     * </pre>\n+     */\n+    protected HashMap<String, TypeConverter> defaultMappings = new HashMap<String, TypeConverter>();  // non-action (eg. returned value)\n+\n+    /**\n+     * Record classes that doesn't have conversion mapping defined.\n+     * <pre>\n+     * - String -> classname as String\n+     * </pre>\n+     */\n+    protected HashSet<String> unknownMappings = new HashSet<String>();     // non-action (eg. returned value)\n+\n+    private TypeConverter defaultTypeConverter;\n+    private ObjectFactory objectFactory;\n+\n+\n+    protected XWorkConverter() {\n+    }\n+\n+    @Inject\n+    public void setObjectFactory(ObjectFactory factory) {\n+        this.objectFactory = factory;\n+        // note: this file is deprecated\n+        loadConversionProperties(\"xwork-default-conversion.properties\");\n+\n+        loadConversionProperties(\"xwork-conversion.properties\");\n+    }\n+\n+    @Inject\n+    public void setDefaultTypeConverter(XWorkBasicConverter conv) {\n+        this.defaultTypeConverter = conv;\n+    }\n+\n+    public static String getConversionErrorMessage(String propertyName, ValueStack stack) {\n+        String defaultMessage = LocalizedTextUtil.findDefaultText(XWorkMessages.DEFAULT_INVALID_FIELDVALUE,\n+                ActionContext.getContext().getLocale(),\n+                new Object[]{\n+                        propertyName\n+                });\n+\n+        List<String> indexValues = getIndexValues(propertyName);\n+\n+        propertyName = removeAllIndexesInProperyName(propertyName);\n+\n+        String getTextExpression = \"getText('\" + CONVERSION_ERROR_PROPERTY_PREFIX + propertyName + \"','\" + defaultMessage + \"')\";\n+        String message = (String) stack.findValue(getTextExpression);\n+\n+        if (message == null) {\n+            message = defaultMessage;\n+        } else {\n+            message = MessageFormat.format(message, indexValues.toArray());\n+        }\n+\n+        return message;\n+    }\n+\n+    private static String removeAllIndexesInProperyName(String propertyName) {\n+        return propertyName.replaceAll(MESSAGE_INDEX_PATTERN, PERIOD);\n+    }\n+\n+    private static List<String> getIndexValues(String propertyName) {\n+        Matcher matcher = messageIndexPattern.matcher(propertyName);\n+        List<String> indexes = new ArrayList<String>();\n+        while (matcher.find()) {\n+            Integer index = new Integer(matcher.group().replaceAll(MESSAGE_INDEX_BRACKET_PATTERN, \"\")) + 1;\n+            indexes.add(Integer.toString(index));\n+        }\n+        return indexes;\n+    }\n+\n+    public static String buildConverterFilename(Class clazz) {\n+        String className = clazz.getName();\n+        return className.replace('.', '/') + \"-conversion.properties\";\n+    }\n+\n+    @Override\n+    public Object convertValue(Map<String, Object> map, Object o, Class aClass) {\n+        return convertValue(map, null, null, null, o, aClass);\n+    }\n+\n+    /**\n+     * Convert value from one form to another.\n+     * Minimum requirement of arguments:\n+     * <ul>\n+     * <li>supplying context, toClass and value</li>\n+     * <li>supplying context, target and value.</li>\n+     * </ul>\n+     *\n+     * @see TypeConverter#convertValue(java.util.Map, java.lang.Object, java.lang.reflect.Member, java.lang.String, java.lang.Object, java.lang.Class)\n+     */\n+    @Override\n+    public Object convertValue(Map<String, Object> context, Object target, Member member, String property, Object value, Class toClass) {\n+        //\n+        // Process the conversion using the default mappings, if one exists\n+        //\n+        TypeConverter tc = null;\n+\n+        if ((value != null) && (toClass == value.getClass())) {\n+            return value;\n+        }\n+\n+        // allow this method to be called without any context\n+        // i.e. it can be called with as little as \"Object value\" and \"Class toClass\"\n+        if (target != null) {\n+            Class clazz = target.getClass();\n+\n+            Object[] classProp = null;\n+\n+            // this is to handle weird issues with setValue with a different type\n+            if ((target instanceof CompoundRoot) && (context != null)) {\n+                classProp = getClassProperty(context);\n+            }\n+\n+            if (classProp != null) {\n+                clazz = (Class) classProp[0];\n+                property = (String) classProp[1];\n+            }\n+\n+            tc = (TypeConverter) getConverter(clazz, property);\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"field-level type converter for property [\" + property + \"] = \" + (tc == null ? \"none found\" : tc));\n+        }\n+\n+        if (tc == null && context != null) {\n+            // ok, let's see if we can look it up by path as requested in XW-297\n+            Object lastPropertyPath = context.get(ReflectionContextState.CURRENT_PROPERTY_PATH);\n+            Class clazz = (Class) context.get(XWorkConverter.LAST_BEAN_CLASS_ACCESSED);\n+            if (lastPropertyPath != null && clazz != null) {\n+                String path = lastPropertyPath + \".\" + property;\n+                tc = (TypeConverter) getConverter(clazz, path);\n+            }\n+        }\n+\n+        if (tc == null) {\n+            if (toClass.equals(String.class) && (value != null) && !(value.getClass().equals(String.class) || value.getClass().equals(String[].class))) {\n+                // when converting to a string, use the source target's class's converter\n+                tc = lookup(value.getClass());\n+            } else {\n+                // when converting from a string, use the toClass's converter\n+                tc = lookup(toClass);\n+            }\n+\n+            if (LOG.isDebugEnabled())\n+                LOG.debug(\"global-level type converter for property [\" + property + \"] = \" + (tc == null ? \"none found\" : tc));\n+        }\n+\n+\n+        if (tc != null) {\n+            try {\n+                return tc.convertValue(context, target, member, property, value, toClass);\n+            } catch (Exception e) {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"unable to convert value using type converter [#0]\", e, tc.getClass().getName());\n+                handleConversionException(context, property, value, target);\n+\n+                return TypeConverter.NO_CONVERSION_POSSIBLE;\n+            }\n+        }\n+\n+        if (defaultTypeConverter != null) {\n+            try {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"falling back to default type converter [\" + defaultTypeConverter + \"]\");\n+                return defaultTypeConverter.convertValue(context, target, member, property, value, toClass);\n+            } catch (Exception e) {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"unable to convert value using type converter [#0]\", e, defaultTypeConverter.getClass().getName());\n+                handleConversionException(context, property, value, target);\n+\n+                return TypeConverter.NO_CONVERSION_POSSIBLE;\n+            }\n+        } else {\n+            try {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"falling back to Ognl's default type conversion\");\n+                return super.convertValue(value, toClass);\n+            } catch (Exception e) {\n+                if (LOG.isDebugEnabled())\n+                    LOG.debug(\"unable to convert value using type converter [#0]\", e, super.getClass().getName());\n+                handleConversionException(context, property, value, target);\n+\n+                return TypeConverter.NO_CONVERSION_POSSIBLE;\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Looks for a TypeConverter in the default mappings.\n+     *\n+     * @param className name of the class the TypeConverter must handle\n+     * @return a TypeConverter to handle the specified class or null if none can be found\n+     */\n+    public TypeConverter lookup(String className) {\n+        if (unknownMappings.contains(className) && !defaultMappings.containsKey(className)) {\n+            return null;\n+        }\n+\n+        TypeConverter result = defaultMappings.get(className);\n+\n+        //Looks for super classes\n+        if (result == null) {\n+            Class clazz = null;\n+\n+            try {\n+                clazz = Thread.currentThread().getContextClassLoader().loadClass(className);\n+            } catch (ClassNotFoundException cnfe) {\n+                //swallow\n+            }\n+\n+            result = lookupSuper(clazz);\n+\n+            if (result != null) {\n+                //Register now, the next lookup will be faster\n+                registerConverter(className, result);\n+            } else {\n+                // if it isn't found, never look again (also faster)\n+                registerConverterNotFound(className);\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Looks for a TypeConverter in the default mappings.\n+     *\n+     * @param clazz the class the TypeConverter must handle\n+     * @return a TypeConverter to handle the specified class or null if none can be found\n+     */\n+    public TypeConverter lookup(Class clazz) {\n+        return lookup(clazz.getName());\n+    }\n+\n+    protected Object getConverter(Class clazz, String property) {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Property: \" + property);\n+            LOG.debug(\"Class: \" + clazz.getName());\n+        }\n+        synchronized (clazz) {\n+            if ((property != null) && !noMapping.contains(clazz)) {\n+                try {\n+                    Map<String, Object> mapping = mappings.get(clazz);\n+\n+                    if (mapping == null) {\n+                        mapping = buildConverterMapping(clazz);\n+                    } else {\n+                        mapping = conditionalReload(clazz, mapping);\n+                    }\n+\n+                    Object converter = mapping.get(property);\n+                    if (LOG.isDebugEnabled() && converter == null) {\n+                        LOG.debug(\"converter is null for property \" + property + \". Mapping size: \" + mapping.size());\n+                        for (String next : mapping.keySet()) {\n+                            LOG.debug(next + \":\" + mapping.get(next));\n+                        }\n+                    }\n+                    return converter;\n+                } catch (Throwable t) {\n+                    noMapping.add(clazz);\n+                }\n+            }\n+        }\n+\n+        return null;\n+    }\n+\n+    protected void handleConversionException(Map<String, Object> context, String property, Object value, Object object) {\n+        if (context != null && (Boolean.TRUE.equals(context.get(REPORT_CONVERSION_ERRORS)))) {\n+            String realProperty = property;\n+            String fullName = (String) context.get(CONVERSION_PROPERTY_FULLNAME);\n+\n+            if (fullName != null) {\n+                realProperty = fullName;\n+            }\n+\n+            Map<String, Object> conversionErrors = (Map<String, Object>) context.get(ActionContext.CONVERSION_ERRORS);\n+\n+            if (conversionErrors == null) {\n+                conversionErrors = new HashMap<String, Object>();\n+                context.put(ActionContext.CONVERSION_ERRORS, conversionErrors);\n+            }\n+\n+            conversionErrors.put(realProperty, value);\n+        }\n+    }\n+\n+    public synchronized void registerConverter(String className, TypeConverter converter) {\n+        defaultMappings.put(className, converter);\n+        if (unknownMappings.contains(className)) {\n+            unknownMappings.remove(className);\n+        }\n+    }\n+\n+    public synchronized void registerConverterNotFound(String className) {\n+        unknownMappings.add(className);\n+    }\n+\n+    private Object[] getClassProperty(Map<String, Object> context) {\n+        Object lastClass = context.get(LAST_BEAN_CLASS_ACCESSED);\n+        Object lastProperty = context.get(LAST_BEAN_PROPERTY_ACCESSED);\n+        return (lastClass != null && lastProperty != null) ? new Object[] {lastClass, lastProperty} : null;\n+    }\n+\n+    /**\n+     * Looks for converter mappings for the specified class and adds it to an existing map.  Only new converters are\n+     * added.  If a converter is defined on a key that already exists, the converter is ignored.\n+     *\n+     * @param mapping an existing map to add new converter mappings to\n+     * @param clazz   class to look for converter mappings for\n+     */\n+    protected void addConverterMapping(Map<String, Object> mapping, Class clazz) {\n+        try {\n+            String converterFilename = buildConverterFilename(clazz);\n+            InputStream is = FileManager.loadFile(converterFilename, clazz);\n+\n+            if (is != null) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"processing conversion file [\" + converterFilename + \"] [class=\" + clazz + \"]\");\n+                }\n+\n+                Properties prop = new Properties();\n+                prop.load(is);\n+\n+                for (Map.Entry<Object, Object> entry : prop.entrySet()) {\n+                    String key = (String) entry.getKey();\n+\n+                    if (mapping.containsKey(key)) {\n+                        break;\n+                    }\n+                    // for keyProperty of Set\n+                    if (key.startsWith(DefaultObjectTypeDeterminer.KEY_PROPERTY_PREFIX)\n+                            || key.startsWith(DefaultObjectTypeDeterminer.CREATE_IF_NULL_PREFIX)) {\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \"[treated as String]\");\n+                        }\n+                        mapping.put(key, entry.getValue());\n+                    }\n+                    //for properties of classes\n+                    else if (!(key.startsWith(DefaultObjectTypeDeterminer.ELEMENT_PREFIX) ||\n+                            key.startsWith(DefaultObjectTypeDeterminer.KEY_PREFIX) ||\n+                            key.startsWith(DefaultObjectTypeDeterminer.DEPRECATED_ELEMENT_PREFIX))\n+                            ) {\n+                        TypeConverter _typeConverter = createTypeConverter((String) entry.getValue());\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \"[treated as TypeConverter \" + _typeConverter + \"]\");\n+                        }\n+                        mapping.put(key, _typeConverter);\n+                    }\n+                    //for keys of Maps\n+                    else if (key.startsWith(DefaultObjectTypeDeterminer.KEY_PREFIX)) {\n+\n+                        Class converterClass = Thread.currentThread().getContextClassLoader().loadClass((String) entry.getValue());\n+\n+                        //check if the converter is a type converter if it is one\n+                        //then just put it in the map as is. Otherwise\n+                        //put a value in for the type converter of the class\n+                        if (converterClass.isAssignableFrom(TypeConverter.class)) {\n+                            TypeConverter _typeConverter = createTypeConverter((String) entry.getValue());\n+                            if (LOG.isDebugEnabled()) {\n+                                LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \"[treated as TypeConverter \" + _typeConverter + \"]\");\n+                            }\n+                            mapping.put(key, _typeConverter);\n+                        } else {\n+                            if (LOG.isDebugEnabled()) {\n+                                LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \"[treated as Class \" + converterClass + \"]\");\n+                            }\n+                            mapping.put(key, converterClass);\n+                        }\n+                    }\n+                    //elements(values) of maps / lists\n+                    else {\n+                        Class _c = Thread.currentThread().getContextClassLoader().loadClass((String) entry.getValue());\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \"[treated as Class \" + _c + \"]\");\n+                        }\n+                        mapping.put(key, _c);\n+                    }\n+                }\n+            }\n+        } catch (Exception ex) {\n+            LOG.error(\"Problem loading properties for \" + clazz.getName(), ex);\n+        }\n+\n+        // Process annotations\n+        Annotation[] annotations = clazz.getAnnotations();\n+\n+        for (Annotation annotation : annotations) {\n+            if (annotation instanceof Conversion) {\n+                Conversion conversion = (Conversion) annotation;\n+\n+                for (TypeConversion tc : conversion.conversions()) {\n+\n+                    String key = tc.key();\n+\n+                    if (mapping.containsKey(key)) {\n+                        break;\n+                    }\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(key + \":\" + key);\n+                    }\n+\n+                    if (key != null) {\n+                        try {\n+                            if (tc.type() == ConversionType.APPLICATION) {\n+                                defaultMappings.put(key, createTypeConverter(tc.converter()));\n+                            } else {\n+                                if (tc.rule().toString().equals(ConversionRule.KEY_PROPERTY) || tc.rule().toString().equals(ConversionRule.CREATE_IF_NULL)) {\n+                                    mapping.put(key, tc.value());\n+                                }\n+                                //for properties of classes\n+                                else if (!(tc.rule().toString().equals(ConversionRule.ELEMENT.toString())) ||\n+                                        tc.rule().toString().equals(ConversionRule.KEY.toString()) ||\n+                                        tc.rule().toString().equals(ConversionRule.COLLECTION.toString())\n+                                        ) {\n+                                    mapping.put(key, createTypeConverter(tc.converter()));\n+\n+\n+                                }\n+                                //for keys of Maps\n+                                else if (tc.rule().toString().equals(ConversionRule.KEY.toString())) {\n+                                    Class converterClass = Thread.currentThread().getContextClassLoader().loadClass(tc.converter());\n+                                    if (LOG.isDebugEnabled()) {\n+                                        LOG.debug(\"Converter class: \" + converterClass);\n+                                    }\n+                                    //check if the converter is a type converter if it is one\n+                                    //then just put it in the map as is. Otherwise\n+                                    //put a value in for the type converter of the class\n+                                    if (converterClass.isAssignableFrom(TypeConverter.class)) {\n+                                        mapping.put(key, createTypeConverter(tc.converter()));\n+                                    } else {\n+                                        mapping.put(key, converterClass);\n+                                        if (LOG.isDebugEnabled()) {\n+                                            LOG.debug(\"Object placed in mapping for key \"\n+                                                    + key\n+                                                    + \" is \"\n+                                                    + mapping.get(key));\n+                                        }\n+\n+                                    }\n+\n+                                }\n+                                //elements(values) of maps / lists\n+                                else {\n+                                    mapping.put(key, Thread.currentThread().getContextClassLoader().loadClass(tc.converter()));\n+                                }\n+                            }\n+                        } catch (Exception e) {\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        Method[] methods = clazz.getMethods();\n+\n+        for (Method method : methods) {\n+\n+            annotations = method.getAnnotations();\n+\n+            for (Annotation annotation : annotations) {\n+                if (annotation instanceof TypeConversion) {\n+                    TypeConversion tc = (TypeConversion) annotation;\n+\n+                    String key = tc.key();\n+                    if (mapping.containsKey(key)) {\n+                        break;\n+                    }\n+                    // Default to the property name\n+                    if (key != null && key.length() == 0) {\n+                        key = AnnotationUtils.resolvePropertyName(method);\n+                        LOG.debug(\"key from method name... \" + key + \" - \" + method.getName());\n+                    }\n+\n+\n+                    if (LOG.isDebugEnabled()) {\n+                        LOG.debug(key + \":\" + key);\n+                    }\n+\n+                    if (key != null) {\n+                        try {\n+                            if (tc.type() == ConversionType.APPLICATION) {\n+                                defaultMappings.put(key, createTypeConverter(tc.converter()));\n+                            } else {\n+                                if (tc.rule().toString().equals(ConversionRule.KEY_PROPERTY)) {\n+                                    mapping.put(key, tc.value());\n+                                }\n+                                //for properties of classes\n+                                else if (!(tc.rule().toString().equals(ConversionRule.ELEMENT.toString())) ||\n+                                        tc.rule().toString().equals(ConversionRule.KEY.toString()) ||\n+                                        tc.rule().toString().equals(ConversionRule.COLLECTION.toString())\n+                                        ) {\n+                                    mapping.put(key, createTypeConverter(tc.converter()));\n+                                }\n+                                //for keys of Maps\n+                                else if (tc.rule().toString().equals(ConversionRule.KEY.toString())) {\n+                                    Class converterClass = Thread.currentThread().getContextClassLoader().loadClass(tc.converter());\n+                                    if (LOG.isDebugEnabled()) {\n+                                        LOG.debug(\"Converter class: \" + converterClass);\n+                                    }\n+                                    //check if the converter is a type converter if it is one\n+                                    //then just put it in the map as is. Otherwise\n+                                    //put a value in for the type converter of the class\n+                                    if (converterClass.isAssignableFrom(TypeConverter.class)) {\n+                                        mapping.put(key, createTypeConverter(tc.converter()));\n+                                    } else {\n+                                        mapping.put(key, converterClass);\n+                                        if (LOG.isDebugEnabled()) {\n+                                            LOG.debug(\"Object placed in mapping for key \"\n+                                                    + key\n+                                                    + \" is \"\n+                                                    + mapping.get(key));\n+                                        }\n+\n+                                    }\n+\n+                                }\n+                                //elements(values) of maps / lists\n+                                else {\n+                                    mapping.put(key, Thread.currentThread().getContextClassLoader().loadClass(tc.converter()));\n+                                }\n+                            }\n+                        } catch (Exception e) {\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Looks for converter mappings for the specified class, traversing up its class hierarchy and interfaces and adding\n+     * any additional mappings it may find.  Mappings lower in the hierarchy have priority over those higher in the\n+     * hierarcy.\n+     *\n+     * @param clazz the class to look for converter mappings for\n+     * @return the converter mappings\n+     */\n+    protected Map<String, Object> buildConverterMapping(Class clazz) throws Exception {\n+        Map<String, Object> mapping = new HashMap<String, Object>();\n+\n+        // check for conversion mapping associated with super classes and any implemented interfaces\n+        Class curClazz = clazz;\n+\n+        while (!curClazz.equals(Object.class)) {\n+            // add current class' mappings\n+            addConverterMapping(mapping, curClazz);\n+\n+            // check interfaces' mappings\n+            Class[] interfaces = curClazz.getInterfaces();\n+\n+            for (Class anInterface : interfaces) {\n+                addConverterMapping(mapping, anInterface);\n+            }\n+\n+            curClazz = curClazz.getSuperclass();\n+        }\n+\n+        if (mapping.size() > 0) {\n+            mappings.put(clazz, mapping);\n+        } else {\n+            noMapping.add(clazz);\n+        }\n+\n+        return mapping;\n+    }\n+\n+    private Map<String, Object> conditionalReload(Class clazz, Map<String, Object> oldValues) throws Exception {\n+        Map<String, Object> mapping = oldValues;\n+\n+        if (FileManager.isReloadingConfigs()) {\n+            if (FileManager.fileNeedsReloading(buildConverterFilename(clazz), clazz)) {\n+                mapping = buildConverterMapping(clazz);\n+            }\n+        }\n+\n+        return mapping;\n+    }\n+\n+    TypeConverter createTypeConverter(String className) throws Exception {\n+        // type converters are used across users\n+        Object obj = objectFactory.buildBean(className, null);\n+        if (obj instanceof TypeConverter) {\n+            return (TypeConverter) obj;\n+\n+            // For backwards compatibility\n+        } else if (obj instanceof ognl.TypeConverter) {\n+            return new XWorkTypeConverterWrapper((ognl.TypeConverter) obj);\n+        } else {\n+            throw new IllegalArgumentException(\"Type converter class \" + obj.getClass() + \" doesn't implement com.opensymphony.xwork2.conversion.TypeConverter\");\n+        }\n+    }\n+\n+    public void loadConversionProperties(String propsName) {\n+        loadConversionProperties(propsName, false);\n+    }\n+\n+    public void loadConversionProperties(String propsName, boolean require) {\n+        try {\n+            Iterator<URL> resources = ClassLoaderUtil.getResources(propsName, getClass(), true);\n+            while (resources.hasNext()) {\n+                URL url = resources.next();\n+                Properties props = new Properties();\n+                props.load(url.openStream());\n+\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"processing conversion file [\" + propsName + \"]\");\n+                }\n+\n+                for (Object o : props.entrySet()) {\n+                    Map.Entry entry = (Map.Entry) o;\n+                    String key = (String) entry.getKey();\n+\n+                    try {\n+                        TypeConverter _typeConverter = createTypeConverter((String) entry.getValue());\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"\\t\" + key + \":\" + entry.getValue() + \" [treated as TypeConverter \" + _typeConverter + \"]\");\n+                        }\n+                        defaultMappings.put(key, _typeConverter);\n+                    } catch (Exception e) {\n+                        LOG.error(\"Conversion registration error\", e);\n+                    }\n+                }\n+            }\n+        } catch (IOException ex) {\n+            if (require) {\n+                throw new XWorkException(\"Cannot load conversion properties file: \"+propsName, ex);\n+            } else {\n+                LOG.debug(\"Cannot load conversion properties file: \"+propsName, ex);\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Recurses through a class' interfaces and class hierarchy looking for a TypeConverter in the default mapping that\n+     * can handle the specified class.\n+     *\n+     * @param clazz the class the TypeConverter must handle\n+     * @return a TypeConverter to handle the specified class or null if none can be found\n+     */\n+    TypeConverter lookupSuper(Class clazz) {\n+        TypeConverter result = null;\n+\n+        if (clazz != null) {\n+            result = defaultMappings.get(clazz.getName());\n+\n+            if (result == null) {\n+                // Looks for direct interfaces (depth = 1 )\n+                Class[] interfaces = clazz.getInterfaces();\n+\n+                for (Class anInterface : interfaces) {\n+                    if (defaultMappings.containsKey(anInterface.getName())) {\n+                        result = (TypeConverter) defaultMappings.get(anInterface.getName());\n+                        break;\n+                    }\n+                }\n+\n+                if (result == null) {\n+                    // Looks for the superclass\n+                    // If 'clazz' is the Object class, an interface, a primitive type or void then clazz.getSuperClass() returns null\n+                    result = lookupSuper(clazz.getSuperclass());\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+\n+}"
        },
        {
            "sha": "1234e2ef6cf9f8697dbc23413152217f3f6db712",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/metadata/ConversionDescription.java",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2FConversionDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2FConversionDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2FConversionDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,184 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.conversion.metadata;\n+\n+import com.opensymphony.xwork2.conversion.annotations.ConversionRule;\n+import com.opensymphony.xwork2.conversion.impl.DefaultObjectTypeDeterminer;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+\n+/**\n+ * <code>ConversionDescription</code>\n+ *\n+ * @author Rainer Hermanns\n+ * @version $Id$\n+ */\n+public class ConversionDescription {\n+\n+    /**\n+     * Jakarta commons-logging reference.\n+     */\n+    protected static Logger log = null;\n+\n+\n+    public static final String KEY_PREFIX = \"Key_\";\n+    public static final String ELEMENT_PREFIX = \"Element_\";\n+    public static final String KEY_PROPERTY_PREFIX = \"KeyProperty_\";\n+    public static final String DEPRECATED_ELEMENT_PREFIX = \"Collection_\";\n+\n+    /**\n+     * Key used for type conversion of maps.\n+     */\n+    String MAP_PREFIX = \"Map_\";\n+\n+    public String property;\n+    public String typeConverter = \"\";\n+    public String rule = \"\";\n+    public String value = \"\";\n+    public String fullQualifiedClassName;\n+    public String type = null;\n+\n+    public ConversionDescription() {\n+        log = LoggerFactory.getLogger(this.getClass());\n+    }\n+\n+    /**\n+     * Creates an ConversionDescription with the specified property name.\n+     *\n+     * @param property\n+     */\n+    public ConversionDescription(String property) {\n+        this.property = property;\n+        log = LoggerFactory.getLogger(this.getClass());\n+    }\n+\n+    /**\n+     * <p>\n+     * Sets the property name to be inserted into the related conversion.properties file.<br/>\n+     * Note: Do not add COLLECTION_PREFIX or MAP_PREFIX keys to property names.\n+     * </p>\n+     *\n+     * @param property The property to be converted.\n+     */\n+    public void setProperty(String property) {\n+        this.property = property;\n+    }\n+\n+    /**\n+     * Sets the class name of the type converter to be used.\n+     *\n+     * @param typeConverter The class name of the type converter.\n+     */\n+    public void setTypeConverter(String typeConverter) {\n+        this.typeConverter = typeConverter;\n+    }\n+\n+    /**\n+     * Sets the rule prefix for COLLECTION_PREFIX or MAP_PREFIX key.\n+     * Defaults to en emtpy String.\n+     *\n+     * @param rule\n+     */\n+    public void setRule(String rule) {\n+        if (rule != null && rule.length() > 0) {\n+            if (rule.equals(ConversionRule.COLLECTION.toString())) {\n+                this.rule = DefaultObjectTypeDeterminer.DEPRECATED_ELEMENT_PREFIX;\n+            } else if (rule.equals(ConversionRule.ELEMENT.toString())) {\n+                this.rule = DefaultObjectTypeDeterminer.ELEMENT_PREFIX;\n+            } else if (rule.equals(ConversionRule.KEY.toString())) {\n+                this.rule = DefaultObjectTypeDeterminer.KEY_PREFIX;\n+            } else if (rule.equals(ConversionRule.KEY_PROPERTY.toString())) {\n+                this.rule = DefaultObjectTypeDeterminer.KEY_PROPERTY_PREFIX;\n+            } else if (rule.equals(ConversionRule.MAP.toString())) {\n+                this.rule = MAP_PREFIX;\n+            }\n+        }\n+    }\n+\n+\n+    public void setType(String type) {\n+        this.type = type;\n+    }\n+\n+    public String getType() {\n+        return type;\n+    }\n+\n+    public String getValue() {\n+        return value;\n+    }\n+\n+    public void setValue(String value) {\n+        this.value = value;\n+    }\n+\n+    /**\n+     * Returns the conversion description as property entry.\n+     * <p>\n+     * Example:<br/>\n+     * property.name = converter.className<br/>\n+     * Collection_property.name = converter.className<br/>\n+     * Map_property.name = converter.className\n+     * KeyProperty_name = id\n+     * </p>\n+     *\n+     * @return the conversion description as property entry.\n+     */\n+    public String asProperty() {\n+        StringWriter sw = new StringWriter();\n+        PrintWriter writer = null;\n+        try {\n+            writer = new PrintWriter(sw);\n+            writer.print(rule);\n+            writer.print(property);\n+            writer.print(\"=\");\n+            if ( rule.startsWith(DefaultObjectTypeDeterminer.KEY_PROPERTY_PREFIX) && value != null && value.length() > 0 ) {\n+                writer.print(value);\n+            } else {\n+                writer.print(typeConverter);\n+            }\n+        } finally {\n+            if (writer != null) {\n+                writer.flush();\n+                writer.close();\n+            }\n+        }\n+\n+        return sw.toString();\n+\n+    }\n+\n+    /**\n+     * Returns the fullQualifiedClassName attribute is used to create the special <code>conversion.properties</code> file name.\n+     *\n+     * @return fullQualifiedClassName\n+     */\n+    public String getFullQualifiedClassName() {\n+        return fullQualifiedClassName;\n+    }\n+\n+    /**\n+     * The fullQualifiedClassName attribute is used to create the special <code>conversion.properties</code> file name.\n+     *\n+     * @param fullQualifiedClassName\n+     */\n+    public void setFullQualifiedClassName(String fullQualifiedClassName) {\n+        this.fullQualifiedClassName = fullQualifiedClassName;\n+    }\n+}"
        },
        {
            "sha": "c50a611ab994cf925c6232b31766e5bb6f68b39f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/conversion/metadata/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fconversion%2Fmetadata%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Type conversion meta data classes.</body>"
        },
        {
            "sha": "44a9e2010df302e864ede2bc5e2b41c2b1dfaf88",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/ConstructionContext.java",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FConstructionContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FConstructionContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FConstructionContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,124 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.lang.reflect.InvocationHandler;\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Proxy;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+/**\n+ * Context of a dependency construction. Used to manage circular references.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+class ConstructionContext<T> {\n+\n+  T currentReference;\n+  boolean constructing;\n+\n+  List<DelegatingInvocationHandler<T>> invocationHandlers;\n+\n+  T getCurrentReference() {\n+    return currentReference;\n+  }\n+\n+  void removeCurrentReference() {\n+    this.currentReference = null;\n+  }\n+\n+  void setCurrentReference(T currentReference) {\n+    this.currentReference = currentReference;\n+  }\n+\n+  boolean isConstructing() {\n+    return constructing;\n+  }\n+\n+  void startConstruction() {\n+    this.constructing = true;\n+  }\n+\n+  void finishConstruction() {\n+    this.constructing = false;\n+    invocationHandlers = null;\n+  }\n+\n+  Object createProxy(Class<? super T> expectedType) {\n+    // TODO: if I create a proxy which implements all the interfaces of\n+    // the implementation type, I'll be able to get away with one proxy\n+    // instance (as opposed to one per caller).\n+\n+    if (!expectedType.isInterface()) {\n+      throw new DependencyException(\n+          expectedType.getName() + \" is not an interface.\");\n+    }\n+\n+    if (invocationHandlers == null) {\n+      invocationHandlers = new ArrayList<DelegatingInvocationHandler<T>>();\n+    }\n+\n+    DelegatingInvocationHandler<T> invocationHandler =\n+        new DelegatingInvocationHandler<T>();\n+    invocationHandlers.add(invocationHandler);\n+\n+    return Proxy.newProxyInstance(\n+      expectedType.getClassLoader(),\n+      new Class[] { expectedType },\n+      invocationHandler\n+    );\n+  }\n+\n+  void setProxyDelegates(T delegate) {\n+    if (invocationHandlers != null) {\n+      for (DelegatingInvocationHandler<T> invocationHandler\n+          : invocationHandlers) {\n+        invocationHandler.setDelegate(delegate);\n+      }\n+    }\n+  }\n+\n+  static class DelegatingInvocationHandler<T> implements InvocationHandler {\n+\n+    T delegate;\n+\n+    public Object invoke(Object proxy, Method method, Object[] args)\n+        throws Throwable {\n+      if (delegate == null) {\n+        throw new IllegalStateException(\n+            \"Not finished constructing. Please don't call methods on this\"\n+                + \" object until the caller's construction is complete.\");\n+      }\n+\n+      try {\n+        return method.invoke(delegate, args);\n+      } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+      } catch (IllegalArgumentException e) {\n+        throw new RuntimeException(e);\n+      } catch (InvocationTargetException e) {\n+        throw e.getTargetException();\n+      }\n+    }\n+\n+    void setDelegate(T delegate) {\n+      this.delegate = delegate;\n+    }\n+  }\n+}"
        },
        {
            "sha": "c64bb7125f4ffaee430617edbebac4a2a3f09dae",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Container.java",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainer.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainer.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainer.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,113 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.io.Serializable;\n+import java.util.Set;\n+\n+/**\n+ * Injects dependencies into constructors, methods and fields annotated with\n+ * {@link Inject}. Immutable.\n+ *\n+ * <p>When injecting a method or constructor, you can additionally annotate\n+ * its parameters with {@link Inject} and specify a dependency name. When a\n+ * parameter has no annotation, the container uses the name from the method or\n+ * constructor's {@link Inject} annotation respectively.\n+ *\n+ * <p>For example:\n+ *\n+ * <pre>\n+ *  class Foo {\n+ *\n+ *    // Inject the int constant named \"i\".\n+ *    &#64;Inject(\"i\") int i;\n+ *\n+ *    // Inject the default implementation of Bar and the String constant\n+ *    // named \"s\".\n+ *    &#64;Inject Foo(Bar bar, @Inject(\"s\") String s) {\n+ *      ...\n+ *    }\n+ *\n+ *    // Inject the default implementation of Baz and the Bob implementation\n+ *    // named \"foo\".\n+ *    &#64;Inject void initialize(Baz baz, @Inject(\"foo\") Bob bob) {\n+ *      ...\n+ *    }\n+ *\n+ *    // Inject the default implementation of Tee.\n+ *    &#64;Inject void setTee(Tee tee) {\n+ *      ...\n+ *    }\n+ *  }\n+ * </pre>\n+ *\n+ * <p>To create and inject an instance of {@code Foo}:\n+ *\n+ * <pre>\n+ *  Container c = ...;\n+ *  Foo foo = c.inject(Foo.class);\n+ * </pre>\n+ *\n+ * @see ContainerBuilder\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public interface Container extends Serializable {\n+\n+  /**\n+   * Default dependency name.\n+   */\n+  String DEFAULT_NAME = \"default\";\n+\n+  /**\n+   * Injects dependencies into the fields and methods of an existing object.\n+   */\n+  void inject(Object o);\n+\n+  /**\n+   * Creates and injects a new instance of type {@code implementation}.\n+   */\n+  <T> T inject(Class<T> implementation);\n+\n+  /**\n+   * Gets an instance of the given dependency which was declared in\n+   * {@link com.opensymphony.xwork2.inject.ContainerBuilder}.\n+   */\n+  <T> T getInstance(Class<T> type, String name);\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code getInstance(type,\n+   * DEFAULT_NAME)}.\n+   */\n+  <T> T getInstance(Class<T> type);\n+  \n+  /**\n+   * Gets a set of all registered names for the given type\n+   * @param type The instance type\n+   * @return A set of registered names\n+   */\n+  Set<String> getInstanceNames(Class<?> type);\n+\n+  /**\n+   * Sets the scope strategy for the current thread.\n+   */\n+  void setScopeStrategy(Scope.Strategy scopeStrategy);\n+\n+  /**\n+   * Removes the scope strategy for the current thread.\n+   */\n+  void removeScopeStrategy();\n+}"
        },
        {
            "sha": "7eec8208ddb388c3fcc764233d172d97ba7f1f08",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/ContainerBuilder.java",
            "status": "added",
            "additions": 527,
            "deletions": 0,
            "changes": 527,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerBuilder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerBuilder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerBuilder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,527 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.lang.reflect.Member;\n+import java.util.*;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Builds a dependency injection {@link Container}. The combination of\n+ * dependency type and name uniquely identifies a dependency mapping; you can\n+ * use the same name for two different types. Not safe for concurrent use.\n+ *\n+ * <p>Adds the following factories by default:\n+ *\n+ * <ul>\n+ *   <li>Injects the current {@link Container}.\n+ *   <li>Injects the {@link Logger} for the injected member's declaring class.\n+ * </ul>\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public final class ContainerBuilder {\n+\n+  final Map<Key<?>, InternalFactory<?>> factories =\n+      new HashMap<Key<?>, InternalFactory<?>>();\n+  final List<InternalFactory<?>> singletonFactories =\n+      new ArrayList<InternalFactory<?>>();\n+  final List<Class<?>> staticInjections = new ArrayList<Class<?>>();\n+  boolean created;\n+  boolean allowDuplicates = false;\n+\n+  private static final InternalFactory<Container> CONTAINER_FACTORY =\n+      new InternalFactory<Container>() {\n+        public Container create(InternalContext context) {\n+          return context.getContainer();\n+        }\n+      };\n+\n+  private static final InternalFactory<Logger> LOGGER_FACTORY =\n+      new InternalFactory<Logger>() {\n+        public Logger create(InternalContext context) {\n+          Member member = context.getExternalContext().getMember();\n+          return member == null ? Logger.getAnonymousLogger()\n+              : Logger.getLogger(member.getDeclaringClass().getName());\n+        }\n+      };\n+\n+  /**\n+   * Constructs a new builder.\n+   */\n+  public ContainerBuilder() {\n+    // In the current container as the default Container implementation.\n+    factories.put(Key.newInstance(Container.class, Container.DEFAULT_NAME),\n+        CONTAINER_FACTORY);\n+\n+    // Inject the logger for the injected member's declaring class.\n+    factories.put(Key.newInstance(Logger.class, Container.DEFAULT_NAME),\n+        LOGGER_FACTORY);\n+  }\n+\n+  /**\n+   * Maps a dependency. All methods in this class ultimately funnel through\n+   * here.\n+   */\n+  private <T> ContainerBuilder factory(final Key<T> key,\n+      InternalFactory<? extends T> factory, Scope scope) {\n+    ensureNotCreated();\n+    checkKey(key);\n+    final InternalFactory<? extends T> scopedFactory =\n+        scope.scopeFactory(key.getType(), key.getName(), factory);\n+    factories.put(key, scopedFactory);\n+    if (scope == Scope.SINGLETON) {\n+      singletonFactories.add(new InternalFactory<T>() {\n+        public T create(InternalContext context) {\n+          try {\n+            context.setExternalContext(ExternalContext.newInstance(\n+                null, key, context.getContainerImpl()));\n+            return scopedFactory.create(context);\n+          } finally {\n+            context.setExternalContext(null);\n+          }\n+        }\n+      });\n+    }\n+    return this;\n+  }\n+  \n+  /**\n+   * Ensures a key isn't already mapped.\n+   */\n+  private void checkKey(Key<?> key) {\n+    if (factories.containsKey(key) && !allowDuplicates) {\n+      throw new DependencyException(\n+          \"Dependency mapping for \" + key + \" already exists.\");\n+    }\n+  }\n+\n+  /**\n+   * Maps a factory to a given dependency type and name.\n+   *\n+   * @param type of dependency\n+   * @param name of dependency\n+   * @param factory creates objects to inject\n+   * @param scope scope of injected instances\n+   * @return this builder\n+   */\n+  public <T> ContainerBuilder factory(final Class<T> type, final String name,\n+      final Factory<? extends T> factory, Scope scope) {\n+    InternalFactory<T> internalFactory =\n+        new InternalFactory<T>() {\n+\n+      public T create(InternalContext context) {\n+        try {\n+          Context externalContext = context.getExternalContext();\n+          return factory.create(externalContext);\n+        } catch (Exception e) {\n+          throw new RuntimeException(e);\n+        }\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return new LinkedHashMap<String, Object>() {{\n+          put(\"type\", type);\n+          put(\"name\", name);\n+          put(\"factory\", factory);\n+        }}.toString();\n+      }\n+    };\n+\n+    return factory(Key.newInstance(type, name), internalFactory, scope);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, factory, scope)}.\n+   *\n+   * @see #factory(Class, String, Factory, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type,\n+      Factory<? extends T> factory, Scope scope) {\n+    return factory(type, Container.DEFAULT_NAME, factory, scope);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type, name, factory,\n+   * Scope.DEFAULT)}.\n+   *\n+   * @see #factory(Class, String, Factory, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type, String name,\n+      Factory<? extends T> factory) {\n+    return factory(type, name, factory, Scope.DEFAULT);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, factory, Scope.DEFAULT)}.\n+   *\n+   * @see #factory(Class, String, Factory, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type,\n+      Factory<? extends T> factory) {\n+    return factory(type, Container.DEFAULT_NAME, factory, Scope.DEFAULT);\n+  }\n+\n+  /**\n+   * Maps an implementation class to a given dependency type and name. Creates\n+   * instances using the container, recursively injecting dependencies.\n+   *\n+   * @param type of dependency\n+   * @param name of dependency\n+   * @param implementation class\n+   * @param scope scope of injected instances\n+   * @return this builder\n+   */\n+  public <T> ContainerBuilder factory(final Class<T> type, final String name,\n+      final Class<? extends T> implementation, final Scope scope) {\n+    // This factory creates new instances of the given implementation.\n+    // We have to lazy load the constructor because the Container\n+    // hasn't been created yet.\n+    InternalFactory<? extends T> factory = new InternalFactory<T>() {\n+\n+      volatile ContainerImpl.ConstructorInjector<? extends T> constructor;\n+\n+      @SuppressWarnings(\"unchecked\")\n+      public T create(InternalContext context) {\n+        if (constructor == null) {\n+          this.constructor =\n+              context.getContainerImpl().getConstructor(implementation);\n+        }\n+        return (T) constructor.construct(context, type);\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return new LinkedHashMap<String, Object>() {{\n+          put(\"type\", type);\n+          put(\"name\", name);\n+          put(\"implementation\", implementation);\n+          put(\"scope\", scope);\n+        }}.toString();\n+      }\n+    };\n+\n+    return factory(Key.newInstance(type, name), factory, scope);\n+  }\n+\n+  /**\n+   * Maps an implementation class to a given dependency type and name. Creates\n+   * instances using the container, recursively injecting dependencies.\n+   *\n+   * <p>Sets scope to value from {@link Scoped} annotation on the\n+   * implementation class. Defaults to {@link Scope#DEFAULT} if no annotation\n+   * is found.\n+   *\n+   * @param type of dependency\n+   * @param name of dependency\n+   * @param implementation class\n+   * @return this builder\n+   */\n+  public <T> ContainerBuilder factory(final Class<T> type, String name,\n+      final Class<? extends T> implementation) {\n+    Scoped scoped = implementation.getAnnotation(Scoped.class);\n+    Scope scope = scoped == null ? Scope.DEFAULT : scoped.value();\n+    return factory(type, name, implementation, scope);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, implementation)}.\n+   *\n+   * @see #factory(Class, String, Class)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type,\n+      Class<? extends T> implementation) {\n+    return factory(type, Container.DEFAULT_NAME, implementation);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, type)}.\n+   *\n+   * @see #factory(Class, String, Class)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type) {\n+    return factory(type, Container.DEFAULT_NAME, type);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type, name, type)}.\n+   *\n+   * @see #factory(Class, String, Class)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type, String name) {\n+    return factory(type, name, type);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, implementation, scope)}.\n+   *\n+   * @see #factory(Class, String, Class, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type,\n+      Class<? extends T> implementation, Scope scope) {\n+    return factory(type, Container.DEFAULT_NAME, implementation, scope);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type,\n+   * Container.DEFAULT_NAME, type, scope)}.\n+   *\n+   * @see #factory(Class, String, Class, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type, Scope scope) {\n+    return factory(type, Container.DEFAULT_NAME, type, scope);\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code factory(type, name, type,\n+   * scope)}.\n+   *\n+   * @see #factory(Class, String, Class, Scope)\n+   */\n+  public <T> ContainerBuilder factory(Class<T> type, String name, Scope scope) {\n+    return factory(type, name, type, scope);\n+  }\n+  \n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code alias(type, Container.DEFAULT_NAME,\n+   * type)}.\n+   *\n+   * @see #alias(Class, String, String)\n+   */\n+  public <T> ContainerBuilder alias(Class<T> type, String alias) {\n+    return alias(type, Container.DEFAULT_NAME, alias);\n+  }\n+  \n+  /**\n+   * Maps an existing factory to a new name. \n+   * \n+   * @param type of dependency\n+   * @param name of dependency\n+   * @param alias of to the dependency\n+   * @return this builder\n+   */\n+  public <T> ContainerBuilder alias(Class<T> type, String name, String alias) {\n+    return alias(Key.newInstance(type, name), Key.newInstance(type, alias));\n+  }\n+  \n+  /**\n+   * Maps an existing dependency. All methods in this class ultimately funnel through\n+   * here.\n+   */\n+  private <T> ContainerBuilder alias(final Key<T> key,\n+      final Key<T> aliasKey) {\n+    ensureNotCreated();\n+    checkKey(aliasKey);\n+    \n+    final InternalFactory<? extends T> scopedFactory = \n+      (InternalFactory<? extends T>)factories.get(key);\n+    if (scopedFactory == null) {\n+        throw new DependencyException(\n+                \"Dependency mapping for \" + key + \" doesn't exists.\");\n+    }\n+    factories.put(aliasKey, scopedFactory);\n+    return this;\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, String value) {\n+    return constant(String.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, int value) {\n+    return constant(int.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, long value) {\n+    return constant(long.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, boolean value) {\n+    return constant(boolean.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, double value) {\n+    return constant(double.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, float value) {\n+    return constant(float.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, short value) {\n+    return constant(short.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given name.\n+   */\n+  public ContainerBuilder constant(String name, char value) {\n+    return constant(char.class, name, value);\n+  }\n+\n+  /**\n+   * Maps a class to the given name.\n+   */\n+  public ContainerBuilder constant(String name, Class value) {\n+    return constant(Class.class, name, value);\n+  }\n+\n+  /**\n+   * Maps an enum to the given name.\n+   */\n+  public <E extends Enum<E>> ContainerBuilder constant(String name, E value) {\n+    return constant(value.getDeclaringClass(), name, value);\n+  }\n+\n+  /**\n+   * Maps a constant value to the given type and name.\n+   */\n+  private <T> ContainerBuilder constant(final Class<T> type, final String name,\n+      final T value) {\n+    InternalFactory<T> factory = new InternalFactory<T>() {\n+      public T create(InternalContext ignored) {\n+        return value;\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return new LinkedHashMap<String, Object>() {\n+          {\n+            put(\"type\", type);\n+            put(\"name\", name);\n+            put(\"value\", value);\n+          }\n+        }.toString();\n+      }\n+    };\n+\n+    return factory(Key.newInstance(type, name), factory, Scope.DEFAULT);\n+  }\n+\n+  /**\n+   * Upon creation, the {@link Container} will inject static fields and methods\n+   * into the given classes.\n+   *\n+   * @param types for which static members will be injected\n+   */\n+  public ContainerBuilder injectStatics(Class<?>... types) {\n+    staticInjections.addAll(Arrays.asList(types));\n+    return this;\n+  }\n+\n+  /**\n+   * Returns true if this builder contains a mapping for the given type and\n+   * name.\n+   */\n+  public boolean contains(Class<?> type, String name) {\n+    return factories.containsKey(Key.newInstance(type, name));\n+  }\n+\n+  /**\n+   * Convenience method.&nbsp;Equivalent to {@code contains(type,\n+   * Container.DEFAULT_NAME)}.\n+   */\n+  public boolean contains(Class<?> type) {\n+    return contains(type, Container.DEFAULT_NAME);\n+  }\n+\n+  /**\n+   * Creates a {@link Container} instance. Injects static members for classes\n+   * which were registered using {@link #injectStatics(Class...)}.\n+   *\n+   * @param loadSingletons If true, the container will load all singletons\n+   *  now. If false, the container will lazily load singletons. Eager loading\n+   *  is appropriate for production use while lazy loading can speed\n+   *  development.\n+   * @throws IllegalStateException if called more than once\n+   */\n+  public Container create(boolean loadSingletons) {\n+    ensureNotCreated();\n+    created = true;\n+    final ContainerImpl container = new ContainerImpl(\n+        new HashMap<Key<?>, InternalFactory<?>>(factories));\n+    if (loadSingletons) {\n+      container.callInContext(new ContainerImpl.ContextualCallable<Void>() {\n+        public Void call(InternalContext context) {\n+          for (InternalFactory<?> factory : singletonFactories) {\n+            factory.create(context);\n+          }\n+          return null;\n+        }\n+      });\n+    }\n+    container.injectStatics(staticInjections);\n+    return container;\n+  }\n+\n+  /**\n+   * Currently we only support creating one Container instance per builder.\n+   * If we want to support creating more than one container per builder,\n+   * we should move to a \"factory factory\" model where we create a factory\n+   * instance per Container. Right now, one factory instance would be\n+   * shared across all the containers, singletons synchronize on the\n+   * container when lazy loading, etc.\n+   */\n+  private void ensureNotCreated() {\n+    if (created) {\n+      throw new IllegalStateException(\"Container already created.\");\n+    }\n+  }\n+  \n+  public void setAllowDuplicates(boolean val) {\n+      allowDuplicates = val;\n+  }\n+\n+  /**\n+   * Implemented by classes which participate in building a container.\n+   */\n+  public interface Command {\n+\n+    /**\n+     * Contributes factories to the given builder.\n+     *\n+     * @param builder\n+     */\n+    void build(ContainerBuilder builder);\n+  }\n+}"
        },
        {
            "sha": "f1cba9ff740564714b974f792dd8f604a8891ac9",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/ContainerImpl.java",
            "status": "added",
            "additions": 621,
            "deletions": 0,
            "changes": 621,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerImpl.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerImpl.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContainerImpl.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,621 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import com.opensymphony.xwork2.inject.util.ReferenceCache;\n+\n+import java.io.Serializable;\n+import java.lang.annotation.Annotation;\n+import java.lang.reflect.*;\n+import java.util.*;\n+import java.util.Map.Entry;\n+import java.security.AccessControlException;\n+\n+/**\n+ * Default {@link Container} implementation.\n+ *\n+ * @see ContainerBuilder\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+class ContainerImpl implements Container {\n+\n+  final Map<Key<?>, InternalFactory<?>> factories;\n+  final Map<Class<?>,Set<String>> factoryNamesByType;\n+\n+  ContainerImpl(Map<Key<?>, InternalFactory<?>> factories) {\n+    this.factories = factories;\n+    Map<Class<?>,Set<String>> map = new HashMap<Class<?>,Set<String>>();\n+    for (Key<?> key : factories.keySet()) {\n+      Set<String> names = map.get(key.getType());\n+      if (names == null) {\n+        names = new HashSet<String>();\n+        map.put(key.getType(), names);\n+      }\n+      names.add(key.getName());\n+    }\n+    \n+    for (Entry<Class<?>,Set<String>> entry : map.entrySet()) {\n+      entry.setValue(Collections.unmodifiableSet(entry.getValue()));\n+    }\n+    \n+    this.factoryNamesByType = Collections.unmodifiableMap(map);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  <T> InternalFactory<? extends T> getFactory(Key<T> key) {\n+    return (InternalFactory<T>) factories.get(key);\n+  }\n+\n+  /**\n+   * Field and method injectors.\n+   */\n+  final Map<Class<?>, List<Injector>> injectors =\n+      new ReferenceCache<Class<?>, List<Injector>>() {\n+        @Override\n+        protected List<Injector> create(Class<?> key) {\n+          List<Injector> injectors = new ArrayList<Injector>();\n+          addInjectors(key, injectors);\n+          return injectors;\n+        }\n+      };\n+\n+  /**\n+   * Recursively adds injectors for fields and methods from the given class to\n+   * the given list. Injects parent classes before sub classes.\n+   */\n+  void addInjectors(Class clazz, List<Injector> injectors) {\n+    if (clazz == Object.class) {\n+      return;\n+    }\n+\n+    // Add injectors for superclass first.\n+    addInjectors(clazz.getSuperclass(), injectors);\n+\n+    // TODO (crazybob): Filter out overridden members.\n+    addInjectorsForFields(clazz.getDeclaredFields(), false, injectors);\n+    addInjectorsForMethods(clazz.getDeclaredMethods(), false, injectors);\n+  }\n+\n+  void injectStatics(List<Class<?>> staticInjections) {\n+    final List<Injector> injectors = new ArrayList<Injector>();\n+\n+    for (Class<?> clazz : staticInjections) {\n+      addInjectorsForFields(clazz.getDeclaredFields(), true, injectors);\n+      addInjectorsForMethods(clazz.getDeclaredMethods(), true, injectors);\n+    }\n+\n+    callInContext(new ContextualCallable<Void>() {\n+      public Void call(InternalContext context) {\n+        for (Injector injector : injectors) {\n+          injector.inject(context, null);\n+        }\n+        return null;\n+      }\n+    });\n+  }\n+\n+  void addInjectorsForMethods(Method[] methods, boolean statics,\n+      List<Injector> injectors) {\n+    addInjectorsForMembers(Arrays.asList(methods), statics, injectors,\n+        new InjectorFactory<Method>() {\n+          public Injector create(ContainerImpl container, Method method,\n+              String name) throws MissingDependencyException {\n+            return new MethodInjector(container, method, name);\n+          }\n+        });\n+  }\n+\n+  void addInjectorsForFields(Field[] fields, boolean statics,\n+      List<Injector> injectors) {\n+    addInjectorsForMembers(Arrays.asList(fields), statics, injectors,\n+        new InjectorFactory<Field>() {\n+          public Injector create(ContainerImpl container, Field field,\n+              String name) throws MissingDependencyException {\n+            return new FieldInjector(container, field, name);\n+          }\n+        });\n+  }\n+\n+  <M extends Member & AnnotatedElement> void addInjectorsForMembers(\n+      List<M> members, boolean statics, List<Injector> injectors,\n+      InjectorFactory<M> injectorFactory) {\n+    for (M member : members) {\n+      if (isStatic(member) == statics) {\n+        Inject inject = member.getAnnotation(Inject.class);\n+        if (inject != null) {\n+          try {\n+            injectors.add(injectorFactory.create(this, member, inject.value()));\n+          } catch (MissingDependencyException e) {\n+            if (inject.required()) {\n+              throw new DependencyException(e);\n+            }\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  interface InjectorFactory<M extends Member & AnnotatedElement> {\n+    Injector create(ContainerImpl container, M member, String name)\n+        throws MissingDependencyException;\n+  }\n+\n+  private boolean isStatic(Member member) {\n+    return Modifier.isStatic(member.getModifiers());\n+  }\n+\n+  static class FieldInjector implements Injector {\n+\n+    final Field field;\n+    final InternalFactory<?> factory;\n+    final ExternalContext<?> externalContext;\n+\n+    public FieldInjector(ContainerImpl container, Field field, String name)\n+        throws MissingDependencyException {\n+      this.field = field;\n+        if (!field.isAccessible()) {\n+            SecurityManager sm = System.getSecurityManager();\n+            try {\n+                if (sm != null) sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n+                field.setAccessible(true);\n+            } catch(AccessControlException e) {\n+                throw new DependencyException(\"Security manager in use, could not access field: \"\n+                        + field.getDeclaringClass().getName() + \"(\" + field.getName() + \")\", e);\n+            }\n+        }\n+\n+      Key<?> key = Key.newInstance(field.getType(), name);\n+      factory = container.getFactory(key);\n+      if (factory == null) {\n+        throw new MissingDependencyException(\n+            \"No mapping found for dependency \" + key + \" in \" + field + \".\");\n+      }\n+\n+      this.externalContext = ExternalContext.newInstance(field, key, container);\n+    }\n+\n+    public void inject(InternalContext context, Object o) {\n+      ExternalContext<?> previous = context.getExternalContext();\n+      context.setExternalContext(externalContext);\n+      try {\n+        field.set(o, factory.create(context));\n+      } catch (IllegalAccessException e) {\n+        throw new AssertionError(e);\n+      } finally {\n+        context.setExternalContext(previous);\n+      }\n+    }\n+  }\n+\n+  /**\n+   * Gets parameter injectors.\n+   *\n+   * @param member to which the parameters belong\n+   * @param annotations on the parameters\n+   * @param parameterTypes parameter types\n+   * @return injections\n+   */\n+  <M extends AccessibleObject & Member> ParameterInjector<?>[]\n+      getParametersInjectors(M member,\n+      Annotation[][] annotations, Class[] parameterTypes, String defaultName)\n+      throws MissingDependencyException {\n+    List<ParameterInjector<?>> parameterInjectors =\n+        new ArrayList<ParameterInjector<?>>();\n+\n+    Iterator<Annotation[]> annotationsIterator =\n+        Arrays.asList(annotations).iterator();\n+    for (Class<?> parameterType : parameterTypes) {\n+      Inject annotation = findInject(annotationsIterator.next());\n+      String name = annotation == null ? defaultName : annotation.value();\n+      Key<?> key = Key.newInstance(parameterType, name);\n+      parameterInjectors.add(createParameterInjector(key, member));\n+    }\n+\n+    return toArray(parameterInjectors);\n+  }\n+\n+  <T> ParameterInjector<T> createParameterInjector(\n+      Key<T> key, Member member) throws MissingDependencyException {\n+    InternalFactory<? extends T> factory = getFactory(key);\n+    if (factory == null) {\n+      throw new MissingDependencyException(\n+          \"No mapping found for dependency \" + key + \" in \" + member + \".\");\n+    }\n+\n+    ExternalContext<T> externalContext =\n+        ExternalContext.newInstance(member, key, this);\n+    return new ParameterInjector<T>(externalContext, factory);\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  private ParameterInjector<?>[] toArray(\n+      List<ParameterInjector<?>> parameterInjections) {\n+    return parameterInjections.toArray(\n+        new ParameterInjector[parameterInjections.size()]);\n+  }\n+\n+  /**\n+   * Finds the {@link Inject} annotation in an array of annotations.\n+   */\n+  Inject findInject(Annotation[] annotations) {\n+    for (Annotation annotation : annotations) {\n+      if (annotation.annotationType() == Inject.class) {\n+        return Inject.class.cast(annotation);\n+      }\n+    }\n+    return null;\n+  }\n+\n+  static class MethodInjector implements Injector {\n+\n+    final Method method;\n+    final ParameterInjector<?>[] parameterInjectors;\n+\n+    public MethodInjector(ContainerImpl container, Method method, String name)\n+        throws MissingDependencyException {\n+      this.method = method;\n+        if (!method.isAccessible()) {\n+            SecurityManager sm = System.getSecurityManager();\n+            try {\n+                if (sm != null) sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n+                method.setAccessible(true);\n+            } catch(AccessControlException e) {\n+                throw new DependencyException(\"Security manager in use, could not access method: \"\n+                        + name + \"(\" + method.getName() + \")\", e);\n+            }\n+        }\n+\n+      Class<?>[] parameterTypes = method.getParameterTypes();\n+      if (parameterTypes.length == 0) {\n+        throw new DependencyException(\n+            method + \" has no parameters to inject.\");\n+      }\n+      parameterInjectors = container.getParametersInjectors(\n+          method, method.getParameterAnnotations(), parameterTypes, name);\n+    }\n+\n+    public void inject(InternalContext context, Object o) {\n+      try {\n+        method.invoke(o, getParameters(method, context, parameterInjectors));\n+      } catch (Exception e) {\n+        throw new RuntimeException(e);\n+      }\n+    }\n+  }\n+\n+  Map<Class<?>, ConstructorInjector> constructors =\n+      new ReferenceCache<Class<?>, ConstructorInjector>() {\n+        @Override\n+        @SuppressWarnings(\"unchecked\")\n+        protected ConstructorInjector<?> create(Class<?> implementation) {\n+          return new ConstructorInjector(ContainerImpl.this, implementation);\n+        }\n+      };\n+\n+  static class ConstructorInjector<T> {\n+\n+    final Class<T> implementation;\n+    final List<Injector> injectors;\n+    final Constructor<T> constructor;\n+    final ParameterInjector<?>[] parameterInjectors;\n+\n+    ConstructorInjector(ContainerImpl container, Class<T> implementation) {\n+      this.implementation = implementation;\n+\n+      constructor = findConstructorIn(implementation);\n+        if (!constructor.isAccessible()) {\n+            SecurityManager sm = System.getSecurityManager();\n+            try {\n+                if (sm != null) sm.checkPermission(new ReflectPermission(\"suppressAccessChecks\"));\n+                constructor.setAccessible(true);\n+            } catch(AccessControlException e) {\n+                throw new DependencyException(\"Security manager in use, could not access constructor: \"\n+                        + implementation.getName() + \"(\" + constructor.getName() + \")\", e);\n+            }\n+        }\n+\n+      MissingDependencyException exception = null;\n+      Inject inject = null;\n+      ParameterInjector<?>[] parameters = null;\n+        \n+      try {\n+        inject = constructor.getAnnotation(Inject.class);\n+        parameters = constructParameterInjector(inject, container, constructor);\n+      } catch (MissingDependencyException e) {\n+        exception = e;\n+      }\n+      parameterInjectors = parameters;\n+\n+      if ( exception != null) {\n+        if ( inject != null && inject.required()) {\n+          throw new DependencyException(exception);\n+        }\n+      }\n+      injectors = container.injectors.get(implementation);\n+    }\n+\n+    ParameterInjector<?>[] constructParameterInjector(\n+    Inject inject, ContainerImpl container, Constructor<T> constructor) throws MissingDependencyException{\n+    return constructor.getParameterTypes().length == 0\n+      ? null // default constructor.\n+      : container.getParametersInjectors(\n+        constructor,\n+        constructor.getParameterAnnotations(),\n+        constructor.getParameterTypes(),\n+        inject.value()\n+      );\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private Constructor<T> findConstructorIn(Class<T> implementation) {\n+      Constructor<T> found = null;\n+      Constructor<T>[] declaredConstructors = (Constructor<T>[]) implementation\n+                    .getDeclaredConstructors();\n+      for(Constructor<T> constructor :  declaredConstructors) {\n+        if (constructor.getAnnotation(Inject.class) != null) {\n+          if (found != null) {\n+            throw new DependencyException(\"More than one constructor annotated\"\n+              + \" with @Inject found in \" + implementation + \".\");\n+          }\n+          found = constructor;\n+        }\n+      }\n+      if (found != null) {\n+        return found;\n+      }\n+\n+      // If no annotated constructor is found, look for a no-arg constructor\n+      // instead.\n+      try {\n+        return implementation.getDeclaredConstructor();\n+      } catch (NoSuchMethodException e) {\n+        throw new DependencyException(\"Could not find a suitable constructor\"\n+            + \" in \" + implementation.getName() + \".\");\n+      }\n+    }\n+\n+    /**\n+     * Construct an instance. Returns {@code Object} instead of {@code T}\n+     * because it may return a proxy.\n+     */\n+    Object construct(InternalContext context, Class<? super T> expectedType) {\n+      ConstructionContext<T> constructionContext =\n+          context.getConstructionContext(this);\n+\n+      // We have a circular reference between constructors. Return a proxy.\n+      if (constructionContext.isConstructing()) {\n+        // TODO (crazybob): if we can't proxy this object, can we proxy the\n+        // other object?\n+        return constructionContext.createProxy(expectedType);\n+      }\n+\n+      // If we're re-entering this factory while injecting fields or methods,\n+      // return the same instance. This prevents infinite loops.\n+      T t = constructionContext.getCurrentReference();\n+      if (t != null) {\n+        return t;\n+      }\n+\n+      try {\n+        // First time through...\n+        constructionContext.startConstruction();\n+        try {\n+          Object[] parameters =\n+              getParameters(constructor, context, parameterInjectors);\n+          t = constructor.newInstance(parameters);\n+          constructionContext.setProxyDelegates(t);\n+        } finally {\n+          constructionContext.finishConstruction();\n+        }\n+\n+        // Store reference. If an injector re-enters this factory, they'll\n+        // get the same reference.\n+        constructionContext.setCurrentReference(t);\n+\n+        // Inject fields and methods.\n+        for (Injector injector : injectors) {\n+          injector.inject(context, t);\n+        }\n+\n+        return t;\n+      } catch (InstantiationException e) {\n+        throw new RuntimeException(e);\n+      } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+      } catch (InvocationTargetException e) {\n+        throw new RuntimeException(e);\n+      } finally {\n+        constructionContext.removeCurrentReference();\n+      }\n+    }\n+  }\n+\n+  static class ParameterInjector<T> {\n+\n+    final ExternalContext<T> externalContext;\n+    final InternalFactory<? extends T> factory;\n+\n+    public ParameterInjector(ExternalContext<T> externalContext,\n+        InternalFactory<? extends T> factory) {\n+      this.externalContext = externalContext;\n+      this.factory = factory;\n+    }\n+\n+    T inject(Member member, InternalContext context) {\n+      ExternalContext<?> previous = context.getExternalContext();\n+      context.setExternalContext(externalContext);\n+      try {\n+        return factory.create(context);\n+      } finally {\n+        context.setExternalContext(previous);\n+      }\n+    }\n+  }\n+\n+  private static Object[] getParameters(Member member, InternalContext context,\n+      ParameterInjector[] parameterInjectors) {\n+    if (parameterInjectors == null) {\n+      return null;\n+    }\n+\n+    Object[] parameters = new Object[parameterInjectors.length];\n+    for (int i = 0; i < parameters.length; i++) {\n+      parameters[i] = parameterInjectors[i].inject(member, context);\n+    }\n+    return parameters;\n+  }\n+\n+  void inject(Object o, InternalContext context) {\n+    List<Injector> injectors = this.injectors.get(o.getClass());\n+    for (Injector injector : injectors) {\n+      injector.inject(context, o);\n+    }\n+  }\n+\n+  <T> T inject(Class<T> implementation, InternalContext context) {\n+    try {\n+      ConstructorInjector<T> constructor = getConstructor(implementation);\n+      return implementation.cast(\n+          constructor.construct(context, implementation));\n+    } catch (Exception e) {\n+      throw new RuntimeException(e);\n+    }\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  <T> T getInstance(Class<T> type, String name, InternalContext context) {\n+    ExternalContext<?> previous = context.getExternalContext();\n+    Key<T> key = Key.newInstance(type, name);\n+    context.setExternalContext(ExternalContext.newInstance(null, key, this));\n+    try {\n+      InternalFactory o = getFactory(key);\n+      if (o != null) {\n+          return getFactory(key).create(context);\n+      } else {\n+          return null;\n+      }\n+    } finally {\n+      context.setExternalContext(previous);\n+    }\n+  }\n+\n+  <T> T getInstance(Class<T> type, InternalContext context) {\n+    return getInstance(type, DEFAULT_NAME, context);\n+  }\n+\n+  public void inject(final Object o) {\n+    callInContext(new ContextualCallable<Void>() {\n+      public Void call(InternalContext context) {\n+        inject(o, context);\n+        return null;\n+      }\n+    });\n+  }\n+\n+  public <T> T inject(final Class<T> implementation) {\n+    return callInContext(new ContextualCallable<T>() {\n+      public T call(InternalContext context) {\n+        return inject(implementation, context);\n+      }\n+    });\n+  }\n+\n+  public <T> T getInstance(final Class<T> type, final String name) {\n+    return callInContext(new ContextualCallable<T>() {\n+      public T call(InternalContext context) {\n+        return getInstance(type, name, context);\n+      }\n+    });\n+  }\n+\n+  public <T> T getInstance(final Class<T> type) {\n+    return callInContext(new ContextualCallable<T>() {\n+      public T call(InternalContext context) {\n+        return getInstance(type, context);\n+      }\n+    });\n+  }\n+  \n+  public Set<String> getInstanceNames(final Class<?> type) {\n+    return factoryNamesByType.get(type);\n+  }\n+\n+  ThreadLocal<Object[]> localContext =\n+      new ThreadLocal<Object[]>() {\n+        @Override\n+        protected Object[] initialValue() {\n+          return new Object[1];\n+        }\n+      };\n+\n+  /**\n+   * Looks up thread local context. Creates (and removes) a new context if\n+   * necessary.\n+   */\n+  <T> T callInContext(ContextualCallable<T> callable) {\n+    Object[] reference = localContext.get();\n+    if (reference[0] == null) {\n+      reference[0] = new InternalContext(this);\n+      try {\n+        return callable.call((InternalContext)reference[0]);\n+      } finally {\n+        // Only remove the context if this call created it.\n+        reference[0] = null;\n+      }\n+    } else {\n+      // Someone else will clean up this context.\n+      return callable.call((InternalContext)reference[0]);\n+    }\n+  }\n+\n+  interface ContextualCallable<T> {\n+    T call(InternalContext context);\n+  }\n+\n+  /**\n+   * Gets a constructor function for a given implementation class.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  <T> ConstructorInjector<T> getConstructor(Class<T> implementation) {\n+    return constructors.get(implementation);\n+  }\n+\n+  final ThreadLocal<Object> localScopeStrategy =\n+      new ThreadLocal<Object>();\n+\n+  public void setScopeStrategy(Scope.Strategy scopeStrategy) {\n+    this.localScopeStrategy.set(scopeStrategy);\n+  }\n+\n+  public void removeScopeStrategy() {\n+    this.localScopeStrategy.remove();\n+  }\n+\n+  /**\n+   * Injects a field or method in a given object.\n+   */\n+  interface Injector extends Serializable {\n+    void inject(InternalContext context, Object o);\n+  }\n+\n+  static class MissingDependencyException extends Exception {\n+\n+    MissingDependencyException(String message) {\n+      super(message);\n+    }\n+  }\n+}"
        },
        {
            "sha": "233b5e47813dc58e7885d4237fccad544734fc02",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Context.java",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,57 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.lang.reflect.Member;\n+\n+/**\n+ * Context of the current injection.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public interface Context {\n+\n+  /**\n+   * Gets the {@link Container}.\n+   */\n+  Container getContainer();\n+\n+  /**\n+   * Gets the current scope strategy. See {@link\n+   * Container#setScopeStrategy(Scope.Strategy)}.\n+   *\n+   * @throws IllegalStateException if no strategy has been set\n+   */\n+  Scope.Strategy getScopeStrategy();\n+\n+  /**\n+   * Gets the field, method or constructor which is being injected. Returns\n+   * {@code null} if the object currently being constructed is pre-loaded as\n+   * a singleton or requested from {@link Container#getInstance(Class)}.\n+   */\n+  Member getMember();\n+\n+  /**\n+   * Gets the type of the field or parameter which is being injected.\n+   */\n+  Class<?> getType();\n+\n+  /**\n+   * Gets the name of the injection specified by {@link Inject#value()}.\n+   */\n+  String getName();\n+}"
        },
        {
            "sha": "f92896defe25c2f62b8f353696ec2f01de445eee",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/DependencyException.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FDependencyException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FDependencyException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FDependencyException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+/**\n+ * Thrown when a dependency is misconfigured.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public class DependencyException extends RuntimeException {\n+\n+  public DependencyException(String message) {\n+    super(message);\n+  }\n+\n+  public DependencyException(String message, Throwable cause) {\n+    super(message, cause);\n+  }\n+\n+  public DependencyException(Throwable cause) {\n+    super(cause);\n+  }\n+}"
        },
        {
            "sha": "8a3880e1bc15534f51ff7ea87694fc265b59f75e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/ExternalContext.java",
            "status": "added",
            "additions": 74,
            "deletions": 0,
            "changes": 74,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FExternalContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FExternalContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FExternalContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,74 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.lang.reflect.Member;\n+import java.util.LinkedHashMap;\n+\n+/**\n+ * An immutable snapshot of the current context which is safe to\n+ * expose to client code.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+class ExternalContext<T> implements Context {\n+\n+  final Member member;\n+  final Key<T> key;\n+  final ContainerImpl container;\n+\n+  public ExternalContext(Member member, Key<T> key, ContainerImpl container) {\n+    this.member = member;\n+    this.key = key;\n+    this.container = container;\n+  }\n+\n+  public Class<T> getType() {\n+    return key.getType();\n+  }\n+\n+  public Scope.Strategy getScopeStrategy() {\n+    return (Scope.Strategy) container.localScopeStrategy.get();\n+  }\n+\n+  public Container getContainer() {\n+    return container;\n+  }\n+\n+  public Member getMember() {\n+    return member;\n+  }\n+\n+  public String getName() {\n+    return key.getName();\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"Context\" + new LinkedHashMap<String, Object>() {{\n+      put(\"member\", member);\n+      put(\"type\", getType());\n+      put(\"name\", getName());\n+      put(\"container\", container);\n+    }}.toString();\n+  }\n+\n+  static <T> ExternalContext<T> newInstance(Member member, Key<T> key,\n+      ContainerImpl container) {\n+    return new ExternalContext<T>(member, key, container);\n+  }\n+}"
        },
        {
            "sha": "11175061e13e7e2d138d1183134376670c769d3e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Factory.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+/**\n+ * A custom factory. Creates objects which will be injected.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public interface Factory<T> {\n+\n+  /**\n+   * Creates an object to be injected.\n+   *\n+   * @param context of this injection\n+   * @return instance to be injected\n+   * @throws Exception if unable to create object\n+   */\n+  T create(Context context) throws Exception;\n+}"
        },
        {
            "sha": "610d2bb2227194d5b3f88a0d50251afa2d1d7f9d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Inject.java",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInject.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInject.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInject.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,46 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import static com.opensymphony.xwork2.inject.Container.DEFAULT_NAME;\n+\n+import static java.lang.annotation.ElementType.*;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * <p>Annotates members and parameters which should have their value[s]\n+ * injected.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+@Target({METHOD, CONSTRUCTOR, FIELD, PARAMETER})\n+@Retention(RUNTIME)\n+public @interface Inject {\n+\n+  /**\n+   * Dependency name. Defaults to {@link Container#DEFAULT_NAME}.\n+   */\n+  String value() default DEFAULT_NAME;\n+\n+  /**\n+   * Whether or not injection is required. Applicable only to methods and\n+   * fields (not constructors or parameters).\n+   */\n+  boolean required() default true;\n+}"
        },
        {
            "sha": "16fa0c1307a8147b1bbfacde165d47b0ffa91ccf",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/InternalContext.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,80 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+/**\n+ * Internal context. Used to coordinate injections and support circular\n+ * dependencies.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+class InternalContext {\n+\n+  final ContainerImpl container;\n+  final Map<Object, ConstructionContext<?>> constructionContexts =\n+      new HashMap<Object, ConstructionContext<?>>();\n+  Scope.Strategy scopeStrategy;\n+  ExternalContext<?> externalContext;\n+\n+  InternalContext(ContainerImpl container) {\n+    this.container = container;\n+  }\n+\n+  public Container getContainer() {\n+    return container;\n+  }\n+\n+  ContainerImpl getContainerImpl() {\n+    return container;\n+  }\n+\n+  Scope.Strategy getScopeStrategy() {\n+    if (scopeStrategy == null) {\n+      scopeStrategy = (Scope.Strategy) container.localScopeStrategy.get();\n+\n+      if (scopeStrategy == null) {\n+        throw new IllegalStateException(\"Scope strategy not set. \"\n+            + \"Please call Container.setScopeStrategy().\");\n+      }\n+    }\n+\n+    return scopeStrategy;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  <T> ConstructionContext<T> getConstructionContext(Object key) {\n+    ConstructionContext<T> constructionContext =\n+        (ConstructionContext<T>) constructionContexts.get(key);\n+    if (constructionContext == null) {\n+      constructionContext = new ConstructionContext<T>();\n+      constructionContexts.put(key, constructionContext);\n+    }\n+    return constructionContext;\n+  }\n+\n+  @SuppressWarnings(\"unchecked\")\n+  <T> ExternalContext<T> getExternalContext() {\n+    return (ExternalContext<T>) externalContext;\n+  }\n+\n+  void setExternalContext(ExternalContext<?> externalContext) {\n+    this.externalContext = externalContext;\n+  }\n+}"
        },
        {
            "sha": "49fcf27e89b71c5034f0179f7a1828e6acf1bffc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/InternalFactory.java",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FInternalFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.io.Serializable;\n+\n+/**\n+ * Creates objects which will be injected.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+interface InternalFactory<T> extends Serializable {\n+\n+  /**\n+   * Creates an object to be injected.\n+   *\n+   * @param context of this injection\n+   * @return instance to be injected\n+   */\n+  T create(InternalContext context);\n+}"
        },
        {
            "sha": "03756b9f60492e997b2cd0cfad7021c4b052f02e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Key.java",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FKey.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FKey.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FKey.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+/**\n+ * Dependency mapping key. Uniquely identified by the required type and name.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+class Key<T> {\n+\n+  final Class<T> type;\n+  final String name;\n+  final int hashCode;\n+\n+  private Key(Class<T> type, String name) {\n+    if (type == null) {\n+      throw new NullPointerException(\"Type is null.\");\n+    }\n+    if (name == null) {\n+      throw new NullPointerException(\"Name is null.\");\n+    }\n+\n+    this.type = type;\n+    this.name = name;\n+\n+    hashCode = type.hashCode() * 31 + name.hashCode();\n+  }\n+\n+  Class<T> getType() {\n+    return type;\n+  }\n+\n+  String getName() {\n+    return name;\n+  }\n+\n+  @Override\n+  public int hashCode() {\n+    return hashCode;\n+  }\n+\n+  @Override\n+  public boolean equals(Object o) {\n+    if (!(o instanceof Key)) {\n+      return false;\n+    }\n+    if (o == this) {\n+      return true;\n+    }\n+    Key other = (Key) o;\n+    return name.equals(other.name) && type.equals(other.type);\n+  }\n+\n+  @Override\n+  public String toString() {\n+    return \"[type=\" + type.getName() + \", name='\" + name + \"']\";\n+  }\n+\n+  static <T> Key<T> newInstance(Class<T> type, String name) {\n+    return new Key<T>(type, name);\n+  }\n+}"
        },
        {
            "sha": "b327db837051052f0f0458e25e63458fef91abcc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Scope.java",
            "status": "added",
            "additions": 217,
            "deletions": 0,
            "changes": 217,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScope.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScope.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScope.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,217 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.util.concurrent.Callable;\n+\n+/**\n+ * Scope of an injected objects.\n+ *\n+ * @author crazybob\n+ */\n+public enum Scope {\n+\n+  /**\n+   * One instance per injection.\n+   */\n+  DEFAULT {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(Class<T> type, String name,\n+        InternalFactory<? extends T> factory) {\n+      return factory;\n+    }\n+  },\n+\n+  /**\n+   * One instance per container.\n+   */\n+  SINGLETON {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(Class<T> type, String name,\n+        final InternalFactory<? extends T> factory) {\n+      return new InternalFactory<T>() {\n+        T instance;\n+        public T create(InternalContext context) {\n+          synchronized (context.getContainer()) {\n+            if (instance == null) {\n+              instance = factory.create(context);\n+            }\n+            return instance;\n+          }\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return factory.toString();\n+        }\n+      };\n+    }\n+  },\n+\n+  /**\n+   * One instance per thread.\n+   *\n+   * <p><b>Note:</b> if a thread local object strongly references its {@link\n+   * Container}, neither the {@code Container} nor the object will be\n+   * eligible for garbage collection, i.e. memory leak.\n+   */\n+  THREAD {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(Class<T> type, String name,\n+        final InternalFactory<? extends T> factory) {\n+      return new InternalFactory<T>() {\n+        final ThreadLocal<T> threadLocal = new ThreadLocal<T>();\n+        public T create(final InternalContext context) {\n+          T t = threadLocal.get();\n+          if (t == null) {\n+            t = factory.create(context);\n+            threadLocal.set(t);\n+          }\n+          return t;\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return factory.toString();\n+        }\n+      };\n+    }\n+  },\n+\n+  /**\n+   * One instance per request.\n+   */\n+  REQUEST {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(final Class<T> type,\n+        final String name, final InternalFactory<? extends T> factory) {\n+      return new InternalFactory<T>() {\n+        public T create(InternalContext context) {\n+          Strategy strategy = context.getScopeStrategy();\n+          try {\n+            return strategy.findInRequest(\n+                type, name, toCallable(context, factory));\n+          } catch (Exception e) {\n+            throw new RuntimeException(e);\n+          }\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return factory.toString();\n+        }\n+      };\n+    }\n+  },\n+\n+  /**\n+   * One instance per session.\n+   */\n+  SESSION {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(final Class<T> type,\n+        final String name, final InternalFactory<? extends T> factory) {\n+      return new InternalFactory<T>() {\n+        public T create(InternalContext context) {\n+          Strategy strategy = context.getScopeStrategy();\n+          try {\n+            return strategy.findInSession(\n+                type, name, toCallable(context, factory));\n+          } catch (Exception e) {\n+            throw new RuntimeException(e);\n+          }\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return factory.toString();\n+        }\n+      };\n+    }\n+  },\n+\n+  /**\n+   * One instance per wizard.\n+   */\n+  WIZARD {\n+    @Override\n+            <T> InternalFactory<? extends T> scopeFactory(final Class<T> type,\n+        final String name, final InternalFactory<? extends T> factory) {\n+      return new InternalFactory<T>() {\n+        public T create(InternalContext context) {\n+          Strategy strategy = context.getScopeStrategy();\n+          try {\n+            return strategy.findInWizard(\n+                type, name, toCallable(context, factory));\n+          } catch (Exception e) {\n+            throw new RuntimeException(e);\n+          }\n+        }\n+\n+        @Override\n+        public String toString() {\n+          return factory.toString();\n+        }\n+      };\n+    }\n+  };\n+\n+  <T> Callable<? extends T> toCallable(final InternalContext context,\n+      final InternalFactory<? extends T> factory) {\n+    return new Callable<T>() {\n+      public T call() throws Exception {\n+        return factory.create(context);\n+      }\n+    };\n+  }\n+\n+  /**\n+   * Wraps factory with scoping logic.\n+   */\n+  abstract <T> InternalFactory<? extends T> scopeFactory(\n+      Class<T> type, String name, InternalFactory<? extends T> factory);\n+\n+  /**\n+   * Pluggable scoping strategy. Enables users to provide custom\n+   * implementations of request, session, and wizard scopes. Implement and\n+   * pass to {@link\n+   * Container#setScopeStrategy(com.opensymphony.xwork2.inject.Scope.Strategy)}.\n+   */\n+  public interface Strategy {\n+\n+    /**\n+     * Finds an object for the given type and name in the request scope.\n+     * Creates a new object if necessary using the given factory.\n+     */\n+    <T> T findInRequest(Class<T> type, String name,\n+        Callable<? extends T> factory) throws Exception;\n+\n+    /**\n+     * Finds an object for the given type and name in the session scope.\n+     * Creates a new object if necessary using the given factory.\n+     */\n+    <T> T findInSession(Class<T> type, String name,\n+        Callable<? extends T> factory) throws Exception;\n+\n+    /**\n+     * Finds an object for the given type and name in the wizard scope.\n+     * Creates a new object if necessary using the given factory.\n+     */\n+    <T> T findInWizard(Class<T> type, String name,\n+        Callable<? extends T> factory) throws Exception;\n+  }\n+}"
        },
        {
            "sha": "31a9447ca1710bdba8768e0a293390f6f33a99d3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/Scoped.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScoped.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScoped.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2FScoped.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,37 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject;\n+\n+import java.lang.annotation.ElementType;\n+import java.lang.annotation.Retention;\n+import static java.lang.annotation.RetentionPolicy.RUNTIME;\n+import java.lang.annotation.Target;\n+\n+/**\n+ * Annotates a scoped implementation class.\n+ *\n+ * @author crazybob\n+ */\n+@Target(ElementType.TYPE)\n+@Retention(RUNTIME)\n+public @interface Scoped {\n+\n+  /**\n+   * Scope.\n+   */\n+  Scope value();\n+}"
        },
        {
            "sha": "6e26e24c557fad10afd08bf4cab99d77bbb40eec",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/package-info.java",
            "status": "added",
            "additions": 30,
            "deletions": 0,
            "changes": 30,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Fpackage-info.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Fpackage-info.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Fpackage-info.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,30 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+/**\n+ * <i>Guice</i> (pronounced \"juice\"). A lightweight dependency injection\n+ * container. Features include:\n+ *\n+ * <ul>\n+ *   <li>constructor, method, and field injection</li>\n+ *   <li>static method and field injection</li>\n+ *   <li>circular reference support (including constructors if you depend upon\n+ *    interfaces)</li>\n+ *   <li>high performance</li>\n+ *   <li>externalize what needs to be and no more</li>\n+ * </ul>\n+ */\n+package com.opensymphony.xwork2.inject;"
        },
        {
            "sha": "869b96bfbd03c1d59cbba1de850eca52dc916c49",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/FinalizablePhantomReference.java",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizablePhantomReference.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizablePhantomReference.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizablePhantomReference.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,35 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import java.lang.ref.PhantomReference;\n+\n+/**\n+ * Phantom reference with a {@link com.opensymphony.xwork2.inject.util.FinalizableReference#finalizeReferent() finalizeReferent()} method which a\n+ * background thread invokes after the garbage collector reclaims the\n+ * referent. This is a simpler alternative to using a {@link\n+ * java.lang.ref.ReferenceQueue}.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public abstract class FinalizablePhantomReference<T>\n+    extends PhantomReference<T> implements FinalizableReference {\n+\n+  protected FinalizablePhantomReference(T referent) {\n+    super(referent, FinalizableReferenceQueue.getInstance());\n+  }\n+}"
        },
        {
            "sha": "16653e2d6d07c9ba590b31d42cba68ffb79426b8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/FinalizableReference.java",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReference.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReference.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReference.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,32 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+/**\n+ * Package-private interface implemented by references that have code to run\n+ * after garbage collection of their referents.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+interface FinalizableReference {\n+\n+    /**\n+     * Invoked on a background thread after the referent has been garbage\n+     * collected.\n+     */\n+    void finalizeReferent();\n+}"
        },
        {
            "sha": "72121efbab67530d0b1f7242d4dbfe9876f062e7",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/FinalizableReferenceQueue.java",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReferenceQueue.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReferenceQueue.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableReferenceQueue.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,77 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import java.lang.ref.Reference;\n+import java.lang.ref.ReferenceQueue;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+\n+/**\n+ * Starts a background thread that cleans up after reclaimed referents.\n+ *\n+ * @author Bob Lee (crazybob@google.com)\n+ */\n+class FinalizableReferenceQueue extends ReferenceQueue<Object> {\n+\n+  private static final Logger logger =\n+      Logger.getLogger(FinalizableReferenceQueue.class.getName());\n+\n+  private FinalizableReferenceQueue() {}\n+\n+  void cleanUp(Reference reference) {\n+    try {\n+      ((FinalizableReference) reference).finalizeReferent();\n+    } catch (Throwable t) {\n+      deliverBadNews(t);\n+    }\n+  }\n+\n+  void deliverBadNews(Throwable t) {\n+    logger.log(Level.SEVERE, \"Error cleaning up after reference.\", t);\n+  }\n+\n+  void start() {\n+    Thread thread = new Thread(\"FinalizableReferenceQueue\") {\n+      @Override\n+      public void run() {\n+        while (true) {\n+          try {\n+            cleanUp(remove());\n+          } catch (InterruptedException e) { /* ignore */ }\n+        }\n+      }\n+    };\n+    thread.setDaemon(true);\n+    thread.start();\n+  }\n+\n+  static ReferenceQueue<Object> instance = createAndStart();\n+\n+  static FinalizableReferenceQueue createAndStart() {\n+    FinalizableReferenceQueue queue = new FinalizableReferenceQueue();\n+    queue.start();\n+    return queue;\n+  }\n+\n+  /**\n+   * Gets instance.\n+   */\n+  public static ReferenceQueue<Object> getInstance() {\n+    return instance;\n+  }\n+}"
        },
        {
            "sha": "eeb1c206466093defe40c7269eb8f683fe038fe9",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/FinalizableSoftReference.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableSoftReference.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableSoftReference.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableSoftReference.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import java.lang.ref.SoftReference;\n+\n+/**\n+ * Soft reference with a {@link com.opensymphony.xwork2.inject.util.FinalizableReference#finalizeReferent() finalizeReferent()} method which a background\n+ * thread invokes after the garbage collector reclaims the referent. This is a\n+ * simpler alternative to using a {@link java.lang.ref.ReferenceQueue}.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public abstract class FinalizableSoftReference<T> extends SoftReference<T>\n+    implements FinalizableReference {\n+\n+  protected FinalizableSoftReference(T referent) {\n+    super(referent, FinalizableReferenceQueue.getInstance());\n+  }\n+}"
        },
        {
            "sha": "7c3a67faa5309d1c1d256bbcf566d2719be53fa9",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/FinalizableWeakReference.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableWeakReference.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableWeakReference.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFinalizableWeakReference.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,34 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import java.lang.ref.WeakReference;\n+\n+/**\n+ * Weak reference with a {@link com.opensymphony.xwork2.inject.util.FinalizableReference#finalizeReferent() finalizeReferent()} method which a background\n+ * thread invokes after the garbage collector reclaims the referent. This is a\n+ * simpler alternative to using a {@link java.lang.ref.ReferenceQueue}.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public abstract class FinalizableWeakReference<T> extends WeakReference<T>\n+    implements FinalizableReference {\n+\n+  protected FinalizableWeakReference(T referent) {\n+    super(referent, FinalizableReferenceQueue.getInstance());\n+  }\n+}"
        },
        {
            "sha": "fd212373e719906bf7e4b8ba17d8033db6fab75e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/Function.java",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFunction.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFunction.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FFunction.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,44 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+/**\n+ * A Function provides a transformation on an object and returns the resulting\n+ * object.  For example, a {@code StringToIntegerFunction} may implement\n+ * <code>Function&lt;String,Integer&gt;</code> and transform integers in String\n+ * format to Integer format.\n+ *\n+ * <p>The transformation on the source object does not necessarily result in\n+ * an object of a different type.  For example, a\n+ * {@code FarenheitToCelciusFunction} may implement\n+ * <code>Function&lt;Float,Float&gt;</code>.\n+ *\n+ * <p>Implementors of Function which may cause side effects upon evaluation are\n+ * strongly encouraged to state this fact clearly in their API documentation.\n+ */\n+public interface Function<F,T> {\n+\n+  /**\n+   * Applies the function to an object of type {@code F}, resulting in an object\n+   * of type {@code T}.  Note that types {@code F} and {@code T} may or may not\n+   * be the same.\n+   *\n+   * @param from The source object.\n+   * @return The resulting object.\n+   */\n+  T apply(F from);\n+}"
        },
        {
            "sha": "166742cfa07a6ff8176c77547597dead6a393214",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/ReferenceCache.java",
            "status": "added",
            "additions": 184,
            "deletions": 0,
            "changes": 184,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceCache.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceCache.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceCache.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,184 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import static com.opensymphony.xwork2.inject.util.ReferenceType.STRONG;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.util.concurrent.*;\n+\n+/**\n+ * Extends {@link ReferenceMap} to support lazy loading values by overriding\n+ * {@link #create(Object)}.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public abstract class ReferenceCache<K, V> extends ReferenceMap<K, V> {\n+\n+  private static final long serialVersionUID = 0;\n+\n+  transient ConcurrentMap<Object, Future<V>> futures =\n+      new ConcurrentHashMap<Object, Future<V>>();\n+\n+  transient ThreadLocal<Future<V>> localFuture = new ThreadLocal<Future<V>>();\n+\n+  public ReferenceCache(ReferenceType keyReferenceType,\n+      ReferenceType valueReferenceType) {\n+    super(keyReferenceType, valueReferenceType);\n+  }\n+\n+  /**\n+   * Equivalent to {@code new ReferenceCache(STRONG, STRONG)}.\n+   */\n+  public ReferenceCache() {\n+    super(STRONG, STRONG);\n+  }\n+\n+  /**\n+   * Override to lazy load values. Use as an alternative to {@link\n+   * #put(Object,Object)}. Invoked by getter if value isn't already cached.\n+   * Must not return {@code null}. This method will not be called again until\n+   * the garbage collector reclaims the returned value.\n+   */\n+  protected abstract V create(K key);\n+\n+  V internalCreate(K key) {\n+    try {\n+      FutureTask<V> futureTask = new FutureTask<V>(\n+          new CallableCreate(key));\n+\n+      // use a reference so we get the same equality semantics.\n+      Object keyReference = referenceKey(key);\n+      Future<V> future = futures.putIfAbsent(keyReference, futureTask);\n+      if (future == null) {\n+        // winning thread.\n+        try {\n+          if (localFuture.get() != null) {\n+            throw new IllegalStateException(\n+                \"Nested creations within the same cache are not allowed.\");\n+          }\n+          localFuture.set(futureTask);\n+          futureTask.run();\n+          V value = futureTask.get();\n+          putStrategy().execute(this,\n+              keyReference, referenceValue(keyReference, value));\n+          return value;\n+        } finally {\n+          localFuture.remove();\n+          futures.remove(keyReference);\n+        }\n+      } else {\n+        // wait for winning thread.\n+        return future.get();\n+      }\n+    } catch (InterruptedException e) {\n+      throw new RuntimeException(e);\n+    } catch (ExecutionException e) {\n+      Throwable cause = e.getCause();\n+      if (cause instanceof RuntimeException) {\n+        throw (RuntimeException) cause;\n+      } else if (cause instanceof Error) {\n+        throw (Error) cause;\n+      }\n+      throw new RuntimeException(cause);\n+    }\n+  }\n+\n+  /**\n+   * {@inheritDoc}\n+   *\n+   * If this map does not contain an entry for the given key and {@link\n+   * #create(Object)} has been overridden, this method will create a new\n+   * value, put it in the map, and return it.\n+   *\n+   * @throws NullPointerException if {@link #create(Object)} returns null.\n+   * @throws java.util.concurrent.CancellationException if the creation is\n+   *  cancelled. See {@link #cancel()}.\n+   */\n+  @SuppressWarnings(\"unchecked\")\n+  @Override public V get(final Object key) {\n+    V value = super.get(key);\n+    return (value == null)\n+      ? internalCreate((K) key)\n+      : value;\n+  }\n+\n+  /**\n+   * Cancels the current {@link #create(Object)}. Throws {@link\n+   * java.util.concurrent.CancellationException} to all clients currently\n+   * blocked on {@link #get(Object)}.\n+   */\n+  protected void cancel() {\n+    Future<V> future = localFuture.get();\n+    if (future == null) {\n+      throw new IllegalStateException(\"Not in create().\");\n+    }\n+    future.cancel(false);\n+  }\n+\n+  class CallableCreate implements Callable<V> {\n+\n+    K key;\n+\n+    public CallableCreate(K key) {\n+      this.key = key;\n+    }\n+\n+    public V call() {\n+      // try one more time (a previous future could have come and gone.)\n+      V value = internalGet(key);\n+      if (value != null) {\n+        return value;\n+      }\n+\n+      // create value.\n+      value = create(key);\n+      if (value == null) {\n+        throw new NullPointerException(\n+            \"create(K) returned null for: \" + key);\n+      }\n+      return value;\n+    }\n+  }\n+\n+  /**\n+   * Returns a {@code ReferenceCache} delegating to the specified {@code\n+   * function}. The specified function must not return {@code null}.\n+   */\n+  public static <K, V> ReferenceCache<K, V> of(\n+      ReferenceType keyReferenceType,\n+      ReferenceType valueReferenceType,\n+      final Function<? super K, ? extends V> function) {\n+    ensureNotNull(function);\n+    return new ReferenceCache<K, V>(keyReferenceType, valueReferenceType) {\n+      @Override\n+      protected V create(K key) {\n+        return function.apply(key);\n+      }\n+      private static final long serialVersionUID = 0;\n+    };\n+  }\n+\n+  private void readObject(ObjectInputStream in) throws IOException,\n+      ClassNotFoundException {\n+    in.defaultReadObject();\n+    this.futures = new ConcurrentHashMap<Object, Future<V>>();\n+    this.localFuture = new ThreadLocal<Future<V>>();\n+  }\n+\n+}"
        },
        {
            "sha": "2542a8c960197e58d280c2f4a25e7dfcabad5a9d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/ReferenceMap.java",
            "status": "added",
            "additions": 616,
            "deletions": 0,
            "changes": 616,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceMap.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceMap.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceMap.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,616 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+import static com.opensymphony.xwork2.inject.util.ReferenceType.STRONG;\n+\n+import java.io.IOException;\n+import java.io.ObjectInputStream;\n+import java.io.ObjectOutputStream;\n+import java.io.Serializable;\n+import java.lang.ref.Reference;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+/**\n+ * Concurrent hash map that wraps keys and/or values in soft or weak\n+ * references. Does not support null keys or values. Uses identity equality\n+ * for weak and soft keys.\n+ *\n+ * <p>The concurrent semantics of {@link ConcurrentHashMap} combined with the\n+ * fact that the garbage collector can asynchronously reclaim and clean up\n+ * after keys and values at any time can lead to some racy semantics. For\n+ * example, {@link #size()} returns an upper bound on the size, i.e. the actual\n+ * size may be smaller in cases where the key or value has been reclaimed but\n+ * the map entry has not been cleaned up yet.\n+ *\n+ * <p>Another example: If {@link #get(Object)} cannot find an existing entry\n+ * for a key, it will try to create one. This operation is not atomic. One\n+ * thread could {@link #put(Object, Object)} a value between the time another\n+ * thread running {@code get()} checks for an entry and decides to create one.\n+ * In this case, the newly created value will replace the put value in the\n+ * map. Also, two threads running {@code get()} concurrently can potentially\n+ * create duplicate values for a given key.\n+ *\n+ * <p>In other words, this class is great for caching but not atomicity.\n+ *\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+@SuppressWarnings(\"unchecked\")\n+public class ReferenceMap<K, V> implements Map<K, V>, Serializable {\n+\n+  private static final long serialVersionUID = 0;\n+\n+  transient ConcurrentMap<Object, Object> delegate;\n+\n+  final ReferenceType keyReferenceType;\n+  final ReferenceType valueReferenceType;\n+\n+  /**\n+   * Concurrent hash map that wraps keys and/or values based on specified\n+   * reference types.\n+   *\n+   * @param keyReferenceType key reference type\n+   * @param valueReferenceType value reference type\n+   */\n+  public ReferenceMap(ReferenceType keyReferenceType,\n+      ReferenceType valueReferenceType) {\n+    ensureNotNull(keyReferenceType, valueReferenceType);\n+\n+    if (keyReferenceType == ReferenceType.PHANTOM\n+        || valueReferenceType == ReferenceType.PHANTOM) {\n+      throw new IllegalArgumentException(\"Phantom references not supported.\");\n+    }\n+\n+    this.delegate = new ConcurrentHashMap<Object, Object>();\n+    this.keyReferenceType = keyReferenceType;\n+    this.valueReferenceType = valueReferenceType;\n+  }\n+\n+  V internalGet(K key) {\n+    Object valueReference = delegate.get(makeKeyReferenceAware(key));\n+    return valueReference == null\n+        ? null\n+        : (V) dereferenceValue(valueReference);\n+  }\n+\n+  public V get(final Object key) {\n+    ensureNotNull(key);\n+    return internalGet((K) key);\n+  }\n+\n+  V execute(Strategy strategy, K key, V value) {\n+    ensureNotNull(key, value);\n+    Object keyReference = referenceKey(key);\n+    Object valueReference = strategy.execute(\n+      this,\n+      keyReference,\n+      referenceValue(keyReference, value)\n+    );\n+    return valueReference == null ? null\n+        : (V) dereferenceValue(valueReference);\n+  }\n+\n+  public V put(K key, V value) {\n+    return execute(putStrategy(), key, value);\n+  }\n+\n+  public V remove(Object key) {\n+    ensureNotNull(key);\n+    Object referenceAwareKey = makeKeyReferenceAware(key);\n+    Object valueReference = delegate.remove(referenceAwareKey);\n+    return valueReference == null ? null\n+        : (V) dereferenceValue(valueReference);\n+  }\n+\n+  public int size() {\n+    return delegate.size();\n+  }\n+\n+  public boolean isEmpty() {\n+    return delegate.isEmpty();\n+  }\n+\n+  public boolean containsKey(Object key) {\n+    ensureNotNull(key);\n+    Object referenceAwareKey = makeKeyReferenceAware(key);\n+    return delegate.containsKey(referenceAwareKey);\n+  }\n+\n+  public boolean containsValue(Object value) {\n+    ensureNotNull(value);\n+    for (Object valueReference : delegate.values()) {\n+      if (value.equals(dereferenceValue(valueReference))) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public void putAll(Map<? extends K, ? extends V> t) {\n+    for (Map.Entry<? extends K, ? extends V> entry : t.entrySet()) {\n+      put(entry.getKey(), entry.getValue());\n+    }\n+  }\n+\n+  public void clear() {\n+    delegate.clear();\n+  }\n+\n+  /**\n+   * Returns an unmodifiable set view of the keys in this map. As this method\n+   * creates a defensive copy, the performance is O(n).\n+   */\n+  public Set<K> keySet() {\n+    return Collections.unmodifiableSet(\n+        dereferenceKeySet(delegate.keySet()));\n+  }\n+\n+  /**\n+   * Returns an unmodifiable set view of the values in this map. As this\n+   * method creates a defensive copy, the performance is O(n).\n+   */\n+  public Collection<V> values() {\n+    return Collections.unmodifiableCollection(\n+        dereferenceValues(delegate.values()));\n+  }\n+\n+  public V putIfAbsent(K key, V value) {\n+    // TODO (crazybob) if the value has been gc'ed but the entry hasn't been\n+    // cleaned up yet, this put will fail.\n+    return execute(putIfAbsentStrategy(), key, value);\n+  }\n+\n+  public boolean remove(Object key, Object value) {\n+    ensureNotNull(key, value);\n+    Object referenceAwareKey = makeKeyReferenceAware(key);\n+    Object referenceAwareValue = makeValueReferenceAware(value);\n+    return delegate.remove(referenceAwareKey, referenceAwareValue);\n+  }\n+\n+  public boolean replace(K key, V oldValue, V newValue) {\n+    ensureNotNull(key, oldValue, newValue);\n+    Object keyReference = referenceKey(key);\n+\n+    Object referenceAwareOldValue = makeValueReferenceAware(oldValue);\n+    return delegate.replace(\n+      keyReference,\n+      referenceAwareOldValue,\n+      referenceValue(keyReference, newValue)\n+    );\n+  }\n+\n+  public V replace(K key, V value) {\n+    // TODO (crazybob) if the value has been gc'ed but the entry hasn't been\n+    // cleaned up yet, this will succeed when it probably shouldn't.\n+    return execute(replaceStrategy(), key, value);\n+  }\n+\n+  /**\n+   * Returns an unmodifiable set view of the entries in this map. As this\n+   * method creates a defensive copy, the performance is O(n).\n+   */\n+  public Set<Map.Entry<K, V>> entrySet() {\n+    Set<Map.Entry<K, V>> entrySet = new HashSet<Map.Entry<K, V>>();\n+    for (Map.Entry<Object, Object> entry : delegate.entrySet()) {\n+      Map.Entry<K, V> dereferenced = dereferenceEntry(entry);\n+      if (dereferenced != null) {\n+        entrySet.add(dereferenced);\n+      }\n+    }\n+    return Collections.unmodifiableSet(entrySet);\n+  }\n+\n+  /**\n+   * Dereferences an entry. Returns null if the key or value has been gc'ed.\n+   */\n+  Entry dereferenceEntry(Map.Entry<Object, Object> entry) {\n+    K key = dereferenceKey(entry.getKey()); \n+    V value = dereferenceValue(entry.getValue());\n+    return (key == null || value == null)\n+        ? null\n+        : new Entry(key, value);\n+  }\n+\n+  /**\n+   * Creates a reference for a key.\n+   */\n+  Object referenceKey(K key) {\n+    switch (keyReferenceType) {\n+      case STRONG: return key;\n+      case SOFT: return new SoftKeyReference(key);\n+      case WEAK: return new WeakKeyReference(key);\n+      default: throw new AssertionError();\n+    }\n+  }\n+\n+  /**\n+   * Converts a reference to a key.\n+   */\n+  K dereferenceKey(Object o) {\n+    return (K) dereference(keyReferenceType, o);\n+  }\n+\n+  /**\n+   * Converts a reference to a value.\n+   */\n+  V dereferenceValue(Object o) {\n+    return (V) dereference(valueReferenceType, o);\n+  }\n+\n+  /**\n+   * Returns the refererent for reference given its reference type.\n+   */\n+  Object dereference(ReferenceType referenceType, Object reference) {\n+    return referenceType == STRONG ? reference : ((Reference) reference).get();\n+  }\n+\n+  /**\n+   * Creates a reference for a value.\n+   */\n+  Object referenceValue(Object keyReference, Object value) {\n+    switch (valueReferenceType) {\n+      case STRONG: return value;\n+      case SOFT: return new SoftValueReference(keyReference, value);\n+      case WEAK: return new WeakValueReference(keyReference, value);\n+      default: throw new AssertionError();\n+    }\n+  }\n+\n+  /**\n+   * Dereferences a set of key references.\n+   */\n+  Set<K> dereferenceKeySet(Set keyReferences) {\n+    return keyReferenceType == STRONG\n+        ? keyReferences\n+        : dereferenceCollection(keyReferenceType, keyReferences, new HashSet());\n+  }\n+\n+  /**\n+   * Dereferences a collection of value references.\n+   */\n+  Collection<V> dereferenceValues(Collection valueReferences) {\n+    return valueReferenceType == STRONG\n+        ? valueReferences\n+        : dereferenceCollection(valueReferenceType, valueReferences,\n+            new ArrayList(valueReferences.size()));\n+  }\n+\n+  /**\n+   * Wraps key so it can be compared to a referenced key for equality.\n+   */\n+  Object makeKeyReferenceAware(Object o) {\n+    return keyReferenceType == STRONG ? o : new KeyReferenceAwareWrapper(o);\n+  }\n+\n+  /**\n+   * Wraps value so it can be compared to a referenced value for equality.\n+   */\n+  Object makeValueReferenceAware(Object o) {\n+    return valueReferenceType == STRONG ? o : new ReferenceAwareWrapper(o);\n+  }\n+\n+  /**\n+   * Dereferences elements in {@code in} using\n+   * {@code referenceType} and puts them in {@code out}. Returns\n+   * {@code out}.\n+   */\n+  <T extends Collection<Object>> T dereferenceCollection(\n+      ReferenceType referenceType, T in, T out) {\n+    for (Object reference : in) {\n+      out.add(dereference(referenceType, reference));\n+    }\n+    return out;\n+  }\n+\n+  /**\n+   * Marker interface to differentiate external and internal references.\n+   */\n+  interface InternalReference {}\n+\n+  static int keyHashCode(Object key) {\n+    return System.identityHashCode(key);\n+  }\n+\n+  /**\n+   * Tests weak and soft references for identity equality. Compares references\n+   * to other references and wrappers. If o is a reference, this returns true\n+   * if r == o or if r and o reference the same non null object. If o is a\n+   * wrapper, this returns true if r's referent is identical to the wrapped\n+   * object.\n+   */\n+  static boolean referenceEquals(Reference r, Object o) {\n+    // compare reference to reference.\n+    if (o instanceof InternalReference) {\n+      // are they the same reference? used in cleanup.\n+      if (o == r) {\n+        return true;\n+      }\n+\n+      // do they reference identical values? used in conditional puts.\n+      Object referent = ((Reference) o).get();\n+      return referent != null && referent == r.get();\n+    }\n+\n+    // is the wrapped object identical to the referent? used in lookups.\n+    return ((ReferenceAwareWrapper) o).unwrap() == r.get();\n+  }\n+\n+  /**\n+   * Big hack. Used to compare keys and values to referenced keys and values\n+   * without creating more references.\n+   */\n+  static class ReferenceAwareWrapper {\n+\n+    Object wrapped;\n+\n+    ReferenceAwareWrapper(Object wrapped) {\n+      this.wrapped = wrapped;\n+    }\n+\n+    Object unwrap() {\n+      return wrapped;\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return wrapped.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object obj) {\n+      // defer to reference's equals() logic.\n+      return obj.equals(this);\n+    }\n+  }\n+\n+  /**\n+   * Used for keys. Overrides hash code to use identity hash code.\n+   */\n+  static class KeyReferenceAwareWrapper extends ReferenceAwareWrapper {\n+\n+    public KeyReferenceAwareWrapper(Object wrapped) {\n+      super(wrapped);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return System.identityHashCode(wrapped);\n+    }\n+  }\n+\n+  class SoftKeyReference extends FinalizableSoftReference<Object>\n+      implements InternalReference {\n+\n+    int hashCode;\n+\n+    public SoftKeyReference(Object key) {\n+      super(key);\n+      this.hashCode = keyHashCode(key);\n+    }\n+\n+    public void finalizeReferent() {\n+      delegate.remove(this);\n+    }\n+\n+    @Override public int hashCode() {\n+      return this.hashCode;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return referenceEquals(this, o);\n+    }\n+  }\n+\n+  class WeakKeyReference extends FinalizableWeakReference<Object>\n+      implements InternalReference {\n+\n+    int hashCode;\n+\n+    public WeakKeyReference(Object key) {\n+      super(key);\n+      this.hashCode = keyHashCode(key);\n+    }\n+\n+    public void finalizeReferent() {\n+      delegate.remove(this);\n+    }\n+\n+    @Override public int hashCode() {\n+      return this.hashCode;\n+    }\n+\n+    @Override public boolean equals(Object o) {\n+      return referenceEquals(this, o);\n+    }\n+  }\n+\n+  class SoftValueReference extends FinalizableSoftReference<Object>\n+      implements InternalReference {\n+\n+    Object keyReference;\n+\n+    public SoftValueReference(Object keyReference, Object value) {\n+      super(value);\n+      this.keyReference = keyReference;\n+    }\n+\n+    public void finalizeReferent() {\n+      delegate.remove(keyReference, this);\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+      return referenceEquals(this, obj);\n+    }\n+  }\n+\n+  class WeakValueReference extends FinalizableWeakReference<Object>\n+      implements InternalReference {\n+\n+    Object keyReference;\n+\n+    public WeakValueReference(Object keyReference, Object value) {\n+      super(value);\n+      this.keyReference = keyReference;\n+    }\n+\n+    public void finalizeReferent() {\n+      delegate.remove(keyReference, this);\n+    }\n+\n+    @Override public boolean equals(Object obj) {\n+      return referenceEquals(this, obj);\n+    }\n+  }\n+\n+  protected interface Strategy {\n+    public Object execute(ReferenceMap map, Object keyReference,\n+        Object valueReference);\n+  }\n+\n+  protected Strategy putStrategy() {\n+    return PutStrategy.PUT;\n+  }\n+\n+  protected Strategy putIfAbsentStrategy() {\n+    return PutStrategy.PUT_IF_ABSENT;\n+  }\n+\n+  protected Strategy replaceStrategy() {\n+    return PutStrategy.REPLACE;\n+  }\n+\n+  private enum PutStrategy implements Strategy {\n+    PUT {\n+      public Object execute(ReferenceMap map, Object keyReference,\n+          Object valueReference) {\n+        return map.delegate.put(keyReference, valueReference);\n+      }\n+    },\n+\n+    REPLACE {\n+      public Object execute(ReferenceMap map, Object keyReference,\n+          Object valueReference) {\n+        return map.delegate.replace(keyReference, valueReference);\n+      }\n+    },\n+\n+    PUT_IF_ABSENT {\n+      public Object execute(ReferenceMap map, Object keyReference,\n+          Object valueReference) {\n+        return map.delegate.putIfAbsent(keyReference, valueReference);\n+      }\n+    };\n+  };\n+\n+  private static PutStrategy defaultPutStrategy;\n+\n+  protected PutStrategy getPutStrategy() {\n+    return defaultPutStrategy;\n+  }\n+\n+\n+  class Entry implements Map.Entry<K, V> {\n+\n+    K key;\n+    V value;\n+\n+    public Entry(K key, V value) {\n+      this.key = key;\n+      this.value = value;\n+    }\n+\n+    public K getKey() {\n+      return this.key;\n+    }\n+\n+    public V getValue() {\n+      return this.value;\n+    }\n+\n+    public V setValue(V value) {\n+      return put(key, value);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return key.hashCode() * 31 + value.hashCode();\n+    }\n+\n+    @Override\n+    public boolean equals(Object o) {\n+      if (!(o instanceof ReferenceMap.Entry)) {\n+        return false;\n+      }\n+\n+      Entry entry = (Entry) o;\n+      return key.equals(entry.key) && value.equals(entry.value);\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return key + \"=\" + value;\n+    }\n+  }\n+\n+  static void ensureNotNull(Object o) {\n+    if (o == null) {\n+      throw new NullPointerException();\n+    }\n+  }\n+\n+  static void ensureNotNull(Object... array) {\n+    for (int i = 0; i < array.length; i++) {\n+      if (array[i] == null) {\n+        throw new NullPointerException(\"Argument #\" + i + \" is null.\");\n+      }\n+    }\n+  }\n+\n+  private void writeObject(ObjectOutputStream out) throws IOException  {\n+    out.defaultWriteObject();\n+    out.writeInt(size());\n+    for (Map.Entry<Object, Object> entry : delegate.entrySet()) {\n+      Object key = dereferenceKey(entry.getKey());\n+      Object value = dereferenceValue(entry.getValue());\n+\n+      // don't persist gc'ed entries.\n+      if (key != null && value != null) {\n+        out.writeObject(key);\n+        out.writeObject(value);\n+      }\n+    }\n+    out.writeObject(null);\n+  }\n+\n+  private void readObject(ObjectInputStream in) throws IOException,\n+      ClassNotFoundException {\n+    in.defaultReadObject();\n+    int size = in.readInt();\n+    this.delegate = new ConcurrentHashMap<Object, Object>(size);\n+    while (true) {\n+      K key = (K) in.readObject();\n+      if (key == null) {\n+        break;\n+      }\n+      V value = (V) in.readObject();\n+      put(key, value);\n+    }\n+  }\n+\n+}"
        },
        {
            "sha": "a223a00ee9702fc5c944d796ae1d64d62ae4c6ef",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/ReferenceType.java",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceType.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceType.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FReferenceType.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+/**\n+ * Reference type. Used to specify what type of reference to keep to a\n+ * referent.\n+ *\n+ * @see java.lang.ref.Reference\n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public enum ReferenceType {\n+\n+  /**\n+   * Prevents referent from being reclaimed by the garbage collector.\n+   */\n+  STRONG,\n+\n+  /**\n+   * Referent reclaimed in an LRU fashion when the VM runs low on memory and\n+   * no strong references exist.\n+   *\n+   * @see java.lang.ref.SoftReference\n+   */\n+  SOFT,\n+\n+  /**\n+   * Referent reclaimed when no strong or soft references exist.\n+   *\n+   * @see java.lang.ref.WeakReference\n+   */\n+  WEAK,\n+\n+  /**\n+   * Similar to weak references except the garbage collector doesn't actually\n+   * reclaim the referent. More flexible alternative to finalization.\n+   *\n+   * @see java.lang.ref.PhantomReference\n+   */\n+  PHANTOM;\n+}"
        },
        {
            "sha": "a15291ae2c7822e876e267f58556c3a629b4bc2b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/Strings.java",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FStrings.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FStrings.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2FStrings.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,55 @@\n+/**\n+ * Copyright (C) 2006 Google Inc.\n+ *\n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ *\n+ * http://www.apache.org/licenses/LICENSE-2.0\n+ *\n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.inject.util;\n+\n+/**\n+ * String utilities.\n+ * \n+ * @author crazybob@google.com (Bob Lee)\n+ */\n+public class Strings {\n+\n+  /**\n+   * Returns a string that is equivalent to the specified string with its\n+   * first character converted to uppercase as by {@link String#toUpperCase}.\n+   * The returned string will have the same value as the specified string if\n+   * its first character is non-alphabetic, if its first character is already\n+   * uppercase, or if the specified string is of length 0.\n+   *\n+   * <p>For example:\n+   * <pre>\n+   *    capitalize(\"foo bar\").equals(\"Foo bar\");\n+   *    capitalize(\"2b or not 2b\").equals(\"2b or not 2b\")\n+   *    capitalize(\"Foo bar\").equals(\"Foo bar\");\n+   *    capitalize(\"\").equals(\"\");\n+   * </pre>\n+   *\n+   * @param s the string whose first character is to be uppercased\n+   * @return a string equivalent to <tt>s</tt> with its first character\n+   *     converted to uppercase\n+   * @throws NullPointerException if <tt>s</tt> is null\n+   */\n+  public static String capitalize(String s) {\n+    if (s.length() == 0)\n+      return s;\n+    char first = s.charAt(0);\n+    char capitalized = Character.toUpperCase(first);\n+    return (first == capitalized)\n+        ? s\n+        : capitalized + s.substring(1);\n+  }\n+}"
        },
        {
            "sha": "e3264616f4b13bf485e041a2e111365c4d3c4b2e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/inject/util/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finject%2Futil%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1 @@\n+<body>Guice util classes.</body>"
        },
        {
            "sha": "470d3495097942d7877b1b43b6af957ed1f276d8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/AbstractInterceptor.java",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAbstractInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAbstractInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAbstractInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,42 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+\n+/**\n+ * Provides default implementations of optional lifecycle methods\n+ */\n+public abstract class AbstractInterceptor implements Interceptor {\n+\n+    /**\n+     * Does nothing\n+     */\n+    public void init() {\n+    }\n+    \n+    /**\n+     * Does nothing\n+     */\n+    public void destroy() {\n+    }\n+\n+\n+    /**\n+     * Override to handle interception\n+     */\n+    public abstract String intercept(ActionInvocation invocation) throws Exception;\n+}"
        },
        {
            "sha": "4132c3a13506266f3d0baea54a77dda9ddecb627",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/AliasInterceptor.java",
            "status": "added",
            "additions": 193,
            "deletions": 0,
            "changes": 193,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAliasInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAliasInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FAliasInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,193 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.ValidationAware;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.config.entities.ActionConfig;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.ClearableValueStack;\n+import com.opensymphony.xwork2.util.ValueStackFactory;\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Map;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ *\n+ * The aim of this Interceptor is to alias a named parameter to a different named parameter. By acting as the glue\n+ * between actions sharing similiar parameters (but with different names), it can help greatly with action chaining.\n+ *\n+ * <p/>  Action's alias expressions should be in the form of  <code>#{ \"name1\" : \"alias1\", \"name2\" : \"alias2\" }</code>.\n+ * This means that assuming an action (or something else in the stack) has a value for the expression named <i>name1</i> and the\n+ * action this interceptor is applied to has a setter named <i>alias1</i>, <i>alias1</i> will be set with the value from\n+ * <i>name1</i>.\n+ *\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Interceptor parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ *\n+ * <li>aliasesKey (optional) - the name of the action parameter to look for the alias map (by default this is\n+ * <i>aliases</i>).</li>\n+ *\n+ * </ul>\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Extending the interceptor:</u>\n+ *\n+ * <p/>\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ *\n+ * This interceptor does not have any known extension points.\n+ *\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;!-- The value for the foo parameter will be applied as if it were named bar --&gt;\n+ *     &lt;param name=\"aliases\"&gt;#{ 'foo' : 'bar' }&lt;/param&gt;\n+ *\n+ *     &lt;interceptor-ref name=\"alias\"/&gt;\n+ *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Matthew Payne\n+ */\n+public class AliasInterceptor extends AbstractInterceptor {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(AliasInterceptor.class);\n+\n+    private static final String DEFAULT_ALIAS_KEY = \"aliases\";\n+    protected String aliasesKey = DEFAULT_ALIAS_KEY;\n+\n+    protected ValueStackFactory valueStackFactory;\n+    static boolean devMode = false;\n+\n+    @Inject(\"devMode\")\n+    public static void setDevMode(String mode) {\n+        devMode = \"true\".equals(mode);\n+    }   \n+\n+    @Inject\n+    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n+        this.valueStackFactory = valueStackFactory;\n+    }\n+\n+    /**\n+     * Sets the name of the action parameter to look for the alias map.\n+     * <p/>\n+     * Default is <code>aliases</code>.\n+     *\n+     * @param aliasesKey  the name of the action parameter\n+     */\n+    public void setAliasesKey(String aliasesKey) {\n+        this.aliasesKey = aliasesKey;\n+    }\n+\n+    @Override public String intercept(ActionInvocation invocation) throws Exception {\n+\n+        ActionConfig config = invocation.getProxy().getConfig();\n+        ActionContext ac = invocation.getInvocationContext();\n+        Object action = invocation.getAction();\n+\n+        // get the action's parameters\n+        final Map<String, String> parameters = config.getParams();\n+\n+        if (parameters.containsKey(aliasesKey)) {\n+\n+            String aliasExpression = parameters.get(aliasesKey);\n+            ValueStack stack = ac.getValueStack();\n+            Object obj = stack.findValue(aliasExpression);\n+\n+            if (obj != null && obj instanceof Map) {\n+                //get secure stack\n+                ValueStack newStack = valueStackFactory.createValueStack(stack);\n+                boolean clearableStack = newStack instanceof ClearableValueStack;\n+                if (clearableStack) {\n+                    //if the stack's context can be cleared, do that to prevent OGNL\n+                    //from having access to objects in the stack, see XW-641\n+                    ((ClearableValueStack)newStack).clearContextValues();\n+                    Map<String, Object> context = newStack.getContext();\n+                    ReflectionContextState.setCreatingNullObjects(context, true);\n+                    ReflectionContextState.setDenyMethodExecution(context, true);\n+                    ReflectionContextState.setReportingConversionErrors(context, true);\n+\n+                    //keep locale from original context\n+                    context.put(ActionContext.LOCALE, stack.getContext().get(ActionContext.LOCALE));\n+                }\n+\n+                // override\n+                Map aliases = (Map) obj;\n+                for (Object o : aliases.entrySet()) {\n+                    Map.Entry entry = (Map.Entry) o;\n+                    String name = entry.getKey().toString();\n+                    String alias = (String) entry.getValue();\n+                    Object value = stack.findValue(name);\n+                    if (null == value) {\n+                        // workaround\n+                        Map<String, Object> contextParameters = ActionContext.getContext().getParameters();\n+\n+                        if (null != contextParameters) {\n+                            value = contextParameters.get(name);\n+                        }\n+                    }\n+                    if (null != value) {\n+                        try {\n+                            newStack.setValue(alias, value);\n+                        } catch (RuntimeException e) {\n+                            if (devMode) {\n+                                String developerNotification = LocalizedTextUtil.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n+                                        \"Unexpected Exception caught setting '\" + entry.getKey() + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n+                                });\n+                                LOG.error(developerNotification);\n+                                if (action instanceof ValidationAware) {\n+                                    ((ValidationAware) action).addActionMessage(developerNotification);\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (clearableStack && (stack.getContext() != null) && (newStack.getContext() != null))\n+                    stack.getContext().put(ActionContext.CONVERSION_ERRORS, newStack.getContext().get(ActionContext.CONVERSION_ERRORS));\n+            } else {\n+                LOG.debug(\"invalid alias expression:\" + aliasesKey);\n+            }\n+        }\n+        \n+        return invocation.invoke();\n+    }\n+    \n+}"
        },
        {
            "sha": "50633089f4e9fbf0fb08e638dda05013111fdd4a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ChainingInterceptor.java",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FChainingInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FChainingInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FChainingInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,176 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.Unchainable;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.CompoundRoot;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionProvider;\n+\n+import java.util.*;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ *\n+ * An interceptor that copies all the properties of every object in the value stack to the currently executing object,\n+ * except for any object that implements {@link Unchainable}. A collection of optional <i>includes</i> and\n+ * <i>excludes</i> may be provided to control how and which parameters are copied. Only includes or excludes may be\n+ * specified. Specifying both results in undefined behavior. See the javadocs for {@link ReflectionProvider#copy(Object, Object,\n+ * java.util.Map, java.util.Collection, java.util.Collection)} for more information.\n+ *\n+ * <p/>\n+ * <b>Note:</b> It is important to remember that this interceptor does nothing if there are no objects already on the stack.\n+ * <br/>This means two things:\n+ * <br/><b>One</b>, you can safely apply it to all your actions without any worry of adverse affects.\n+ * <br/><b/>Two</b>, it is up to you to ensure an object exists in the stack prior to invoking this action. The most typical way this is done\n+ * is through the use of the <b>chain</b> result type, which combines with this interceptor to make up the action\n+ * chaining feature.\n+ *\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Interceptor parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ *\n+ * <li>excludes (optional) - the list of parameter names to exclude from copying (all others will be included).</li>\n+ *\n+ * <li>includes (optional) - the list of parameter names to include when copying (all others will be excluded).</li>\n+ *\n+ * </ul>\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Extending the interceptor:</u>\n+ *\n+ * <p/>\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ *\n+ * There are no known extension points to this interceptor.\n+ *\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * \n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *     &lt;result name=\"success\" type=\"chain\"&gt;otherAction&lt;/result&gt;\n+ * &lt;/action&gt;\n+ *\n+ * &lt;action name=\"otherAction\" class=\"com.examples.OtherAction\"&gt;\n+ *     &lt;interceptor-ref name=\"chain\"/&gt;\n+ *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * \n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @see com.opensymphony.xwork2.ActionChainResult\n+ * @author mrdon\n+ * @author tm_jee ( tm_jee(at)yahoo.co.uk )\n+ */\n+public class ChainingInterceptor extends AbstractInterceptor {\n+\t\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ChainingInterceptor.class);\n+\t\n+    protected Collection<String> excludes;\n+    protected Collection<String> includes;\n+    \n+    protected ReflectionProvider reflectionProvider;\n+    \n+    @Inject\n+    public void setReflectionProvider(ReflectionProvider prov) {\n+        this.reflectionProvider = prov;\n+    }\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        ValueStack stack = invocation.getStack();\n+        CompoundRoot root = stack.getRoot();\n+\n+        if (root.size() > 1) {\n+            List<CompoundRoot> list = new ArrayList<CompoundRoot>(root);\n+            list.remove(0);\n+            Collections.reverse(list);\n+\n+            Map<String, Object> ctxMap = invocation.getInvocationContext().getContextMap();\n+            Iterator<CompoundRoot> iterator = list.iterator();\n+            int index = 1; // starts with 1, 0 has been removed\n+            while (iterator.hasNext()) {\n+            \tindex = index + 1;\n+                Object o = iterator.next();\n+                if (o != null) {\n+                \tif (!(o instanceof Unchainable)) {\n+                \t\treflectionProvider.copy(o, invocation.getAction(), ctxMap, excludes, includes);\n+                \t}\n+                }\n+                else {\n+                \tLOG.warn(\"compound root element at index \"+index+\" is null\");\n+                }\n+            }\n+        }\n+        \n+        return invocation.invoke();\n+    }\n+    \n+    /**\n+     * Gets list of parameter names to exclude\n+     *\n+     * @return the exclude list\n+     */\n+    public Collection<String> getExcludes() {\n+        return excludes;\n+    }\n+\n+    /**\n+     * Sets the list of parameter names to exclude from copying (all others will be included).\n+     *\n+     * @param excludes  the excludes list\n+     */\n+    public void setExcludes(Collection<String> excludes) {\n+        this.excludes = excludes;\n+    }\n+\n+    /**\n+     * Gets list of parameter names to include\n+     *\n+     * @return the include list\n+     */\n+    public Collection<String> getIncludes() {\n+        return includes;\n+    }\n+\n+    /**\n+     * Sets the list of parameter names to include when copying (all others will be excluded).\n+     *\n+     * @param includes  the includes list\n+     */\n+    public void setIncludes(Collection<String> includes) {\n+        this.includes = includes;\n+    }\n+\n+}"
        },
        {
            "sha": "65793c289dd0ec8677651ac799e4f3c3e6924066",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ConversionErrorInterceptor.java",
            "status": "added",
            "additions": 139,
            "deletions": 0,
            "changes": 139,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FConversionErrorInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FConversionErrorInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FConversionErrorInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,139 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.ValidationAware;\n+import com.opensymphony.xwork2.conversion.impl.XWorkConverter;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * ConversionErrorInterceptor adds conversion errors from the ActionContext to the Action's field errors.\n+ *\n+ * <p/>\n+ * This interceptor adds any error found in the {@link ActionContext}'s conversionErrors map as a field error (provided\n+ * that the action implements {@link ValidationAware}). In addition, any field that contains a validation error has its\n+ * original value saved such that any subsequent requests for that value return the original value rather than the value\n+ * in the action. This is important because if the value \"abc\" is submitted and can't be converted to an int, we want to\n+ * display the original string (\"abc\") again rather than the int value (likely 0, which would make very little sense to\n+ * the user).\n+ *\n+ *\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Interceptor parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ *\n+ * <li>None</li>\n+ *\n+ * </ul>\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Extending the interceptor:</u>\n+ *\n+ * <p/>\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ *\n+ * Because this interceptor is not web-specific, it abstracts the logic for whether an error should be added. This\n+ * allows for web-specific interceptors to use more complex logic in the {@link #shouldAddError} method for when a value\n+ * has a conversion error but is null or empty or otherwise indicates that the value was never actually entered by the\n+ * user.\n+ *\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"conversionError\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Jason Carreira\n+ */\n+public class ConversionErrorInterceptor extends AbstractInterceptor {\n+\n+    public static final String ORIGINAL_PROPERTY_OVERRIDE = \"original.property.override\";\n+\n+    protected Object getOverrideExpr(ActionInvocation invocation, Object value) {\n+        return \"'\" + value + \"'\";\n+    }\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+\n+        ActionContext invocationContext = invocation.getInvocationContext();\n+        Map<String, Object> conversionErrors = invocationContext.getConversionErrors();\n+        ValueStack stack = invocationContext.getValueStack();\n+\n+        HashMap<Object, Object> fakie = null;\n+\n+        for (Map.Entry<String, Object> entry : conversionErrors.entrySet()) {\n+            String propertyName = entry.getKey();\n+            Object value = entry.getValue();\n+\n+            if (shouldAddError(propertyName, value)) {\n+                String message = XWorkConverter.getConversionErrorMessage(propertyName, stack);\n+\n+                Object action = invocation.getAction();\n+                if (action instanceof ValidationAware) {\n+                    ValidationAware va = (ValidationAware) action;\n+                    va.addFieldError(propertyName, message);\n+                }\n+\n+                if (fakie == null) {\n+                    fakie = new HashMap<Object, Object>();\n+                }\n+\n+                fakie.put(propertyName, getOverrideExpr(invocation, value));\n+            }\n+        }\n+\n+        if (fakie != null) {\n+            // if there were some errors, put the original (fake) values in place right before the result\n+            stack.getContext().put(ORIGINAL_PROPERTY_OVERRIDE, fakie);\n+            invocation.addPreResultListener(new PreResultListener() {\n+                public void beforeResult(ActionInvocation invocation, String resultCode) {\n+                    Map<Object, Object> fakie = (Map<Object, Object>) invocation.getInvocationContext().get(ORIGINAL_PROPERTY_OVERRIDE);\n+\n+                    if (fakie != null) {\n+                        invocation.getStack().setExprOverrides(fakie);\n+                    }\n+                }\n+            });\n+        }\n+        return invocation.invoke();\n+    }\n+\n+    protected boolean shouldAddError(String propertyName, Object value) {\n+        return true;\n+    }\n+}"
        },
        {
            "sha": "1cdf20f4fbb8f77ed7c649f8e58e509d1d4e3c15",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/DefaultWorkflowInterceptor.java",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FDefaultWorkflowInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FDefaultWorkflowInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FDefaultWorkflowInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,179 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.Action;\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.ValidationAware;\n+import com.opensymphony.xwork2.interceptor.annotations.InputConfig;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.lang.reflect.Method;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * <p/>\n+ * An interceptor that makes sure there are not validation errors before allowing the interceptor chain to continue.\n+ * <b>This interceptor does not perform any validation</b>.\n+ * <p/>\n+ * <p/>This interceptor does nothing if the name of the method being invoked is specified in the <b>excludeMethods</b>\n+ * parameter. <b>excludeMethods</b> accepts a comma-delimited list of method names. For example, requests to\n+ * <b>foo!input.action</b> and <b>foo!back.action</b> will be skipped by this interceptor if you set the\n+ * <b>excludeMethods</b> parameter to \"input, back\".\n+ * <p/>\n+ * <b>Note:</b> As this method extends off MethodFilterInterceptor, it is capable of\n+ * deciding if it is applicable only to selective methods in the action class. This is done by adding param tags\n+ * for the interceptor element, naming either a list of excluded method names and/or a list of included method\n+ * names, whereby includeMethods overrides excludedMethods. A single * sign is interpreted as wildcard matching\n+ * all methods for both parameters.\n+ * See {@link MethodFilterInterceptor} for more info.\n+ * <p/>\n+ * <!-- END SNIPPET: description -->\n+ * <p/>\n+ * <p/> <u>Interceptor parameters:</u>\n+ * <p/>\n+ * <!-- START SNIPPET: parameters -->\n+ * <p/>\n+ * <ul>\n+ * <p/>\n+ * <li>inputResultName - Default to \"input\". Determine the result name to be returned when\n+ * an action / field error is found.</li>\n+ * <p/>\n+ * </ul>\n+ * <p/>\n+ * <!-- END SNIPPET: parameters -->\n+ * <p/>\n+ * <p/> <u>Extending the interceptor:</u>\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: extending -->\n+ * <p/>\n+ * There are no known extension points for this interceptor.\n+ * <p/>\n+ * <!-- END SNIPPET: extending -->\n+ * <p/>\n+ * <p/> <u>Example code:</u>\n+ * <p/>\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * <p/>\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"validation\"/&gt;\n+ *     &lt;interceptor-ref name=\"workflow\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <p/>\n+ * &lt;-- In this case myMethod as well as mySecondMethod of the action class\n+ *        will not pass through the workflow process --&gt;\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"validation\"/&gt;\n+ *     &lt;interceptor-ref name=\"workflow\"&gt;\n+ *         &lt;param name=\"excludeMethods\"&gt;myMethod,mySecondMethod&lt;/param&gt;\n+ *     &lt;/interceptor-ref name=\"workflow\"&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <p/>\n+ * &lt;-- In this case, the result named \"error\" will be used when\n+ *        an action / field error is found --&gt;\n+ * &lt;-- The Interceptor will only be applied for myWorkflowMethod method of action\n+ *        classes, since this is the only included method while any others are excluded --&gt;\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"validation\"/&gt;\n+ *     &lt;interceptor-ref name=\"workflow\"&gt;\n+ *        &lt;param name=\"inputResultName\"&gt;error&lt;/param&gt;\n+ *         &lt;param name=\"excludeMethods\"&gt;*&lt;/param&gt;\n+ *         &lt;param name=\"includeMethods\"&gt;myWorkflowMethod&lt;/param&gt;\n+ *     &lt;/interceptor-ref&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <p/>\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Jason Carreira\n+ * @author Rainer Hermanns\n+ * @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+ * @author Philip Luppens\n+ * @author tm_jee\n+ */\n+public class DefaultWorkflowInterceptor extends MethodFilterInterceptor {\n+\n+    private static final long serialVersionUID = 7563014655616490865L;\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(DefaultWorkflowInterceptor.class);\n+\n+    private static final Class[] EMPTY_CLASS_ARRAY = new Class[0];\n+    \n+    private String inputResultName = Action.INPUT;\n+\n+    /**\n+     * Set the <code>inputResultName</code> (result name to be returned when\n+     * a action / field error is found registered). Default to {@link Action#INPUT}\n+     *\n+     * @param inputResultName what result name to use when there was validation error(s).\n+     */\n+    public void setInputResultName(String inputResultName) {\n+        this.inputResultName = inputResultName;\n+    }\n+\n+    /**\n+     * Intercept {@link ActionInvocation} and returns a <code>inputResultName</code>\n+     * when action / field errors is found registered.\n+     *\n+     * @return String result name\n+     */\n+    @Override\n+    protected String doIntercept(ActionInvocation invocation) throws Exception {\n+        Object action = invocation.getAction();\n+\n+        if (action instanceof ValidationAware) {\n+            ValidationAware validationAwareAction = (ValidationAware) action;\n+\n+            if (validationAwareAction.hasErrors()) {\n+                if (LOG.isDebugEnabled()) {\n+                    LOG.debug(\"Errors on action \" + validationAwareAction + \", returning result name 'input'\");\n+                }\n+\n+                String resultName = inputResultName;\n+\n+                if (action instanceof ValidationWorkflowAware) {\n+                    resultName = ((ValidationWorkflowAware) action).getInputResultName();\n+                }\n+\n+                InputConfig annotation = action.getClass().getMethod(invocation.getProxy().getMethod(), EMPTY_CLASS_ARRAY).getAnnotation(InputConfig.class);\n+                if (annotation != null) {\n+                    if (!annotation.methodName().equals(\"\")) {\n+                        Method method = action.getClass().getMethod(annotation.methodName());\n+                        resultName = (String) method.invoke(action);\n+                    } else {\n+                        resultName = annotation.resultName();\n+                    }\n+                }\n+\n+\n+                return resultName;\n+            }\n+        }\n+\n+        return invocation.invoke();\n+    }\n+\n+}"
        },
        {
            "sha": "90382b5c92859bf8863bbd432db19f423635c989",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ExceptionHolder.java",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionHolder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionHolder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionHolder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,84 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import java.io.IOException;\n+import java.io.PrintWriter;\n+import java.io.StringWriter;\n+import java.io.Serializable;\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ *\n+ * A simple wrapper around an exception, providing an easy way to print out the stack trace of the exception as well as\n+ * a way to get a handle on the exception itself.\n+ *\n+ * <!-- END SNIPPET: javadoc -->\n+ *\n+ * @author Matthew E. Porter (matthew dot porter at metissian dot com)\n+ */\n+public class ExceptionHolder implements Serializable {\n+\n+    private Exception exception;\n+\n+    /**\n+     * Holds the given exception\n+     *\n+     * @param exception  the exception to hold.\n+     */\n+    public ExceptionHolder(Exception exception) {\n+        this.exception = exception;\n+    }\n+\n+    /**\n+     * Gets the holded exception\n+     *\n+     * @return  the holded exception\n+     */\n+    public Exception getException() {\n+        return this.exception;\n+    }\n+\n+    /**\n+     * Gets the holded exception stacktrace using {@link Exception#printStackTrace()}.\n+     *\n+     * @return  stacktrace\n+     */\n+    public String getExceptionStack() {\n+        String exceptionStack = null;\n+\n+        if (getException() != null) {\n+            StringWriter sw = new StringWriter();\n+            PrintWriter pw = new PrintWriter(sw);\n+\n+            try {\n+                getException().printStackTrace(pw);\n+                exceptionStack = sw.toString();\n+            }\n+            finally {\n+                try {\n+                    sw.close();\n+                    pw.close();\n+                } catch (IOException e) {\n+                    // ignore\n+                }\n+            }\n+        }\n+\n+        return exceptionStack;\n+    }\n+    \n+}"
        },
        {
            "sha": "1627f26a4d41c816c706acfe4f0fb90b298960c1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ExceptionMappingInterceptor.java",
            "status": "added",
            "additions": 304,
            "deletions": 0,
            "changes": 304,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionMappingInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionMappingInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FExceptionMappingInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,304 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.config.entities.ExceptionMappingConfig;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.List;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ *\n+ * This interceptor forms the core functionality of the exception handling feature. Exception handling allows you to map\n+ * an exception to a result code, just as if the action returned a result code instead of throwing an unexpected\n+ * exception. When an exception is encountered, it is wrapped with an {@link ExceptionHolder} and pushed on the stack,\n+ * providing easy access to the exception from within your result.\n+ *\n+ * <b>Note:</b> While you can configure exception mapping in your configuration file at any point, the configuration\n+ * will not have any effect if this interceptor is not in the interceptor stack for your actions. It is recommended that\n+ * you make this interceptor the first interceptor on the stack, ensuring that it has full access to catch any\n+ * exception, even those caused by other interceptors.\n+ *\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Interceptor parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ *\n+ * <li>logEnabled (optional) - Should exceptions also be logged? (boolean true|false)</li>\n+ * \n+ * <li>logLevel (optional) - what log level should we use (<code>trace, debug, info, warn, error, fatal</code>)? - defaut is <code>debug</code></li>\n+ * \n+ * <li>logCategory (optional) - If provided we would use this category (eg. <code>com.mycompany.app</code>).\n+ * Default is to use <code>com.opensymphony.xwork2.interceptor.ExceptionMappingInterceptor</code>.</li>\n+ *\n+ * </ul>\n+ *\n+ * The parameters above enables us to log all thrown exceptions with stacktace in our own logfile,\n+ * and present a friendly webpage (with no stacktrace) to the end user.\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Extending the interceptor:</u>\n+ *\n+ * <p/>\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ *\n+ * If you want to add custom handling for publishing the Exception, you may override\n+ * {@link #publishException(com.opensymphony.xwork2.ActionInvocation, ExceptionHolder)}. The default implementation\n+ * pushes the given ExceptionHolder on value stack. A custom implementation could add additional logging etc.\n+ *\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;xwork&gt;\n+ *     &lt;package name=\"default\" extends=\"xwork-default\"&gt;\n+ *         &lt;global-results&gt;\n+ *             &lt;result name=\"error\" type=\"freemarker\"&gt;error.ftl&lt;/result&gt;\n+ *         &lt;/global-results&gt;\n+ *\n+ *         &lt;global-exception-mappings&gt;\n+ *             &lt;exception-mapping exception=\"java.lang.Exception\" result=\"error\"/&gt;\n+ *         &lt;/global-exception-mappings&gt;\n+ *\n+ *         &lt;action name=\"test\"&gt;\n+ *             &lt;interceptor-ref name=\"exception\"/&gt;\n+ *             &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *             &lt;exception-mapping exception=\"com.acme.CustomException\" result=\"custom_error\"/&gt;\n+ *             &lt;result name=\"custom_error\"&gt;custom_error.ftl&lt;/result&gt;\n+ *             &lt;result name=\"success\" type=\"freemarker\"&gt;test.ftl&lt;/result&gt;\n+ *         &lt;/action&gt;\n+ *     &lt;/package&gt;\n+ * &lt;/xwork&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ * \n+ * <p/>\n+ * This second example will also log the exceptions using our own category\n+ * <code>com.mycompany.app.unhandled<code> at WARN level. \n+ * \n+ * <pre>\n+ * <!-- START SNIPPET: example2 -->\n+ * &lt;xwork&gt;\n+ *   &lt;package name=\"something\" extends=\"xwork-default\"&gt;\n+ *      &lt;interceptors&gt;\n+ *          &lt;interceptor-stack name=\"exceptionmappingStack\"&gt;\n+ *              &lt;interceptor-ref name=\"exception\"&gt;\n+ *                  &lt;param name=\"logEnabled\"&gt;true&lt;/param&gt;\n+ *                  &lt;param name=\"logCategory\"&gt;com.mycompany.app.unhandled&lt;/param&gt;\n+ *                  &lt;param name=\"logLevel\"&gt;WARN&lt;/param&gt;\t        \t\t\n+ *              &lt;/interceptor-ref&gt;\t\n+ *              &lt;interceptor-ref name=\"i18n\"/&gt;\n+ *              &lt;interceptor-ref name=\"staticParams\"/&gt;\n+ *              &lt;interceptor-ref name=\"params\"/&gt;\n+ *              &lt;interceptor-ref name=\"validation\"&gt;\n+ *                  &lt;param name=\"excludeMethods\"&gt;input,back,cancel,browse&lt;/param&gt;\n+ *              &lt;/interceptor-ref&gt;\n+ *          &lt;/interceptor-stack&gt;\n+ *      &lt;/interceptors&gt;\n+ *\n+ *      &lt;default-interceptor-ref name=\"exceptionmappingStack\"/&gt;\n+ *    \n+ *      &lt;global-results&gt;\n+ *           &lt;result name=\"unhandledException\"&gt;/unhandled-exception.jsp&lt;/result&gt;\n+ *      &lt;/global-results&gt;\n+ *\n+ *      &lt;global-exception-mappings&gt;\n+ *           &lt;exception-mapping exception=\"java.lang.Exception\" result=\"unhandledException\"/&gt;\n+ *      &lt;/global-exception-mappings&gt;\n+ *        \n+ *      &lt;action name=\"exceptionDemo\" class=\"org.apache.struts2.showcase.exceptionmapping.ExceptionMappingAction\"&gt;\n+ *          &lt;exception-mapping exception=\"org.apache.struts2.showcase.exceptionmapping.ExceptionMappingException\"\n+ *                             result=\"damm\"/&gt;\n+ *          &lt;result name=\"input\"&gt;index.jsp&lt;/result&gt;\n+ *          &lt;result name=\"success\"&gt;success.jsp&lt;/result&gt;            \n+ *          &lt;result name=\"damm\"&gt;damm.jsp&lt;/result&gt;\n+ *      &lt;/action&gt;\n+ *\n+ *   &lt;/package&gt;\n+ * &lt;/xwork&gt;\n+ * <!-- END SNIPPET: example2 -->\n+ * </pre>\n+ *\n+ * @author Matthew E. Porter (matthew dot porter at metissian dot com) \n+ * @author Claus Ibsen\n+ */\n+public class ExceptionMappingInterceptor extends AbstractInterceptor {\n+    \n+    protected static final Logger LOG = LoggerFactory.getLogger(ExceptionMappingInterceptor.class);\n+\n+    protected Logger categoryLogger;\n+    protected boolean logEnabled = false;\n+    protected String logCategory;\n+    protected String logLevel;\n+    \n+\n+    public boolean isLogEnabled() {\n+        return logEnabled;\n+    }\n+\n+    public void setLogEnabled(boolean logEnabled) {\n+        this.logEnabled = logEnabled;\n+    }\n+\n+    public String getLogCategory() {\n+\t\treturn logCategory;\n+\t}\n+\n+\tpublic void setLogCategory(String logCatgory) {\n+\t\tthis.logCategory = logCatgory;\n+\t}\n+\n+\tpublic String getLogLevel() {\n+\t\treturn logLevel;\n+\t}\n+\n+\tpublic void setLogLevel(String logLevel) {\n+\t\tthis.logLevel = logLevel;\n+\t}\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        String result;\n+\n+        try {\n+            result = invocation.invoke();\n+        } catch (Exception e) {\n+            if (isLogEnabled()) {\n+                handleLogging(e);\n+            }\n+            List<ExceptionMappingConfig> exceptionMappings = invocation.getProxy().getConfig().getExceptionMappings();\n+            String mappedResult = this.findResultFromExceptions(exceptionMappings, e);\n+            if (mappedResult != null) {\n+                result = mappedResult;\n+                publishException(invocation, new ExceptionHolder(e));\n+            } else {\n+                throw e;\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Handles the logging of the exception.\n+     * \n+     * @param e  the exception to log.\n+     */\n+    protected void handleLogging(Exception e) {\n+    \tif (logCategory != null) {\n+        \tif (categoryLogger == null) {\n+        \t\t// init category logger\n+        \t\tcategoryLogger = LoggerFactory.getLogger(logCategory);\n+        \t}\n+        \tdoLog(categoryLogger, e);\n+    \t} else {\n+    \t\tdoLog(LOG, e);\n+    \t}\n+    }\n+    \n+    /**\n+     * Performs the actual logging.\n+     * \n+     * @param logger  the provided logger to use.\n+     * @param e  the exception to log.\n+     */\n+    protected void doLog(Logger logger, Exception e) {\n+    \tif (logLevel == null) {\n+    \t\tlogger.debug(e.getMessage(), e);\n+    \t\treturn;\n+    \t}\n+    \t\n+    \tif (\"trace\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.trace(e.getMessage(), e);\n+    \t} else if (\"debug\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.debug(e.getMessage(), e);\n+    \t} else if (\"info\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.info(e.getMessage(), e);\n+    \t} else if (\"warn\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.warn(e.getMessage(), e);\n+    \t} else if (\"error\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.error(e.getMessage(), e);\n+    \t} else if (\"fatal\".equalsIgnoreCase(logLevel)) {\n+    \t\tlogger.fatal(e.getMessage(), e);\n+    \t} else {\n+    \t\tthrow new IllegalArgumentException(\"LogLevel [\" + logLevel + \"] is not supported\");\n+    \t}\n+    }\n+\n+    protected String findResultFromExceptions(List<ExceptionMappingConfig> exceptionMappings, Throwable t) {\n+        String result = null;\n+\n+        // Check for specific exception mappings.\n+        if (exceptionMappings != null) {\n+            int deepest = Integer.MAX_VALUE;\n+            for (Object exceptionMapping : exceptionMappings) {\n+                ExceptionMappingConfig exceptionMappingConfig = (ExceptionMappingConfig) exceptionMapping;\n+                int depth = getDepth(exceptionMappingConfig.getExceptionClassName(), t);\n+                if (depth >= 0 && depth < deepest) {\n+                    deepest = depth;\n+                    result = exceptionMappingConfig.getResult();\n+                }\n+            }\n+        }\n+\n+        return result;\n+    }\n+\n+    /**\n+     * Return the depth to the superclass matching. 0 means ex matches exactly. Returns -1 if there's no match.\n+     * Otherwise, returns depth. Lowest depth wins.\n+     *\n+     * @param exceptionMapping  the mapping classname\n+     * @param t  the cause\n+     * @return the depth, if not found -1 is returned.\n+     */\n+    public int getDepth(String exceptionMapping, Throwable t) {\n+        return getDepth(exceptionMapping, t.getClass(), 0);\n+    }\n+\n+    private int getDepth(String exceptionMapping, Class exceptionClass, int depth) {\n+        if (exceptionClass.getName().contains(exceptionMapping)) {\n+            // Found it!\n+            return depth;\n+        }\n+        // If we've gone as far as we can go and haven't found it...\n+        if (exceptionClass.equals(Throwable.class)) {\n+            return -1;\n+        }\n+        return getDepth(exceptionMapping, exceptionClass.getSuperclass(), depth + 1);\n+    }\n+\n+    /**\n+     * Default implementation to handle ExceptionHolder publishing. Pushes given ExceptionHolder on the stack.\n+     * Subclasses may override this to customize publishing.\n+     *\n+     * @param invocation The invocation to publish Exception for.\n+     * @param exceptionHolder The exceptionHolder wrapping the Exception to publish.\n+     */\n+    protected void publishException(ActionInvocation invocation, ExceptionHolder exceptionHolder) {\n+        invocation.getStack().push(exceptionHolder);\n+    }\n+}"
        },
        {
            "sha": "e8fb4f1212c8b9399e5523fc384cf20435c22524",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/I18nInterceptor.java",
            "status": "added",
            "additions": 211,
            "deletions": 0,
            "changes": 211,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FI18nInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FI18nInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FI18nInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,211 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Locale;\n+import java.util.Map;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * <p/>\n+ * An interceptor that handles setting the locale specified in a session as the locale for the current action request.\n+ * In addition, this interceptor will look for a specific HTTP request parameter and set the locale to whatever value is\n+ * provided. This means that this interceptor can be used to allow for your application to dynamically change the locale\n+ * for the user's session or, alternatively, only for the current request (since XWork 2.1.3).\n+ * This is very useful for applications that require multi-lingual support and want the user to\n+ * be able to set his or her language preference at any point. The locale parameter is removed during the execution of\n+ * this interceptor, ensuring that properties aren't set on an action (such as request_locale) that have no typical\n+ * corresponding setter in your action.\n+ * <p/>\n+ * <p/>For example, using the default parameter name, a request to <b>foo.action?request_locale=en_US</b>, then the\n+ * locale for US English is saved in the user's session and will be used for all future requests.\n+ * <p/>\n+ * <!-- END SNIPPET: description -->\n+ * <p/>\n+ * <p/> <u>Interceptor parameters:</u>\n+ * <p/>\n+ * <!-- START SNIPPET: parameters -->\n+ * <p/>\n+ * <ul>\n+ * <p/>\n+ * <li>parameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to and save\n+ * in the session. By default this is <b>request_locale</b></li>\n+ * <p/>\n+ * <li>requestOnlyParameterName (optional) - the name of the HTTP request parameter that dictates the locale to switch to\n+ * for the current request only, without saving it in the session. By default this is <b>request_only_locale</b></li>\n+ * <p/>\n+ * <li>attributeName (optional) - the name of the session key to store the selected locale. By default this is\n+ * <b>WW_TRANS_I18N_LOCALE</b></li>\n+ * <p/>\n+ * </ul>\n+ * <p/>\n+ * <!-- END SNIPPET: parameters -->\n+ * <p/>\n+ * <p/> <u>Extending the interceptor:</u>\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: extending -->\n+ * <p/>\n+ * There are no known extensions points for this interceptor.\n+ * <p/>\n+ * <!-- END SNIPPET: extending -->\n+ * <p/>\n+ * <p/> <u>Example code:</u>\n+ * <p/>\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"i18n\"/&gt;\n+ *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Aleksei Gopachenko\n+ */\n+public class I18nInterceptor extends AbstractInterceptor {\n+    protected static final Logger LOG = LoggerFactory.getLogger(I18nInterceptor.class);\n+\n+    public static final String DEFAULT_SESSION_ATTRIBUTE = \"WW_TRANS_I18N_LOCALE\";\n+    public static final String DEFAULT_PARAMETER = \"request_locale\";\n+    public static final String DEFAULT_REQUESTONLY_PARAMETER = \"request_only_locale\";\n+\n+    protected String parameterName = DEFAULT_PARAMETER;\n+    protected String requestOnlyParameterName = DEFAULT_REQUESTONLY_PARAMETER;\n+    protected String attributeName = DEFAULT_SESSION_ATTRIBUTE;\n+\n+    public I18nInterceptor() {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"new I18nInterceptor()\");\n+        }\n+    }\n+\n+    public void setParameterName(String parameterName) {\n+        this.parameterName = parameterName;\n+    }\n+\n+    public void setRequestOnlyParameterName(String requestOnlyParameterName) {\n+        this.requestOnlyParameterName = requestOnlyParameterName;\n+    }\n+\n+    public void setAttributeName(String attributeName) {\n+        this.attributeName = attributeName;\n+    }\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"intercept '\"\n+                    + invocation.getProxy().getNamespace() + \"/\"\n+                    + invocation.getProxy().getActionName() + \"' { \");\n+        }\n+        //get requested locale\n+        Map<String, Object> params = invocation.getInvocationContext().getParameters();\n+\n+        boolean storeInSession = true;\n+        Object requested_locale = findLocaleParameter(params, parameterName);\n+        if (requested_locale == null) {\n+            requested_locale = findLocaleParameter(params, requestOnlyParameterName);\n+            if (requested_locale != null) {\n+                storeInSession = false;\n+            }\n+        }\n+\n+        //save it in session\n+        Map<String, Object> session = invocation.getInvocationContext().getSession();\n+\n+        Locale locale = null;\n+        if (requested_locale != null) {\n+            locale = (requested_locale instanceof Locale) ?\n+                    (Locale) requested_locale : LocalizedTextUtil.localeFromString(requested_locale.toString(), null);\n+            if (locale != null && LOG.isDebugEnabled()) {\n+                LOG.debug(\"applied request locale=\" + locale);\n+            }\n+        }\n+        if (session != null) {\n+            synchronized (session) {\n+                if (locale == null) {\n+                    storeInSession = false;\n+                    // check session for saved locale\n+                    Object sessionLocale = session.get(attributeName);\n+                    if (sessionLocale != null && sessionLocale instanceof Locale) {\n+                        locale = (Locale) sessionLocale;\n+                        if (LOG.isDebugEnabled()) {\n+                            LOG.debug(\"applied session locale=\" + locale);\n+                        }\n+                    } else {\n+                        // no overriding locale definition found, stay with current invocation (=browser) locale\n+                        locale = invocation.getInvocationContext().getLocale();\n+                        if (locale != null && LOG.isDebugEnabled()) {\n+                            LOG.debug(\"applied invocation context locale=\" + locale);\n+                        }\n+                    }\n+                }\n+                if (storeInSession) {\n+                    session.put(attributeName, locale);\n+                }\n+            }\n+        }\n+        saveLocale(invocation, locale);\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"before Locale=\" + invocation.getStack().findValue(\"locale\"));\n+        }\n+\n+        final String result = invocation.invoke();\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"after Locale=\" + invocation.getStack().findValue(\"locale\"));\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"intercept } \");\n+        }\n+\n+        return result;\n+    }\n+\n+    private Object findLocaleParameter(Map<String, Object> params, String parameterName) {\n+        Object requested_locale = params.remove(parameterName);\n+        if (requested_locale != null && requested_locale.getClass().isArray()\n+                && ((Object[]) requested_locale).length == 1) {\n+            requested_locale = ((Object[]) requested_locale)[0];\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"requested_locale=\" + requested_locale);\n+            }\n+        }\n+        return requested_locale;\n+    }\n+\n+    /**\n+     * Save the given locale to the ActionInvocation.\n+     *\n+     * @param invocation The ActionInvocation.\n+     * @param locale     The locale to save.\n+     */\n+    protected void saveLocale(ActionInvocation invocation, Locale locale) {\n+        invocation.getInvocationContext().setLocale(locale);\n+    }\n+\n+}"
        },
        {
            "sha": "4266236485ae73ad780e752f275846da71212753",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/Interceptor.java",
            "status": "added",
            "additions": 213,
            "deletions": 0,
            "changes": 213,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,213 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+\n+import java.io.Serializable;\n+\n+\n+/**\n+ * <!-- START SNIPPET: introduction -->\n+ * <p/>\n+ * An interceptor is a stateless class that follows the interceptor pattern, as\n+ * found in {@link  javax.servlet.Filter} and in AOP languages.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * Interceptors are objects that dynamically intercept Action invocations.\n+ * They provide the developer with the opportunity to define code that can be executed\n+ * before and/or after the execution of an action. They also have the ability\n+ * to prevent an action from executing. Interceptors provide developers a way to\n+ * encapulate common functionality in a re-usable form that can be applied to\n+ * one or more Actions.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * Interceptors <b>must</b> be stateless and not assume that a new instance will be created for each request or Action.\n+ * Interceptors may choose to either short-circuit the {@link ActionInvocation} execution and return a return code\n+ * (such as {@link com.opensymphony.xwork2.Action#SUCCESS}), or it may choose to do some processing before\n+ * and/or after delegating the rest of the procesing using {@link ActionInvocation#invoke()}.\n+ * <p/>\n+ * <!-- END SNIPPET: introduction -->\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <!-- START SNIPPET: parameterOverriding -->\n+ * <p/>\n+ * Interceptor's parameter could be overriden through the following ways :-\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * <b>Method 1:</b>\n+ * <pre>\n+ * &lt;action name=\"myAction\" class=\"myActionClass\"&gt;\n+ *     &lt;interceptor-ref name=\"exception\"/&gt;\n+ *     &lt;interceptor-ref name=\"alias\"/&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"servletConfig\"/&gt;\n+ *     &lt;interceptor-ref name=\"prepare\"/&gt;\n+ *     &lt;interceptor-ref name=\"i18n\"/&gt;\n+ *     &lt;interceptor-ref name=\"chain\"/&gt;\n+ *     &lt;interceptor-ref name=\"modelDriven\"/&gt;\n+ *     &lt;interceptor-ref name=\"fileUpload\"/&gt;\n+ *     &lt;interceptor-ref name=\"staticParams\"/&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;interceptor-ref name=\"conversionError\"/&gt;\n+ *     &lt;interceptor-ref name=\"validation\"&gt;\n+ *     &lt;param name=\"excludeMethods\"&gt;myValidationExcudeMethod&lt;/param&gt;\n+ *     &lt;/interceptor-ref&gt;\n+ *     &lt;interceptor-ref name=\"workflow\"&gt;\n+ *     &lt;param name=\"excludeMethods\"&gt;myWorkflowExcludeMethod&lt;/param&gt;\n+ *     &lt;/interceptor-ref&gt;\n+ * &lt;/action&gt;\n+ * </pre>\n+ * <p/>\n+ * <b>Method 2:</b>\n+ * <pre>\n+ * &lt;action name=\"myAction\" class=\"myActionClass\"&gt;\n+ *   &lt;interceptor-ref name=\"defaultStack\"&gt;\n+ *     &lt;param name=\"validation.excludeMethods\"&gt;myValidationExcludeMethod&lt;/param&gt;\n+ *     &lt;param name=\"workflow.excludeMethods\"&gt;myWorkflowExcludeMethod&lt;/param&gt;\n+ *   &lt;/interceptor-ref&gt;\n+ * &lt;/action&gt;\n+ * </pre>\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * In the first method, the whole default stack is copied and the parameter then\n+ * changed accordingly.\n+ * <p/>\n+ * <p/>\n+ * <p/>\n+ * In the second method, the 'interceptor-ref' refer to an existing\n+ * interceptor-stack, namely defaultStack in this example, and override the validator\n+ * and workflow interceptor excludeMethods typically in this case. Note that in the\n+ * 'param' tag, the name attribute contains a dot (.) the word before the dot(.)\n+ * specifies the interceptor name whose parameter is to be overridden and the word after\n+ * the dot (.) specifies the parameter itself. Essetially it is as follows :-\n+ * <p/>\n+ * <pre>\n+ *    &lt;interceptor-name&gt;.&lt;parameter-name&gt;\n+ * </pre>\n+ * <p/>\n+ * <b>Note</b> also that in this case the 'interceptor-ref' name attribute\n+ * is used to indicate an interceptor stack which makes sense as if it is referring\n+ * to the interceptor itself it would be just using Method 1 describe above.\n+ * <p/>\n+ * <!-- END SNIPPET: parameterOverriding -->\n+ * <p/>\n+ * <p/>\n+ * <b>Nested Interceptor param overriding</b>\n+ * <p/>\n+ * <!-- START SNIPPET: nestedParameterOverriding -->\n+ * <p/>\n+ * Interceptor stack parameter overriding could be nested into as many level as possible, though it would\n+ * be advisable not to nest it too deep as to avoid confusion, For example,\n+ * <pre>\n+ * &lt;interceptor name=\"interceptor1\" class=\"foo.bar.Interceptor1\" /&gt;\n+ * &lt;interceptor name=\"interceptor2\" class=\"foo.bar.Interceptor2\" /&gt;\n+ * &lt;interceptor name=\"interceptor3\" class=\"foo.bar.Interceptor3\" /&gt;\n+ * &lt;interceptor name=\"interceptor4\" class=\"foo.bar.Interceptor4\" /&gt;\n+ * &lt;interceptor-stack name=\"stack1\"&gt;\n+ *     &lt;interceptor-ref name=\"interceptor1\" /&gt;\n+ * &lt;/interceptor-stack&gt;\n+ * &lt;interceptor-stack name=\"stack2\"&gt;\n+ *     &lt;interceptor-ref name=\"intercetor2\" /&gt;\n+ *     &lt;interceptor-ref name=\"stack1\" /&gt;\n+ * &lt;/interceptor-stack&gt;\n+ * &lt;interceptor-stack name=\"stack3\"&gt;\n+ *     &lt;interceptor-ref name=\"interceptor3\" /&gt;\n+ *     &lt;interceptor-ref name=\"stack2\" /&gt;\n+ * &lt;/interceptor-stack&gt;\n+ * &lt;interceptor-stack name=\"stack4\"&gt;\n+ *     &lt;interceptor-ref name=\"interceptor4\" /&gt;\n+ *     &lt;interceptor-ref name=\"stack3\" /&gt;\n+ *  &lt;/interceptor-stack&gt;\n+ * </pre>\n+ * Assuming the interceptor has the following properties\n+ * <table border=\"1\" width=\"100%\">\n+ * <tr>\n+ * <td>Interceptor</td>\n+ * <td>property</td>\n+ * </tr>\n+ * <tr>\n+ * <td>Interceptor1</td>\n+ * <td>param1</td>\n+ * </tr>\n+ * <tr>\n+ * <td>Interceptor2</td>\n+ * <td>param2</td>\n+ * </tr>\n+ * <tr>\n+ * <td>Interceptor3</td>\n+ * <td>param3</td>\n+ * </tr>\n+ * <tr>\n+ * <td>Interceptor4</td>\n+ * <td>param4</td>\n+ * </tr>\n+ * </table>\n+ * We could override them as follows :-\n+ * <pre>\n+ *    &lt;action ... &gt;\n+ *        &lt;!-- to override parameters of interceptor located directly in the stack  --&gt;\n+ *        &lt;interceptor-ref name=\"stack4\"&gt;\n+ *           &lt;param name=\"interceptor4.param4\"&gt; ... &lt;/param&gt;\n+ *        &lt;/interceptor-ref&gt;\n+ *    &lt;/action&gt;\n+ * <p/>\n+ *    &lt;action ... &gt;\n+ *        &lt;!-- to override parameters of interceptor located under nested stack --&gt;\n+ *        &lt;interceptor-ref name=\"stack4\"&gt;\n+ *            &lt;param name=\"stack3.interceptor3.param3\"&gt; ... &lt;/param&gt;\n+ *            &lt;param name=\"stack3.stack2.interceptor2.param2\"&gt; ... &lt;/param&gt;\n+ *            &lt;param name=\"stack3.stack2.stack1.interceptor1.param1\"&gt; ... &lt;/param&gt;\n+ *        &lt;/interceptor-ref&gt;\n+ *    &lt;/action&gt;\n+ *  </pre>\n+ * <p/>\n+ * <!-- END SNIPPET: nestedParameterOverriding -->\n+ *\n+ * @author Jason Carreira\n+ * @author tmjee\n+ * @version $Date$ $Id$\n+ */\n+public interface Interceptor extends Serializable {\n+\n+    /**\n+     * Called to let an interceptor clean up any resources it has allocated.\n+     */\n+    void destroy();\n+\n+    /**\n+     * Called after an interceptor is created, but before any requests are processed using\n+     * {@link #intercept(com.opensymphony.xwork2.ActionInvocation) intercept} , giving\n+     * the Interceptor a chance to initialize any needed resources.\n+     */\n+    void init();\n+\n+    /**\n+     * Allows the Interceptor to do some processing on the request before and/or after the rest of the processing of the\n+     * request by the {@link ActionInvocation} or to short-circuit the processing and just return a String return code.\n+     *\n+     * @param invocation the action invocation\n+     * @return the return code, either returned from {@link ActionInvocation#invoke()}, or from the interceptor itself.\n+     * @throws Exception any system-level error, as defined in {@link com.opensymphony.xwork2.Action#execute()}.\n+     */\n+    String intercept(ActionInvocation invocation) throws Exception;\n+\n+}"
        },
        {
            "sha": "d7195699094bbeea0b906a119cae8d6adf60a7b3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/LoggingInterceptor.java",
            "status": "added",
            "additions": 86,
            "deletions": 0,
            "changes": 86,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FLoggingInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FLoggingInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FLoggingInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,86 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * This interceptor logs the start and end of the execution an action (in English-only, not internationalized).\n+ * <br/>\n+ * <b>Note:</b>: This interceptor will log at <tt>INFO</tt> level.\n+ * <p/>\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ * There are no parameters for this interceptor.\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ * There are no obvious extensions to the existing interceptor.\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;!-- prints out a message before and after the immediate action execution --&gt;\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"completeStack\"/&gt;\n+ *     &lt;interceptor-ref name=\"logger\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ *\n+ * &lt;!-- prints out a message before any more interceptors continue and after they have finished --&gt;\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"logger\"/&gt;\n+ *     &lt;interceptor-ref name=\"completeStack\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Jason Carreira\n+ */\n+public class LoggingInterceptor extends AbstractInterceptor {\n+    private static final Logger LOG = LoggerFactory.getLogger(LoggingInterceptor.class);\n+    private static final String FINISH_MESSAGE = \"Finishing execution stack for action \";\n+    private static final String START_MESSAGE = \"Starting execution stack for action \";\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        logMessage(invocation, START_MESSAGE);\n+        String result = invocation.invoke();\n+        logMessage(invocation, FINISH_MESSAGE);\n+        return result;\n+    }\n+\n+    private void logMessage(ActionInvocation invocation, String baseMessage) {\n+        if (LOG.isInfoEnabled()) {\n+            StringBuilder message = new StringBuilder(baseMessage);\n+            String namespace = invocation.getProxy().getNamespace();\n+\n+            if ((namespace != null) && (namespace.trim().length() > 0)) {\n+                message.append(namespace).append(\"/\");\n+            }\n+\n+            message.append(invocation.getProxy().getActionName());\n+            LOG.info(message.toString());\n+        }\n+    }\n+\n+}"
        },
        {
            "sha": "fd44df86afa0196e4ccab42f78dfbdaa66cf61eb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/MethodFilterInterceptor.java",
            "status": "added",
            "additions": 124,
            "deletions": 0,
            "changes": 124,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,124 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.Set;\n+\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ * \n+ * MethodFilterInterceptor is an abstract <code>Interceptor</code> used as\n+ * a base class for interceptors that will filter execution based on method \n+ * names according to specified included/excluded method lists.\n+ * \n+ * <p/>\n+ * \n+ * Settable parameters are as follows:\n+ * \n+ * <ul>\n+ * \t\t<li>excludeMethods - method names to be excluded from interceptor processing</li>\n+ * \t\t<li>includeMethods - method names to be included in interceptor processing</li>\n+ * </ul>\n+ * \n+ * <p/>\n+ * \n+ * <b>NOTE:</b> If method name are available in both includeMethods and \n+ * excludeMethods, it will be considered as an included method: \n+ * includeMethods takes precedence over excludeMethods.\n+ * \n+ * <p/>\n+ * \n+ * Interceptors that extends this capability include:\n+ * \n+ * <ul>\n+ *    <li>TokenInterceptor</li>\n+ *    <li>TokenSessionStoreInterceptor</li>\n+ *    <li>DefaultWorkflowInterceptor</li>\n+ *    <li>ValidationInterceptor</li>\n+ * </ul>\n+ * \n+ * <!-- END SNIPPET: javadoc -->\n+ * \n+ * @author <a href='mailto:the_mindstorm[at]evolva[dot]ro'>Alexandru Popescu</a>\n+ * @author Rainer Hermanns\n+ * \n+ * @see org.apache.struts2.interceptor.TokenInterceptor\n+ * @see org.apache.struts2.interceptor.TokenSessionStoreInterceptor\n+ * @see com.opensymphony.xwork2.interceptor.DefaultWorkflowInterceptor\n+ * @see com.opensymphony.xwork2.validator.ValidationInterceptor\n+ * \n+ * @version $Date$ $Id$\n+ */\n+public abstract class MethodFilterInterceptor extends AbstractInterceptor {\n+    protected transient Logger log = LoggerFactory.getLogger(getClass());\n+    \n+    protected Set<String> excludeMethods = Collections.emptySet();\n+    protected Set<String> includeMethods = Collections.emptySet();\n+\n+    public void setExcludeMethods(String excludeMethods) {\n+        this.excludeMethods = TextParseUtil.commaDelimitedStringToSet(excludeMethods);\n+    }\n+    \n+    public Set<String> getExcludeMethodsSet() {\n+    \treturn excludeMethods;\n+    }\n+\n+    public void setIncludeMethods(String includeMethods) {\n+        this.includeMethods = TextParseUtil.commaDelimitedStringToSet(includeMethods);\n+    }\n+    \n+    public Set<String> getIncludeMethodsSet() {\n+    \treturn includeMethods;\n+    }\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        if (applyInterceptor(invocation)) {\n+            return doIntercept(invocation);\n+        } \n+        return invocation.invoke();\n+    }\n+\n+    protected boolean applyInterceptor(ActionInvocation invocation) {\n+        String method = invocation.getProxy().getMethod();\n+        // ValidationInterceptor\n+        boolean applyMethod = MethodFilterInterceptorUtil.applyMethod(excludeMethods, includeMethods, method);\n+        if (log.isDebugEnabled()) {\n+        \tif (!applyMethod) {\n+        \t\tlog.debug(\"Skipping Interceptor... Method [\" + method + \"] found in exclude list.\");\n+        \t}\n+        }\n+        return applyMethod;\n+    }\n+    \n+    /**\n+     * Subclasses must override to implement the interceptor logic.\n+     * \n+     * @param invocation the action invocation\n+     * @return the result of invocation\n+     * @throws Exception\n+     */\n+    protected abstract String doIntercept(ActionInvocation invocation) throws Exception;\n+    \n+}"
        },
        {
            "sha": "c9d0c927be4b6ce64dc41d069e8ed394d3e05518",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/MethodFilterInterceptorUtil.java",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptorUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptorUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FMethodFilterInterceptorUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.WildcardHelper;\n+\n+import java.util.HashMap;\n+import java.util.Iterator;\n+import java.util.Set;\n+\n+/**\n+ * Utility class contains common methods used by \n+ * {@link com.opensymphony.xwork2.interceptor.MethodFilterInterceptor}.\n+ * \n+ * @author tm_jee\n+ */\n+public class MethodFilterInterceptorUtil {\n+\n+\t/**\n+     * Static method to decide if the specified <code>method</code> should be\n+     * apply (not filtered) depending on the set of <code>excludeMethods</code> and \n+     * <code>includeMethods</code>. \n+     *\n+     * <ul>\n+     * <li>\n+     * \t<code>includeMethods</code> takes precedence over <code>excludeMethods</code>\n+     * </li>\n+     * </ul>\n+     * <b>Note:</b> Supports wildcard listings in includeMethods/excludeMethods\n+     *\n+     * @param excludeMethods  list of methods to exclude.\n+     * @param includeMethods  list of methods to include.\n+     * @param method the specified method to check\n+     * @return <tt>true</tt> if the method should be applied.\n+     */\n+    public static boolean applyMethod(Set<String> excludeMethods, Set<String> includeMethods, String method) {\n+        \n+        // quick check to see if any actual pattern matching is needed\n+        boolean needsPatternMatch = false;\n+        Iterator quickIter = includeMethods.iterator();\n+        for (String incMeth : includeMethods) {\n+            if (!\"*\".equals(incMeth) && incMeth.contains(\"*\")) {\n+                needsPatternMatch = true;\n+            }\n+        }\n+        \n+        for (String incMeth : excludeMethods) {\n+            if (!\"*\".equals(incMeth) && incMeth.contains(\"*\")) {\n+                needsPatternMatch = true;\n+            }\n+        }\n+\n+        // this section will try to honor the original logic, while \n+        // still allowing for wildcards later\n+        if (!needsPatternMatch && (includeMethods.contains(\"*\") || includeMethods.size() == 0) ) {\n+            if (excludeMethods != null \n+                    && excludeMethods.contains(method) \n+                    && !includeMethods.contains(method) ) {\n+                return false;\n+            }\n+        }\n+        \n+        // test the methods using pattern matching\n+        WildcardHelper wildcard = new WildcardHelper();\n+        String methodCopy ;\n+        if (method == null ) { // no method specified\n+            methodCopy = \"\";\n+        }\n+        else {\n+            methodCopy = new String(method);\n+        }\n+        for (String pattern : includeMethods) {\n+            if (pattern.contains(\"*\")) {\n+                int[] compiledPattern = wildcard.compilePattern(pattern);\n+                HashMap<String,String> matchedPatterns = new HashMap<String, String>();\n+                boolean matches = wildcard.match(matchedPatterns, methodCopy, compiledPattern);\n+                if (matches) {\n+                    return true; // run it, includeMethods takes precedence\n+                }\n+            }\n+            else {\n+                if (pattern.equals(methodCopy)) {\n+                    return true; // run it, includeMethods takes precedence\n+                }\n+            }\n+        }\n+        if (excludeMethods.contains(\"*\") ) {\n+            return false;\n+        }\n+\n+        // CHECK ME: Previous implementation used include method \n+        for ( String pattern : excludeMethods) {\n+            if (pattern.contains(\"*\")) {\n+                int[] compiledPattern = wildcard.compilePattern(pattern);\n+                HashMap<String,String> matchedPatterns = new HashMap<String, String>();\n+                boolean matches = wildcard.match(matchedPatterns, methodCopy, compiledPattern);\n+                if (matches) {\n+                    // if found, and wasn't included earlier, don't run it\n+                    return false; \n+                }\n+            }\n+            else {\n+                if (pattern.equals(methodCopy)) {\n+                    // if found, and wasn't included earlier, don't run it\n+                    return false; \n+                }\n+            }\n+        }\n+    \n+\n+        // default fall-back from before changes\n+        return includeMethods.size() == 0 || includeMethods.contains(method) || includeMethods.contains(\"*\");\n+    }\n+    \n+    /**\n+     * Same as {@link #applyMethod(Set, Set, String)}, except that <code>excludeMethods</code>\n+     * and <code>includeMethods</code> are supplied as comma separated string.\n+     * \n+     * @param excludeMethods  comma seperated string of methods to exclude.\n+     * @param includeMethods  comma seperated string of methods to include.\n+     * @param method the specified method to check\n+     * @return <tt>true</tt> if the method should be applied.\n+     */\n+    public static boolean applyMethod(String excludeMethods, String includeMethods, String method) {\n+    \tSet<String> includeMethodsSet = TextParseUtil.commaDelimitedStringToSet(includeMethods == null? \"\" : includeMethods);\n+    \tSet<String> excludeMethodsSet = TextParseUtil.commaDelimitedStringToSet(excludeMethods == null? \"\" : excludeMethods);\n+    \t\n+    \treturn applyMethod(excludeMethodsSet, includeMethodsSet, method);\n+    }\n+\n+}"
        },
        {
            "sha": "f145534b53d2318081a81d2bae6dcd1b697384fb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ModelDrivenInterceptor.java",
            "status": "added",
            "additions": 143,
            "deletions": 0,
            "changes": 143,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FModelDrivenInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FModelDrivenInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FModelDrivenInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,143 @@\n+/*\n+ * Copyright 2002-2006,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.ModelDriven;\n+import com.opensymphony.xwork2.util.CompoundRoot;\n+import com.opensymphony.xwork2.util.ValueStack;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ *\n+ * Watches for {@link ModelDriven} actions and adds the action's model on to the value stack.\n+ *\n+ * <p/> <b>Note:</b>  The ModelDrivenInterceptor must come before the both {@link StaticParametersInterceptor} and\n+ * {@link ParametersInterceptor} if you want the parameters to be applied to the model.\n+ * \n+ * <p/> <b>Note:</b>  The ModelDrivenInterceptor will only push the model into the stack when the\n+ * model is not null, else it will be ignored.\n+ *\n+ * <!-- END SNIPPET: description -->\n+ *\n+ * <p/> <u>Interceptor parameters:</u>\n+ *\n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ *\n+ * <li>refreshModelBeforeResult - set to true if you want the model to be refreshed on the value stack after action\n+ * execution and before result execution.  The setting is useful if you want to change the model instance during the\n+ * action execution phase, like when loading it from the data layer.  This will result in getModel() being called at\n+ * least twice.</li>\n+ *\n+ * </ul>\n+ *\n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <p/> <u>Extending the interceptor:</u>\n+ *\n+ * <p/>\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ *\n+ * There are no known extension points to this interceptor.\n+ *\n+ * <!-- END SNIPPET: extending -->\n+ *\n+ * <p/> <u>Example code:</u>\n+ *\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"modelDriven\"/&gt;\n+ *     &lt;interceptor-ref name=\"basicStack\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ * \n+ * @author tm_jee\n+ * @version $Date$ $Id$\n+ */\n+public class ModelDrivenInterceptor extends AbstractInterceptor {\n+\n+    protected boolean refreshModelBeforeResult = false;\n+\n+    public void setRefreshModelBeforeResult(boolean val) {\n+        this.refreshModelBeforeResult = val;\n+    }\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+        Object action = invocation.getAction();\n+\n+        if (action instanceof ModelDriven) {\n+            ModelDriven modelDriven = (ModelDriven) action;\n+            ValueStack stack = invocation.getStack();\n+            Object model = modelDriven.getModel();\n+            if (model !=  null) {\n+            \tstack.push(model);\n+            }\n+            if (refreshModelBeforeResult) {\n+                invocation.addPreResultListener(new RefreshModelBeforeResult(modelDriven, model));\n+            }\n+        }\n+        return invocation.invoke();\n+    }\n+\n+    /**\n+     * Refreshes the model instance on the value stack, if it has changed\n+     */\n+    protected static class RefreshModelBeforeResult implements PreResultListener {\n+        private Object originalModel = null;\n+        protected ModelDriven action;\n+\n+\n+        public RefreshModelBeforeResult(ModelDriven action, Object model) {\n+            this.originalModel = model;\n+            this.action = action;\n+        }\n+\n+        public void beforeResult(ActionInvocation invocation, String resultCode) {\n+            ValueStack stack = invocation.getStack();\n+            CompoundRoot root = stack.getRoot();\n+\n+            boolean needsRefresh = true;\n+            Object newModel = action.getModel();\n+\n+            // Check to see if the new model instance is already on the stack\n+            for (Object item : root) {\n+                if (item.equals(newModel)) {\n+                    needsRefresh = false;\n+                }\n+            }\n+\n+            // Add the new model on the stack\n+            if (needsRefresh) {\n+\n+                // Clear off the old model instance\n+                if (originalModel != null) {\n+                    root.remove(originalModel);\n+                }\n+                if (newModel != null) {\n+                    stack.push(newModel);\n+                }\n+            }\n+        }\n+    }\n+}"
        },
        {
            "sha": "8db8fbce76f093693072f3c4b3d2317816c0469d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/NoParameters.java",
            "status": "added",
            "additions": 32,
            "deletions": 0,
            "changes": 32,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FNoParameters.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FNoParameters.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FNoParameters.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,32 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+\n+/**\n+ * Marker interface to incidate no auto setting of parameters.\n+ * <p/>\n+ * This marker interface should be implemented by actions that do not want any\n+ * request parameters set on them automatically (by the ParametersInterceptor).\n+ * This may be useful if one is using the action tag and want to supply\n+ * the parameters to the action manually using the param tag.\n+ * It may also be useful if one for security reasons wants to make sure that\n+ * parameters cannot be set by malicious users.\n+ *\n+ * @author Dick Zetterberg (dick@transitor.se)\n+ */\n+public interface NoParameters {\n+}"
        },
        {
            "sha": "89a6f479681737656d85f0c26ea450f71700858a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ParameterFilterInterceptor.java",
            "status": "added",
            "additions": 247,
            "deletions": 0,
            "changes": 247,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterFilterInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterFilterInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterFilterInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,247 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Collection;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.TreeMap;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ *\n+ * The Parameter Filter Interceptor blocks parameters from getting\n+ * to the rest of the stack or your action. You can use multiple \n+ * parameter filter interceptors for a given action, so, for example,\n+ * you could use one in your default stack that filtered parameters\n+ * you wanted blocked from every action and those you wanted blocked \n+ * from an individual action you could add an additional interceptor\n+ * for each action.\n+ * \n+ * <!-- END SNIPPET: description -->\n+ * \n+ * <!-- START SNIPPET: parameters -->\n+ *\n+ * <ul>\n+ * <li>allowed - a comma delimited list of parameter prefixes\n+ *  that are allowed to pass to the action</li>\n+ * <li>blocked - a comma delimited list of parameter prefixes \n+ * that are not allowed to pass to the action</li>\n+ * <li>defaultBlock - boolean (default to false) whether by\n+ * default a given parameter is blocked. If true, then a parameter\n+ * must have a prefix in the allowed list in order to be able \n+ * to pass to the action\n+ * </ul>\n+ * \n+ * <p>The way parameters are filtered for the least configuration is that\n+ * if a string is in the allowed or blocked lists, then any parameter\n+ * that is a member of the object represented by the parameter is allowed\n+ * or blocked respectively.</p>\n+ * \n+ * <p>For example, if the parameters are:\n+ * <ul>\n+ * <li>blocked: person,person.address.createDate,personDao</li>\n+ * <li>allowed: person.address</li>\n+ * <li>defaultBlock: false</li>\n+ * </ul>\n+ * <br>\n+ * The parameters person.name, person.phoneNum etc would be blocked \n+ * because 'person' is in the blocked list. However, person.address.street\n+ * and person.address.city would be allowed because person.address is\n+ * in the allowed list (the longer string determines permissions).</p> \n+ * <!-- END SNIPPET: parameters -->\n+ *\n+ * <!-- START SNIPPET: extending -->\n+ * There are no known extension points to this interceptor.\n+ * <!-- END SNIPPET: extending -->\n+ * \n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;interceptors&gt;\n+ *   ...\n+ *   &lt;interceptor name=\"parameterFilter\" class=\"com.opensymphony.xwork2.interceptor.ParameterFilterInterceptor\"/&gt;\n+ *   ...\n+ * &lt;/interceptors&gt;\n+ * \n+ * &lt;action ....&gt;\n+ *   ...\n+ *   &lt;interceptor-ref name=\"parameterFilter\"&gt;\n+ *     &lt;param name=\"blocked\"&gt;person,person.address.createDate,personDao&lt;/param&gt;\n+ *   &lt;/interceptor-ref&gt;\n+ *   ...\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ * \n+ * @author Gabe\n+ */\n+public class ParameterFilterInterceptor extends AbstractInterceptor {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ParameterFilterInterceptor.class);\n+\n+    private Collection<String> allowed;\n+    private Collection<String> blocked;\n+    private Map<String, Boolean> includesExcludesMap;\n+    private boolean defaultBlock = false;\n+\n+    @Override\n+    public String intercept(ActionInvocation invocation) throws Exception {\n+\n+        Map<String, Object> parameters = invocation.getInvocationContext().getParameters();\n+        HashSet<String> paramsToRemove = new HashSet<String>();\n+\n+        Map<String, Boolean> includesExcludesMap = getIncludesExcludesMap();\n+\n+        for (Object o : parameters.keySet()) {\n+            String param = o.toString();\n+\n+            boolean currentAllowed = !isDefaultBlock();\n+\n+            boolean foundApplicableRule = false;\n+            for (Object o1 : includesExcludesMap.keySet()) {\n+                String currRule = (String) o1;\n+\n+                if (param.startsWith(currRule)\n+                        && (param.length() == currRule.length()\n+                        || isPropSeperator(param.charAt(currRule.length())))) {\n+                    currentAllowed = includesExcludesMap.get(currRule).booleanValue();\n+                } else {\n+                    if (foundApplicableRule) {\n+                        foundApplicableRule = false;\n+                        break;\n+                    }\n+                }\n+            }\n+            if (!currentAllowed) {\n+                paramsToRemove.add(param);\n+            }\n+        }\n+\n+        if (LOG.isDebugEnabled()) {\n+            LOG.debug(\"Params to remove: \" + paramsToRemove);\n+        }\n+\n+        for (Object aParamsToRemove : paramsToRemove) {\n+            parameters.remove(aParamsToRemove);\n+        }\n+\n+        return invocation.invoke();\n+    }\n+\n+    /**\n+     * Tests if the given char is a property seperator char <code>.([</code>.\n+     *\n+     * @param c the char\n+     * @return <tt>true</tt>, if char is property separator, <tt>false</tt> otherwise.\n+     */\n+    private static boolean isPropSeperator(char c) {\n+        return c == '.' || c == '(' || c == '[';\n+    }\n+\n+    private Map<String, Boolean> getIncludesExcludesMap() {\n+        if (this.includesExcludesMap == null) {\n+            this.includesExcludesMap = new TreeMap<String, Boolean>();\n+\n+            if (getAllowedCollection() != null) {\n+                for (String e : getAllowedCollection()) {\n+                    this.includesExcludesMap.put(e, Boolean.TRUE);\n+                }\n+            }\n+            if (getBlockedCollection() != null) {\n+                for (String b : getBlockedCollection()) {\n+                    this.includesExcludesMap.put(b, Boolean.FALSE);\n+                }\n+            }\n+        }\n+\n+        return this.includesExcludesMap;\n+    }\n+\n+    /**\n+     * @return Returns the defaultBlock.\n+     */\n+    public boolean isDefaultBlock() {\n+        return defaultBlock;\n+    }\n+\n+    /**\n+     * @param defaultExclude The defaultExclude to set.\n+     */\n+    public void setDefaultBlock(boolean defaultExclude) {\n+        this.defaultBlock = defaultExclude;\n+    }\n+\n+    /**\n+     * @return Returns the blocked.\n+     */\n+    public Collection<String> getBlockedCollection() {\n+        return blocked;\n+    }\n+\n+    /**\n+     * @param blocked The blocked to set.\n+     */\n+    public void setBlockedCollection(Collection<String> blocked) {\n+        this.blocked = blocked;\n+    }\n+\n+    /**\n+     * @param blocked The blocked paramters as comma separated String.\n+     */\n+    public void setBlocked(String blocked) {\n+        setBlockedCollection(asCollection(blocked));\n+    }\n+\n+    /**\n+     * @return Returns the allowed.\n+     */\n+    public Collection<String> getAllowedCollection() {\n+        return allowed;\n+    }\n+\n+    /**\n+     * @param allowed The allowed to set.\n+     */\n+    public void setAllowedCollection(Collection<String> allowed) {\n+        this.allowed = allowed;\n+    }\n+\n+    /**\n+     * @param allowed The allowed paramters as comma separated String.\n+     */\n+    public void setAllowed(String allowed) {\n+        setAllowedCollection(asCollection(allowed));\n+    }\n+\n+    /**\n+     * Return a collection from the comma delimited String.\n+     *\n+     * @param commaDelim the comma delimited String.\n+     * @return A collection from the comma delimited String. Returns <tt>null</tt> if the string is empty.\n+     */\n+    private Collection<String> asCollection(String commaDelim) {\n+        if (commaDelim == null || commaDelim.trim().length() == 0) {\n+            return null;\n+        }\n+        return TextParseUtil.commaDelimitedStringToSet(commaDelim);\n+    }\n+\n+}"
        },
        {
            "sha": "292dbeb830cc167e3aeffaef65f38270e0f4cdc3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ParameterNameAware.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterNameAware.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterNameAware.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterNameAware.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,40 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+/**\n+ * <!-- START SNIPPET: javadoc -->\n+ *\n+ * This interface is implemented by actions that want to declare acceptable parameters. Works in conjunction with {@link\n+ * ParametersInterceptor}. For example, actions may want to create a whitelist of parameters they will accept or a\n+ * blacklist of paramters they will reject to prevent clients from setting other unexpected (and possibly dangerous)\n+ * parameters.\n+ *\n+ * <!-- END SNIPPET: javadoc -->\n+ *\n+ * @author Bob Lee (crazybob@google.com)\n+ */\n+public interface ParameterNameAware {\n+\n+    /**\n+     * Tests if the the action will accept the parameter with the given name.\n+     *\n+     * @param parameterName  the parameter name\n+     * @return <tt> if accepted, <tt>false</tt> otherwise\n+     */\n+    boolean acceptableParameterName(String parameterName);\n+    \n+}"
        },
        {
            "sha": "dafec0ef1f75afb7406f5b205ca6e1eff02672f1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ParameterRemoverInterceptor.java",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterRemoverInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterRemoverInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParameterRemoverInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,145 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+\n+import java.util.Collections;\n+import java.util.Map;\n+import java.util.Set;\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * This is a simple XWork interceptor that allows parameters (matching\n+ * one of the paramNames attribute csv value) to be \n+ * removed from the parameter map if they match a certain value\n+ * (matching one of the paramValues attribute csv value), before they \n+ * are set on the action. A typical usage would be to want a dropdown/select \n+ * to map onto a boolean value on an action. The select had the options \n+ * none, yes and no with values -1, true and false. The true and false would \n+ * map across correctly. However the -1 would be set to false. \n+ * This was not desired as one might needed the value on the action to stay null. \n+ * This interceptor fixes this by preventing the parameter from ever reaching \n+ * the action.\n+ * <!-- END SNIPPET: description -->\n+ * \n+ * \n+ * <!-- START SNIPPET: parameters -->\n+ * <ul>\n+ * \t<li>paramNames - A comma separated value (csv) indicating the parameter name \n+ * \t\t\t\t\t\t\t\t    whose param value should be considered that if they match any of the\n+ *                                     comma separated value (csv) from paramValues attribute, shall be \n+ *                                     removed from the parameter map such that they will not be applied\n+ *                                     to the action</li>\n+ * \t<li>paramValues - A comma separated value (csv) indicating the parameter value that if \n+ * \t\t\t\t\t\t\t      matched shall have its parameter be removed from the parameter map \n+ * \t\t\t\t\t\t\t      such that they will not be applied to the action</li>\n+ * </ul>\n+ * <!-- END SNIPPET: parameters -->\n+ * \n+ * \n+ * <!-- START SNIPPET: extending -->\n+ * No intended extension point\n+ * <!-- END SNIPPET: extending -->\n+ * \n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ *\t\n+ * &lt;action name=\"sample\" class=\"org.martingilday.Sample\"&gt;\n+ * \t&lt;interceptor-ref name=\"paramRemover\"&gt;\n+ *   \t\t&lt;param name=\"paramNames\"&gt;aParam,anotherParam&lt;/param&gt;\n+ *   \t\t&lt;param name=\"paramValues\"&gt;--,-1&lt;/param&gt;\n+ * \t&lt;/interceptor-ref&gt;\n+ * \t&lt;interceptor-ref name=\"defaultStack\" /&gt;\n+ * \t...\n+ * &lt;/action&gt;\n+ *  \n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *  \n+ *  \n+ * @author martin.gilday\n+ */\n+public class ParameterRemoverInterceptor extends AbstractInterceptor {\n+\n+\tprivate static final Logger LOG = LoggerFactory.getLogger(ParameterRemoverInterceptor.class);\n+\n+\tprivate static final long serialVersionUID = 1;\n+\n+\tprivate Set<String> paramNames = Collections.emptySet();\n+\n+\tprivate Set<String> paramValues = Collections.emptySet();\n+\n+\t\n+\t/**\n+\t * Decide if the parameter should be removed from the parameter map based on\n+\t * <code>paramNames</code> and <code>paramValues</code>.\n+\t * \n+\t * @see com.opensymphony.xwork2.interceptor.AbstractInterceptor\n+\t */\n+\t@Override\n+\tpublic String intercept(ActionInvocation invocation) throws Exception {\n+\t\tif (!(invocation.getAction() instanceof NoParameters)\n+\t\t\t\t&& (null != this.paramNames)) {\n+\t\t\tActionContext ac = invocation.getInvocationContext();\n+\t\t\tfinal Map<String, Object> parameters = ac.getParameters();\n+\n+\t\t\tif (parameters != null) {\n+                for (String removeName : paramNames) {\n+                    // see if the field is in the parameter map\n+                    if (parameters.containsKey(removeName)) {\n+\n+                        try {\n+                            String[] values = (String[]) parameters\n+                                    .get(removeName);\n+                            String value = values[0];\n+                            if (null != value && this.paramValues.contains(value)) {\n+                                parameters.remove(removeName);\n+                            }\n+                        } catch (Exception e) {\n+                            LOG.error(\"Failed to convert parameter to string\", e);\n+                        }\n+                    }\n+                }\n+\t\t\t}\n+\t\t}\n+\t\treturn invocation.invoke();\n+\t}\n+\n+\t/**\n+\t * Allows <code>paramNames</code> attribute to be set as comma-separated-values (csv).\n+\t * \n+\t * @param paramNames the paramNames to set\n+\t */\n+\tpublic void setParamNames(String paramNames) {\n+\t\tthis.paramNames = TextParseUtil.commaDelimitedStringToSet(paramNames);\n+\t}\n+\n+\n+\t/**\n+\t * Allows <code>paramValues</code> attribute to be set as a comma-separated-values (csv).\n+\t * \n+\t * @param paramValues the paramValues to set\n+\t */\n+\tpublic void setParamValues(String paramValues) {\n+\t\tthis.paramValues = TextParseUtil.commaDelimitedStringToSet(paramValues);\n+\t}\n+}\n+"
        },
        {
            "sha": "bce32dbb2dc68813b7fc7fec2b3c7e5b3642f3c4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ParametersInterceptor.java",
            "status": "added",
            "additions": 436,
            "deletions": 0,
            "changes": 436,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParametersInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParametersInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FParametersInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,436 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.HashSet;\n+import java.util.Map;\n+import java.util.Set;\n+import java.util.TreeMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.opensymphony.xwork2.ActionContext;\n+import com.opensymphony.xwork2.ActionInvocation;\n+import com.opensymphony.xwork2.ValidationAware;\n+import com.opensymphony.xwork2.conversion.impl.InstantiatingNullHandler;\n+import com.opensymphony.xwork2.conversion.impl.XWorkConverter;\n+import com.opensymphony.xwork2.inject.Inject;\n+import com.opensymphony.xwork2.util.ClearableValueStack;\n+import com.opensymphony.xwork2.util.LocalizedTextUtil;\n+import com.opensymphony.xwork2.util.MemberAccessValueStack;\n+import com.opensymphony.xwork2.util.TextParseUtil;\n+import com.opensymphony.xwork2.util.ValueStack;\n+import com.opensymphony.xwork2.util.ValueStackFactory;\n+import com.opensymphony.xwork2.util.logging.Logger;\n+import com.opensymphony.xwork2.util.logging.LoggerFactory;\n+import com.opensymphony.xwork2.util.reflection.ReflectionContextState;\n+\n+\n+/**\n+ * <!-- START SNIPPET: description -->\n+ * This interceptor sets all parameters on the value stack.\n+ * <p/>\n+ * This interceptor gets all parameters from {@link ActionContext#getParameters()} and sets them on the value stack by\n+ * calling {@link ValueStack#setValue(String, Object)}, typically resulting in the values submitted in a form\n+ * request being applied to an action in the value stack. Note that the parameter map must contain a String key and\n+ * often containers a String[] for the value.\n+ * <p/>\n+ * <p/> The interceptor takes one parameter named 'ordered'. When set to true action properties are guaranteed to be\n+ * set top-down which means that top action's properties are set first. Then it's subcomponents properties are set.\n+ * The reason for this order is to enable a 'factory' pattern. For example, let's assume that one has an action\n+ * that contains a property named 'modelClass' that allows to choose what is the underlying implementation of model.\n+ * By assuring that modelClass property is set before any model properties are set, it's possible to choose model\n+ * implementation during action.setModelClass() call. Similiarily it's possible to use action.setPrimaryKey()\n+ * property set call to actually load the model class from persistent storage. Without any assumption on parameter\n+ * order you have to use patterns like 'Preparable'.\n+ * <p/>\n+ * <p/> Because parameter names are effectively OGNL statements, it is important that security be taken in to account.\n+ * This interceptor will not apply any values in the parameters map if the expression contains an assignment (=),\n+ * multiple expressions (,), or references any objects in the context (#). This is all done in the {@link\n+ * #acceptableName(String)} method. In addition to this method, if the action being invoked implements the {@link\n+ * ParameterNameAware} interface, the action will be consulted to determine if the parameter should be set.\n+ * <p/>\n+ * <p/> In addition to these restrictions, a flag ({@link ReflectionContextState#DENY_METHOD_EXECUTION}) is set such that\n+ * no methods are allowed to be invoked. That means that any expression such as <i>person.doSomething()</i> or\n+ * <i>person.getName()</i> will be explicitely forbidden. This is needed to make sure that your application is not\n+ * exposed to attacks by malicious users.\n+ * <p/>\n+ * <p/> While this interceptor is being invoked, a flag ({@link ReflectionContextState#CREATE_NULL_OBJECTS}) is turned\n+ * on to ensure that any null reference is automatically created - if possible. See the type conversion documentation\n+ * and the {@link InstantiatingNullHandler} javadocs for more information.\n+ * <p/>\n+ * <p/> Finally, a third flag ({@link XWorkConverter#REPORT_CONVERSION_ERRORS}) is set that indicates any errors when\n+ * converting the the values to their final data type (String[] -&gt; int) an unrecoverable error occured. With this\n+ * flag set, the type conversion errors will be reported in the action context. See the type conversion documentation\n+ * and the {@link XWorkConverter} javadocs for more information.\n+ * <p/>\n+ * <p/> If you are looking for detailed logging information about your parameters, turn on DEBUG level logging for this\n+ * interceptor. A detailed log of all the parameter keys and values will be reported.\n+ * <p/>\n+ * <p/>\n+ * <b>Note:</b> Since XWork 2.0.2, this interceptor extends {@link MethodFilterInterceptor}, therefore being\n+ * able to deal with excludeMethods / includeMethods parameters. See [Workflow Interceptor]\n+ * (class {@link DefaultWorkflowInterceptor}) for documentation and examples on how to use this feature.\n+ * <p/>\n+ * <!-- END SNIPPET: description -->\n+ * <p/>\n+ * <p/> <u>Interceptor parameters:</u>\n+ * <p/>\n+ * <!-- START SNIPPET: parameters -->\n+ * <p/>\n+ * <ul>\n+ * <p/>\n+ * <li>ordered - set to true if you want the top-down property setter behaviour</li>\n+ * <p/>\n+ * </ul>\n+ * <p/>\n+ * <!-- END SNIPPET: parameters -->\n+ * <p/>\n+ * <p/> <u>Extending the interceptor:</u>\n+ * <p/>\n+ * <!-- START SNIPPET: extending -->\n+ * <p/>\n+ * <p/> The best way to add behavior to this interceptor is to utilize the {@link ParameterNameAware} interface in your\n+ * actions. However, if you wish to apply a global rule that isn't implemented in your action, then you could extend\n+ * this interceptor and override the {@link #acceptableName(String)} method.\n+ * <p/>\n+ * <!-- END SNIPPET: extending -->\n+ * <p/>\n+ * <p/> <u>Example code:</u>\n+ * <p/>\n+ * <pre>\n+ * <!-- START SNIPPET: example -->\n+ * &lt;action name=\"someAction\" class=\"com.examples.SomeAction\"&gt;\n+ *     &lt;interceptor-ref name=\"params\"/&gt;\n+ *     &lt;result name=\"success\"&gt;good_result.ftl&lt;/result&gt;\n+ * &lt;/action&gt;\n+ * <!-- END SNIPPET: example -->\n+ * </pre>\n+ *\n+ * @author Patrick Lightbody\n+ */\n+public class ParametersInterceptor extends MethodFilterInterceptor {\n+\n+    private static final Logger LOG = LoggerFactory.getLogger(ParametersInterceptor.class);\n+\n+    boolean ordered = false;\n+    Set<Pattern> excludeParams = Collections.emptySet();\n+    Set<Pattern> acceptParams = Collections.emptySet();\n+    static boolean devMode = false;\n+\n+    private String acceptedParamNames = \"[[\\\\p{Graph}\\\\s]&&[^,#:=]]*\";\n+    private Pattern acceptedPattern = Pattern.compile(acceptedParamNames);\n+\n+    private ValueStackFactory valueStackFactory;\n+\n+    @Inject\n+    public void setValueStackFactory(ValueStackFactory valueStackFactory) {\n+        this.valueStackFactory = valueStackFactory;\n+    }\n+\n+    @Inject(\"devMode\")\n+    public static void setDevMode(String mode) {\n+        devMode = \"true\".equals(mode);\n+    }\n+\n+    public void setAcceptParamNames(String commaDelim) {\n+        Collection<String> acceptPatterns = asCollection(commaDelim);\n+        if (acceptPatterns != null) {\n+            acceptParams = new HashSet<Pattern>();\n+            for (String pattern : acceptPatterns) {\n+                acceptParams.add(Pattern.compile(pattern));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Compares based on number of '.' characters (fewer is higher)\n+     */\n+    static final Comparator<String> rbCollator = new Comparator<String>() {\n+        public int compare(String s1, String s2) {\n+            int l1 = 0, l2 = 0;\n+            for (int i = s1.length() - 1; i >= 0; i--) {\n+                if (s1.charAt(i) == '.') l1++;\n+            }\n+            for (int i = s2.length() - 1; i >= 0; i--) {\n+                if (s2.charAt(i) == '.') l2++;\n+            }\n+            return l1 < l2 ? -1 : (l2 < l1 ? 1 : s1.compareTo(s2));\n+        }\n+\n+    };\n+\n+    @Override\n+    public String doIntercept(ActionInvocation invocation) throws Exception {\n+        Object action = invocation.getAction();\n+        if (!(action instanceof NoParameters)) {\n+            ActionContext ac = invocation.getInvocationContext();\n+            final Map<String, Object> parameters = retrieveParameters(ac);\n+\n+            if (LOG.isDebugEnabled()) {\n+                LOG.debug(\"Setting params \" + getParameterLogMap(parameters));\n+            }\n+\n+            if (parameters != null) {\n+                Map<String, Object> contextMap = ac.getContextMap();\n+                try {\n+                    ReflectionContextState.setCreatingNullObjects(contextMap, true);\n+                    ReflectionContextState.setDenyMethodExecution(contextMap, true);\n+                    ReflectionContextState.setReportingConversionErrors(contextMap, true);\n+\n+                    ValueStack stack = ac.getValueStack();\n+                    setParameters(action, stack, parameters);\n+                } finally {\n+                    ReflectionContextState.setCreatingNullObjects(contextMap, false);\n+                    ReflectionContextState.setDenyMethodExecution(contextMap, false);\n+                    ReflectionContextState.setReportingConversionErrors(contextMap, false);\n+                }\n+            }\n+        }\n+        return invocation.invoke();\n+    }\n+\n+    /**\n+     * Gets the parameter map to apply from wherever appropriate\n+     *\n+     * @param ac The action context\n+     * @return The parameter map to apply\n+     */\n+    protected Map<String, Object> retrieveParameters(ActionContext ac) {\n+        return ac.getParameters();\n+    }\n+\n+\n+    /**\n+     * Adds the parameters into context's ParameterMap\n+     *\n+     * @param ac        The action context\n+     * @param newParams The parameter map to apply\n+     *                  <p/>\n+     *                  In this class this is a no-op, since the parameters were fetched from the same location.\n+     *                  In subclasses both retrieveParameters() and addParametersToContext() should be overridden.\n+     */\n+    protected void addParametersToContext(ActionContext ac, Map<String, Object> newParams) {\n+    }\n+\n+    protected void setParameters(Object action, ValueStack stack, final Map<String, Object> parameters) {\n+        ParameterNameAware parameterNameAware = (action instanceof ParameterNameAware)\n+                ? (ParameterNameAware) action : null;\n+\n+        Map<String, Object> params;\n+        Map<String, Object> acceptableParameters;\n+        if (ordered) {\n+            params = new TreeMap<String, Object>(getOrderedComparator());\n+            acceptableParameters = new TreeMap<String, Object>(getOrderedComparator());\n+            params.putAll(parameters);\n+        } else {\n+            params = new TreeMap<String, Object>(parameters);\n+            acceptableParameters = new TreeMap<String, Object>();\n+        }\n+\n+        for (Map.Entry<String, Object> entry : params.entrySet()) {\n+            String name = entry.getKey();\n+\n+            boolean acceptableName = acceptableName(name)\n+                    && (parameterNameAware == null\n+                    || parameterNameAware.acceptableParameterName(name));\n+\n+            if (acceptableName) {\n+                acceptableParameters.put(name, entry.getValue());\n+            }\n+        }\n+\n+        ValueStack newStack = valueStackFactory.createValueStack(stack);\n+        boolean clearableStack = newStack instanceof ClearableValueStack;\n+        if (clearableStack) {\n+            //if the stack's context can be cleared, do that to prevent OGNL\n+            //from having access to objects in the stack, see XW-641\n+            ((ClearableValueStack)newStack).clearContextValues();\n+            Map<String, Object> context = newStack.getContext();\n+            ReflectionContextState.setCreatingNullObjects(context, true);\n+            ReflectionContextState.setDenyMethodExecution(context, true);\n+            ReflectionContextState.setReportingConversionErrors(context, true);\n+\n+            //keep locale from original context\n+            context.put(ActionContext.LOCALE, stack.getContext().get(ActionContext.LOCALE));\n+        }\n+\n+        boolean memberAccessStack = newStack instanceof MemberAccessValueStack;\n+        if (memberAccessStack) {\n+            //block or allow access to properties\n+            //see WW-2761 for more details\n+            MemberAccessValueStack accessValueStack = (MemberAccessValueStack) newStack;\n+            accessValueStack.setAcceptProperties(acceptParams);\n+            accessValueStack.setExcludeProperties(excludeParams);\n+        }\n+\n+        for (Map.Entry<String, Object> entry : acceptableParameters.entrySet()) {\n+            String name = entry.getKey();\n+            Object value = entry.getValue();\n+            try {\n+                newStack.setValue(name, value);\n+            } catch (RuntimeException e) {\n+                if (devMode) {\n+                    String developerNotification = LocalizedTextUtil.findText(ParametersInterceptor.class, \"devmode.notification\", ActionContext.getContext().getLocale(), \"Developer Notification:\\n{0}\", new Object[]{\n+                             \"Unexpected Exception caught setting '\" + name + \"' on '\" + action.getClass() + \": \" + e.getMessage()\n+                    });\n+                    LOG.error(developerNotification);\n+                    if (action instanceof ValidationAware) {\n+                        ((ValidationAware) action).addActionMessage(developerNotification);\n+                    }\n+                }\n+            }\n+        }\n+\n+        if (clearableStack && (stack.getContext() != null) && (newStack.getContext() != null))\n+            stack.getContext().put(ActionContext.CONVERSION_ERRORS, newStack.getContext().get(ActionContext.CONVERSION_ERRORS));\n+\n+        addParametersToContext(ActionContext.getContext(), acceptableParameters);\n+    }\n+\n+    /**\n+     * Gets an instance of the comparator to use for the ordered sorting.  Override this\n+     * method to customize the ordering of the parameters as they are set to the\n+     * action.\n+     *\n+     * @return A comparator to sort the parameters\n+     */\n+    protected Comparator<String> getOrderedComparator() {\n+        return rbCollator;\n+    }\n+\n+    private String getParameterLogMap(Map<String, Object> parameters) {\n+        if (parameters == null) {\n+            return \"NONE\";\n+        }\n+\n+        StringBuilder logEntry = new StringBuilder();\n+        for (Map.Entry entry : parameters.entrySet()) {\n+            logEntry.append(String.valueOf(entry.getKey()));\n+            logEntry.append(\" => \");\n+            if (entry.getValue() instanceof Object[]) {\n+                Object[] valueArray = (Object[]) entry.getValue();\n+                logEntry.append(\"[ \");\n+\t\t        if (valueArray.length > 0 ) {\n+                    for (int indexA = 0; indexA < (valueArray.length - 1); indexA++) {\n+                        Object valueAtIndex = valueArray[indexA];\n+                        logEntry.append(String.valueOf(valueAtIndex));\n+                        logEntry.append(\", \");\n+                    }\n+                    logEntry.append(String.valueOf(valueArray[valueArray.length - 1]));\n+                }\n+                logEntry.append(\" ] \");\n+            } else {\n+                logEntry.append(String.valueOf(entry.getValue()));\n+            }\n+        }\n+\n+        return logEntry.toString();\n+    }\n+\n+    protected boolean acceptableName(String name) {\n+        if (isAccepted(name) && !isExcluded(name)) {\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    protected boolean isAccepted(String paramName) {\n+        if (!this.acceptParams.isEmpty()) {\n+            for (Pattern pattern : acceptParams) {\n+                Matcher matcher = pattern.matcher(paramName);\n+                if (matcher.matches()) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        } else\n+            return acceptedPattern.matcher(paramName).matches();\n+    }\n+\n+    protected boolean isExcluded(String paramName) {\n+        if (!this.excludeParams.isEmpty()) {\n+            for (Pattern pattern : excludeParams) {\n+                Matcher matcher = pattern.matcher(paramName);\n+                if (matcher.matches()) {\n+                    return true;\n+                }\n+            }\n+        }\n+        return false;\n+    }\n+\n+    /**\n+     * Whether to order the parameters or not\n+     *\n+     * @return True to order\n+     */\n+    public boolean isOrdered() {\n+        return ordered;\n+    }\n+\n+    /**\n+     * Set whether to order the parameters by object depth or not\n+     *\n+     * @param ordered True to order them\n+     */\n+    public void setOrdered(boolean ordered) {\n+        this.ordered = ordered;\n+    }\n+\n+    /**\n+     * Gets a set of regular expressions of parameters to remove\n+     * from the parameter map\n+     *\n+     * @return A set of compiled regular expression patterns\n+     */\n+    protected Set getExcludeParamsSet() {\n+        return excludeParams;\n+    }\n+\n+    /**\n+     * Sets a comma-delimited list of regular expressions to match\n+     * parameters that should be removed from the parameter map.\n+     *\n+     * @param commaDelim A comma-delimited list of regular expressions\n+     */\n+    public void setExcludeParams(String commaDelim) {\n+        Collection<String> excludePatterns = asCollection(commaDelim);\n+        if (excludePatterns != null) {\n+            excludeParams = new HashSet<Pattern>();\n+            for (String pattern : excludePatterns) {\n+                excludeParams.add(Pattern.compile(pattern));\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Return a collection from the comma delimited String.\n+     *\n+     * @param commaDelim the comma delimited String.\n+     * @return A collection from the comma delimited String. Returns <tt>null</tt> if the string is empty.\n+     */\n+    private Collection<String> asCollection(String commaDelim) {\n+        if (commaDelim == null || commaDelim.trim().length() == 0) {\n+            return null;\n+        }\n+        return TextParseUtil.commaDelimitedStringToSet(commaDelim);\n+    }\n+\n+}"
        },
        {
            "sha": "12643a3d2f86375eca74f587c51db4ef872c8f8f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/PreResultListener.java",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPreResultListener.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPreResultListener.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPreResultListener.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd",
            "patch": "@@ -0,0 +1,39 @@\n+/*\n+ * Copyright 2002-2007,2009 The Apache Software Foundation.\n+ * \n+ * Licensed under the Apache License, Version 2.0 (the \"License\");\n+ * you may not use this file except in compliance with the License.\n+ * You may obtain a copy of the License at\n+ * \n+ *      http://www.apache.org/licenses/LICENSE-2.0\n+ * \n+ * Unless required by applicable law or agreed to in writing, software\n+ * distributed under the License is distributed on an \"AS IS\" BASIS,\n+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+ * See the License for the specific language governing permissions and\n+ * limitations under the License.\n+ */\n+package com.opensymphony.xwork2.interceptor;\n+\n+import com.opensymphony.xwork2.ActionInvocation;\n+\n+\n+/**\n+ * PreResultListeners may be registered with an {@link ActionInvocation} to get a callback after the\n+ * {@link com.opensymphony.xwork2.Action} has been executed but before the {@link com.opensymphony.xwork2.Result}\n+ * is executed.\n+ *\n+ * @author Jason Carreira\n+ */\n+public interface PreResultListener {\n+\n+    /**\n+     * This callback method will be called after the {@link com.opensymphony.xwork2.Action} execution and\n+     * before the {@link com.opensymphony.xwork2.Result} execution.\n+     *\n+     * @param invocation  the action invocation\n+     * @param resultCode  the result code returned by the action (eg. <code>success</code>).\n+     */\n+    void beforeResult(ActionInvocation invocation, String resultCode);\n+\n+}"
        },
        {
            "sha": "30e543f8f414ffbeab77791f4cd31a912ede0fc3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/PrefixMethodInvocationUtil.java",
            "status": "added",
            "additions": 0,
            "deletions": 0,
            "changes": 0,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrefixMethodInvocationUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrefixMethodInvocationUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrefixMethodInvocationUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5c627656ec9a4419f4e7cd5a65f7adf962180fd6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/PrepareInterceptor.java",
            "status": "added",
            "additions": 152,
            "deletions": 0,
            "changes": 152,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrepareInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrepareInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FPrepareInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e38137375fe6188a0ab764f787da5f3c615c88df",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ScopedModelDriven.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDriven.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDriven.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDriven.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "8cf10acb36738fb9c05d6c9c2f14940eebccebc0",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ScopedModelDrivenInterceptor.java",
            "status": "added",
            "additions": 164,
            "deletions": 0,
            "changes": 164,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDrivenInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDrivenInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FScopedModelDrivenInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ed965900377feb3abb243075af9e662ca5d68ffd",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/StaticParametersInterceptor.java",
            "status": "added",
            "additions": 241,
            "deletions": 0,
            "changes": 241,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FStaticParametersInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FStaticParametersInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FStaticParametersInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ad53d80e46b52e01b4730919cdd8c9e2937669be",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/TimerInterceptor.java",
            "status": "added",
            "additions": 243,
            "deletions": 0,
            "changes": 243,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FTimerInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FTimerInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FTimerInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b5f2a55091c785edc1a22a26257dc10e0ebd91b5",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/ValidationWorkflowAware.java",
            "status": "added",
            "additions": 9,
            "deletions": 0,
            "changes": 9,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FValidationWorkflowAware.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FValidationWorkflowAware.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2FValidationWorkflowAware.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "3fc2fcd8e0eaa15f56adb776ab00ad226a4dc0cc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/After.java",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAfter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAfter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAfter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "42633444ec026d43ad62f58446ce2dab1c4423bc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/Allowed.java",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAllowed.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAllowed.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAllowed.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "528a65f9478a2a4c575d569c243d575d87ed9bda",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/AnnotationParameterFilterIntereptor.java",
            "status": "added",
            "additions": 84,
            "deletions": 0,
            "changes": 84,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationParameterFilterIntereptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationParameterFilterIntereptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationParameterFilterIntereptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "118d8ac2f8109e8e29ee645917524e467161e4ba",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/AnnotationWorkflowInterceptor.java",
            "status": "added",
            "additions": 199,
            "deletions": 0,
            "changes": 199,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationWorkflowInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationWorkflowInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FAnnotationWorkflowInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "cb0e5556398b6ea2d96a71c30b9a64ea8c308ab7",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/Before.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBefore.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBefore.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBefore.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "faeb4003c2c9d5dfcb42e123084c5ff10546a759",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/BeforeResult.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBeforeResult.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBeforeResult.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBeforeResult.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a87ac0b97c9bbddb4bf8ba59e04d4b4381947516",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/BlockByDefault.java",
            "status": "added",
            "additions": 21,
            "deletions": 0,
            "changes": 21,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlockByDefault.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlockByDefault.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlockByDefault.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e9a288585ba8e68e3b6bc405e475c2bbf6f4dd86",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/Blocked.java",
            "status": "added",
            "additions": 18,
            "deletions": 0,
            "changes": 18,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlocked.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlocked.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FBlocked.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5d70744d4f446ace3080e9822672d382a454a48d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/InputConfig.java",
            "status": "added",
            "additions": 92,
            "deletions": 0,
            "changes": 92,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FInputConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FInputConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2FInputConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "8ac50a8b637b1d66f6e73aaa5babfde541d21413",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/annotations/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fannotations%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "505d814e0749b77d52a8568e63f72d452dc3fd24",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/interceptor/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Finterceptor%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "f137c80eec3420f09a6d81762c31ab8d835ccf77",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/MockActionInvocation.java",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionInvocation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionInvocation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionInvocation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "4eda2ef157c43dbee8f1b92ddce837b8d2fb529d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/MockActionProxy.java",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionProxy.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionProxy.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockActionProxy.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c244770edbfe19429ceaebeb178d121bc495ed04",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/MockInterceptor.java",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "605aaf2c050d7df454ec28baf2679cacb2052609",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/MockObjectTypeDeterminer.java",
            "status": "added",
            "additions": 125,
            "deletions": 0,
            "changes": 125,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockObjectTypeDeterminer.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockObjectTypeDeterminer.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockObjectTypeDeterminer.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "53eac6303ff15d38efed7f28ddf0925f0359af51",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/MockResult.java",
            "status": "added",
            "additions": 50,
            "deletions": 0,
            "changes": 50,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockResult.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockResult.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2FMockResult.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "61bdf48e9236e5fbffc15c754bd887018638c493",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/mock/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fmock%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b01fd6736f8876b6dfa7a2617215016860962076",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/ObjectProxy.java",
            "status": "added",
            "additions": 55,
            "deletions": 0,
            "changes": 55,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FObjectProxy.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FObjectProxy.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FObjectProxy.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "95a0e35a2c0a68f0a9d25caf474a58e241645943",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlNullHandlerWrapper.java",
            "status": "added",
            "additions": 24,
            "deletions": 0,
            "changes": 24,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlNullHandlerWrapper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlNullHandlerWrapper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlNullHandlerWrapper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "03a5537f14cf4c1d1456523ff127e2b5cf3857fa",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlReflectionContextFactory.java",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionContextFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionContextFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionContextFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b59720e619ab4e14c964c3f1122deaeb2391425a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlReflectionProvider.java",
            "status": "added",
            "additions": 126,
            "deletions": 0,
            "changes": 126,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlReflectionProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "55a71be31a621209e99c002c7161b154f1a23b55",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlTypeConverterWrapper.java",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlTypeConverterWrapper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlTypeConverterWrapper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlTypeConverterWrapper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "1ccf7cf0a61dd11ddc5a61d63b723bff3f26ccbf",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlUtil.java",
            "status": "added",
            "additions": 432,
            "deletions": 0,
            "changes": 432,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "8d1a5684baeff99c4c54c0ff27775b9de8124ded",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlValueStack.java",
            "status": "added",
            "additions": 491,
            "deletions": 0,
            "changes": 491,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStack.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStack.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStack.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ad16587d6fa5d7e8fe3143cf49740095b8acd609",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/OgnlValueStackFactory.java",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStackFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStackFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FOgnlValueStackFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0a5069f066cd6d9d7bffab6e430613e4aa57e84a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/SecurityMemberAccess.java",
            "status": "added",
            "additions": 128,
            "deletions": 0,
            "changes": 128,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FSecurityMemberAccess.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FSecurityMemberAccess.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FSecurityMemberAccess.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "dbf21f67becd00fddff04accceb5ced14d238afe",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/XWorkTypeConverterWrapper.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FXWorkTypeConverterWrapper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FXWorkTypeConverterWrapper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2FXWorkTypeConverterWrapper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "aebfdb6a9f293f743cc0fa9059257e1fc62efdab",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/CompoundRootAccessor.java",
            "status": "added",
            "additions": 326,
            "deletions": 0,
            "changes": 326,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FCompoundRootAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FCompoundRootAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FCompoundRootAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "255a0fce6f0fdca9030b70a49a8af8ad1a80d9b0",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/ObjectAccessor.java",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "714acf714f30e3944839c16d7264d494f9a19318",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/ObjectProxyPropertyAccessor.java",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectProxyPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectProxyPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FObjectProxyPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "32cf2edca685daba2b3c7c0a6d1153d68624ee9a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkCollectionPropertyAccessor.java",
            "status": "added",
            "additions": 277,
            "deletions": 0,
            "changes": 277,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkCollectionPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkCollectionPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkCollectionPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "88e6408b34612ae2f9b54c848239311e8bee5d27",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkEnumerationAccessor.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkEnumerationAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkEnumerationAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkEnumerationAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7afe3f56f5d27f7d7ffc44dfc71696522fc20b65",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkIteratorPropertyAccessor.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkIteratorPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkIteratorPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkIteratorPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "6dab13bf34d2b75456ef540d9cb209f75936cc3d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkListPropertyAccessor.java",
            "status": "added",
            "additions": 182,
            "deletions": 0,
            "changes": 182,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkListPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkListPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkListPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b7d3c10b72f22edb336532a25dc55eb93531b4ca",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkMapPropertyAccessor.java",
            "status": "added",
            "additions": 176,
            "deletions": 0,
            "changes": 176,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMapPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMapPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMapPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "11d3f315f23db3a68895459cad9bc49ecbf7b8ee",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkMethodAccessor.java",
            "status": "added",
            "additions": 159,
            "deletions": 0,
            "changes": 159,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMethodAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMethodAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkMethodAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5351401bf7273b1e07dbce317cf9bedd3b3c0ba8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/ognl/accessor/XWorkObjectPropertyAccessor.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkObjectPropertyAccessor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkObjectPropertyAccessor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fognl%2Faccessor%2FXWorkObjectPropertyAccessor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "37941547633d0f4ee47d73ca12b4b03df80c0188",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e7e174a4bef38f312c750e0476206874f52cd2b1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/spring/SpringObjectFactory.java",
            "status": "added",
            "additions": 274,
            "deletions": 0,
            "changes": 274,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringObjectFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringObjectFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringObjectFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "db3d89d35d34df5158ba0590f25ed02227fb82c2",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/spring/SpringProxyableObjectFactory.java",
            "status": "added",
            "additions": 96,
            "deletions": 0,
            "changes": 96,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringProxyableObjectFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringProxyableObjectFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2FSpringProxyableObjectFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c76ccc254bef48dab61303e7b6664579a843d254",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/spring/interceptor/ActionAutowiringInterceptor.java",
            "status": "added",
            "additions": 136,
            "deletions": 0,
            "changes": 136,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2FActionAutowiringInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2FActionAutowiringInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2FActionAutowiringInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "6579e80e6bf9460b5a84a965e1d79dd33512521b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/spring/interceptor/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Finterceptor%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "91d2d95a5fc60a9404d13f762339a8cd9d27e42f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/spring/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fspring%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "309db062302590930c22964f10ff484c0ac6a932",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/test/StubConfigurationProvider.java",
            "status": "added",
            "additions": 36,
            "deletions": 0,
            "changes": 36,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Ftest%2FStubConfigurationProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Ftest%2FStubConfigurationProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Ftest%2FStubConfigurationProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a9462a239ce0bce99191595cfddf66ce9880e5ae",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/AnnotationUtils.java",
            "status": "added",
            "additions": 227,
            "deletions": 0,
            "changes": 227,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FAnnotationUtils.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FAnnotationUtils.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FAnnotationUtils.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "01ff02364e2bdb6ed23b8853a6f654b4e4ca3ce7",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ArrayUtils.java",
            "status": "added",
            "additions": 31,
            "deletions": 0,
            "changes": 31,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FArrayUtils.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FArrayUtils.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FArrayUtils.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "54f113e83efd021fe6ca73df1edb1e4e5ad594d4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ClassLoaderUtil.java",
            "status": "added",
            "additions": 235,
            "deletions": 0,
            "changes": 235,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassLoaderUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassLoaderUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassLoaderUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a8ebca2f441a8b2cad2c151d07a9edb3df45aa13",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ClassPathFinder.java",
            "status": "added",
            "additions": 177,
            "deletions": 0,
            "changes": 177,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassPathFinder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassPathFinder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClassPathFinder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e4d129e94c4017a63e197337eb6000a0fbd14737",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ClearableValueStack.java",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClearableValueStack.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClearableValueStack.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FClearableValueStack.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "9abade0668ee6cfca39c124c1c53180381e789ed",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/CompoundRoot.java",
            "status": "added",
            "additions": 53,
            "deletions": 0,
            "changes": 53,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCompoundRoot.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCompoundRoot.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCompoundRoot.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "050ec2a55f3b4732b5f64e233ee7af2637d1a100",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/CreateIfNull.java",
            "status": "added",
            "additions": 77,
            "deletions": 0,
            "changes": 77,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCreateIfNull.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCreateIfNull.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FCreateIfNull.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "d867148023fce42384bd87d7212d71aeb0b39a2f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/DomHelper.java",
            "status": "added",
            "additions": 366,
            "deletions": 0,
            "changes": 366,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FDomHelper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FDomHelper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FDomHelper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "30903d2d70175f8d2577eb9df203b512d238573c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/Element.java",
            "status": "added",
            "additions": 81,
            "deletions": 0,
            "changes": 81,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FElement.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FElement.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FElement.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "abc36f78a25525e1edcbc4224d0123b8ce7d1053",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/FileManager.java",
            "status": "added",
            "additions": 321,
            "deletions": 0,
            "changes": 321,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FFileManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FFileManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FFileManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c1b0fc8bf28a557ce3be9e4779318b1b9040c9db",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/Key.java",
            "status": "added",
            "additions": 78,
            "deletions": 0,
            "changes": 78,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKey.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKey.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKey.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "8832beebf71f1dca38b06e60032275a99174f00b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/KeyProperty.java",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKeyProperty.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKeyProperty.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FKeyProperty.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e52487ab9b8fce6cce0f969bf5d36a69f05ea02c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/LocalizedTextUtil.java",
            "status": "added",
            "additions": 950,
            "deletions": 0,
            "changes": 950,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FLocalizedTextUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FLocalizedTextUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FLocalizedTextUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "369676fa6e829a1eb57f121d800d1e4056e72b93",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/MemberAccessValueStack.java",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FMemberAccessValueStack.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FMemberAccessValueStack.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FMemberAccessValueStack.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a0bc6521b30c8e542d09fb01e39309b519a13ac3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/NamedVariablePatternMatcher.java",
            "status": "added",
            "additions": 143,
            "deletions": 0,
            "changes": 143,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FNamedVariablePatternMatcher.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FNamedVariablePatternMatcher.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FNamedVariablePatternMatcher.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "f4728930d3cc8eda3ff535fee64503a01a38d510",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/PatternMatcher.java",
            "status": "added",
            "additions": 57,
            "deletions": 0,
            "changes": 57,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPatternMatcher.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPatternMatcher.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPatternMatcher.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5a086c9ad6ac7c3535f5e88fb9b18260a9dac036",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/PropertiesReader.java",
            "status": "added",
            "additions": 599,
            "deletions": 0,
            "changes": 599,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPropertiesReader.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPropertiesReader.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FPropertiesReader.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0e583f92ed9bfb5efc69a263b884e1f3b315cb2d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ResolverUtil.java",
            "status": "added",
            "additions": 458,
            "deletions": 0,
            "changes": 458,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FResolverUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FResolverUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FResolverUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e009334987e11862aaab5fe4f9ea9d971d460d09",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/TextParseUtil.java",
            "status": "added",
            "additions": 284,
            "deletions": 0,
            "changes": 284,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FTextParseUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FTextParseUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FTextParseUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ebc1467a8424f4d6a7e5ce3c4f641fc45675175a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/URLUtil.java",
            "status": "added",
            "additions": 105,
            "deletions": 0,
            "changes": 105,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FURLUtil.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FURLUtil.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FURLUtil.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c2a208634fcf1520f3b8f4a73b5c61dd63ae93f6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ValueStack.java",
            "status": "added",
            "additions": 150,
            "deletions": 0,
            "changes": 150,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStack.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStack.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStack.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "aa8256d680f5dd65697661e1848fb9de935a0d06",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/ValueStackFactory.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStackFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStackFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FValueStackFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "86a3b9a807f0e7b3c47038568c35070a3f7411a5",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/WildcardHelper.java",
            "status": "added",
            "additions": 463,
            "deletions": 0,
            "changes": 463,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FWildcardHelper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FWildcardHelper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FWildcardHelper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "52e0109d3901054b593c609ad2fd1b1f44036fca",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/XWorkList.java",
            "status": "added",
            "additions": 226,
            "deletions": 0,
            "changes": 226,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkList.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkList.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkList.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "57083e0a36eb351c84314a790ebee2e595298b09",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/XWorkTestCaseHelper.java",
            "status": "added",
            "additions": 95,
            "deletions": 0,
            "changes": 95,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkTestCaseHelper.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkTestCaseHelper.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2FXWorkTestCaseHelper.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "4475449c51e14be68f1360c1f301d9492958bcca",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/classloader/FileResourceStore.java",
            "status": "added",
            "additions": 79,
            "deletions": 0,
            "changes": 79,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FFileResourceStore.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FFileResourceStore.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FFileResourceStore.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c991f759a444ccacfac39cdf6b203540ff394bd3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/classloader/JarResourceStore.java",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FJarResourceStore.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FJarResourceStore.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FJarResourceStore.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0fec8efe1dfbdabe6ef5ffe9e2c0fced9af7e701",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/classloader/ReloadingClassLoader.java",
            "status": "added",
            "additions": 177,
            "deletions": 0,
            "changes": 177,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FReloadingClassLoader.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FReloadingClassLoader.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FReloadingClassLoader.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "80e6ce9588e87844fddfb528f94616008d270a4b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/classloader/ResourceStore.java",
            "status": "added",
            "additions": 27,
            "deletions": 0,
            "changes": 27,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStore.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStore.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStore.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "9cf38e1c02db0dda493ba1a01ddb2cb71b4a5272",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/classloader/ResourceStoreClassLoader.java",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStoreClassLoader.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStoreClassLoader.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fclassloader%2FResourceStoreClassLoader.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "99f64e6d5927138fa5919cfc4ee864886b737aa7",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/ClassFinder.java",
            "status": "added",
            "additions": 886,
            "deletions": 0,
            "changes": 886,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassFinder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassFinder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassFinder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "f9b4a0fbcb4691afa3ba53e8cd1bf9d84c98fd25",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/ClassLoaderInterface.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterface.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterface.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterface.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "79fa46084d82b22f791588818147f16bd4c6b8b6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/ClassLoaderInterfaceDelegate.java",
            "status": "added",
            "additions": 52,
            "deletions": 0,
            "changes": 52,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterfaceDelegate.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterfaceDelegate.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FClassLoaderInterfaceDelegate.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "28a146e9849fe263f0c1ee542351913389a10dd1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/ResourceFinder.java",
            "status": "added",
            "additions": 1153,
            "deletions": 0,
            "changes": 1153,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FResourceFinder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FResourceFinder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FResourceFinder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b78d6f4b67db8c07268f95c7c3e72c4abb9934a3",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/Test.java",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FTest.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FTest.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FTest.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "d8b7cdeaa2d7a6c5615cfde55d00c45ab05d6939",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/finder/UrlSet.java",
            "status": "added",
            "additions": 266,
            "deletions": 0,
            "changes": 266,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FUrlSet.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FUrlSet.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Ffinder%2FUrlSet.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "fc6f69cd19816168aea9b5b5cf15cde9a8556202",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/Locatable.java",
            "status": "added",
            "additions": 29,
            "deletions": 0,
            "changes": 29,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatable.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatable.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatable.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "99cde0e3d8dcc0d37e71c59d215d034f564d7dc4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/LocatableProperties.java",
            "status": "added",
            "additions": 76,
            "deletions": 0,
            "changes": 76,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatableProperties.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatableProperties.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocatableProperties.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7c2c795ed8121b75fa8c547afdccc851683fe7c6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/Located.java",
            "status": "added",
            "additions": 42,
            "deletions": 0,
            "changes": 42,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocated.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocated.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocated.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7791d4fd2d5f96ffcb61971e37fe35c6dbaa7580",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/Location.java",
            "status": "added",
            "additions": 69,
            "deletions": 0,
            "changes": 69,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0bc5079225eaeee8beaf36390d096dbe3913aa2f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/LocationAttributes.java",
            "status": "added",
            "additions": 348,
            "deletions": 0,
            "changes": 348,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationAttributes.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationAttributes.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationAttributes.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "554098c6006750c37aa8bfd9ef2ab38aa3bef4c1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/LocationImpl.java",
            "status": "added",
            "additions": 217,
            "deletions": 0,
            "changes": 217,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationImpl.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationImpl.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationImpl.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0cbd53cb7f7559a3a4fc8365757951262e4178b4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/LocationUtils.java",
            "status": "added",
            "additions": 305,
            "deletions": 0,
            "changes": 305,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationUtils.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationUtils.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2FLocationUtils.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "840814bd981fb4e9a87cb78c7462cc48df060008",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/location/package.html",
            "status": "added",
            "additions": 3,
            "deletions": 0,
            "changes": 3,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flocation%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "d9fc1fb46e7063510d0a52c837a945091df46e5b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/Logger.java",
            "status": "added",
            "additions": 45,
            "deletions": 0,
            "changes": 45,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLogger.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLogger.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLogger.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5dac28f532c27bd2a4c901ffef7b64bc10f3b7da",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/LoggerFactory.java",
            "status": "added",
            "additions": 80,
            "deletions": 0,
            "changes": 80,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "da565504daa838958b80eaa6385729ae41446494",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/LoggerUtils.java",
            "status": "added",
            "additions": 72,
            "deletions": 0,
            "changes": 72,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerUtils.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerUtils.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2FLoggerUtils.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "9e88930fac6f87b85449339b210c5c1a7c88a373",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/commons/CommonsLogger.java",
            "status": "added",
            "additions": 108,
            "deletions": 0,
            "changes": 108,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLogger.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLogger.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLogger.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "3979e9c00fdcc4f4155e45a5cf2ff9133a4b701a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/commons/CommonsLoggerFactory.java",
            "status": "added",
            "additions": 37,
            "deletions": 0,
            "changes": 37,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLoggerFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLoggerFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fcommons%2FCommonsLoggerFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "2aaec24702e26420eb4d726bd66d2535fc60b680",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/jdk/JdkLogger.java",
            "status": "added",
            "additions": 106,
            "deletions": 0,
            "changes": 106,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLogger.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLogger.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLogger.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "af8b67747628e6a4954c4d9cc5cd5094e699ce33",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/logging/jdk/JdkLoggerFactory.java",
            "status": "added",
            "additions": 35,
            "deletions": 0,
            "changes": 35,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLoggerFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLoggerFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Flogging%2Fjdk%2FJdkLoggerFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e400bf97ff2d4b4a5f5ae371a61425085e69f8d0",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "d374a2c0c0b78e53fb285594ec080439e825084e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/profiling/ObjectProfiler.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FObjectProfiler.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FObjectProfiler.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FObjectProfiler.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "35baaa4d491dd55f00a0f89f29e0914afb5b5d41",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/profiling/ProfilingTimerBean.java",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FProfilingTimerBean.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FProfilingTimerBean.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FProfilingTimerBean.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "2322f939ca8dd2dce7e5fdbdffa5867300f7976f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/profiling/UtilTimerStack.java",
            "status": "added",
            "additions": 485,
            "deletions": 0,
            "changes": 485,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FUtilTimerStack.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FUtilTimerStack.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2FUtilTimerStack.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c0b1f7f63c9d27d5419baa45b28ffed0f7c4dc25",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/profiling/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Fprofiling%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "704b5af71bc87f796103cf054763b715c8183c1d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionContextFactory.java",
            "status": "added",
            "additions": 15,
            "deletions": 0,
            "changes": 15,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "60fd456f9474106cab9a8ee77b2cf1fc38c15989",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionContextState.java",
            "status": "added",
            "additions": 179,
            "deletions": 0,
            "changes": 179,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextState.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextState.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionContextState.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a6d107d9bb4cb964d8ce5a6544875487520019b2",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionException.java",
            "status": "added",
            "additions": 41,
            "deletions": 0,
            "changes": 41,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b5c7d8a5d664d3e5d7024d692e0ae9e4297e2528",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionExceptionHandler.java",
            "status": "added",
            "additions": 14,
            "deletions": 0,
            "changes": 14,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionExceptionHandler.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionExceptionHandler.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionExceptionHandler.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0230c60d3eca65f16626d4815f635957735f79f2",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionProvider.java",
            "status": "added",
            "additions": 141,
            "deletions": 0,
            "changes": 141,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProvider.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProvider.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProvider.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "a05b7d6065c56ba4bbff05c237cdaf6f5526c16f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/util/reflection/ReflectionProviderFactory.java",
            "status": "added",
            "additions": 10,
            "deletions": 0,
            "changes": 10,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProviderFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProviderFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Futil%2Freflection%2FReflectionProviderFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "6650817cc35faa1aaffbbe083f8ff4dac5c90a0d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ActionValidatorManager.java",
            "status": "added",
            "additions": 87,
            "deletions": 0,
            "changes": 87,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FActionValidatorManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FActionValidatorManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FActionValidatorManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "844f782444101c4c633cea8aba894bddb0de6c27",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/AnnotationActionValidatorManager.java",
            "status": "added",
            "additions": 410,
            "deletions": 0,
            "changes": 410,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationActionValidatorManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationActionValidatorManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationActionValidatorManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "c0ca47ea1f6d8c40066d1af22c96a0db35d29117",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/AnnotationValidationConfigurationBuilder.java",
            "status": "added",
            "additions": 816,
            "deletions": 0,
            "changes": 816,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationValidationConfigurationBuilder.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationValidationConfigurationBuilder.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FAnnotationValidationConfigurationBuilder.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "0042e0a677230954a9337f7efdaba50313854a4c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/DefaultActionValidatorManager.java",
            "status": "added",
            "additions": 387,
            "deletions": 0,
            "changes": 387,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultActionValidatorManager.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultActionValidatorManager.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultActionValidatorManager.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "70e55440b6857167c6f981d80e3c9879bb19d904",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/DefaultValidatorFactory.java",
            "status": "added",
            "additions": 198,
            "deletions": 0,
            "changes": 198,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "38be46802e269f0c16c292865a83cace68ac3733",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/DefaultValidatorFileParser.java",
            "status": "added",
            "additions": 241,
            "deletions": 0,
            "changes": 241,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFileParser.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFileParser.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDefaultValidatorFileParser.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "8fd62b6f6303479f1cf908522bdb735d2937db66",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/DelegatingValidatorContext.java",
            "status": "added",
            "additions": 310,
            "deletions": 0,
            "changes": 310,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDelegatingValidatorContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDelegatingValidatorContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FDelegatingValidatorContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "307767145327738b66d9109e589e605707e327c6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/FieldValidator.java",
            "status": "added",
            "additions": 39,
            "deletions": 0,
            "changes": 39,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "651270d974f0c95de1070b663a5b9667659b9acf",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ShortCircuitableValidator.java",
            "status": "added",
            "additions": 44,
            "deletions": 0,
            "changes": 44,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FShortCircuitableValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FShortCircuitableValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FShortCircuitableValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "584678a5b86dd6d04b806ebc949b731a4b0cca6c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidationException.java",
            "status": "added",
            "additions": 40,
            "deletions": 0,
            "changes": 40,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationException.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationException.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationException.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7bf027721874fc366047ee3eb78cd50134a40996",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidationInterceptor.java",
            "status": "added",
            "additions": 266,
            "deletions": 0,
            "changes": 266,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationInterceptor.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationInterceptor.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidationInterceptor.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "021a231c6a890383dde9c31015654a8ef2eb9600",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/Validator.java",
            "status": "added",
            "additions": 490,
            "deletions": 0,
            "changes": 490,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b55af0d020ad28b69a5a39394037084d62b11a07",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidatorConfig.java",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorConfig.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorConfig.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorConfig.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "f79586724a193c650171c60d7081e92664513f66",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidatorContext.java",
            "status": "added",
            "additions": 38,
            "deletions": 0,
            "changes": 38,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorContext.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorContext.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorContext.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "92fec21bf98fd89145a0eaa63dc4993c530941d8",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidatorFactory.java",
            "status": "added",
            "additions": 239,
            "deletions": 0,
            "changes": 239,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFactory.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFactory.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFactory.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "2c9e39d22d74a988ea83f4b3f2f282f89a0f9e2d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/ValidatorFileParser.java",
            "status": "added",
            "additions": 46,
            "deletions": 0,
            "changes": 46,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFileParser.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFileParser.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2FValidatorFileParser.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "63408280a27be7402defd11a63e79e6a4f2147e2",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/ConditionalVisitorFieldValidator.java",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConditionalVisitorFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConditionalVisitorFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConditionalVisitorFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "e79401954b9c5055fce224d5e6191f712e11d476",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/ConversionErrorFieldValidator.java",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConversionErrorFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConversionErrorFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FConversionErrorFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "240a2d92ae07ccecb23c478f8e58503645c64453",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/CustomValidator.java",
            "status": "added",
            "additions": 113,
            "deletions": 0,
            "changes": 113,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FCustomValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FCustomValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FCustomValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "fd47fce8d1727dd1731056f4fc1a3a7ceba3bad9",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/DateRangeFieldValidator.java",
            "status": "added",
            "additions": 146,
            "deletions": 0,
            "changes": 146,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDateRangeFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDateRangeFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDateRangeFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "50f4e616409e03801c3e9fceb36a52e48b90871d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/DoubleRangeFieldValidator.java",
            "status": "added",
            "additions": 170,
            "deletions": 0,
            "changes": 170,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDoubleRangeFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDoubleRangeFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FDoubleRangeFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7ee9515ddcbadc370665544a2002af605038ded1",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/EmailValidator.java",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FEmailValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FEmailValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FEmailValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "52768462e0b381a349715948016c7493de43e429",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/ExpressionValidator.java",
            "status": "added",
            "additions": 112,
            "deletions": 0,
            "changes": 112,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FExpressionValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FExpressionValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FExpressionValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "854ef889965f191f7c79f8e43af8659a653fe49e",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/FieldExpressionValidator.java",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FFieldExpressionValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FFieldExpressionValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FFieldExpressionValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "439701716f130108aacbeae9d52279a6eca5f555",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/IntRangeFieldValidator.java",
            "status": "added",
            "additions": 149,
            "deletions": 0,
            "changes": 149,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FIntRangeFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FIntRangeFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FIntRangeFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "77e3219a2ccadabe8c4bdc9c63b329a2b749ac41",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/RegexFieldValidator.java",
            "status": "added",
            "additions": 130,
            "deletions": 0,
            "changes": 130,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRegexFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRegexFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRegexFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7ff4a96c1b91044274245069335e70a5276e6471",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/RequiredFieldValidator.java",
            "status": "added",
            "additions": 123,
            "deletions": 0,
            "changes": 123,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "bfdad5d3d6fcf1f05d65140ca5f3883f0684bbf9",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/RequiredStringValidator.java",
            "status": "added",
            "additions": 134,
            "deletions": 0,
            "changes": 134,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredStringValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredStringValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FRequiredStringValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ce4be991cfd562cc4bffce0738b0d31e106c8494",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/StringLengthFieldValidator.java",
            "status": "added",
            "additions": 159,
            "deletions": 0,
            "changes": 159,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FStringLengthFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FStringLengthFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FStringLengthFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "4a9b4a52ab8753d7289971c742a5e08029bb6fab",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/UrlValidator.java",
            "status": "added",
            "additions": 122,
            "deletions": 0,
            "changes": 122,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FUrlValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FUrlValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FUrlValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "2769b12c519d7ff89488728fca5a08517e42d5bb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/Validation.java",
            "status": "added",
            "additions": 137,
            "deletions": 0,
            "changes": 137,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidation.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidation.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidation.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "1482aed5543299b0f3e71dccb34fe9b3afa756cb",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/ValidationParameter.java",
            "status": "added",
            "additions": 83,
            "deletions": 0,
            "changes": 83,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidationParameter.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidationParameter.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidationParameter.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "b33f6d223f52b966520afed008c3d8bbdc21b780",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/Validations.java",
            "status": "added",
            "additions": 186,
            "deletions": 0,
            "changes": 186,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidations.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidations.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidations.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "aed95d71fbe20e3de0041652800d4d051c629cbf",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/ValidatorType.java",
            "status": "added",
            "additions": 34,
            "deletions": 0,
            "changes": 34,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidatorType.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidatorType.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FValidatorType.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "7274aed3538ee2c98f464eb22f199bbf2947c2cc",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/VisitorFieldValidator.java",
            "status": "added",
            "additions": 150,
            "deletions": 0,
            "changes": 150,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FVisitorFieldValidator.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FVisitorFieldValidator.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2FVisitorFieldValidator.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ff910e78864ad23be8f1e27be1563a04df5ee0c6",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/annotations/package.html",
            "status": "added",
            "additions": 1,
            "deletions": 0,
            "changes": 1,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2Fpackage.html",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2Fpackage.html",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fannotations%2Fpackage.html?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "076e3b8aa3fa7306d6ab28438833a5f0262f89b4",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/AbstractFieldValidatorDescription.java",
            "status": "added",
            "additions": 133,
            "deletions": 0,
            "changes": 133,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FAbstractFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FAbstractFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FAbstractFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "ce62cfc5c59c9b8bf33afcb460dccb5acb9f3c2f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/ConversionErrorFieldValidatorDescription.java",
            "status": "added",
            "additions": 118,
            "deletions": 0,
            "changes": 118,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FConversionErrorFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FConversionErrorFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FConversionErrorFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "6d41713f0058562fd611689555d645a1cacbe377",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/DateRangeFieldValidatorDescription.java",
            "status": "added",
            "additions": 140,
            "deletions": 0,
            "changes": 140,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDateRangeFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDateRangeFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDateRangeFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5b45156921aa66997b06cf69c66fc6d0ea3b3d1b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/DoubleRangeFieldValidatorDescription.java",
            "status": "added",
            "additions": 142,
            "deletions": 0,
            "changes": 142,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDoubleRangeFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDoubleRangeFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FDoubleRangeFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "134be4f98ab43347a3656328f85285695797ee46",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/EmailValidatorDescription.java",
            "status": "added",
            "additions": 119,
            "deletions": 0,
            "changes": 119,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FEmailValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FEmailValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FEmailValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "72e263afa3f3521df2f168f29cf532daa27f904f",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/ExpressionValidatorDescription.java",
            "status": "added",
            "additions": 94,
            "deletions": 0,
            "changes": 94,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FExpressionValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FExpressionValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FExpressionValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "1e5e84e1babffadf9a36116dfa76fb2041179a4a",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/FieldExpressionValidatorDescription.java",
            "status": "added",
            "additions": 114,
            "deletions": 0,
            "changes": 114,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FFieldExpressionValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FFieldExpressionValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FFieldExpressionValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5cc403b3dfda90e4d9a8b670d1ce7327730b8cb0",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/IntRangeFieldValidatorDescription.java",
            "status": "added",
            "additions": 145,
            "deletions": 0,
            "changes": 145,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FIntRangeFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FIntRangeFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FIntRangeFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "426cd694809e3a8f556480f14d92b71e9b381ace",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/RequiredFieldValidatorDescription.java",
            "status": "added",
            "additions": 116,
            "deletions": 0,
            "changes": 116,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "5868d87fa3b56f1d71e7b45ab147b61cf67c3b3d",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/RequiredStringValidatorDescription.java",
            "status": "added",
            "additions": 129,
            "deletions": 0,
            "changes": 129,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredStringValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredStringValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FRequiredStringValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "878937e843d486079e8d0146789cf612fd0d5f89",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/StringLengthFieldValidatorDescription.java",
            "status": "added",
            "additions": 153,
            "deletions": 0,
            "changes": 153,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FStringLengthFieldValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FStringLengthFieldValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FStringLengthFieldValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "6fe03e57a455cf6ee4a2ab637edee254152d892c",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/URLValidatorDescription.java",
            "status": "added",
            "additions": 117,
            "deletions": 0,
            "changes": 117,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FURLValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FURLValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FURLValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        },
        {
            "sha": "cbf6f62248461f971f25e3f9f10876714e58231b",
            "filename": "xwork-core/src/main/java/com/opensymphony/xwork2/validator/metadata/ValidatorDescription.java",
            "status": "added",
            "additions": 62,
            "deletions": 0,
            "changes": 62,
            "blob_url": "https://github.com/apache/struts/blob/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FValidatorDescription.java",
            "raw_url": "https://github.com/apache/struts/raw/0c543aef318341ca9bd482e15f1637497b8a4dfd/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FValidatorDescription.java",
            "contents_url": "https://api.github.com/repos/apache/struts/contents/xwork-core%2Fsrc%2Fmain%2Fjava%2Fcom%2Fopensymphony%2Fxwork2%2Fvalidator%2Fmetadata%2FValidatorDescription.java?ref=0c543aef318341ca9bd482e15f1637497b8a4dfd"
        }
    ]
}